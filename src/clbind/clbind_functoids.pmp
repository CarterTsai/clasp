$var NumArgs = 16
    $var RetSV = 0
    $var RetVoid = 1
    $var InnerCount = NumArgs+1
    $range ret 0..1
    $range template_ 0..(InnerCount-1)
    $for ret [[
        $for template_ [[
                $var numVoids = template_
                $var numArgs = NumArgs - template_
                $range Args_ 1..numArgs
                // ret = $ret
                // template_ = $template_
                // numVoids = $numVoids
                // numArgs = $numArgs
                /* Specialization */
                template <typename Pols $if ret==RetVoid [[]] $else [[, typename RT ]] $if numArgs [[,]] $for Args_ ,[[typename ARG$Args_]] >
                class VariadicFunctoid
                < $if ret==RetVoid [[void]] $else [[RT ]] (*)($for Args_ , [[ARG$Args_]]), Pols>
                : public core::Functoid {
                public:
                typedef core::Functoid TemplatedBase;
                public:
                    typedef $if ret==RetVoid [[void]] $else [[RT]](*Type)($for Args_ , [[ARG$Args_]]);
                    Type fptr;
                public:
                    enum { NumParams = $numArgs };
                    VariadicFunctoid(const string& name, Type ptr) : core::Functoid(name), fptr(ptr) {};
                    DISABLE_NEW();
                    core::T_mv activate( core::ActivationFrame_sp closedOverFrame, int numArgs, ArgArray args )
                    {
                        int countPureOutValues = CountPureOutValues<Pols>::value;
                        if ( numArgs != (NumParams-countPureOutValues) )
                        {
                            core::wrongNumberOfArguments(numArgs,NumParams-countPureOutValues);
                        }
                            $for Args_ [[
                                    translate::from_object<ARG$Args_,typename DoesNotContain_<Pols,pureOutValue<$Args_> >::type > a$Args_(*args);
                                    IncWhen<typename DoesNotContain_<Pols,pureOutValue<$Args_> >::type >::go(args);
                                ]]
                            $if ret==RetVoid [[]] $else [[ RT retval = ]] fptr($for Args_ ,[[a$Args_._v]]);
                        $if numArgs>0 [[
                                core::MultipleValues& returnValues = _lisp->multipleValues();
                                returnValues.setSize(0);
                                ]]
                            $if ret==RetVoid [[
                                $if numArgs==0 [[]] $else [[ int oidx = 0; ]]
                                ]] $else [[
                                int oidx = 1;
                                ]]
                            $for Args_ [[
                                ReturnValueWhen(returnValues,oidx
                                                , typename is_outValue<Pols,$Args_>::type()
                                                , typename AdoptPointer<Pols,$Args_>::type()
                                                , a$Args_._v);
                                ]]
                            $if ret==RetVoid [[
                                $if numArgs==0 [[
                                        return Values0<core::T_O>();
                                        ]] $else [[
                                        return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
                                        ]]
                                ]] $else [[
                                return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),oidx);
                                ]]
          
                            }

                };
                ]]
        ]]

