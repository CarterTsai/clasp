#
# Usage:
#    python scrapeDocs.py userDoc.tex editDoc.tex sourceFile1 source2 ...
#
#
import sys
import re


class	DocumentationEntry:
    def __init__(self,path,sectionName,content,fileName,line):
   	self._Path = path
	self._SectionName = sectionName
        self._Children = {}
	self._Content = content
	self._Missing = True
	self._FileName = fileName
	self._LineNumber = line
	print("DocumentationEntry-------")
	print("   SectionName: %s"%sectionName)

    def setNotMissing(self):
        self._Missing = False 

    def createEntry(self,pathHead,pathTail,fileName,line):
        if __debug__:
	    print("---createEntry has pathHead=%s pathTail=%s"%(pathHead,pathTail))
	    print("  my path=%s"%self._Path)
        target = pathTail[0]
        newPathHead = list(pathHead)
	newPathTail = []
	if ( len(pathTail)>0 ):
	    if __debug__:
		print("pathTail is not empty: %s" %pathTail )
	    newPathTail = pathTail[1:]
	    newPathHead.append(target)
	else:
	    if __debug__:
		print("pathTail is empty")
	    pass
	print("  my path=%s"%self._Path)
        if ( target not in self._Children ):
	    if __debug__:
		print ("Creating new entry with path: %s" % newPathHead )
		print ("Parent path: %s"% self._Path )
		print ("Remaining path: %s"% newPathTail )
	    child = DocumentationEntry(newPathHead,target,"",fileName,line)
	    self._Children[target] = child
	else:
	    if __debug__:
		print("Found child: %s"%target)
	    pass
	child = self._Children[target]
	if ( len(newPathTail) > 0 ):
	    if __debug__:
		print( "      calling child.createEntry")
	    child = child.createEntry(newPathHead,newPathTail,fileName,line)
	return child

    def findEntry(self,path):
        if ( path[0] not in self._Children ):
	    raise Exception,"Entry key(%s) could not be found"
	child = self._Children[path[0]]
	if ( len(path) > 1 ):
	    restOfPath = path[1:]
	    child = child.findEntry(restOfPath)
	return child

    def setFileName(self,fn):
        self._FileName = fn

    def setLineNumber(self,ln):
        self._LineNumber = ln

    def getPathAsString(self):
        st = None
        for p in self._Path:
	    if ( st == None ):
		st = p
	    else:
		st = st + "." + p
	return st

    def setContent(self,p):
        self._Content = p

    def getContent(self):
    	return self._Content

    def getSectionType(self):
        if ( len(self._Path)==0 ):
	    return ""
        if ( len(self._Path)==1 ):
	    return "chapter"
        if ( len(self._Path)==2 ):
	    return "section"
	if ( len(self._Path)==3 ):
	    return "subsection"
	if ( len(self._Path)==4 ):
	    return "subsubsection"
	raise Exception, "illegal path length: %d"%len(self._Path)

    def setSectionName(self,p):
        self._SectionName = p

    def getSectionName(self):
        if ( self._SectionName == "!class" ):
	    return "%s class methods" % self._Path[-2]
        if ( self._SectionName == "!instance" ):
	    return "%s instance methods" % self._Path[-2]
    	return self._SectionName

    def sortedChildren(self):
        keys = self._Children.keys()
	keys.sort()
	return [ self._Children[key] for key in keys ]

    def write(self,fout,editing):
	if ( self.getSectionType() != "" ):
	    if ( editing ):
		fout.write("\\rule{6in}{0.01cm}\\par\n");
		print("write: %s" %self._Path)
		if ( self._Missing ):
		    fedit.write("\\framebox{Generated by %s %d path: %s  type: %s}\par\n"%(self._FileName, self._LineNumber,self.getPathAsString(),self.getSectionType()))
		else:
		    fedit.write("\\framebox{Scraped from %s %d path: %s  type: %s}\par\n"%(self._FileName, self._LineNumber,self.getPathAsString(),self.getSectionType()))
	    fout.write("\\%s{%s}\n"%(self.getSectionType(),self.getSectionName()))
	    if ( self._Content != "" ):
		fout.write("%s\n"%self._Content)
	keys = self._Children.keys()
	keys.sort()
	for key in keys:
	    self._Children[key].write(fout,editing)


class	Documentation:
    def __init__(self):
        self._RootEntry = DocumentationEntry([],"","","-nofile-",0)

    def addEntry(self,path,sectionName,content,fileName,lineNumber):
    	keys = path.split(".")
    	entry = self._RootEntry.createEntry([],keys,fileName,lineNumber)
	entry.setNotMissing()
	entry.setContent(content)
	if ( sectionName != "" ):
	    entry.setSectionName(sectionName)

    def appendEntry(self,path,content):
    	keys = path.split(".")
    	entry = self._RootEntry.createEntry([],keys,"",0)
	existingContent = entry.getContent()
	existingContent += content
	entry.setContent(existingContent)

    def write(self,fdoc,fedit):
	self._RootEntry.write(fdoc,False)
	self._RootEntry.write(fedit,True)



beginDocDef = re.compile('\s*__BEGIN_DOC\(\s*([!\w\.]*)\s*,\s*([\w\s]*)\s*\)')
beginDocShortDef = re.compile('\s*__BEGIN_DOC\(\s*([!\w\.]*)\s*\)')
appendDocDef = re.compile('\s*__APPEND_DOC\(\s*([\w\.]*)\s*\)')
endDocDef = re.compile('\s*__END_DOC')

outFileName = sys.argv[1]
editFileName = sys.argv[2]

fileNames = sys.argv[3:]

docs = Documentation()
for fileName in fileNames:
    print("Extracting documentation from: %s"%fileName)
    fin = open(fileName,"r")
    ln = 0
    while ( 1 ):
	l = fin.readline()
	if ( l == "" ):
	    break
	ln += 1
	line = l.strip().rstrip()
	match = beginDocDef.match(line)
	if ( match != None ):
	    if __debug__: print("Got match: %s"%l)
	    content = ""
	    gotEnd = False
	    while ( 1):
		rl = fin.readline()
		if ( rl=="" ):
		    break
		ln += 1
		rline = rl.strip().rstrip()
		if ( rline == "__END_DOC"):
		    gotEnd = True
		    break
		content += rl
	    if (not gotEnd):
		raise Exception,"Unterminated __BEGIN_DOC in file: %s"%fileName
	    docs.addEntry(match.groups()[0],match.groups()[1],content,fileName,ln)
	match = beginDocShortDef.match(line)
	if ( match != None ):
	    if __debug__: print("Got match: %s"%l)
	    content = ""
	    gotEnd = False
	    while ( 1):
		rl = fin.readline()
		if ( rl=="" ):
		    break
		ln += 1
		rline = rl.strip().rstrip()
		if ( rline == "__END_DOC"):
		    gotEnd = True
		    break
		content += rl
	    if (not gotEnd):
		raise Exception,"Unterminated __BEGIN_DOC in file: %s"%fileName
	    docs.addEntry(match.groups()[0],"",content,fileName,ln)
	match = appendDocDef.match(line)
	if ( match != None ):
	    if __debug__: print("Got match: %s"%l)
	    content = ""
	    gotEnd = False
	    while ( 1):
		rl = fin.readline()
		if ( rl=="" ):
		    break
		ln += 1
		rline = rl.strip().rstrip()
		if ( rline == "__END_DOC"):
		    gotEnd = True
		    break
		content += rl
	    if (not gotEnd):
		raise Exception,"Unterminated __APPEND_DOC in file: %s"%fileName
	    docs.appendEntry(match.groups()[0],content)
    fin.close()



print("Writing documentation")
fdoc = open(outFileName,"w")
fedit = open(editFileName,"w")
docs.write(fdoc,fedit)
fdoc.close()
fedit.close()

