



(defvar *dkpSecondaryAmideSmarts* (chem:ChemInfo :smarts "[N&H]1C2(=O3)CNC(=O)C[N&H;?1]" ))
(let ((good (compileSucceeded *dkpSecondaryAmideSmarts* )))
  (ifTrue (not good )
	  (raise "Failed to compile *dkpSecondaryAmideSmarts*" )))
(defvar *primaryAmideSmarts* (ChemInfo :smarts "[N&H2]C(=O)C" ))
(let ((good (compileSucceeded *primaryAmideSmarts* )))
  (ifTrue (not good )
	  (raise "Failed to compile *primaryAmideSmarts*" )))
(defvar *secondaryAmideSmarts* (ChemInfo :smarts "[N&H1&R0]1(C)C2(=O3)C" ))
(let ((good (compileSucceeded *secondaryAmideSmarts* )))
  (ifTrue (not good )
	  (raise "Failed to compile *secondaryAmideSmarts*" )))
(defClass AmideBondTester ()(_DkpAmides _AcyclicAmides _Matter _Messages )
  (method __init__ (self matter )
	  (setq (slot self _Matter )matter )
	  (setq (slot self _DkpAmides )())
	  (setq (slot self _AcyclicAmides )())
	  (setq (slot self _Messages )(StringOutStream ))
	  (identifyAmideBonds self ))


  (method assembleAmide (self smarts )
	  (let* ((match (getMatch smarts ))
		 (an (tag match "1"))
		 (ah (let ((foundAtoms ()))
		       (block outer
			      (for b (bondsAsList an)
				   (let ((otherAtom (getOtherAtom b an)))
				     (when (== (chem:getElement otherAtom ) :H )
				       (return-from outer otherAtom))
				     (setq foundAtoms (Cons otherAtom foundAtoms))))
			      (raise (LispError (% "Could not find secondary amide hydrogen - the %d atoms I found where %s - the bonds I found where: %s" (length foundAtoms) (repr foundAtoms) (repr (bondsAsList an))))))))
		 (ac (tag match "2" ))
		 (ao (tag match "3" ))
		 )
	    (list ah an ac ao)))

  (method measureDihedral (self amide )
	  (let (ah an ac ao vh vn vc vo dih )
	    (setq ah (@ amide 0 ))
	    (setq an (@ amide 1 ))
	    (setq ac (@ amide 2 ))
	    (setq ao (@ amide 3 ))
	    (setq vh (chem:getPosition ah ))
	    (setq vn (chem:getPosition an ))
	    (setq vc (chem:getPosition ac ))
	    (setq vo (chem:getPosition ao ))
	    (setq dih (/ (dihedral vh vn vc vo )0.0174533 ))
	    (log (% "dihedral = %lf " dih ))
	    dih ))

  (method identifyAmideBonds (self )
	  (let (amide ns )
	    (setq (slot self _DkpAmides )())
	    (setq (slot self _AcyclicAmides )())
	    (setq ns (allAtomsOfElementAsList (slot self _Matter ):N ))
	    (foreach a ns
		     (block inner
		       (ifTrue (matches *primaryAmideSmarts* a )
			       (return-from inner))
		       (if (matches *dkpSecondaryAmideSmarts* a )
			   (then 
			    (ifTrue (> (getBondedHydrogenCount a )1 )
				    (raise "We ignore primary amides but this nitrogen has two hydrogens" ))
			    (setq amide (assembleAmide self *dkpSecondaryAmideSmarts* ))
			    (setq (slot self _DkpAmides )(cons amide (slot self _DkpAmides ))))
			 (else 
			  (ifTrue (matches *secondaryAmideSmarts* a )
				  (ifTrue (> (getBondedHydrogenCount a )1 )
					  (raise "We ignore primary amides but this nitrogen has two hydrogens" ))
				  (setq amide (assembleAmide self *secondaryAmideSmarts* ))
				  (setq (slot self _AcyclicAmides )(cons amide (slot self _AcyclicAmides ))))))))))
  (method countBadAmidesInMatter (self matter )
	  (let (badAmideCount dih )
	    (clear (slot self _Messages ))
	    (setq badAmideCount 0 )
	    (foreach dkp (slot self _DkpAmides )
		     (setq dih (measureDihedral self dkp ))
		     (ifTrue (or (> dih 90.0 )(< dih -90.0 ))
			     (log (% "bad dkp secondary amide, H-N-C=O dihedral angle = %lf degrees" dih ))
			     (writeln (slot self _Messages )(% "bad dkp secondary amide, H-N-C=O dihedral angle = %lf degrees" dih ))
			     (setq badAmideCount (+ badAmideCount 1 ))))
	    (foreach am (slot self _AcyclicAmides ) ;

		     (setq dih (measureDihedral self am ))
		     (ifTrue (and (> dih -90.0 )(< dih 90.0 ))
			     (log (% "bad acyclic secondary amide, H-N-C=O dihedral angle = %lf degrees" dih ))
			     (writeln (slot self _Messages )(% "bad acyclic secondary amide, H-N-C=O dihedral angle = %lf degrees" dih ))
			     (setq badAmideCount (+ badAmideCount 1 ))))
	    badAmideCount ))

  (method getMessages (self )
	  (str (slot self _Messages )))

  (method countBadAmidesInEntry (self entry )
	  (let ((stage (getSelectedStage entry ))badAmideCount )
	    (writeCoordinatesToMatter stage matter )
	    (setq badAmideCount (countBadAmidesInMatter self matter ))
	    badAmideCount ))
)