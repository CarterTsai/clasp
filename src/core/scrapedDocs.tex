\chapter{Cando Scripting Language}
Cando-Script is a language tailored to constructing and searching virtual oligomer libraries.
Cando-Script is modeled after the languages Lisp and Scheme with Smalltalk/Objective-C thrown in, not to be different but because
these languages have a simple and compact syntax and they seemed to be a good match for the
problem.\par

Cando-Script is designed to allow a chemists to easily define virtual oligomer libraries, build 3D models of members of of
oligomer libraries, score members of these libraries and identify the best 
oligomer structures that present functional groups
in a desired three-dimensional constellation.\par

Cando-Script commands are invoked using two forms: 

\begin{itemize}
\item Prefix form - [\textbf{command} \emph{arg1 arg2 arg3 ...} ]

This is the ``prefix'' form, where the \textbf{command} is given followed by its arguments. 
Square brackets are used to indicate that this is a prefix form command.

When {\CANDOSCRIPT} encounters a command in prefix form it does the following:
\begin{enumerate}
\item It checks if the command is a macro name like ``defClass'' or ``if'' and if it is
then the arguments are passed to the internal macro code for it to handle in its own way.
{\CANDOSCRIPT} then goes on to the next command.

\item {\CANDOSCRIPT} evaluates all of the arguments and constructs a list of evaluated arguments to
pass to the function or method.

\item {\CANDOSCRIPT} checks to see if the first evaluated argument object recognizes the method with
the \textbf{command} name and if it does {\CANDOSCRIPT} invokes the method with the evaluated argument list.
{\CANDOSCRIPT} then puts the result of the invocation into a growing argument list and goes to the
next command.

\item If the \textbf{command} didn't match an object/method call then {\CANDOSCRIPT} checks if \textbf{command}
matches a function call.  If it does then {\CANDOSCRIPT} invokes the function with the evaluated arguments and puts the
result into a growing result list and goes to the next command.

\item {\CANDOSCRIPT} throws an error saying that the current command is not recognized.

\end{enumerate}

Examples:\par
\begin{verbatim}
[save hitList "hits.oml" ]  # saves the hitList object 
                            #    to the file: hits.oml.
[:= x 10.0]                 # assigns the value 10.0 
                            #    to the global variable x.
[println "Hello world" ]    # prints "Hello world" to stdout 
                            #    followed by a carriage return.
\end{verbatim}

\item Infix form - ( object \textbf{command} \emph{arg1 arg2 ...} )

This is the "infix" form, where the \textbf{command} is sent to the \emph{object} 
with the arguments \emph{arg1 arg2 ...}. 

Internally the ``infix'' form is automatically converted into ``prefix'' form 
by swapping the order of \emph{object} and \textbf{command}. 

So the command: ( \emph{object} \textbf{command} \emph{arg1 arg2 ...} ) \par
is converted to [ \textbf{command} \emph{object} \emph{arg1 arg2 ...} ]

The purpose of the infix-form is
to allow the programmer to use a more familiar notation for mathematical 
expressions and conditional expressions.


\end{verbatim}

\section{database}
\subsection{bundleDatabasePath}
\scriptCmd{bundleDatabasePath}{directoryName:text}

Return the full path of a file in the bundle database directory.

\subsection{contextGrep}
\positional{Text::contextKeySubstring}

Search for contexts with keys that contain the substring.

\subsection{setDatabase}
\scriptCmd{standardDatabase}{directoryName:text}

Set the database.

\subsection{standardDatabase}
\args{((Text databaseFileName) &optional (Bool loadSeed) (Int (verbosity 0)))}
\returns{()}

Load the database with the name \emph{databaseFileName}.
If \emph{loadSeed} is true then it loads the seed database (no MonomerCoordinates) 
- otherwise it loads the standard database.
If :verbosity is set to a non zero value then debugging information is printed during loading.

\section{Debugging}
CandoScript commands used for debugging scripts.

\section{general}
These commands apply to a variety of objects.

\subsection{and}
  \scriptCmdRet{and}{boolA boolB}{bool}\par

  Return boolA AND boolB.

\subsection{apply}
  \scriptCmdRet{apply}{}{Function argList}

  Evaluate the function with the argument list.

\subsection{apropos}
  \scriptCmdRet{apropos}{}{Text::substring [packageName]}

  Return every symbol that contains the (substring)

\subsection{backtrace}
  \scriptCmdRet{backtrace}{}{Cons::}

  Return a backtrace as a list of SourceCodeCons.

\subsection{caddr}
  \scriptCmdRet{caddr}{list}{object}

  Return the third element of the list.

\subsection{cadr}
  \scriptCmdRet{cadr}{list}{object}

  Return the second element of the list.

\subsection{car}
  \scriptCmdRet{car}{list}{object}

  Return the first element of the list.

\subsection{cdddr}
  \scriptCmdRet{cdddr}{list}{object}

  Return the cdddr list after the first element is removed.

\subsection{cddr}
  \scriptCmdRet{cddr}{list}{object}

  Return the cddr list after the first element is removed.

\subsection{cdr}
  \scriptCmdRet{cdr}{list}{object}

  Return the rest of the list after the first element is removed.

\subsection{changeWorkingDirectory}
  \scriptCmdRet{changeWorkingDirectory}{}{Text::}

  Change the current working directory.

\subsection{className}
  \scriptCmdRet{className}{object}{string}

  Return the name of the class the object belongs to.

\subsection{cons}
  \scriptCmdRet{cons}{object list}{cons}

  Create a "cons" with from object,list.

\subsection{contentWithName}
\scriptCmd{contentWithName}{object:matter name:text}

Return the content of the Matter(Aggregate/Molecule/Residue) with the name \scriptArg{name}.

\subsection{databaseDir}
  \scriptCmdRet{databaseDir}{}{Text::}

  Return the path for the database directory.

\subsection{debugDumpClassManager}
  \scriptCmd{debugDumpClassManager}{}

  Dump the class manager.

\subsection{debugLogOff}
  \scriptCmd{debugLogOff}{true/false:bool}

  Turn on or off writing debug statements to the debug log. This is useful when running
  long scripts that crash, you can turn of debug logging up to the point where
  the crash happens and then examine the output.

\subsection{debugLogOn}
  \scriptCmd{debugLogOn}{true/false:bool}

  Turn on or off writing debug statements to the debug log. This is useful when running
  long scripts that crash, you can turn of debug logging up to the point where
  the crash happens and then examine the output.

\subsection{defparameter}
  \scriptCmd{let}{symbol object}\par

  Evaluate the arguments and put it into the global variable \scriptArg{symbol}.

\subsection{defvarAndExport}
  \scriptCmd{let}{symbol object}\par

  Evaluate the arguments and put it into the global variable \scriptArg{symbol}.

\subsection{div}
  \scriptCmdRet{div}{valueA:number valueB:number}{number}\par
  \scriptCmdRet{/}{valueA:number valueB:number}{number}

  Return the division of the arguments.

\subsection{dumpEnvironment}
  \scriptCmdRet{dumpEnvironment}{}{Text::packageName}

  Dump the current environment.

\subsection{dumpHidden}
  \scriptCmdRet{dumpHidden}{}{Text::packageName}

  Dump the keys in the Hidden binder.

\subsection{eq}
  \scriptCmdRet{eq}{valueA valueB }{Bool::}\par
  \scriptMethodRet{valueA}{==}{valueB }{Bool::}

  Return true if the objects are equal. For some objects (numbers,strings,bools) it compares the objects values. For more complex objects it returns true if they are identical.

\subsection{export}
  \scriptCmd{export}{symbols...}

  Tell the symbols that they can be exported.


\subsection{format}
  \scriptCmdRet{format}{Text::format args ...}{string}\par
  \scriptMethodRet{Text::format}{\%}{args ...}{string}

  Generates formatted output using the boost "format" library.  
  It generates formatted output similar to the C-printf function.
  The result is returned as a string.

\subsection{formatCons}
  \scriptCmdRet{format}{Text::formatCons Cons::args}{string}\par
  \scriptMethodRet{Text::formatCons}{\%}{Cons::argsstring}

  Generates formatted output using the boost "format" library.  
  Arguments are passed as a Cons.
  It generates formatted output similar to the C-printf function.
  The result is returned as a string.

\subsection{funcall}
  \scriptCmdRet{funcall}{}{Function arg1 arg2 ...}

  Evaluate the function with the arguments.

\subsection{ge}
  \scriptCmdRet{ge}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{$>=$}{valueB }{bool}

  Return true if valueA $>=$ valueB.

\subsection{getForm}
  \scriptCmdRet{getForm}{}{Symbol::}

  Return the Procedure associated with the symbol

\subsection{getPackage}
  \scriptCmdRet{getPackage}{}{Text::packageName}

  Make the package.

\subsection{global}
  \scriptCmd{let}{symbol object}\par

  Evaluate the arguments and put it into the global variable \scriptArg{symbol}.

\subsection{gt}
  \scriptCmdRet{gt}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{$>$}{valueB }{bool}

  Return true if valueA $>$ valueB.

\subsection{handlerCase}
  \scriptCmdRet{handlerCase}{}{Cons::expression Cons::errorClauses$*$}

  Evaluate the expression and if a Condition is thrown then evaluate the appropriate errorClause.

\subsection{import}
  \scriptCmdRet{import}{}{symbols &optional package}

  Import the symbols into the (package) or the current package.

\subsection{inPackage}
  \scriptCmdRet{inPackage}{}{Symbol::packageName}

  Cause the package (packageName) to be set to the current package.
  If that package doesn't exist then throw an exception.

\subsection{isAssignableTo}
  \scriptInfixRet{Object::object}{isAssignableTo}{Class::classObject}{Bool::}

  Return true if \scriptArg{object} can be assigned to a C++ variable of class \scriptArg{classObject}.

\subsection{isOfClass}
  \scriptInfixRet{Object::object}{isOfClass}{Class::classObject}{Bool::}

  Return true if \scriptArg{object} is a subclass of \scriptArg{classObject}.

\subsection{isSubClassOf}
  \scriptInfixRet{Object::object}{isSubClassOf}{Class::classObject}{Bool::}

  Return true if \scriptArg{object} can be assigned to a C++ variable of class \scriptArg{classObject}.

\subsection{isTopLevelScript}

  Return a true if this is a top level script or false if its an include file.

\subsection{keyedList}
  \scriptCmdRet{list}{object1 object2 ...}{list}\par
  \scriptCmdRet{:}{object1 object2 ...}{list}

  Return a list formed by evaluating the arguments.

\subsection{le}
  \scriptCmdRet{le}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{$<$=}{valueB }{bool}

  Return true if valueA $<$= valueB.

\subsection{length}
  \scriptCmdRet{length}{list}{int}

  Return the length of the list.

\subsection{let}
  \scriptCmd{let}{symbol object}\par
  \scriptInfix{symbol}{=}{object}

  Evaluate the arguments and put it into the local variable \scriptArg{symbol}.

\subsection{list}
  \scriptCmdRet{list}{object1 object2 ...}{list}\par
  \scriptCmdRet{:}{object1 object2 ...}{list}

  Return a list formed by evaluating the arguments.

\subsection{listAllPackages}
  \scriptCmdRet{listAllPackages}{}{Text::packageName}

  Return a list of all packages.

\subsection{listref}
  \scriptCmdRet{listref}{list index}{object}

  Return the element of the \scriptArg{list} at position \scriptArg{index}.

\subsection{load}
  \scriptCmd{load}{Text::fileName}

  Open the \sa{fileName}, compile and evaluate its contents.
  It looks through all of the directories in the global variable PATH and then 
  the Scripts directory in the Cando application directory.


\subsection{loadArchive}
\scriptCmd{load}{ fileName:text [debug:level] }

Load an object from an archive and return it.


\subsection{local}
  \scriptCmd{local}{symbol object}\par

  Evaluate the arguments and put it into the local variable \scriptArg{symbol}. If the local variable doesn't exist it is created.

\subsection{localVariableNames}
  \scriptCmdRet{localVariableNames}{}{Text::}

  Return a list of all local variable names.

\subsection{locals}
  \scriptCmdRet{locals}{}{Text::}

  Print a list of all local variable names.

\subsection{lt}
  \scriptCmdRet{lt}{valueA valueB }{Bool::}\par
  \scriptMethodRet{valueA}{$<$}{valueB }{Bool::}

  Return true if valueA $<$ valueB.

\subsection{makePackage}
  \scriptCmdRet{makePackage}{}{Text::packageName}

  Make the package.

\subsection{map}
\subsection{max}
  \scriptCmdRet{max}{valueA:number valueB:number ...}{number}\par

  Return the max of the arguments.

\subsection{min}
  \scriptCmdRet{min}{valueA:number valueB:number ...}{number}\par

  Return the min of the arguments.

\subsection{mod}
  \scriptCmdRet{mod}{valueA:number valueB:number}{number}\par

  Return the result of modulus of the arguments.

\subsection{mpiEnabled}
  \scriptCmdRet{mpiEnabled}{}{}

  Return true if MPI is enabled.

\subsection{mpiRank}
  \scriptCmdRet{mpiRank}{}{}

  Return the mpi rank or 0 if not enabled.

\subsection{mpiSize}
  \scriptCmdRet{mpiSize}{}{}

  Return the mpi rank or 0 if not enabled.

\subsection{mul}
  \scriptCmdRet{mul}{valueA:number valueB:number}{number}\par
  \scriptCmdRet{/}{valueA:number valueB:number}{number}

  Return the mulision of the arguments.

\subsection{ne}
  \scriptCmdRet{ne}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{!=}{valueB }{bool}

  Return true if the objects are not equal. For some objects (numbers,strings,bools) it compares the objects values. For more complex objects it returns true if they are not identical.

\subsection{not}
  \scriptCmdRet{not}{boolA}{bool}\par

  Return not boolA.

\subsection{or}
  \scriptInfixRet{boolA}{or}{boolB}{Bool::}\par

  Return boolA OR boolB.

\subsection{parseConsOfStrings}
  \scriptCmdRet{parseConsOfStrings}{}{Text::}

  Parse a string as a list of elements.

\subsection{prin1}
  \scriptCmd{prin1}{args ...}\par

  Print string representations of the arguments with no new line.

\subsection{print}
  \scriptCmd{println}{args ...}\par

  Print new line followed by string representations of the arguments.

\subsection{printPopPrefix}
  \scriptCmd{printPopPrefixln}{args ...}\par

  Pop a prefix to be printed everytime print is called the arguments followed by a new line.

\subsection{printPushPrefix}
  \scriptCmd{printPushPrefixln}{args ...}\par

  Push a prefix to be printed everytime print is called the arguments followed by a new line.

\subsection{println}
  \scriptCmd{println}{args ...}\par

  Print string representations of the arguments followed by a new line.

\subsection{repr}
  \scriptCmdRet{repr}{object}{string}

  Return a string representation of the object.

\subsection{require}
  \scriptCmd{export}{Text::fileName}

  Open the \sa{fileName}, compile and evaluate its contents.
  It looks through all of the directories in the global variable PATH and then 
  the Scripts directory in the Cando application directory.


\subsection{sourceFileLine}
  \scriptCmdRet{sourceFileLine}{}{Cons::}

  Return the current file name and line number in a two element Cons.

\subsection{sub}
  \scriptCmdRet{sub}{valueA:number valueB:number}{number}\par
  \scriptCmdRet{-}{valueA:number valueB:number}{number}

  Return the sum of the arguments.

\subsection{scannerTest}
  \scriptCmd{testScanner}{Text::fileName}

  Open the \sa{fileName}, run it through the scanner to test it.

\subsection{usePackage}
  \scriptCmdRet{usePackage}{}{Symbol::packageName}

  Use the package. Return true if we used it.

\subsection{yourself}
  \scriptCmdRet{yourself}{}{Object::}

  Return the value of the object.

\section{Macro commands}
These are special commands that manipulate the CandoScript environment.
They don't evaluate their arguments in the same way that all other CandoScript commands do.

\subsection{defClass}
  \scriptCmd{defClass}{Text::className instanceVariableNameList }\par
  \scriptCmd{defClass}{Text::className Class::baseCandoClass instanceVariableNameList }

  Define a class with the name \scriptArg{className}. 
  The \scriptArg{baseClass} is optional and if provided then this new class
  will inherit all of the instance variables and methods of the base class.
  The \scriptArg{instanceVariableNameList} are the names of the instance variables (slots) for this class. Each instance variable "x" will become part of the local namespace within methods for this class.

\subsection{defFunction}
  \scriptCmd{defMacro}{macroName argumentNameList code...}

  Define a macro with the name \scriptArg{macroName}.
  The \scriptArg{argumentNameList} defines the variables that are
  passed to the \scriptArg{code...}.

\subsection{defMethod}
  \scriptCmd{defMethod}{Text::methodName Class::class argumentList code... }

  Define a method with the name \scriptArg{methodName} for the \scriptArg{class}.
  The first argument of the \scriptArg{argumentList} is the class 
  instance (the "self" or "this" object)  for which the method is being invoked.

\subsection{flet}
  \scriptCmd{flet}{(function bindings) code...}

  Define functions in a new lexical environment.

\subsection{labels}
  \scriptCmd{labels}{(function bindings) code...}

  Define functions recursively in new lexical environments.

\subsection{macroLet}
  \scriptCmd{macroLet}{(function bindings) code...}

  Define macros recursively in new lexical environments.

\section{matter}
\subsection{setAtomAliasesForResiduesNamed}
\scriptCmd{extendAliases}{Cons::residuesAndInterestingAtomNames Cons::atomAliases}\par

Lookup the residues in the Matter and set the atom aliases of the atoms.


\begin{verbatim}
setAtomAliasesForResiduesNamed (:
        (: 'glu(S) (aliasAtoms 'OE ) )
        (: 'glu(R) (aliasAtoms 'OE ) )
    )
    (atomAliases 'carbO )
\end{verbatim}

\section{monomerPack}
\subsection{createMonomerPack}
\scriptCmd{createMonomerPack}{name:text monomersAndInterestingAtomNames:list atomAliases:list }\par
\scriptCmd{createMonomerPack}{name:text monomersAndInterestingAtomNames:list}\par

Create a MonomerPack and put it into the database with the name: \scriptArg{name}. A MonomerPack is a group of Stereoisomers each of which has zero or more atom names associated with it that will be built by CANDO during rapid searching through sequence and conformational space. 

\begin{verbatim}
( aaGLu = [createMonomerPack "aaGlu"
    [parts
        [addPart 'glu(S) [aliasAtoms 'OE ] ]
        [addPart 'glu(R) [aliasAtoms 'OE ] ]
    ]
    [atomAliases 'carbO ]
] )
\end{verbatim}

The command names "parts" and "atomAliases" are aliases for the "list" command.

\subsection{extendAliases}
\scriptCmd{extendAliases}{Text::monomerPackName Cons::monomersAndInterestingAtomNames Cons::atomAliases}\par

Lookup a MonomerPack in the CandoDatabase and extend the interesting atom list.



\begin{verbatim}
extendAliases "allBis"
    (:
        (: 'glu(S) (aliasAtoms 'OE ) )
        (: 'glu(R) (aliasAtoms 'OE ) )
    )
    (atomAliases 'carbO )
) )
\end{verbatim}

\subsection{setMonomerPack}
\scriptCmd{setMonomerPack}{name:text monomersAndInterestingAtomNames:list atomAliases:list }\par
\scriptCmd{setMonomerPack}{name:text monomersAndInterestingAtomNames:list}\par

Create a MonomerPack and put it into the database with the name: \scriptArg{name}, also create a local variable with the name \sa{name} containing this MonomerPack. A MonomerPack is a group of Stereoisomers each of which has zero or more atom names associated with it that will be built by CANDO during rapid searching through sequence and conformational space. 

\begin{verbatim}
[setMonomerPack "aaGlu"
    [parts
        [addPart 'glu(S) [aliasAtoms 'OE ] ]
        [addPart 'glu(R) [aliasAtoms 'OE ] ]
    ]
    [atomAliases 'carbO ]
]
\end{verbatim}

The commands "parts" and "atomAliases" are aliases for the "list" command.

\section{Ring identification commands and objects}
Commands to identify rings and to manage RingFinder objects.

\subsection{identifyRings}
\scriptCmd{identifyRings}{matter}

Identify the Smallest Set of Smallest Rings (SSSR) for the Molecule or Aggregate \scriptArg{matter}.
Set the ring membership flags of the atoms that are in rings.

\section{specialForm}
\subsection{ASSERT}
  \scriptCmd{ASSERT}{condition logString}

  If the condition is false then throw an exception with logString.

\subsection{LOG}
  \scriptCmd{LOG}{logString}

  If debugging is on the \scriptArg{logString} is written to the log.

\subsection{block}
  \scriptCmdRet{block}{command1 command2 ...}{lastObject}

  Evaluates each command and returns the value \scriptArg{lastObject} from evaluating the last command. This is what you use to write blocks of code.

\subsection{blockDEBUG}
  \scriptCmd{blockDEBUG}{command1 command2 ...}{lastObject}

  Evaluate the block only if debugging is enabled.
  Return the last evaluated element or nil.

\subsection{blockLOG}
  \scriptCmdRet{blockLOG}{"comment" command1 command2 ...}{lastObject}

  Works just like "block" but if debugging is enabled then it prints a message to the log file when this block is
  entered and when it exists.

\subsection{break}
  \scriptCmd{break}{}

  Break out of the current "foreach" or "while" loop.

\subsection{callAncestorMethod}
  \scriptCmdRet{callAncestorMethod}{}{arg1 arg2 ...}

  Call the current method in an ancestor class.
  If no arguments are passed then use the current arguments.

\subsection{cond}
  \scriptCmd{cond}{[ [cond1 code1 ...] [cond2 code2 ... ] ...] }\par

  Works just like lisp "cond" control structure. Evaluates each condition and for the first one that evaluates as true its associated block is evaluated.

\subsection{continue}
  \scriptCmd{continue}{}

  Continue to the next iteration of the current "foreach" or "while" loop.

\subsection{foreach}
  \scriptCmd{foreach}{localVariableName list code}

  For each element of the list put it in the localVariableName and evaluate the code.

\subsection{function}
  \scriptCmd{function}{object}

  Returns function associated with the symbol.

\subsection{if}
  \scriptCmd{if}{condition thenCode elseCode}\par
  \scriptCmd{if}{condition thenCode }

  If/then/else control statement.

\subsection{ifTrue}
  \scriptCmd{ifFalse}{condition thenCode1 thenCode2 ...}\par

  If the condition is true then evaluate the thenCodes.

\subsection{invoke}
  \scriptCmd{invoke}{Symbol::variable Cons::argumentList}\par

  Lookup the function in \sa{variable} and call it with \sa{argumentList}.

\subsection{lambda}
  \scriptCmdRet{lambda}{arguments code}{object}

  Creates an anonymous function that takes a list of \scriptArg{arguments} and evaluates \scriptArg{code} and returns the result.
  This is used for functional programming.

\subsection{let}
  \scriptCmd{let\*}{assignments code}

  Assign lexical variables and then evaluate code in that context.

\subsection{method}
  \scriptCmd{method}{name arguments code1 code2 code3 ...}\par

  Define a method within a class definition

\subsection{pass}
  \scriptCmd{pass}{}\par

  Do nothing

\subsection{quote}
  \scriptCmdRet{quote}{object}{unevaluatedObject}

  Returns the \scriptArg{object} without evaluating it.

\subsection{return}
  \scriptCmd{return}{object}

  Returns from the current function/method and returns the object.

\subsection{slot}
  \scriptCmd{slot}{object selector}\par

  Return the value of the slot within the CandoObject.

\subsection{throw}
  \scriptCmd{throw}{messageString}

  Throw an exception. For now just throw string messages.

\subsection{when}
  \scriptCmd{ifTrue}{condition thenCode1 thenCode2 ...}\par

  If the condition is true then evaluate the thenCodes.

\subsection{while}
  \scriptCmd{while}{condition code}

  While \scriptArg{condition} is True \scriptArg{code} is evaluated.

  Example:
  \begin{verbatim}
  ( x = 1 )
  [while ( x < 10 ) [block
  [println ( "x = %d" % x ) ]
  ( x = ( x + 1 ) )
  ] ]
  \end{verbatim}

\section{specialForms}
\subsection{debug}
  \scriptCmdRet{debug}{}{}

  Start the debugger.

\subsection{eval}
  \scriptCmdRet{eval}{}{Cons::expression}

  Evaluate the expression.

\chapter{Cando Object Classes}

This chapter describes the classes and methods available within Cando-Script.

\section{Alchemist}
  \inheritsFrom{Object}

  A Alchemist object builds three-dimensional structures of Oligomers. To achieve this, a Alchemist needs to be given at least one Oligomer object using ``addOligomer'' and any MonomerPacks that are used by the Oligomer using the ``addMonomerPack'' method.

  A Alchemist object can be given any number of Oligomers and when its building an Oligomer it creates and manages an Kinemat object that does the actual building of a single Oligomer.

  A Alchemist object lets the user select between the oligomers that it has been given, select between the sequences of the current oligomer and select between the conformationsof the current sequence. It allows the user to build the entire three-dimensional structure of the current conformation or just the ``interesting'' atoms.

\section{Alias}
\subsection{Alias class methods}
\subsubsection{Alias}
\positional{Text::monomerAlias Text::atomAlias}

Create an Alias object that maintains a \sa{monomerAlias} name and an \sa{atomAlias} name.

\section{AnchorOnOtherSideOfPlug}
\subsection{AnchorOnOtherSideOfPlug class methods}
\subsubsection{AnchorOnOtherSideOfPlug}
\requiredKeyed{plugName:}{Text::plugName}

\section{AtomGrid}
\subsection{AtomGrid class methods}
\subsubsection{AtomGrid}
\positional{Matter::matter}
\optionalKeyed{gridResolution}
\optionalKeyed{addRadius}
\optionalKeyed{withinSphere}{List::sphere}

\section{ChemDraw}
\subsection{ChemDraw class methods}
\subsubsection{ChemDraw}
\requiredKeyed{fileName:}{Text::name}

Define a ChemDraw object.  Load a cdxml file from \sa{name} and return the ChemDraw object define by it.

\section{ExplicitFrame}
\subsection{ExplicitFrame class methods}
\subsubsection{ExplicitFrame}
\requiredKeyed{name:}{Text::nameOfExplicitFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{xAtom:}{Text::nameOfXAtom}
\requiredKeyed{xyAtom:}{Text::nameOfXYAtom}

Define a ExplicitFrame with \sa{nameOfExplicitFrame} and centered on the atom with name \sa{nameOfOriginAtom}
with the x-axis on \sa{nameOfXAtom} and xy-plane on \sa{nameOfXYAtom}.


\section{ExtractFrameFinisher}
\subsection{ExtractFrameFinisher class methods}
\subsubsection{ExtractFrameFinisher}
\requiredKeyed{othersFrameName:}{Text::othersFrameName}
\requiredKeyed{plugName:}{Text::myPlugName}
\requiredKeyed{overlapsFrame:}{Frame::myFrame}
\requiredKeyed{recognizer:}{FrameRecognizer::recognizer}


Create an object that will extract a frame of reference that has its
origin atom in a preceeding monomer but overlaps this monomer.  
You must specify a frame of reference in this monomer \sa{myFrame} that overlaps the
others frame of reference and the FrameRecognizer that will recognize the others frame
of reference.

\section{Fragment}
\subsection{Fragment class methods}
\subsubsection{Fragment}
\requiredKeyed{name:}{Text::nameOfFragment}
\requiredKeyed{atoms:}{Cons::listOfAtomNames}

Define a Fragment with \sa{nameOfFragment} and containing the atom named in \sa{listOfAtomNames}.


\section{Frame}
\subsection{Frame class methods}
\subsubsection{Frame}
\requiredKeyed{name:}{Text::nameOfFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{xAtom:}{Text::nameOfXAtom}
\requiredKeyed{xyAtom:}{Text::nameOfXYAtom}

Define a Frame with \sa{nameOfFrame} and centered on the atom with name \sa{nameOfOriginAtom}
with the x-axis on \sa{nameOfXAtom} and xy-plane on \sa{nameOfXYAtom}.


\section{Hit}
\subsection{getBuiltMolecule}
  \returns{Molecule::structure}

  Looks up the ``alchemistState'' entry in the hit data and recreates a alchemist in the state that it was when the hit was identified. This method then returns the molecule with all atoms built in the hit conformation.

\subsection{getData}
  \returns{Dictionary::data}

  Return the Dictionary associated with the hit. The dictionary stores name/object pairs that describe the hit. The user can put any data they want into this dictionary.

\subsection{getScore}
  \returns{Real::score}

  Return the score value of the hit.

\subsection{recreateGenerator}
  \returns{Generator::generator}

  This method restores the Generator to exactly the state that it had when the hit was recorded.

\subsection{setScore}
  \positional{Real::value}

  Set the score value of the hit.  Only use this method on hits that haven't been added yet to a HitList - once the hit is in a HitList changing the score will mess up the ordering in the HitList.

\section{HitList commands}
  Commands that operate on HitLists.

\subsection{addAllHits}
  \scriptMethod{hitList}{addAllHits}{HitList::hits}\par
  Adds all of the hits in \sa{hits} to \sa{hitList}. If the \sa{hitList} becomes overfull then the excess hits are discarded.

\subsection{addHit}
  \scriptMethod{hitList}{addHit}{Hit::hit}\par
  Adds the \sa{hit} to \sa{hitList} if it isn't already in there. If the \sa{hitList} becomes overfull then the excess hits are discarded.

\subsection{describe}
  \scriptMethod{hitList}{describe}{}\par
  Print a description of the contents of the HitList.

\subsection{getHit}
  \scriptMethodRet{hitList}{getHit}{Int::index}{Hit::}\par
  Return a hit by its index value \sa{index} (zero is the first entry). If the index is beyond the end of the \sa{hitList} then the nil object [] is returned.

\subsection{hitListGet}
  \scriptCmd{hitListGet}{hitList index}\par
  Return the hit at \scriptArg{index} from the \scriptArg{hitList}.

\subsection{isAHit}
  \scriptMethodRet{hitList}{isAHit}{Real::score}{Bool::}\par
  This method is used to evaluate if a new score represents a hit that is good enough to add to \sa{hitList}.
  Compare the \sa{score} to the scores of every hit in this list. If \sa{score} is better than the worst score in the list then return true, if not return false. 

\subsection{numberOfHits}
  \scriptMethodRet{hitList}{numberOfHits}{}{Int::}\par
  Return the number of hits in this HitList.

\section{InPlug}
\subsection{InPlug class methods}
\subsubsection{InPlug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}

Initialize a InPlug object. InPlugs can have one bond (eg: amide) or two bonds (eg:diketopiperazine).

\section{IncompleteFrame}
\subsection{IncompleteFrame class methods}
\subsubsection{IncompleteFrame}
\requiredKeyed{name:}{Text::nameOfFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{recognizer:}{FrameRecognizer::recognizer}

Define a IncompleteFrame with \sa{nameOfFrame} and centered on the atom with name \sa{nameOfOriginAtom}
recognized by \sa{recognizer}.


\section{Mate}
\inheritsFrom{MonomerGrouper}
A MonomerSet that keeps track of a capping monomer that is used to cap training oligomers when they are being defined.
The capping monomer is supposed to be small and best represent the other members of the Mate.

\subsection{Mate class methods}
\subsubsection{Mate}
\requiredKeyed{cap:}{Text::capName}
\requiredKeyed{groupNames:}{List::groupNames}

Initialize a Mate object.

\section{OneAtomFrame}
\subsection{OneAtomFrame class methods}
\subsubsection{OneAtomFrame}
\requiredKeyed{name:}{Text::nameOfOneAtomFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}

Define a OneAtomFrame with \sa{nameOfOneAtomFrame} and centered on the atom with name \sa{nameOfOriginAtom}.


\section{OriginPlug}
\subsection{OriginPlug class methods}
\subsubsection{OriginPlug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{originFrame:}{Frame::originFrame}

Initialize a OriginPlug object. OriginPlugs don't make bonds don't have mates but they do have an origin frame that is within the topology.

\section{OutPlug}
\subsection{OutPlug class methods}
\subsubsection{OutPlug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}
\optionalKeyed{exportFrame:}{Frame::exportFrame}

Initialize a OutPlug object. OutPlugs can have one bond (eg: amide) or two bonds (eg:diketopiperazine).
Outgoing plugs export a frame of reference to the next monomer, use \sa{exportFrame} to define this.

\section{Path}
\subsection{Path class methods}
\subsubsection{Path}
\optionalKeyed{path:}{Text::path}

Create a Path object that maintains a system independant path to a file in the file system.

\section{Plug}
Defines one or two atoms of this monomer that can be plugged into, a plug name and a
collection of Mate objects that can act as mates for this plug.

\subsection{Plug class methods}
\subsubsection{Plug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}
\optionalKeyed{exportFrame:}{Frame::exportFrame}

Initialize a Plug object. Plugs can have one bond (eg: amide) or two bonds (eg:diketopiperazine).
Outgoing plugs export a frame of reference to the next monomer, use \sa{exportFrame} to define this.

\section{PlugWithMates}
Defines one or two atoms of this monomer that can be plugged into, a plug name and a
collection of Mate objects that can act as mates for this plug.

\subsection{PlugWithMates class methods}
\subsubsection{PlugWithMates}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}

Initialize a PlugWithMates object. PlugWithMatess can have one bond (eg: amide) or two bonds (eg:diketopiperazine).

\section{RecognizedFrame}
\subsection{RecognizedFrame class methods}
\subsubsection{RecognizedFrame}
\requiredKeyed{name:}{Text::nameOfFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{recognizer:}{FrameRecognizer::recognizer}

Define a RecognizedFrame with \sa{nameOfFrame} and centered on the atom with name \sa{nameOfOriginAtom}
recognized by \sa{recognizer}.


\section{RingClosingMate}
\inheritsFrom{MonomerGrouper}
A MonomerSet that keeps track of a capping monomer that is used to cap training oligomers when they are being defined.
The capping monomer is supposed to be small and best represent the other members of the RingClosingMate.

\subsection{RingClosingMate class methods}
\subsubsection{RingClosingMate}
\requiredKeyed{groupNames:}{List::groupNames}

Initialize a RingClosingMate object.

\section{RingClosingPlug}
\subsection{RingClosingPlug class methods}
\subsubsection{RingClosingPlug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}
\optionalKeyed{exportFrame:}{Frame::exportFrame}
\requiredKeyed{ringClosingMates:}{Cons::listOfRingClosingMates}

Initialize a RingClosingPlug object. RingClosingPlugs can have one bond (eg: amide) or two bonds (eg:diketopiperazine).
RingClosingPlugs export a frame of reference to the next monomer, use \sa{exportFrame} to define this.
There is an additional list of ringClosingMates that can be attached to this plug without building the mates.

\section{StereoConfiguration}
\subsection{StereoConfiguration class methods}
\subsubsection{StereoConfiguration}
\requiredKeyed{atomName:}{Text::atom}
\requiredKeyed{config:}{Text::configuration}

Provide the atom name and the stereo-configuration \sa{configuration} of "R" or "S".

\section{StereoInformation}
\subsection{StereoInformation class methods}
\subsubsection{StereoInformation}
\requiredKeyed{stereoisomers:}{List::stereoisomers}
\optionalKeyed{proChiralCenters:}{List::}
\optionalKeyed{constrainedPiBonds:}{List::}

\subsection{StereoInformation instance methods}
\subsubsection{addProChiralCenter}
\scriptMethod{self}{addProChiralCenter}{ProChiralCenter::center}

Add the \sa{center} to the StereoInformation object.

\section{Stereoisomer}
\subsection{Stereoisomer class methods}
\subsubsection{MultiStereoisomers}
\scriptCmdRet{MultiStereoisomers}{nameTemplate:(Text::template) centers:(List::) configs:(List::)}{Cons::stereoisomers}

\subsubsection{Stereoisomer}
\scriptCmdRet{Stereoisomer}{name:(Text::name) pdb:(Text::pdb) configs:(List::)}{StereoIsomer::}

\section{StringSet}
\subsection{StringSet class methods}
\subsubsection{StringSet}
\requiredKeyed{entries:}{Cons::listOfStrings}

Create a StringSet containing the strings in \sa{listOfStrings}.

\section{SymbolSet}
\subsection{SymbolSet class methods}
\subsubsection{SymbolSet}
\requiredKeyed{entries:}{Cons::listOfStrings}

Create a SymbolSet containing the strings in \sa{listOfStrings}.

\section{TwoAtomFrame}
\subsection{TwoAtomFrame class methods}
\subsubsection{TwoAtomFrame}
\requiredKeyed{name:}{Text::nameOfTwoAtomFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{xAtom:}{Text::nameOfXAtom}

Define a TwoAtomFrame with \sa{nameOfTwoAtomFrame} and centered on the atom with name \sa{nameOfOriginAtom}
with the x-axis on \sa{nameOfXAtom}.


\section{Class methods}
In Cando-Script class names like ``Hit'' or ``Real'' return objects that are of the class ``Class''.  These objects respond to the following methods.

\subsection{describe}
\scriptCmd{describe}{classObject}

Dumps a description of the class to stdout.

\section{HitList class}
  HitList objects store a sorted list of Hit objects as well as a Dictionary for name/object pairs.

\subsection{setHitList}
  \scriptCmd{setHitList}{'symbol maxHits:int}\par
  Create a HitList that can store \scriptArg{maxHits} and put it into the variable named \scriptArg{'symbol}.

\chapter{MSMARTS chemical pattern matching}

Based on SMARTS documentation at 
\begin{verbatim}
http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html
\end{verbatim}

MSMARTS is similar to SMARTS with the following differences.
\begin{itemize}
	\item MSMARTS supports atom tags: numerical labels that can be attached to atoms as an MSMARTS substructure is matched to a molecule. The tagged atoms can then be referenced after the substructure is matched.

	For example: the MSMARTS string "[N\&H1]1C2(=O3)" will recognize a secondary amide and the amide nitrogen, carbonyl carbon and carbonyl oxygen can be obtained using the tags "1", "2" and "3" after a successful match.
	\item The syntax for identifying rings is different. Rings are recognized with strings like: "C1CCC[C\&?1]".  The first "1" assigns a tag "1" to the first carbon, The "[C\&?1]" atom tests if the atom is carbon and has the tag "1".
\end{itemize}

   Substructure searching, the process of finding a particular pattern (subgraph) in a molecule (graph), is one of the most important tasks for computers in chemistry. It is used in virtually every application that employs a digital representation of a molecule, including depiction (to highlight a particular functional group), drug design (searching a database for similar structures and activity), analytical chemistry (looking for previously-characterized structures and comparing their data to that of an unknown), and a host of other problems.

   MSMARTS expressions allow a chemist to specify substructures using rules that 
   are straightforward extensions of SMILES. For example: to search a database 
   for phenol-containing structures, one would use the SMARTS string 
   [OH]c1cccc[c\&?1], which is similar to SMILES (Note: the [c\&?1] atom 
   primative test is used to identify rings in MSMARTS). In fact, almost all 
   SMILES specifications are valid SMARTS targets. Using SMARTS, flexible 
   and efficient substructure-search specifications can be made in terms 
   that are meaningful to chemists.

   In the SMILES language, there are two fundamental types of symbols: atoms and bonds. Using these SMILES symbols, once can specify a molecule's graph (its "nodes" and "edges") and assign "labels" to the components of the graph (that is, say what type of atom each node represents, and what type of bond each edge represents).

   The same is true in SMARTS: One uses atomic and bond symbols to specify a graph. However, in SMARTS the labels for the graph's nodes and edges (its "atoms" and "bonds") are extended to include "logical operators" and special atomic and bond symbols; these allow SMARTS atoms and bonds to be more general. For example, the SMARTS atomic symbol [C,N] is an atom that can be aliphatic C or aliphatic N; the SMARTS bond symbol ~ (tilde) matches any bond.

Below is example code that uses SMARTS to find every amide bond in a molecule:
\begin{verbatim}
#
# Define a ChemInfo object that can carry out
# substructure searches
#
( amideSmarts = [ new ChemInfo] )
#
# Compile a substructure pattern using SMARTS code
#
( amideSmarts compileSmarts "N1~C2=O3" )
# 
# Load a molecule
#
( p53 = [ loadMol2 "p53.mol2" ] )
#
# Iterate through every atom and if it matches
# the substructure search then extract the tagged
# atoms and print their names
#
[foreach a [ atoms p53 ] [block
    [ if ( amideSmarts matches a ) [block 
        [println ( "-----Matching atom: %s" % ( a getName ) ) ]
        ( coAtom = ( amideSmarts getAtomWithTag "2" ) )
        ( oAtom = ( amideSmarts getAtomWithTag "3" ) )
        [ println ( "    Carbonyl carbon: %s" % ( coAtom getName ) ) ]
        [ println ( "    Carbonyl oxygen: %s" % ( oAtom getName ) ) ]
    ] ]
] ]
\end{verbatim}

\section{Atomic Primitives}
   SMARTS provides a number of primitive symbols describing atomic properties beyond those used in SMILES (atomic symbol, charge, and isotopic specifications). The following tables list the atomic primitives used in SMARTS (all SMILES atomic symbols are also legal). In these tables <n> stands for a digit, <c> for chiral class.

   Note that atomic primitive H can have two meanings, implying a property or the element itself. [H] means hydrogen atom. [*H2] means any atom with exactly two hydrogens attached
   
   	\begin{tabular}{| l | l | l | l |}
	\hline
	Symbol & Symbol name & Atomic property requirements & Default \\ \hline
	* & wildcard & any atom & (no default) \\ \hline
	D\emph{n} & APDegree & explicit connections & exactly one \\ \hline
	H\emph{n} & APTotalHCount& \emph{n} attached hydrogens & exactly one \\ \hline
	h\emph{n} & APImplicitHCount& \emph{n} implicit attached hydrogens & at least one\\ \hline
	?\emph{n} & APRingTest& Atom is matched to atom tagged with \emph{n}& (no default)\\ \hline
	U\emph{n} & APResidueTest& Atom must be in same residue as atom tagged \emph{n}& (no default)\\ \hline
	R\emph{n} & APRingMemberCount & is in \emph{n} SSSR rings \par(WORKS?)& any ring atom\\ \hline
	r\emph{n} & APRingSize & is in smallest SSSR size \emph{n} & any ring atom\\ \hline
	v\emph{n} & APValence & total bond order \emph{n} & exactly 1 \\ \hline
	X\emph{n} & APConnectivity& \emph{n} total connections & exactly 1 \\ \hline
	-\emph{n} & APNegativeCharge & -\emph{n} charge & exactly -1 \\ \hline
	-- & APNegativeCharge 2x & -2 charge & exactly -2 \\ \hline
	--- & APNegativeCharge 3x & -3 charge & exactly -3 \\ \hline
	+\emph{n} & APPositiveCharge & +\emph{n} charge & exactly +1 \\ \hline
	++ & APPositiveCharge 2x & +2 charge & exactly +2 \\ \hline
	+++ & APPositiveCharge 3x & +3 charge & exactly +3 \\ \hline
	\#\emph{n} & APAtomicNumber & atomic number \emph{n} & (no default) \\ \hline
	\emph{n} & APAtomicMass & atomic mass \emph{n} & (no default) \\ \hline
	\$(\emph{\tiny MSMARTS}) & recursive MSMARTS & match recursive MSMARTS & (no default) \\ \hline
\end{tabular}

Some of these have not been debugged. Test before you trust them.

Examples: \par
\begin{tabular}{| l | l |}
\hline
  [CH2] & aliphatic carbon with two hydrogens (methylene carbon) \\ \hline
  [!C;R] & ( NOT aliphatic carbon ) AND in ring \\ \hline
  [!C;!R0] & same as above ("!R0" means not in zero rings) \\ \hline
  [n;H1] & H-pyrrole nitrogen \\ \hline
  [n\&H1] & same as above \\ \hline
  [nH1] & same as above \\ \hline
  [c,n\&H1] & any arom carbon OR H-pyrrole nitrogen \\ \hline
  [X3\&H0] & atom with 3 total bonds and no H's \\ \hline
  [c,n;H1] & (arom carbon OR arom nitrogen)  and exactly one H \\ \hline
  [Cl] & any chlorine atom \\ \hline
  [35*] & any atom of mass 35 \\ \hline
  [35Cl] & chlorine atom of mass 35 \\ \hline
  [F,Cl,Br,I] & the 1st four halogens. \\ \hline
\end{tabular}

\section{Logical Operators}

 Atom and bond primitive specifications may be combined to form expressions by using logical operators. In the following table, e is an atom or bond SMARTS expression (which may be a primitive). The logical operators are listed in order of decreasing precedence (high precedence operators are evaluated first).

All atomic expressions which are not simple primitives must be enclosed in brackets. The default operation is \& (high precedence "and"), i.e., two adjacent primitives without an intervening logical operator must both be true for the expression (or subexpression) to be true.

The ability to form expressions gives the SMARTS user a great deal of power to specify exactly what is desired. The two forms of the AND operator are used in SMARTS instead of grouping operators.

\begin{tabular}{|l|l|l|}
\hline
\textbf{Symbol} & \textbf{Expression} & \textbf{Meaning} \\ \hline
exclamation & !e1 & not e1 \\ \hline
ampersand & e1\&e2 & e1 and e2 (high precedence) \\ \hline
comma & e1,e2  & e1 or e2 \\ \hline
semicolon & e1;e2  & e1 and e2 (low precedence) \\ \hline
\end{tabular}

\section{Recursive MSMARTS}

     Any MSMARTS expression may be used to define an atomic environment by writing a SMARTS starting with the atom of interest in this form:
     \$(\emph{MSMARTS})
     Such definitions may be considered atomic properties. These expressions can be used in same manner as other atomic primitives (also, they can be nested). Recursive SMARTS expressions are used in the following manner:

	\begin{tabular}{| l | l |}
	\hline
	*C & atom connected to methyl or methylene carbon \\ \hline
	*CC & atom connected to ethyl carbon \\ \hline
	[\$(*C);\$(*CC)] & Atom in both above environments (matches CCC) \\ \hline
	\end{tabular}

The additional power of such expressions is illustrated by the following
example which derives an expression for methyl carbons which are ortho to
oxygen and meta to a nitrogen on an aromatic ring.


\begin{tabular}{| l | l | }
\hline
CaaO & C ortho to O \\ \hline
CaaaN & C meta to N \\ \hline
Caa(O)aN & C ortho to O and meta to N (but 2O,3N only) \\ \hline
Ca(aO)aaN & C ortho to O and meta to N (but 2O,5N only) \\ \hline
C[\$( aaO);\$( aaaN)] & C ortho to O and meta to N (all cases) \\ \hline
\end{tabular}

