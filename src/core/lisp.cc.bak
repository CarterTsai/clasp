#define	DEBUG_LEVEL_FULL



#include "useBoostPython.h"

#include <stdlib.h>

#include "boost/filesystem.hpp"
#include "boost/program_options.hpp"
//#i n c l u d e	"boost/fstream.hpp"
#include "foundation.h"
#include "object.h"
#include "candoOpenMp.h"
#include "exceptions.h"
#include "symbolTable.h"
#include "compiler.h"
#include "lisp.h"
#include "loadTimeValues.h"
#include "profiler.h"
#include "bundle.h"
#include "stringSet.h"
#include "pointer.h"
#include "cons.h"
#include "specialForm.h"
#include "documentation.h"
#include "backquote.h"
#include "bformat.h"
#include "environment.h"
#include "binder.h"
#include "numbers.h"
#include "bignum.h"
//#i n c l u d e "setfExpander.h"
#include "standardObject.h"
#include "ql.h"
#include "str.h"
#include "commonLispPackage.h"
#include "keywordPackage.h"
#include "fileSystem.h"
#include "sysprop.h"
#include "hashTableEql.h"
#include "debugger.h"
#include "builtInClass.h"
#include "standardClass.h"
#include "executables.h"
#include "myReadLine.h"
#include "sourceFileInfo.h"
#include "lispStream.h"
#include "lispReader.h"
#include "lispMath.h"
#include "print.h"
#include "core/genericFunction.h"
#include "multipleValues.h"
#if defined(XML_ARCHIVE)
#include "xmlLoadArchive.h"
#include "xmlSaveArchive.h"
#endif // defined(XML_ARCHIVE)
#if defined(OLD_SERIALIZE)
#include "serialize.h"
#endif // defined(OLD_SERIALIZE)
#include "bootStrapCoreSymbolMap.h"
#include "numerics.h"
#include "reader.h"
//#i n c l u d e "genericFunction.h"
#include "singleDispatchGenericFunction.h"
#include "executables.h"
#include "designators.h"
#include "sort.h"
#include "bitVector.h"
#include "character.h"
#include "primitives.h"
#include "package.h"
#include "symbol.h"
#include "lambdaListHandler.h"
#include "sequence.h"
#include "evaluator.h"
#include "lispDefinitions.h"
#include "myReadLine.h"
#include "externalObject.h"
#include "initializeClasses.h"
#include "holder.h"
#include "core/corePackage.h"
#include "core/stacks.h"
#include "primitives.h"
#include "readtable.h"
//#i n c l u d e "clos.h"
#include "wrappers.h"
#include "python_wrappers.h"

#ifdef	READLINE
extern "C" char *readline( const char* prompt);
extern "C" void add_history(char* line);
#endif

#define ARGS_empty ""
#define DOCS_empty ""


namespace core 
{


    LispHolder* DefaultLispHolder = NULL;


    extern void lispScannerDebug(istream& sin);
    extern string	getLispError();


    SMART(BuiltInClass);









//
// Constructor
//
    Lisp_O::Lisp_O() : _StackWarnSize(15*1024*1024), // 8MB default stack size before warnings
		       _StackSampleCount(0),
		       _StackSampleSize(0),
		       _StackSampleMax(0),
		       _Bundle(NULL),
		       _DebugStream(NULL),
		       _SingleStepLevel(UndefinedUnsignedInt),
		       _profiler(NULL), 
		       _SystemProperties(_Unbound<HashTable_O>()),
		       _freeOutputStream(false),
		       _PrintvWriteChar(NULL), 
		       _PrintvFlush(NULL), 
		       _MpiEnabled(false), 
		       _MpiRank(0),
		       _MpiSize(1),
		       _Interactive(false),
		       _EmbeddedInPython(false), 
		       _dont_load_startup(false),
		       _BootClassTableIsValid(true)
    {
	this->_Bindings.reserve(1024);
	this->_freeOutputStream = false;
	this->_outputStream = &cout;
	this->_GlobalInitializationCallbacks.clear();
	this->_MakePackageCallback = NULL;
	this->_ExportSymbolCallback = NULL;
#if CLOS
	this->_SlotCachePtr = NULL;
	this->_MethodCachePtr = NULL;
#endif
    }


    void Lisp_O::shutdownLispEnvironment()
    {
	if ( this->_DebugStream != NULL )
	{
	    this->_DebugStream->beginNode(DEBUG_TOPLEVEL);
	}
	this->_CommandLineArguments.reset();
	this->_Packages.clear();
	this->_HiddenBinder.reset();
	this->_SpecialForms.clear();
	this->_TrueObject.reset();
	this->_EofObject.reset();

#if 0
	// 
	// Wipe out the classes in reverse order of how they were created
	// This may still pose problems for BuiltInClass_O and Class_O, the
	// first two classes created
	//
	for ( int i=this->_ClassesByClassSymbol.size()-1;  i>= 0; i-- )
	{
	    LOG(BF( "About to destroy class#%d(%s)") % i % this->_ClassesByClassSymbol[i]->name()->__repr__() );
	    this->_ClassesByClassSymbol[i].reset();
	}
#endif
//    this->_ClassesByClassSymbol.clear();
	if ( this->_Bundle != NULL )    
	{
	    delete this->_Bundle;    
	}
	if ( this->_profiler != NULL )    {	delete this->_profiler; }
	if ( this->_DebugStream!=NULL )    
	{ 
	    this->_DebugStream->endNode(DEBUG_TOPLEVEL);
	    delete this->_DebugStream; 
	}
	if ( this->_freeOutputStream ) 
	{
	    if ( this->_outputStream!=NULL ) delete this->_outputStream;
	}
    }




    void print_startup_info()
    {
#if 1
	printf("%s:%d BRIDGE-COMMON-LISP startup\n", __FILE__, __LINE__ );
#endif
    };
	



    Lisp_O::~Lisp_O()
    {
	// nothing is left to be done here
    }

#if 0    
    InvocationFrame const & Lisp_O::__topFrameWithParsePos(Cons_sp& ppcons) const
    {_G();
	for ( ExecutionStack::const_reverse_iterator ri = this->_ExecutionStack.rbegin(); ri!= this->_ExecutionStack.rend(); ri++ )
	{
	    if ( ri->_Code->consP() )
	    {
		Cons_sp code = ri->_Code->as<Cons_O>();
		ppcons = code->walkToFindParsePos();
		if ( ppcons->notNil() )	return *ri;
	    }
	}
	SIMPLE_ERROR(BF("Nothing on the stack has parsePos"));
    }

    InvocationFrame& Lisp_O::__frame(int idx)
    {_OF();
	if ( idx < 0 ) idx = 0;
	if ( idx > this->__lastFrameIndex() ) idx = this->__lastFrameIndex();
	return this->_ExecutionStack[idx];
    }

#endif
    void Lisp_O::lisp_initSymbols(Lisp_sp lisp)
    {
	Package_sp corePackage = lisp->_CorePackage;
    }


    void	Lisp_O::initialize()
    {
	// Don't do anything here
	// add initialization to the end of createLispEnvironment
    }



    void Lisp_O::addToStarModulesStar(Symbol_sp sym)
    {_OF();
	Cons_sp list = cl::_sym_STARmodulesSTAR->symbolValue()->as<Cons_O>();
	list = Cons_O::create(sym,list,_lisp);
	cl::_sym_STARmodulesSTAR->setf_symbolValue(list);
    }



    template <class oclass>
    void setup_static_classSymbol(BootStrapCoreSymbolMap const& sidMap)
    {
	oclass::___set_static_ClassSymbol(sidMap.lookupSymbol(oclass::static_packageName(),oclass::static_className()));
    }



    string dump_instanceClass_info(Class_sp co, Lisp_sp prog)
    {_G();
	stringstream ss;
	ss << "------------------------------------- class" << co->classNameSymbol()->__repr__() << endl;;
	LOG(BF("Dumping info: %s") % co->dumpInfo() );
	ss << co->dumpInfo();
	return ss.str();
    }
    template <class oclass>
    void dump_info(BuiltInClass_sp co, Lisp_sp lisp)
    {_G();
	LOG(BF("-------    dump_info    --------------- className: %s @ %X")% oclass::static_className() % co.get());
	LOG(BF("%s::static_classSymbol() = %d")% oclass::static_className() % oclass::static_classSymbol() );
	LOG(BF("%s::Base::static_classSymbol() = %d")% oclass::static_className() % oclass::Base::static_classSymbol() );
	LOG(BF("%s::static_newNil_callback() = %X")% oclass::static_className() % (void*)(oclass::static_newNil_callback()) );
//    LOG(BF("%s")%dump_instanceClass_info(co,lisp));
    }





    Lisp_sp Lisp_O::createLispEnvironment(bool mpiEnabled, int mpiRank, int mpiSize )
    {
	Lisp_sp lisp(new Lisp_O());
	::_lisp = lisp;
	lisp->setupMpi(mpiEnabled,mpiRank,mpiSize);
//	lisp->__setWeakThis(lisp);
//	lisp->__resetInitializationOwner();
	lisp->_DebugStream = new DebugStream(mpiRank);
	LOG(BF("The lisp environment DebugStream has been created"));
	lisp->_profiler = new LightProfiler();
	lisp->_PrintvWriteChar = foundation_printv_writeChar;
	lisp->_PrintvFlush = foundation_printv_flush;

	return lisp;
    }



    void Lisp_O::setupMpi(bool mpiEnabled, int mpiRank, int mpiSize)
    {
	this->_MpiEnabled = mpiEnabled;
	this->_MpiRank = mpiRank;
	this->_MpiSize = mpiSize;
    }



    void Lisp_O::startupLispEnvironment(Bundle* bundle)
    {_G();
	this->_Mode = FLAG_EXECUTE;

	// Print info at startup
	print_startup_info();

	::_lisp = this; // this->sharedThis<Lisp_O>();
	
//	initializeProfiler(this->profiler(),_lisp);
	this->_TraceLevel = 0;
	this->_DebuggerLevel = 0;
	this->_CoreBuiltInClassesInitialized = false;
	this->_PackagesInitialized = false;
	this->_BuiltInClassesInitialized = false;
	this->_NilsCreated = false;
	this->_EnvironmentInitialized = false;
	this->_EnvironmentId = 0;
	this->_CommandLineArguments.reset();
	this->_Graphical = false;

	this->_Bundle = bundle;


	CoreExposer* coreExposerPtr = NULL;
	BuiltInClass_sp classDummy;
	{_BLOCK_TRACE("Initializing multiple return values");
	    global_MultipleReturnValues = new MultipleValues(MULTIPLE_VALUES_LIMIT);
	}

	{ _BLOCK_TRACE("Initialize core classes by hand");
	    coreExposerPtr = CoreExposer::create_core_classes(_lisp);
	    {_BLOCK_TRACE("Define important predefined symbols for CorePkg");
		coreExposerPtr->define_essential_globals(_lisp);
		this->_PackagesInitialized = true;
	    }
	}
#if 0
	{_BLOCK_TRACE("Create a top-level lexical environment");
	    this->_TopLevelEnvironment = Environment_O::_nil;
	}
#endif
	{ _BLOCK_TRACE("Initialize special forms and macros");
	    this->_EnvironmentInitialized = true;
	    eval::defineSpecialFormsAndMacros(this->_CorePackage);
	    this->createHiddenBinder();
	}
	this->_BuiltInClassesInitialized = true;
	LOG(BF("ALL CLASSES: %s")% this->dumpClasses() );
//    this->createNils();
#if 0
	this->_NilsCreated= true;
	ASSERT(this->_BootClassTableIsValid);
	{_BLOCK_TRACE("Initialize the nil object for each class");
	    for ( SymbolMap<Class_O>::iterator mi=this->_BootClassTable.begin();
		  mi!=this->_BootClassTable.end(); mi++ )
	    {
		Class_sp mc = mi->second;
		{_BLOCK_TRACEF(BF("Initializing nil for class: %s")% mc->instanceClassName() );
		    T_sp theNilObject = mc->instanceNil<T_O>();
		    ASSERTNOTNULL(theNilObject);
		    theNilObject->initialize();
		}
	    }
	}
#endif
	{_BLOCK_TRACE("Dump of all BuiltInClass classes");
#ifdef	DEBUG_ON
	    //    rootClassManager().debugDump();
#endif
	}


//	LOG(BF("Package(%s) symbols: %s")% this->_CorePackage->getName() % this->_CorePackage->allSymbols() );
//	LOG(BF("Package(%s) symbols: %s")% keywordPackage->getName() % keywordPackage->allSymbols() );

	//
	// Finish initializing Lisp object
	//
	this->_CommandLineArguments = Cons_O::_nil;
	{_BLOCK_TRACE("Initialize scripting stuff");
#include "core_initScripting_inc.h"
	}
	{_BLOCK_TRACE("Initialize other code"); // needs _TrueObject
#define Use_CorePkg
#include "core_initScripting_inc.h"
#undef Use_CorePkg
	    initialize_foundation();
	    initialize_primitives();
	    initialize_stacks();
	    initialize_documentation_primitives(_lisp);
	    initialize_compiler_primitives(_lisp);
	    initialize_backquote(_lisp);
	    initialize_bformat(_lisp);
	    initialize_sysprop();
	    initialize_profile();
	    initialize_designators();
	    initialize_math();
	    initialize_lispStream();
	    initialize_print();
#if CLOS
	    initialize_genericFunction();
#endif
	    initialize_conditions();
	    initialize_exceptions();

	    coreExposerPtr->expose(_lisp,PackageExposer::candoClasses);
//	    initializeCandoClos(_lisp);
	}
	{_BLOCK_TRACE("Initializing special variable PATH");
	    boost_filesystem::path scriptPath = bundle->getLispDir();
	    Cons_sp path = this->create<Cons_O>(this->create<Str_O>("./"));
	    if ( !scriptPath.empty() )
	    {
		Str_sp scriptDir = this->create<Str_O>(scriptPath.string());
		path = Cons_O::create(scriptDir,path,_lisp);
	    }
	    Symbol_sp sym = _sym_STARPATHSTAR;
	    this->defvar(sym,path);
	    this->_RequireLevel = 0;
	}
	//
	//
	//
	this->exposeCando();
	Lisp_O::initializeGlobals(_lisp);
	coreExposerPtr->expose(_lisp,PackageExposer::candoFunctions);
	coreExposerPtr->expose(_lisp,PackageExposer::candoGlobals);
	{_BLOCK_TRACE("Call global initialization callbacks");
	    for ( vector<InitializationCallback>::iterator ic = this->_GlobalInitializationCallbacks.begin(); 
		  ic!=this->_GlobalInitializationCallbacks.end(); ic++ )
	    {
		(*ic)(_lisp);
	    }
	}

	Path_sp startupWorkingDir = Path_O::create(bundle->getStartupWorkingDir());
	this->defconstant(_sym_STARcurrent_working_directorySTAR,Path_O::_nil);
	this->setCurrentWorkingDirectory(startupWorkingDir);

	this->switchToClassNameHashTable();

	{_BLOCK_TRACE("Creating Caches for CLOS");
	    this->_MethodCachePtr = new Cache(MaxFunctionArguments,ClosCacheSize);
	    this->_SlotCachePtr = new Cache(MaxClosSlots,ClosCacheSize);
	}
	if ( this->_dont_load_startup )
	{_BLOCK_TRACE("Load startup code");
	    Path_sp corePath = Path_O::create(this->_Bundle->getLispDir());
	    corePath->path_append("/init");
	    corePath->path_append("/coreFile.lisp");
	    {_BLOCK_TRACEF(BF("Loading core-file with path: %s") % corePath->asString() );
		this->load(corePath);
	    }
	} else
	{
	    LOG(BF("Not loading startup code"));
	}
    }

#if 0
    void Lisp_O::add_accessor_pair(Symbol_sp getter, Symbol_sp setter)
    {_OF();
	Symbol_sp getSym = getter;
	Symbol_sp setSym = setter;
	FunctionNameSetfExpander_sp expander = FunctionNameSetfExpander_O::create(setSym,_lisp);
	_lisp->addSetfExpander(getSym,expander);
    }


    void Lisp_O::addSetfExpander(Symbol_sp sym, SetfExpander_sp expander)
    {_OF();
	LOG(BF("Adding setf expander for symbol[%s] expander[%s]") % sym->__repr__() % expander->__repr__() );
	this->_SetfExpanders.set(sym,expander);
    }

    SetfExpander_sp Lisp_O::lookupSetfExpander(Symbol_sp sym) const
    {_OF();
	SymbolMap<SetfExpander_O>::const_iterator it = this->_SetfExpanders.find(sym);
	if ( it == this->_SetfExpanders.end() ) 
	{
	    LOG(BF("Could not find expander for symbol[%s]") % sym->__repr__() );
	    LOG(BF("Recognized symbols for setf expansion[%s]")
		% StringSet_O::create_fromKeysOfSymbolMap(this->_SetfExpanders,_lisp)->asString() );
	    return SetfExpander_O::_nil;
	}
	LOG(BF("Found setf expander for symbol[%s]") % sym->__repr__() );
	return it->second;
    }

#endif




    void Lisp_O::setCurrentWorkingDirectory(Path_sp dir)
    {
	_sym_STARcurrent_working_directorySTAR->setf_symbolValueReadOnlyOverRide(dir);
    }

    Path_sp Lisp_O::getCurrentWorkingDirectory()
    {
	return _sym_STARcurrent_working_directorySTAR->symbolValue()->as<Path_O>();
    }



    ReadTable_sp Lisp_O::getCurrentReadTable()
    {
	return cl::_sym_STARreadtableSTAR->symbolValue()->as<ReadTable_O>();
    }

    void Lisp_O::setMakePackageAndExportSymbolCallbacks(MakePackageCallback mpc, ExportSymbolCallback esc)
    {_OF();
	LOG(BF("Setting MakePackageCallback and ExportSymbolCallback"));
	this->_MakePackageCallback = mpc;
	this->_ExportSymbolCallback = esc;
    }




    void Lisp_O::setupOutputCallbacks(PrintvWriteCharCallback pvc, PrintvFlushCallback pf)
    {
	this->_PrintvWriteChar = pvc;
	this->_PrintvFlush = pf;
    }










#if defined(OLD_SERIALIZE)
    T_sp Lisp_O::sread(Stream_sp sin, bool eofErrorP, T_sp eofValue )
    {_OF();
	ReadSerializer_sp reader = _lisp->create<ReadSerializer_O>();
	T_sp obj = reader->read(sin,eofErrorP,eofValue);
	return obj;
    }

    void Lisp_O::sprint(T_sp obj, Stream_sp sout )
    {_OF();
	WriteSerializer_sp writer = _lisp->create<WriteSerializer_O>();
	writer->addObject(obj);
	writer->write(sout);
    }
#endif // defined(OLD_SERIALIZER)


    void Lisp_O::set_setfDefinition(Symbol_sp fnName, Function_sp fnDef)
    {_G();
	this->_SetfDefinitions[fnName] = fnDef;
    }

    Function_sp Lisp_O::get_setfDefinition(Symbol_sp fnName) const
    {_G();
	SymbolMap<Function_O>::const_iterator it = this->_SetfDefinitions.find(fnName);
	if ( it == this->_SetfDefinitions.end() ) 
	{
	    return Function_O::_nil;
	}
	return it->second;
    }

    bool Lisp_O::remove_setfDefinition(Symbol_sp fnName)
    {_G();
	SymbolMap<Function_O>::const_iterator it = this->_SetfDefinitions.find(fnName);
	if ( it == this->_SetfDefinitions.end() ) 
	{
	    return false;
	}
	this->_SetfDefinitions.erase(fnName);
	return true;
    }





    void Lisp_O::print(boost::format fmt)
    {_OF();
	TRY_BOOST_FORMAT_STRING(fmt,fmt_str);
	this->printvWrite("\n");
	if ( this->_PrintvLinePrefix != "" ) this->printvWrite(this->_PrintvLinePrefix.c_str());
	this->printvWrite(fmt_str.c_str());
	this->printvFlush();
    }

    void Lisp_O::prin1(boost::format fmt)
    {
	TRY_BOOST_FORMAT_STRING(fmt,fmt_str);
	this->printvWrite(fmt_str.c_str());
	this->printvFlush();
    }



    void Lisp_O::printvWrite(const char* buffer)
    {
	for ( const char* cp = buffer; *cp; cp++ )
	{
	    this->printvWriteChar(*cp);
	}
    }

    void Lisp_O::printvWriteChar(char c)
    {
	HARD_ASSERT(this->_PrintvWriteChar!=NULL);
	(this->_PrintvWriteChar)(c);
	if ( c == '\n' ) this->printvWrite(this->_PrintvLinePrefix.c_str());
    }

    void Lisp_O::printvFlush()
    {
	HARD_ASSERT(this->_PrintvFlush!=NULL);
	(this->_PrintvFlush)();
    }


    Cons_sp Lisp_O::loadTimeValuesIds() const
    {_G();
	Cons_sp names = Cons_O::_nil;
	map<string,LoadTimeValues_sp>::const_iterator it;
	for ( it=this->_LoadTimeValueArrays.begin(); it!=this->_LoadTimeValueArrays.end(); it++ )
	{
	    names = Cons_O::create(Str_O::create(it->first,_lisp),names,_lisp);
	}
	return names;
    }
	

    LoadTimeValues_sp& Lisp_O::getLoadTimeValues(const string& name,int numberOfLoadTimeValues, int numberOfLoadTimeSymbols)
    {_G();
	map<string,LoadTimeValues_sp>::iterator it = this->_LoadTimeValueArrays.find(name);
	if ( it == this->_LoadTimeValueArrays.end() )
	{
	    LoadTimeValues_sp vo = LoadTimeValues_O::make(numberOfLoadTimeValues, numberOfLoadTimeSymbols);
	    this->_LoadTimeValueArrays[name] = vo;
	    return this->_LoadTimeValueArrays[name];
	}
	return it->second;
    }

    void Lisp_O::defvar(Symbol_sp sym, T_sp obj)
    {_OF();
	sym->makeSpecial();
	sym->setf_symbolValue(obj);
    }

    void Lisp_O::defconstant(Symbol_sp sym, T_sp obj)
    {_OF();
	sym->makeSpecial();
	sym->setf_symbolValue(obj);
	sym->setReadOnly(true);
    }



    void Lisp_O::setOutputStream(ostream* o)
    {_OF();
	if ( this->_freeOutputStream )
	{
	    delete this->_outputStream;
	}
	this->_freeOutputStream = true;
	this->_outputStream = o;
    }

    ostream& Lisp_O::outputStream()
    {
	return *(this->_outputStream);
    }



    T_sp Lisp_O::error(const boost::format& fmt)
    {_OF();
	return CandoException_O::create(fmt);
    }


    Symbol_sp Lisp_O::errorUndefinedSymbol(const char* sym)
    {_OF();
	stringstream ss;
	ss << "Unknown symbol("<<sym<<")";
	SIMPLE_ERROR(BF("%s") % ss.str());
    }









    void Lisp_O::createHiddenBinder()
    {_G();
	this->_HiddenBinder = this->create<Binder_O>();
    }

    Binder_sp Lisp_O::hiddenBinder()
    {_G();
	ASSERTNOTNULL(this->_HiddenBinder);
	ASSERT(this->_HiddenBinder->notNil());
	return this->_HiddenBinder;
    }


    Symbol_sp Lisp_O::defineSpecialForm(const string& rawFormName, SpecialFormCallback cb, const string& argstring, const string& docstring )
    {_OF();
	string formName = lispify_symbol_name(rawFormName);
	Symbol_sp sym = _lisp->intern(formName)->exportYourself();
	SpecialForm_sp special = SpecialForm_O::create(sym,cb,_lisp);
	ASSERTP(this->_SpecialForms.count(sym)==0,"You cant define a special form with the symbol("+formName+") it has already been defined");
	this->_SpecialForms[sym] = special;
	return sym;
    }









    SpecialForm_sp Lisp_O::specialFormOrNil(Symbol_sp sym)
    {
	if ( sym->isNil() ) return SpecialForm_O::_nil;
	map<Symbol_sp,SpecialForm_sp>::iterator si = this->_SpecialForms.find(sym);
	if ( si==this->_SpecialForms.end() ) return SpecialForm_O::_nil;
	return si->second;
    }







    void Lisp_O::installPackage(const PackageExposer* pkg)
    {_OF();
	LOG(BF("Installing package[%s]") % pkg->packageName() );
	int firstNewGlobalCallback = this->_GlobalInitializationCallbacks.end()-this->_GlobalInitializationCallbacks.begin();
	ChangePackage change(pkg->package());
//    this->inPackage(pkg->packageName());
	{_BLOCK_TRACE("Initializing classes");
	    pkg->expose(_lisp,PackageExposer::candoClasses);
	}
	{_BLOCK_TRACE("Creating nils for built-in classes");
	    LOG(BF("Nils aren't created here anymore - they are created when the class is registered"));
//	this->createNils();
	}
	{_BLOCK_TRACE("Initializing functions");
	    pkg->expose(_lisp,PackageExposer::candoFunctions);
	}
	{_BLOCK_TRACE("Initializing globals");
	    pkg->expose(_lisp,PackageExposer::candoGlobals);
	}


	{_BLOCK_TRACE("Call global initialization callbacks");
	    for ( vector<InitializationCallback>::iterator ic = this->_GlobalInitializationCallbacks.begin()+firstNewGlobalCallback; 
		  ic!=this->_GlobalInitializationCallbacks.end(); ic++ )
	    {
		(*ic)(_lisp);
	    }
	}

    }


    void Lisp_O::installGlobalInitializationCallback(InitializationCallback c)
    {
	this->_GlobalInitializationCallbacks.push_back(c);
    }



#if defined(XML_ARCHIVE)
    void	Lisp_O::archive(::core::ArchiveP node)
    {_OF();
	SIMPLE_ERROR(BF("Never archive Lisp objects"));
    }
#endif // defined(XML_ARCHIVE)


    void Lisp_O::addClassNameToPackageAsDynamic(const string& package, const string& name, Class_sp mc)
    {_G();
	Symbol_sp classSymbol = _lisp->intern(name,_lisp->findPackage(package));
	classSymbol->exportYourself();
	classSymbol->setf_symbolValue(mc);
//    this->globalEnvironment()->extend(classSymbol,mc);
//    mc->__setLambdaListHandlerString(mc->getInstanceBaseClass()->__getLambdaListHandlerString());
    }

/*! Add the class with (className) to the current package
 */
    void Lisp_O::addClass(Symbol_sp classSymbol,
			  AllocatorFunctor* alloc,
			  Symbol_sp base1ClassSymbol,
			  Symbol_sp base2ClassSymbol,
			  Symbol_sp base3ClassSymbol )
    {_G();
	LOG(BF("Lisp_O::addClass classSymbol(%s) baseClassSymbol1(%u) baseClassSymbol2(%u)")
	    % classSymbol->__repr__() % base1ClassSymbol % base2ClassSymbol  );
	ASSERTP(IS_SYMBOL_DEFINED(BuiltInClass_O::static_classSymbol()),
		"You cannot create a BuiltInClass before the BuiltIn!Class is defined");
	Class_sp cc;
	if ( classSymbol == StandardObject_O::static_classSymbol() )
	{
	    IMPLEMENT_ME(); // WHEN DO StandardClasses get created with addClass?????
	} else {
	    LOG(BF("Adding BuiltInClass with classSymbol(%d)") % classSymbol );
	    cc = BuiltInClass_O::create(classSymbol,_lisp);
	}
	printf("%s:%d --> Adding class[%s]\n", __FILE__, __LINE__, classSymbol->__repr__().c_str() );
	af_setf_findClass(cc,classSymbol,true,_Nil<Environment_O>());
//	this->boot_setf_findClass(classSymbol,cc);
	if ( IS_SYMBOL_DEFINED(base1ClassSymbol))
	{
	    cc->addInstanceBaseClass(base1ClassSymbol);
	} else
	{
	    SIMPLE_ERROR(BF("There must be one base class"));
	}
	if ( IS_SYMBOL_DEFINED(base2ClassSymbol))
	{
	    cc->addInstanceBaseClass(base2ClassSymbol);
	}
	if ( IS_SYMBOL_DEFINED(base3ClassSymbol))
	{
	    cc->addInstanceBaseClass(base3ClassSymbol);
	}
	cc->setInstance_newNil_callback(alloc);
    }


    StringSet_sp Lisp_O::allClassNames()
    {_G();
	DEPRECIATED();
#if 0
	StringSet_sp ss = this->create<StringSet_O>();
	for ( SymbolMap<Class_O>::iterator li=this->_ClassTable.begin();
	      li!=this->_ClassTable.end(); li++ )
	{
	    ss->insert(li->second->getPackagedName());
	}
	return ss;
#endif
    }





    StandardClass_sp Lisp_O::defineStandardClass(Symbol_sp name, T_sp baseClassesDesignator, Cons_sp slotSpecifiers )
    {_OF();
	IMPLEMENT_MEF(BF("Implement defineStandardClass"));
    }





    string Lisp_O::dumpClasses()
    {_G();
	DEPRECIATED();
#if 0
	stringstream ss;
	for ( SymbolMap<Class_O>::const_iterator it=this->_ClassTable.begin();
	      it != this->_ClassTable.end(); it++ )
	{
	    LOG(BF("Dumping info for class[%s]") % it->first->__repr__() );
	    ss << dump_instanceClass_info(it->second,_lisp);
	}
	return ss.str();
#endif
    }


    void Lisp_O::exportToPython(Symbol_sp sym) const
    {_OF();
	if ( this->_ExportSymbolCallback == NULL )
	{
	    LOG(BF("Could not export symbol[%s] because _ExportSymbolCallback is NULL") % sym->__repr__() );
	} else
	{
	    LOG(BF("Exporting symbol[%s]") % sym->__repr__() );
	    this->_ExportSymbolCallback(sym,_lisp);
	}
    }
	

    Package_sp Lisp_O::makePackage(const string& name,list<string> const& nicknames, list<Package_sp> const& usePackages)
    {_G();
	ASSERTP(this->_PackageNameIndexMap.count(name) == 0,"There already exists a package with name: "+name);
	LOG(BF("Creating package with name[%s]") % name);
	Package_sp newPackage = Package_O::create(name);
	int packageIndex = this->_Packages.size();
	{
	    this->_PackageNameIndexMap[name] = packageIndex;
	    this->_Packages.push_back(newPackage);
	}
	for ( list<string>::const_iterator it=nicknames.begin(); it!=nicknames.end(); it++ )
	{
	    string nickName = *it;
	    if ( this->_PackageNameIndexMap.count(nickName) > 0 && nickName != name  )
	    {
		int existingIndex = this->_PackageNameIndexMap[nickName];
		SIMPLE_ERROR(BF("Package nickname[%s] is already being used by package[%s]") % nickName % this->_Packages[existingIndex]->getName());
	    }
	    this->_PackageNameIndexMap[nickName] = packageIndex;
	}

	for ( list<Package_sp>::const_iterator jit=usePackages.begin(); jit!=usePackages.end(); jit++ )
	{
	    Package_sp usePkg = *jit;
	    LOG(BF("Using package[%s]") % usePkg->getName() );
	    newPackage->usePackage(usePkg);
	}
	if ( this->_MakePackageCallback != NULL )
	{
	    LOG(BF("Calling _MakePackageCallback with package[%s]") % name );
	    this->_MakePackageCallback(name,_lisp);
	} else
	{
	    LOG(BF("_MakePackageCallback is NULL - not calling callback"));
	}
	return newPackage;
    }

#if 0
    bool Lisp_O::usePackage(const string& name)
    {_G();
	ASSERTF(this->_Packages.count(name) != 0,BF("In usePackage - there is no package with name[%s]")%name);
	Package_sp usePackage = this->_Packages.get(name);
	Package_sp currentPackage = this->getCurrentPackage();
	bool used = currentPackage->usePackage(usePackage);
	return used;
    }
#endif

    Package_sp Lisp_O::findPackage(const string& name) const
    {_G();
	map<string,int>::const_iterator fi = this->_PackageNameIndexMap.find(name);
	if ( fi == this->_PackageNameIndexMap.end() )
	{
	    stringstream ss;
	    for ( Vector0<Package_O>::const_iterator it = this->_Packages.begin(); it!=this->_Packages.end(); it++ )
	    {
		ss << " " << (*it)->getName();
	    }
	    SIMPLE_ERROR(BF("In getPackage - there is no package with name[%s] - available packages[%s]") %name % ss.str() );
	}
	Package_sp getPackage = this->_Packages[fi->second];
	return getPackage;
    }


    Package_sp Lisp_O::getCurrentPackage() const
    {_OF();
	// At startup the *package* symbol may not yet
	// be defined or bound to a package - in that case just say we are in the core package
	//
	Package_sp cur;
	if ( IS_SYMBOL_UNDEFINED(cl::_sym_STARpackageSTAR) )
	{
	    cur = this->_CorePackage;
	    goto DONE;
	}
	if ( !cl::_sym_STARpackageSTAR->specialP() )
	{
	    cur = this->_CorePackage;
	    goto DONE;
	}
	cur = cl::_sym_STARpackageSTAR->symbolValue()->as<Package_O>();
    DONE:
	ASSERTNOTNULL(cur);
	return cur;
    }

    void Lisp_O::selectPackage(Package_sp pack)
    {_OF();
	cl::_sym_STARpackageSTAR->setf_symbolValue(pack);
    }

    bool Lisp_O::recognizesPackage(const string& packageName ) const
    {
	map<string,int>::const_iterator pi = this->_PackageNameIndexMap.find(packageName);
	return ( pi!=this->_PackageNameIndexMap.end() );
    }

    void Lisp_O::inPackage(const string& p)
    {_OF();
	map<string,int>::const_iterator pi = this->_PackageNameIndexMap.find(p);
	if ( pi==this->_PackageNameIndexMap.end() )
	{
	    ASSERTP(this->recognizesPackage(p),"I do not recognize package: "+p);
	}
	this->selectPackage(this->_Packages[pi->second]);
    }





    void Lisp_O::defineMethod(const string& name, Symbol_sp classSymbol, Functoid* methoid,const string& args, const string& docstring, bool autoExport)
    {    _G();
	DEPRECIATED(); // moved into lisp_defineSingleDispatchMethod
#if 0
	Class_sp mc = this->classFromClassSymbol(classSymbol);
	Symbol_sp sym = this->internWithPackageName(mc->getPackageName(),name);
	if (autoExport) sym->exportYourself();
	LOG(BF("Interned method in class[%s]@%p with symbol[%s] args[%s] - autoexport[%d]")
	    % mc->instanceClassName() % (mc.get()) % sym->fullName() % args % autoExport );
	MethodPrimitive_sp mp = MethodPrimitive_O::create(sym,mc,methoid,args,docstring,_lisp);
	ASSERTNOTNULL(mp);
	mc->addMethod(sym,mp);
#endif
    }


    void Lisp_O::throwIfBuiltInClassesNotInitialized()
    {_G();
	if ( this->_BuiltInClassesInitialized ) return;
	SIMPLE_ERROR(BF("Cpp-classes are not initialized"));
    }




    Path_sp Lisp_O::translateLogicalPathname(T_sp logicalPathName)
    {_G();
	if ( logicalPathName->isAssignableTo<Str_O>() )
	{
	    string fileName = logicalPathName->as<Str_O>()->get();
	    return Path_O::create(fileName);
#if 0
	    LOG(BF("Looking for file: %s") % fileName.c_str()  );
	    LOG(BF("Looking in current directory"));
	    boost_filesystem::path onePath("./");
	    onePath /= fileName;
	    if ( boost_filesystem::exists(onePath) )
	    {
		return Path_O::create(onePath.string());
	    }
	    Symbol_sp pathSym = _sym_STARPATHSTAR;
	    Cons_sp pathList = pathSym->symbolValue()->as<Cons_O>();
	    LOG(BF("PATH variable = %s") % pathList->__repr__().c_str()  );
	    while ( pathList->notNil() )
	    {
		boost_filesystem::path onePath(pathList->car<Str_O>()->get());
		onePath /= fileName;
		LOG(BF("Checking path[%s]") % onePath.string() );
		if ( boost_filesystem::exists(onePath) )
		{
		    return Path_O::create(onePath.string());
		}
		pathList = pathList->cdr();
	    }
#endif
	    SIMPLE_ERROR(BF("include "+fileName+" error, file does not exist"));
	} else
	{
	    SIMPLE_ERROR(BF("Finish implementing Lisp_O::translateLogicalPathname"));
	}
    }



    Path_sp Lisp_O::translateLogicalPathnameUsingPaths(T_sp logicalPathName)
    {_G();
	if ( logicalPathName->isAssignableTo<Str_O>() )
	{
	    string fileName = logicalPathName->as<Str_O>()->get();
	    LOG(BF("Looking for file: %s") % fileName.c_str()  );
	    LOG(BF("Looking in current directory"));
	    boost_filesystem::path onePath("./");
	    onePath /= fileName;
	    if ( boost_filesystem::exists(onePath) )
	    {
		return Path_O::create(onePath.string());
	    }
	    Symbol_sp pathSym = _sym_STARPATHSTAR;
	    Cons_sp pathList = pathSym->symbolValue()->as<Cons_O>();
	    LOG(BF("PATH variable = %s") % pathList->__repr__().c_str()  );
	    while ( pathList->notNil() )
	    {
		boost_filesystem::path onePath(pathList->car<Str_O>()->get());
		onePath /= fileName;
		LOG(BF("Checking path[%s]") % onePath.string() );
		if ( boost_filesystem::exists(onePath) )
		{
		    return Path_O::create(onePath.string());
		}
		pathList = pathList->cdr();
	    }
	    SIMPLE_ERROR(BF("include "+fileName+" error, file does not exist"));
	} else
	{
	    SIMPLE_ERROR(BF("Finish implementing Lisp_O::translateLogicalPathname"));
	}
    }


    uint Lisp_O::nextEnvironmentId()
    {
	this->_EnvironmentId++;
	return this->_EnvironmentId;
    }

#if 0
    Cons_sp Lisp_O::allLocalNamesAsCons()
    {_OF();
	ASSERT(this->_EnvironmentInitialized);
	return this->_Environment->allLocalNamesAsCons();
    }
#endif

    void Lisp_O::parseCommandLineArguments(int argc,char* argv[], bool compileInputFile)
    {_G();
	namespace po = boost::program_options;
	this->_dont_load_startup = false;
	stringstream ss;
	string fileName;
#ifdef DEBUG_ON
	LOG(BF("There are %d arguments") % argc  );
	for ( int ii=0; ii<argc; ii++ )
	{
	    LOG(BF(" argument #%d %s") % ii % argv[ii]  );
	}
#endif
	string dbFileName;
	boost_filesystem::path filePath;
	this->_RenderFileName = "";
	po::options_description desc("Allowed options");
	desc.add_options()
	    ("help,h", "produce help message")
	    ("database,d",po::value<string>(),"define database")
	    ("output,o",po::value<string>(),"define output")
	    ("exec,e",po::value<string>(),"execute string")
	    ("render,r",po::value<string>(),"render object")
	    ("feature,+",po::value< vector<string> >(),"turn on feature")
	    ("scanner,S","run the scanner on the input")
	    ("noload,n","dont load the startup code - go straight into repl")
	    ("core,c","Use the specified core file (defines macros/system functions)  rather than the default")
	    ("init,I","specify the initialization file")
	    ("seed,s",po::value<int>(),"seed the random number generators")
	    ("interactive,i","bring up interactive REPL after script/command evaluated")
	    ;

	po::variables_map vm;
#if 1 // allow unregistered options
	po::parsed_options parsed = po::command_line_parser(argc,argv)
	    .options(desc)
	    .allow_unregistered()
	    .run();
	po::store(parsed,vm);
	vector<string> to_pass_further = po::collect_unrecognized(parsed.options,po::include_positional);

#ifdef	DEBUG_ON
	for ( vector<string>::iterator zit=to_pass_further.begin();
	      zit!=to_pass_further.end(); zit++ )
	{
	    LOG(BF("to_pass_further: %s") % ((*zit).c_str() ) );
	}
#endif
#else
	po::store( po::command_line_parser(argc,argv).
		   options(desc).positional(p).run(), vm );
#endif
	po::notify(vm);

	if ( vm.count("help") )
	{
	    stringstream ss;
	    ss << desc;
	    _lisp->print(BF("%s")% ss.str());
	    return;
	}


	//
	//
	const char* execName = argv[0]+strlen(argv[0])-1;
	while (execName >= argv[0] && *execName != '/') execName--;
	execName++;
	this->_FunctionName = execName;
	this->_RCFileName = EXECUTABLE_NAME "/init.lsp";
	if ( vm.count("init") )
	{
	    this->_RCFileName = vm["init"].as<string>();
	    LOG(BF( "Using initialization file(%s)")% this->_RCFileName);
	}

	if ( vm.count("feature") )
	{
	    vector<string> feature = vm["feature"].as< vector<string> >();
	    Cons_sp features = cl::_sym_STARfeaturesSTAR->symbolValue()->as<Cons_O>();
	    for ( vector<string>::iterator fit=feature.begin(); fit!=feature.end(); fit++ )
	    {
		if ( (*fit) == "" )
		{
		    SIMPLE_ERROR(BF("You must provide a feature with -+"));
		}
		features = Cons_O::create(_lisp->internKeyword(lispify_symbol_name(*fit)),features,_lisp);
	    }
	    cl::_sym_STARfeaturesSTAR->setf_symbolValue(features);
	}
	if ( vm.count("noload") )
	{
	    this->_dont_load_startup = true;
	    this->_Interactive = true;
	}
	if ( vm.count("interactive") )
	{
	    this->_Interactive = true;
	}
	if ( vm.count("output") )
	{
	    string outputFileName = vm["output"].as<string>();
	    LOG(BF("Parsing option -o %s") % outputFileName );
	    boost::format fn("%s%05d");
	    fn % outputFileName % this->mpiRank();
	    TRY_BOOST_FORMAT_STRING(fn,fn_str);
	    LOG(BF("Setting output to fileName(%s)") % fn_str );
	    printvSetOutputFileName(fn_str);
	}
	if ( vm.count("seed") )
	{
	    string seed= vm["seed"].as<string>();
	    long iseed = atol(seed.c_str());
	    LOG(BF("Parsing option -s %s") % seed.c_str()  );
	    seedRandomNumberGenerators(iseed);
	} else
	{
	    seedRandomNumberGenerators(this->mpiRank());
	}

	//
	// Pass whatever is left over to the Lisp environment
	//
	LOG(BF("Parsing what is left over into lisp environment arguments") );
	Cons_sp args = Cons_O::createFromVectorStringsCommandLineArguments(to_pass_further,_lisp);
	LOG(BF(" Command line arguments are being set in Lisp to: %s") % args->__repr__().c_str()  );
	this->_CommandLineArguments = args;

	if ( !compileInputFile ) return;

	//
	// Get the script from the command line or the input-file
	//
	if ( vm.count("exec") != 0 )
	{
	    string script = vm["exec"].as<string>();
	    this->_ProgramCode._ScriptInFile = false;
	    this->_ProgramCode._FileNameOrCode = script+"\n";
	} else 
	{
	    LOG(BF("Evaluating first argument as the script name") );
	    Symbol_sp sym = _sym_STARARGSSTAR;
	    LOG(BF("Binding symbol(%s) to: %s") % sym->fullName() % this->_CommandLineArguments->__repr__() );
	    sym->setf_symbolValue(this->_CommandLineArguments);
//        this->globalEnvironment()->extend(sym,this->_CommandLineArguments);
	    this->_ProgramCode._ScriptInFile = true;
	    this->_ProgramCode._FileNameOrCode = this->_CommandLineArguments->car<Str_O>()->get();
	}
	if ( vm.count("render") != 0 )
	{
	    this->_RenderFileName = vm["render"].as<string>();
	}
	LOG(BF("lisp->_ScriptInFile(%d)  lisp->_FileNameOrCode(%s)") % this->_ProgramCode._ScriptInFile % this->_ProgramCode._FileNameOrCode );
    }



#if 0
/*! Lookup and return the macro executable or nil
 */
    Function_sp	Lisp_O::lookupMacro(Symbol_sp head)
    {_G();
	LOG(BF(" Looking up form(%s)")% head->currentName() );
	if ( this->_Macros.count(head) == 0 ) return this->nil<Function_O>();
	return this->_Macros[head];
    }
#endif





#if 0

    CandoDatabase_sp Lisp_O::getCandoDatabase()
    {_G();
	T_sp		ocdb;
	ASSERTNOTNULL(this->_CandoDatabase);
	return this->_CandoDatabase;
    }

    bool	Lisp_O::hasCandoDatabase()
    {_G();
	return this->_CandoDatabase->notNil();
    }



#endif









    void Lisp_O::load(T_sp filespec, bool verbose,
		      bool print, bool ifDoesNotExist )
    {_OF();
	Package_sp pack = this->getCurrentPackage();
	bool inputWasStream = false;
	Path_sp givenPath = coerce::pathDesignator(filespec);
	Path_sp absolutePath = givenPath->absolute();
	DynamicScopeManager scope(_sym_STARsourcePathNameSTAR,Str_O::create(absolutePath->asString()));
	Stream_sp sin = FileInStream_O::create(absolutePath,_lisp);
	try // exception safe
	{
	    DynamicScopeManager scopeCurrentLineNumber(_sym_STARcurrentLineNumberSTAR,Fixnum_O::create(sin->lineNumber()));
	    DynamicScopeManager scopeCurrentColumn(_sym_STARcurrentColumnSTAR,Fixnum_O::create(sin->column()));
	    TopLevelIHF topFrame(_threadIHS,sin->sourceFileInfo());
	    this->readEvalPrint(sin,_Nil<Environment_O>(),print);
	} catch (...)
	{
	    this->selectPackage(pack);
	    if ( inputWasStream )
	    {
		sin = Stream_O::_nil;
	    }
	    sin->close();
	    throw;
	}
	this->selectPackage(pack);
	if ( inputWasStream )
	{
	    sin = Stream_O::_nil;
	}
	sin->close();
    }

    

    T_mv Lisp_O::readEvalPrint(T_sp isd, Environment_sp environ, bool printResults)
    {_OF();
	T_mv result = Values(T_O::_nil);
	Stream_sp sin = coerce::inputStreamDesignator(isd);
	while (1)
	{
	    TRY()
	    {
		T_sp expression = read_lisp_object(sin,false,_lisp->_eof(),false,_lisp);
		_threadIHS.setLineNumberColumnForTop(sin->lineNumber(),
								sin->column());
		_threadIHS.setActivationFrameForTop(_Nil<ActivationFrame_O>());
		if ( expression == _lisp->_eof() ) break;
//		PushCodeStack codeStack(expression,Environment_O::_nil,_lisp);
		if ( _sym_STARprint_repl_readSTAR->symbolValue()->isTrue() )
		{
		    string suppress;
		    if ( cl::_sym_STARread_suppressSTAR->symbolValue()->isTrue() )
		    {
			suppress = "SUPPRESSED";
			if ( expression->notNil() )
			{
			    SIMPLE_ERROR(BF("*read-suppress* is true but the following expression was read: %s") % expression->__repr__() );
			}
		    }
		    this->print(BF(";;--read-%s-------------\n#|\n%s\n|#----------\n") % suppress.c_str() % expression->__repr__() );
		}
		_BLOCK_TRACEF(BF("---REPL read[%s]") % expression->__repr__() );
		if ( expression->notNil() )
		{
		    result = af_evalWithEnv(expression,environ);
		    if ( printResults )
		    {
			this->print(BF("; --> %s\n")% result->__repr__() );
			for ( int i(1); i<result.number_of_values(); ++i )
			{
			    this->print(BF("; --> %s\n")% result.valueGet(i)->__repr__() );
			}
		    }
		}
	    }
	    catch (Condition& err)
	    {	
		// Catch condition from reader means just ask for another s-exp if 
		// interactive and terminate if batch
		this->print(BF("%s:%d Caught Condition from reader") % __FILE__ % __LINE__ );
		exit(1);
//		this->reportConditionAndTerminateProgramIfBatch(err.conditionObject());
	    }
	    catch (DebuggerSaysAbortToRepl& abort)
	    {
		this->print(BF("%s:%d aborted to repl:") % __FILE__ % __LINE__ );
		// Do nothing
	    }
	    catch (HardError& err)
	    {
		this->print(BF("%s %d Should never happen - catch and convert to Condition below - HardError: %s")
			    % sin->sourceFileInfo()->fileName() % sin->lineNumber() % err.message() );
		IMPLEMENT_ME();
//		this->enterDebugger();
	    } 
	    catch (...)
	    {
		this->print(BF("%s %d Caught every other kind of exception") % __FILE__ % __LINE__ );
		IMPLEMENT_ME();
	    }
	}
	return result;
    }


    void Lisp_O::readEvalPrintFile(const string& pathName, bool printResults )
    {_OF();
	Path_sp path = Path_O::create(pathName);
	FileInStream_sp fin = FileInStream_O::create(path,_lisp);
	this->readEvalPrint(fin,_Nil<Environment_O>(),printResults);
	fin->close();
    }



    T_mv Lisp_O::readEvalPrintString(const string& code, Environment_sp environ, bool printResults )
    {_OF();
	StringInputStream_sp sin = StringInputStream_O::create(code);
	T_mv result = this->readEvalPrint(sin,environ,printResults);
	sin->close();
	return result;
    }



    void Lisp_O::readEvalPrintInteractive()
    {_OF();
	Cons_sp expression;
	TopLevelIHF topFrame(_threadIHS,_Nil<SourceFileInfo_O>());
	while ( 1 )
	{
	    string line;
	    stringstream prompt;
	    prompt << cl::_sym_STARpackageSTAR->symbolValue()->as<Package_O>()->getName() << ">>> ";
	    line = myReadLine(prompt.str());
	    StringInputStream_sp sin = StringInputStream_O::create(line);
	    this->readEvalPrint(sin,_Nil<Environment_O>(),true);
	}
    }





    
#define ARGS_af_stackUsed "()"
#define DECL_af_stackUsed ""
#define DOCS_af_stackUsed "stackUsed"
    uint af_stackUsed()
    {_G();
	int x;
	char* xaddr = (char*)(&x);
	uint stack = (uint)(_lisp->_StackTop-xaddr);
	return stack;
    };




    
    
#define ARGS_af_stackSizeWarning "(arg)"
#define DECL_af_stackSizeWarning ""
#define DOCS_af_stackSizeWarning "stackSizeWarning"
    void af_stackSizeWarning(uint stackUsed)
    {_G();
	printf("%s:%d Stack is getting full currently at %u bytes - warning at %u bytes\n",
	       __FILE__, __LINE__,
	       stackUsed, _lisp->_StackWarnSize );
    };



    
    
#define ARGS_af_stackMonitor "()"
#define DECL_af_stackMonitor ""
#define DOCS_af_stackMonitor "stackMonitor for problems - warn if getting too large"
    void af_stackMonitor()
    {_G();
	uint stackUsed = af_stackUsed();
	if ( stackUsed > _lisp->_StackSampleMax ) _lisp->_StackSampleMax = stackUsed;
	if ( _lisp->_StackSampleSize > 0 )
	{
	    _lisp->_StackSampleCount++;
	    if ( _lisp->_StackSampleCount >= _lisp->_StackSampleSize )
	    {
		printf("STACK-USED samples: %u high-water: %u     %s:%d\n",
		       _lisp->_StackSampleSize,
		       _lisp->_StackSampleMax,
		       __FILE__, __LINE__ );
		_lisp->_StackSampleCount = 0;
		_lisp->_StackSampleMax = 0;
	    }
	}
	if ( stackUsed > _lisp->_StackWarnSize )
	{
	    af_stackSizeWarning(stackUsed);
	}
    };





    
    
#define ARGS_af_setupStackMonitor "(&key warn-size sample-size)"
#define DECL_af_setupStackMonitor ""
#define DOCS_af_setupStackMonitor "setupStackMonitor"
    void af_setupStackMonitor(Fixnum_sp warnSize, Fixnum_sp sampleSize )
    {_G();
	if ( !warnSize.nilp() )
	{
	    _lisp->_StackWarnSize = warnSize->get();
	}
	if ( !sampleSize.nilp() )
	{
	    _lisp->_StackSampleSize = sampleSize->get();
	    _lisp->_StackSampleCount = 0;
	    _lisp->_StackSampleMax = 0;
	}
    };






#define ARGS_af_loadTimeValueArray "(name &optional (data-size 0) (symbol-size 0))"
#define DECL_af_loadTimeValueArray ""
#define DOCS_af_loadTimeValueArray "loadTimeValueArray"
    LoadTimeValues_mv af_loadTimeValueArray(const string& name, int dataSize, int symbolSize )
    {_G();
	return(Values(_lisp->getLoadTimeValues(name,dataSize, symbolSize)));
    };

    
    
#define ARGS_af_exit "(&optional (exit-value 0))"
#define DECL_af_exit ""
#define DOCS_af_exit "exit"
    void af_exit(int exitValue)
    {_G();
	throw(ExitProgram(exitValue));
    };



    
    



#define ARGS_af_acons "(key datum alist)"
#define DECL_af_acons ""
#define DOCS_af_acons "acons"
    T_mv af_acons(T_sp key, T_sp val, Cons_sp alist)
    {_G();
	Cons_sp acons = Cons_O::create(key,val,_lisp);
	return(Values(Cons_O::create(acons,alist,_lisp)));
    }






#define ARGS_af_assoc "(item alist &key key test test-not)"
#define DECL_af_assoc ""
#define DOCS_af_assoc "assoc"
    T_mv af_assoc(T_sp item, Cons_sp alist, T_sp key, T_sp test, T_sp test_not)
    {_G();
	return(Values(alist->assoc(item,key,test,test_not)));
    }


#define ARGS_af_member "(item list &key key test test-not)"
#define	DECL_af_member	""
#define	DOCS_af_member	"See CLHS member"
    T_mv af_member(T_sp item, Cons_sp list, T_sp key, T_sp test, T_sp test_not)
    {_G();
	return(Values(list->member(item,key,test,test_not)));
    }


#define ARGS_af_member1 "(item list test test-not key)"
#define	DECL_af_member1	""
#define	DOCS_af_member1	"Like member but if a key function is provided then apply it to the item. See ecl::list.d::member1"
    T_mv af_member1(T_sp item, Cons_sp list, T_sp test, T_sp test_not, T_sp key)
    {_G();
	return(Values(list->member1(item,key,test,test_not)));
    }

















#define	ARGS_af_setenv	"(name value)"
#define	DECL_af_setenv	""
#define	DOCS_af_setenv	"Set environment variable NAME to VALUE"
    void af_setenv(Str_sp name, Str_sp value)
    {_G();
	setenv(name->get().c_str(),value->get().c_str(),1);
    }



#define	ARGS_af_getenv	"(name)"
#define	DECL_af_getenv	""
#define	DOCS_af_getenv	"Get environment variable NAME"
    T_mv af_getenv(Str_sp name)
    {_G();
	string value = getenv(name->get().c_str());
	return(Values(Str_O::create(value,_lisp)));
    }


/*
  __BEGIN_DOC( candoScript.general.saveArchive, subsection, saveArchive)
  \scriptCmd{save}{Object::object Text::fileName}

  Save the \sa{object} to the \sa{fileName} in Cando-Archive format.
  __END_DOC
*/
    const char* keywords_saveArchive[] = {":debug",""};


#if defined(XML_ARCHIVE)
#define ARGS_af_saveArchive "(obj desig-path &key (debug 0))"
#define DECL_af_saveArchive ""
#define DOCS_af_saveArchive "saveArchive"
    void af_saveArchive(T_sp obj, T_sp desig_path,Fixnum_sp debug)
    {_G();
	Path_sp dest = coerce::pathDesignator(desig_path);
	LOG(BF("Got destination to archive to: %s") % dest->asString() );
	int debugLevel = debug->get();
	core::XmlSaveArchive_sp archive = core::XmlSaveArchive_O::create();
	archive->setVerbosity(debugLevel);
	archive->put("only",obj);
	archive->saveAsToPath(dest);
    }





#define ARGS_af_serialize_xml "(stream obj)"
#define DECL_af_serialize_xml ""
#define DOCS_af_serialize_xml "serializeXml"
    void af_serialize_xml(Stream_sp stream, T_sp obj)
    {_G();
	core::XmlSaveArchive_sp archive = core::XmlSaveArchive_O::create();
	archive->put("only",obj);
	archive->write(stream);
    }






/*
  __BEGIN_DOC( candoScript.general.loadArchive) % subsection, loadArchive)
  \scriptCmd{load}{ fileName:text [debug:level] }

  Load an object from an archive and return it.

  __END_DOC
*/
#define ARGS_af_loadArchive 	"(fileName &optional (debug 0))"
#define DECL_af_loadArchive	""
#define DOCS_af_loadArchive 	"Load an archive from a file"
    T_sp	af_loadArchive(Str_sp fileName, Fixnum_sp debug)
    {_G();
	ObjectVector			contents;
	core::XmlLoadArchive_sp	archive;
	int debugLevel = debug->get();
	archive = core::XmlLoadArchive_O::create();
	archive->setVerbosity(debugLevel);
	boost_filesystem::path filePath(fileName->get());
	LOG(BF("About to open file: %s") % filePath.string());
	archive->open(filePath.string());
	archive->getContents(contents);
	if ( contents.size() != 1 )
	{
	    SIMPLE_ERROR_BF("There must be one and only one object in the file");
	}
	T_sp o = contents[0];
	return o;
    }




#ifdef USEBOOSTPYTHON
    boost::python::tuple python_loadArchive(boost::python::tuple args, boost::python::dict keywords)
    {
	printf("In python_loadArchive\n");
	return boost::python::make_tuple(args,keywords);
    }
#endif


#define ARGS_af_deserialize_xml "(sin)"
#define DECL_af_deserialize_xml ""
#define DOCS_af_deserialize_xml "deserialize_xml"
    T_mv af_deserialize_xml(Stream_sp sin)
    {_G();
	core::XmlLoadArchive_sp archive = core::XmlLoadArchive_O::create();
	archive->setFileName(sin->sourceFileInfo()->fileName());
	archive->read(sin);
	ObjectVector contents;
	archive->getContents(contents);
	if ( contents.size() != 1 )
	{
	    SIMPLE_ERROR_BF("There must be one and only one object in the file");
	}
	T_sp o = contents[0];
	return(Values(o));
    }
#endif // defined(XML_ARCHIVE)


/*
  __BEGIN_DOC( candoScript.general.getline, subsection, getline)
  \scriptCmdRet{getline}{}{String::result}

  Read a line from stdin
  __END_DOC
*/



#define ARGS_af_getline "(&optional (prompt \"\"))"
#define DECL_af_getline ""
#define DOCS_af_getline "getline"
    T_mv af_getline(Str_sp prompt)
    {_G();
	string res;
#ifdef	READLINE
	char* line_read;
	/* Get a line from the user. */
	line_read = readline(prompt->get().c_str());
	if ( line_read != NULL )
	{
	    if (*line_read) add_history(line_read);
	    res = line_read;
	    free(line_read);
	}
#else
	if ( prompt->get() != "" )
	{
	    _lisp->print(BF("%s ") % prompt->get() );
	    _lisp->printvFlush();
	}
	getline(cin,res);
#endif
	Str_sp result = Str_O::create(res,_lisp);
	return(Values(result));
    }







/*
  __BEGIN_DOC( candoScript.general.system, subsection,system)
  \scriptCmdRet{system}{}{String::command}

  Invoke a system call using the UNIX system function call.
  __END_DOC
*/



#define ARGS_af_system "(cmd)"
#define DECL_af_system ""
#define DOCS_af_system "system"
    T_mv af_system(Str_sp cmd)
    {_G();
	string command = cmd->get();
	int ret = system(command.c_str());
	core::Fixnum_sp iret = core::Fixnum_O::create(ret);
	return(Values(iret));
    }





/*
  __BEGIN_DOC( candoScript.general.render, subsection, render)
  \scriptCmdRet{render}{ object}{renderedObject}

  Render an object into a graphical representation of the \scriptArg{object} that can be viewed using "candoView". Save the result into a file using the "save" command and view it later.
  __END_DOC
*/





#define ARGS_af_render "(arg)"
#define DECL_af_render ""
#define DOCS_af_render "render an object"
    T_mv af_render(T_sp obj)
    {_G();
	IMPLEMENT_ME(); // handle render
#if 0
	core::Cons_sp kargs = core::KeyedArguments_O::createFromKeyedObjectCons(args,_lisp);
	if ( kargs->numberOfPositionalArguments()!=1 )
	{
	    THROW(_lisp->create<core::LispError_O>("You must provide the object to render as the only positional argument, 'options' is a keyedArgument "));
	}
	T_sp obj = kargs->getPositionalArgument(0);
	core::Cons_sp options = kargs->getAndRemoveOrDefault("options",core::Cons_O::_nil)->as<core::Cons_O>();
	core::KeyedArguments_sp koptions = core::KeyedArguments_O::createFromKeyedObjectCons(options,lisp);
	core::Render_sp render;
	if ( obj->canRender() )
	{
	    render = obj->rendered(koptions);
	} else
	{
	    SIMPLE_ERROR(BF("Object doesn't support render"));
	}
	return render;
#endif
    }




#if defined(XML_ARCHIVE)
/*
  __BEGIN_DOC( candoScript.general.saveCando, subsection, saveCando)
  \scriptCmd{save}{Object::object Text::fileName}

  Save the \sa{object} to the \sa{fileName} in Cando-OML format.
  __END_DOC
*/
#define ARGS_af_saveCando "(obj pathDesignator)"
#define DECL_af_saveCando ""
#define DOCS_af_saveCando "saveCando"
    T_mv af_saveCando(T_sp obj, T_sp pathDesignator)
    {_G();
	Path_sp path = coerce::pathDesignator(pathDesignator);
	Stream_sp sout = af_open(path,
				 kw::_sym_output,
				 cl::_sym_standard_char,
				 Symbol_O::_nil,
				 Symbol_O::_nil,
				 kw::_sym_default);
	_lisp->sprint(obj,sout);
	sout->close();
	return(Values(T_O::_nil));
    }



#define ARGS_af_loadCando "(pathDesignator)"
#define DECL_af_loadCando ""
#define DOCS_af_loadCando "loadCando"
    T_mv af_loadCando(T_sp pathDesignator)
    {_G();
	Path_sp path = coerce::pathDesignator(pathDesignator);
	Stream_sp sin = af_open(path,kw::_sym_input,cl::_sym_standard_char,Symbol_O::_nil,Symbol_O::_nil,kw::_sym_default);
	T_sp obj = _lisp->sread(sin->as<Stream_O>(),true,T_O::_nil);
	sin->close();
	return(Values(obj));
    }
#endif // defined(XML_ARCHIVE)





    
    
#define ARGS_af_findClass "(symbol &optional errorp environment)"
#define DECL_af_findClass ""
#define DOCS_af_findClass "findClass"
    Class_mv af_findClass(Symbol_sp symbol, bool errorp, Environment_sp env )
    {_G();
	if ( _lisp->bootClassTableIsValid() )
	{
	    return Values(_lisp->boot_findClass(symbol,errorp));
	}
	ASSERTF(env->isNil(),BF("Handle non nil environment"));
	// Use the same global variable that ECL uses
	SYMBOL_SC_(CorePkg,STARclassNameHashTableSTAR);
	HashTable_sp classNames = _sym_STARclassNameHashTableSTAR->symbolValue()->as<HashTable_O>();
	T_mv mc = classNames->gethash(symbol,T_O::_nil);
	Class_sp omc = mc->as<Class_O>();
	bool foundp = mc.valueGet(1)->notNil();
	if ( !foundp )
	{
	    if (errorp)
	    {
		SIMPLE_ERROR(BF("Could not find class %s") % symbol->__repr__() );
	    }
	    return(Values(Class_O::_nil));
	}
#if DEBUG_CLOS>=3
	printf("\nMLOG find-class returning class %p name--> %s\n", (void*)(result.get()), symbol->__repr__().c_str() );
#endif
	return(Values(omc));
    }





#define ARGS_af_setf_findClass "(new-value name)"
#define DECL_af_setf_findClass ""
#define DOCS_af_setf_findClass "setf_findClass"
    Class_mv af_setf_findClass(T_sp newValue, Symbol_sp name, bool errorp, Environment_sp env)
    {_G();
	if ( !newValue->classP() )
	{
	    SIMPLE_ERROR(BF("Classes in cando have to be subclasses of Class unlike ECL which uses Instances to represent classes - while trying to (setf find-class) of %s you gave: %s") % name->__repr__() % newValue->__repr__() );
	}
	if ( _lisp->bootClassTableIsValid() )
	{
	    return Values(_lisp->boot_setf_findClass(name,newValue->as<Class_O>()));
	}
	HashTable_sp ht = _sym_STARclassNameHashTableSTAR->symbolValue()->as<HashTable_O>();
	T_sp oldClass = eval::funcall(cl::_sym_findClass, name, T_O::_nil);
	if ( oldClass->metaClassP() )
	{
	    SIMPLE_ERROR(BF("The built-in class associated to the CL specifier %s cannot be changed") % name->__repr__() );
	} else if ( newValue->isNil() )
	{
	    ht->remhash(name);
	} else
	{
	    ht->hash_table_setf_gethash(name,newValue);
	}
	return Values(newValue->as<Class_O>());
    };







/*
  __BEGIN_DOC(candoScript.general.dumpEnvironment,dumpEnvironment)
  \scriptCmdRet{dumpEnvironment}{}{Text::packageName}

  Dump the current environment.
  __END_DOC
*/









#define ARGS_af_findFileInLispPath "(partialPath)"
#define DECL_af_findFileInLispPath ""
#define DOCS_af_findFileInLispPath "findFileInLispPath"
    T_mv af_findFileInLispPath(Str_sp partialPath)
    {_G();
	LOG(BF("PartialPath=[%s]") % partialPath->get());
	Path_sp fullPath = _lisp->translateLogicalPathnameUsingPaths(partialPath);
	LOG(BF("fullPath is %s") % fullPath->asString());
	return(Values(fullPath));
    }




#define ARGS_af_find_package "(name_desig)"
#define DECL_af_find_package ""
#define DOCS_af_find_package "See CLHS: find-package"
    Package_mv af_find_package(T_sp name_desig)
    {_G();
	if ( name_desig->packageP() ) return(Values(name_desig->as<Package_O>()));
	Str_sp name = coerce::stringDesignator(name_desig);
	Package_sp pkg = _lisp->findPackage(name->get());
	return(Values(pkg));
    }






#define DOCS_af_selectPackage "selectPackage"
#define LOCK_af_selectPackage 1
#define ARGS_af_selectPackage "(package-designator)"
#define DECL_af_selectPackage ""
    void af_selectPackage(T_sp package_designator)
    {_G();
	Package_sp pkg = coerce::packageDesignator(package_designator);
	_lisp->selectPackage(pkg);
    }






/*
  __BEGIN_DOC(candoScript.general.mpiEnabled,mpiEnabled)
  \scriptCmdRet{mpiEnabled}{}{}

  Return true if MPI is enabled.
  __END_DOC
*/



#define ARGS_af_mpi_enabled ""
#define DECL_af_mpi_enabled ""
#define DOCS_af_mpi_enabled "mpi_enabled"
    T_mv af_mpi_enabled()
    {_G();
	return(Values(_lisp->_boolean(_lisp->mpiEnabled())));
    }


/*
  __BEGIN_DOC(candoScript.general.mpiRank,mpiRank)
  \scriptCmdRet{mpiRank}{}{}

  Return the mpi rank or 0 if not enabled.
  __END_DOC
*/
#define ARGS_af_mpi_rank ""
#define DECL_af_mpi_rank ""
#define DOCS_af_mpi_rank "Return the mpi_rank or 0 if mpi is disabled"
    T_mv af_mpi_rank()
    {_G();
	return(Values(Fixnum_O::create(_lisp->mpiRank())));
    }


/*
  __BEGIN_DOC(candoScript.general.mpiSize,mpiSize)
  \scriptCmdRet{mpiSize}{}{}

  Return the mpi rank or 0 if not enabled.
  __END_DOC
*/



#define ARGS_af_mpi_size ""
#define DECL_af_mpi_size ""
#define DOCS_af_mpi_size "Return mpi_size or 0 if mpi is not enabled"
    T_mv af_mpi_size()
    {_G();
	return(Values(Fixnum_O::create(_lisp->mpiSize())));
    }


/*
  __BEGIN_DOC(candoScript.general.dumpHidden,dumpHidden)
  \scriptCmdRet{dumpHidden}{}{Text::packageName}

  Dump the keys in the Hidden binder.
  __END_DOC
*/
#if 0
    T_sp p r i m_dumpHidden(Function_sp e, Cons_sp args, Environment_sp environ, Lisp_sp lisp)
    {_G();
	lisp->print(BF("Hidden Binder keys:%s\n") % lisp->hiddenBinder()->summaryOfContents().c_str() );
	return T_O::_nil;
    }
#endif








#define ARGS_af_macroexpand_1 "(form &optional env)"
#define DECL_af_macroexpand_1 ""
#define DOCS_af_macroexpand_1 "macroexpand_1"
    T_mv af_macroexpand_1(T_sp form, Environment_sp env)
    {_G();
	Function_sp expansionFunction = Function_O::_nil;
	if ( Cons_sp cform = form->asOrNull<Cons_O>() )
	{
	    T_sp head = cform->ocar();
	    if ( head->symbolP() )
	    {
		Symbol_sp headSymbol = head->as<Symbol_O>();
		if ( _lisp->specialFormOrNil(headSymbol)->isNil() )
		{
		    Function_sp func = af_interpreter_lookup_macro(headSymbol,env);
		    if ( func->notNil() && func->macroP() )
		    {
			expansionFunction = func;
		    }
		}
	    }
	} else if ( Symbol_sp sform = form->asOrNull<Symbol_O>() )
	{
	    Function_sp func = af_interpreter_lookup_symbol_macro(sform,env);
	    if ( func->notNil() )
	    {
		expansionFunction = func;
	    }
	}
	if ( expansionFunction->notNil() )
	{
	    T_sp macroexpandHook = cl::_sym_STARmacroexpand_hookSTAR->symbolValue();
	    Function_sp hookFunc = coerce::functionDesignator(macroexpandHook,_lisp);
	    ValueFrame_sp macroHookArgs(ValueFrame_O::create_fill(expansionFunction,form,env,ActivationFrame_O::_nil));
	    T_sp expanded = eval::applyFunctionToActivationFrame(hookFunc,macroHookArgs);
	    return(Values(expanded,_lisp->_true()) );
	}
	return(Values(form,_lisp->_false()) );
    }




#define ARGS_af_macroexpand "(form &optional env)"
#define DECL_af_macroexpand ""
#define DOCS_af_macroexpand "macroexpand"
    T_mv af_macroexpand(T_sp form, Environment_sp env)
    {_G();
	bool sawAMacro = false;
	bool expandedMacro = false;
	uint macroExpansionCount = 0;
	if (_sym_STARdebugMacroexpandSTAR->symbolValue()->isTrue())
	{
	    printf("%s:%d - macroexpanding --> %s\n", __FILE__, 2551, form->__repr__().c_str() );
	}
	T_sp cur = form;
	do {
	    {MULTIPLE_VALUES_CONTEXT();
		T_mv mv = af_macroexpand_1(cur,env);
		cur = mv;
		sawAMacro = mv.valueGet(1)->as<T_O>()->isTrue();
	    }
	    expandedMacro |= sawAMacro;
	    macroExpansionCount++;
	    if ( macroExpansionCount > 100 )
	    {
		SIMPLE_ERROR(BF("Macro expansion happened %d times - You may have a macro expansion infinite loop") % macroExpansionCount );
	    }
	} while ( sawAMacro );
	if (_sym_STARdebugMacroexpandSTAR->symbolValue()->isTrue())
	{
	    printf("%s:%d -     after macroexpanding --> %s\n", __FILE__, 2565, cur->__repr__().c_str() );
	}
	return(Values(cur,_lisp->_boolean(expandedMacro)) );
    };




    struct FindApropos : public KeyValueMapper
    {
    public:
	set<Symbol_sp> _symbols;
	string		_substr;
	FindApropos(const string& str) { this->_substr = str;};
	virtual bool mapKeyValue(T_sp key, T_sp value)
	{
	    Bignum_sp skey = key->as<Bignum_O>();
	    Symbol_sp svalue = value->as<Symbol_O>();
	    string symbolName = svalue->symbolName();
	    string::size_type pos = symbolName.find(this->_substr);
//	    LOG(BF("Looking at symbol(%s) for (%s) found: %d") % symbolName % this->_substring % pos );
	    if ( pos != string::npos )
	    {
		LOG(BF("    It is apropos"));
		this->_symbols.insert(svalue);
	    }
	    return true;
	}
    };


    void searchForApropos(Vector0<Package_O> packages,const string& raw_substring, bool print_values)
    {_G();
	string substring = lispify_symbol_name(raw_substring);
	FindApropos apropos(substring);
	LOG(BF("Searching for symbols apropos to(%s)") % substring);
	for ( Vector0<Package_O>::iterator pi=packages.begin();
	      pi!=packages.end(); pi++ )
	{
	    (*pi)->mapExternals(&apropos);
	    (*pi)->mapInternals(&apropos);
	}
	for ( set<Symbol_sp>::iterator si=apropos._symbols.begin();
	      si!=apropos._symbols.end(); si++ )
	{
	    stringstream ss;
	    ss << (BF("%50s") % (*si)->fullName()).str();
	    if ( (*si)->specialP() || (*si)->fboundp() )
	    {
		if ( (*si)->fboundp() )
		{
		    ss << " ";
		    ss << (*si)->symbolFunction()->className();
		    if ( (*si)->symbolFunction()->macroP() )
		    {
			ss << "(MACRO)";
		    }
		}
		if ( (*si)->specialP())
		{
		    ss << " VALUE";
		    if ( print_values )
		    {
			stringstream sval;
			T_sp symVal = (*si)->symbolValueOrUnbound();
			if ( !symVal )
			{
			    sval << "UNDEFINED";
			} else
			{
			    sval << (*si)->symbolValue()->__repr__();
			}
			ss << ": " << sval.str().substr(0,50);
		    }
		}
	    }
	    _lisp->print(BF("%s") % ss.str());
	}
    }


/*
  __BEGIN_DOC(candoScript.general.apropos,apropos)
  \scriptCmdRet{apropos}{}{Text::substring [packageName]}

  Return every symbol that contains the (substring)
  __END_DOC
*/

#define ARGS_af_apropos "(string_desig &optional package_desig)"
#define DECL_af_apropos ""
#define DOCS_af_apropos "apropos"
    T_mv af_apropos(Str_sp string_desig, T_sp package_desig)
    {_G();
	string substring = coerce::stringDesignator(string_desig)->get();
	Vector0<Package_O>	packages;
	if ( package_desig->isNil() )
	{
	    for ( Vector0<Package_O>::iterator pi=_lisp->packages().begin();
		  pi != _lisp->packages().end(); pi++ )
	    {
		packages.push_back(*pi);
	    }
	} else
	{
	    Package_sp pkg = coerce::packageDesignator(package_desig);
	    packages.push_back(pkg);
	}
	searchForApropos(packages,substring,false);
	return(Values(T_O::_nil));
    }






/*
  __BEGIN_DOC(candoScript.general.funcall,funcall)
  \scriptCmdRet{funcall}{}{Function arg1 arg2 ...}

  Evaluate the function with the arguments.
  __END_DOC
*/




#define ARGS_af_funcall "(function_desig &rest args)"
#define DECL_af_funcall ""
#define DOCS_af_funcall "See CLHS: funcall"
    T_mv af_funcall(T_sp function_desig, Cons_sp args)
    {_G();
	Function_sp func = coerce::functionDesignator(function_desig,_lisp);
	ASSERTF(func->notNil(),BF("funcall target[%s] is undefined") % function_desig->__repr__() );
	Cons_sp passArgs = args;
	ValueFrame_sp frame(ValueFrame_O::create(passArgs,ActivationFrame_O::_nil));
	return eval::applyFunctionToActivationFrame(func,frame);
    }





/*
  __BEGIN_DOC(candoScript.general.apply,apply)
  \scriptCmdRet{apply}{}{Function argList}

  Evaluate the function with the argument list.
  __END_DOC
*/



#define ARGS_af_apply "(head &rest args)"
#define DECL_af_apply ""
#define DOCS_af_apply "apply"
    T_mv af_apply(T_sp head, Cons_sp args)
    {_G();
	/* Special case when apply is called with one arg and that arg is an ActivationFrame
	   APPLY directly to that ActivationFrame */
	if ( args->ocar()->notNil() && args->cdr()->isNil() )
	{
	    Function_sp func = coerce::functionDesignator(head,_lisp);
	    if ( ActivationFrame_sp singleFrame = args->ocar()->asOrNull<ActivationFrame_O>() )
	    {
		return eval::applyFunctionToActivationFrame(func,singleFrame);
	    }
	}
	ql::list largs(_lisp);
	Cons_sp cur;
	for ( cur=args; cur->cdr()->notNil(); cur=cur->cdr() )
	{
	    largs << cur->ocar();
	}
	largs.dot(cur->ocar());
	Cons_sp pass_args = largs.cons();
	ValueFrame_sp frame(ValueFrame_O::create(pass_args,ActivationFrame_O::_nil));
	Function_sp func = coerce::functionDesignator(head,_lisp);
	return eval::applyFunctionToActivationFrame(func,frame);
    }










    class	OrderByLessThan
    {
    public:
	bool operator()(T_sp x, T_sp y )
	{
	    return x->operator<(y);
	}
    };





#define ARGS_af_sorted "(unsorted)"
#define DECL_af_sorted ""
#define DOCS_af_sorted "Sort the list in ascending order using operator< and return the sorted list"
    Cons_mv af_sorted(Cons_sp unsorted)
    {_G();
	Vector0<T_O> sorted; 
	if ( unsorted->length() == 0 ) return(Values(Cons_O::_nil));
	sorted.fillFromCons(unsorted);
	OrderByLessThan orderer;
	sort::quickSort(sorted.begin(),sorted.end(),orderer,_lisp);
	Cons_sp result = sorted.asCons(_lisp);
	return(Values(result));
    }


    class	OrderBySortFunction
    {
    private:
	Lisp_sp 	_Lisp;
	Function_sp _SortFunction;
	Cons_sp 	_args;
    public:
	OrderBySortFunction(Function_sp proc,Lisp_sp lisp)
	{
	    this->_Lisp = lisp;
	    this->_SortFunction = proc;
	    this->_args = Cons_O::createList(T_O::_nil,T_O::_nil);
	}
	bool operator()(T_sp x, T_sp y )
	{
	    ValueFrame_sp frame(ValueFrame_O::create_fill(x,y,ActivationFrame_O::_nil));
	    return eval::apply(this->_SortFunction,frame);
	}
    };


    
    
    
#define ARGS_af_sort "(sequence predicate)"
#define DECL_af_sort ""
#define DOCS_af_sort "Like CLHS: sort but does not support key"
    T_mv af_sort(Cons_sp sequence, T_sp predicate )
    {_G();
	Function_sp sortProc = coerce::functionDesignator(predicate,_lisp);
	Vector0<T_O> sorted; 
	LOG(BF("Unsorted data: %s") % sequence->__repr__() );
	if ( sequence->length() == 0 ) return(Values(Cons_O::_nil));
	sorted.fillFromCons(sequence);
	LOG(BF("Sort function: %s") % sortProc->__repr__() );
	OrderBySortFunction orderer(sortProc,_lisp);
	sort::quickSort(sorted.begin(),sorted.end(),orderer,_lisp);
	Cons_sp result = sorted.asCons(_lisp);
	return(Values(result));
    }






/*
  __BEGIN_DOC(candoScript.general.sourceFileName,sourceFileName)
  \scriptCmdRet{sourceFileName}{}{Cons::}

  Return the current file name and line number in a two element Cons.
  __END_DOC
*/
    
    
    
#define ARGS_af_sourceFileName ""
#define DECL_af_sourceFileName ""
#define DOCS_af_sourceFileName "Return the current sourceFileName"
    T_mv af_sourceFileName()
    {_G();
	Cons_sp ppcons;
	InvocationHistoryFrame* frame = _threadIHS.top();
	string sourcePath = frame->sourcePathName();
	Path_sp path = Path_O::create(sourcePath);
	Path_sp parent_path = path->parent_path();
	return Values(Str_O::create(path->fileName()),Str_O::create(parent_path->asString()));
    }

    
#define ARGS_af_sourceLineColumn ""
#define DECL_af_sourceLineColumn ""
#define DOCS_af_sourceLineColumn "sourceLineColumn"
    T_mv af_sourceLineColumn()
    {_G();
	InvocationHistoryFrame* frame = _threadIHS.top();
	return Values(Fixnum_O::create(frame->lineNumber()),Fixnum_O::create(frame->column()));
    }



/*
  __BEGIN_DOC(candoScript.general.backtrace,backtrace)
  \scriptCmdRet{backtrace}{}{Cons::}

  Return a backtrace as a list of SourceCodeCons.
  __END_DOC
*/
    
    
    



/*
  __BEGIN_DOC(candoScript.general.databaseDir,databaseDir)
  \scriptCmdRet{databaseDir}{}{Text::}

  Return the path for the database directory.
  __END_DOC
*/




#define ARGS_af_script_dir ""
#define DECL_af_script_dir ""
#define DOCS_af_script_dir "script_dir"
    Path_mv af_script_dir()
    {_G();
	Path_sp dir = Path_O::create(_lisp->bundle().getLispDir());
	return(Values(dir));
    }


#define ARGS_af_libraryPath "(&optional rel-path)"
#define DECL_af_libraryPath ""
#define DOCS_af_libraryPath "Returns the absolute path to the library directory - if rel-path is not nil then it prepends the library directory path to rel-path and returns that"
    Path_mv af_libraryPath(T_sp relPathDesignator)
    {_G();
	if ( relPathDesignator->notNil() )
	{
	    Path_sp relPath = coerce::pathDesignator(relPathDesignator);
	    boost_filesystem::path lp = _lisp->bundle().getLibDir();
	    lp /= relPath->getPath();
	    return(Values(Path_O::create(lp)));
	}
	return(Values(Path_O::create(_lisp->bundle().getLibDir())));
    }


#define ARGS_af_lispCodePath "(&optional rel-path)"
#define DECL_af_lispCodePath ""
#define DOCS_af_lispCodePath "Returns the absolute path to the lisp code directory - if rel-path is not nil then it prepends the directory path to rel-path and returns that"
    Path_mv af_lispCodePath(T_sp relPathDesignator)
    {_G();
	if ( relPathDesignator->notNil() )
	{
	    Path_sp relPath = coerce::pathDesignator(relPathDesignator);
	    boost_filesystem::path lp = _lisp->bundle().getLibDir();
	    lp /= relPath->getPath();
	    return(Values(Path_O::create(lp)));
	}
	return(Values(Path_O::create(_lisp->bundle().getLibDir())));
    }



/*
  __BEGIN_DOC(candoScript.general.databaseDir,databaseDir)
  \scriptCmdRet{databaseDir}{}{Text::}

  Return the path for the database directory.
  __END_DOC
*/



#define ARGS_af_database_dir ""
#define DECL_af_database_dir ""
#define DOCS_af_database_dir "database_dir"
    Path_mv af_database_dir()
    {_G();
	Path_sp dir = Path_O::create(_lisp->bundle().getDatabasesDir());
	return(Values(dir));
    }





/*
  __BEGIN_DOC(candoScript.general.changeWorkingDirectory,changeWorkingDirectory)
  \scriptCmdRet{changeWorkingDirectory}{}{Text::}

  Change the current working directory.
  __END_DOC
*/
    
    
    
#define ARGS_af_setCurrentWorkingDirectory "(dir)"
#define DECL_af_setCurrentWorkingDirectory ""
#define DOCS_af_setCurrentWorkingDirectory "setCurrentWorkingDirectory"
    T_mv af_setCurrentWorkingDirectory(Str_sp dir)
    {_G();
	Path_sp cwd = Path_O::create(dir->get());
	_lisp->setCurrentWorkingDirectory(cwd);
	return(Values(dir));
    }


/*
  __BEGIN_DOC(candoScript.general.isTopLevelScript)

  Return a true if this is a top level script or false if its an include file.
  __END_DOC
*/

    
    
    
#define ARGS_af_isTopLevelScript ""
#define DECL_af_isTopLevelScript ""
#define DOCS_af_isTopLevelScript "isTopLevelScript"
    T_mv af_isTopLevelScript()
    {_G();
	LOG(BF("isTopLevelScript = %d") % _lisp->getRequireLevel()  );
	T_sp top = _lisp->_boolean(_lisp->getRequireLevel() == 0);
	return(Values(top));
    }



/*
  __BEGIN_DOC(candoScript.general.debugLogOn,debugLogOn)
  \scriptCmd{debugLogOn}{true/false:bool}

  Turn on or off writing debug statements to the debug log. This is useful when running
  long scripts that crash, you can turn of debug logging up to the point where
  the crash happens and then examine the output.
  __END_DOC
*/

    
    
    
#define ARGS_af_debugLogOn ""
#define DECL_af_debugLogOn ""
#define DOCS_af_debugLogOn "debugLogOn"
    void af_debugLogOn()
    {_G();
	_lisp->debugLog().setSuppressMessages(false);
	LOG(BF("Turning debugLogOn"));
    }

/*
  __BEGIN_DOC(candoScript.general.debugLogOff,debugLogOff)
  \scriptCmd{debugLogOff}{true/false:bool}

  Turn on or off writing debug statements to the debug log. This is useful when running
  long scripts that crash, you can turn of debug logging up to the point where
  the crash happens and then examine the output.
  __END_DOC
*/
    
    
    
#define ARGS_af_debugLogOff ""
#define DECL_af_debugLogOff ""
#define DOCS_af_debugLogOff "debugLogOff"
    void af_debugLogOff()
    {_G();
	_lisp->debugLog().setSuppressMessages(true);
    }





    class RequireFile
    {
    private:
	Path_sp 	_path;
	Lisp_sp 	_Lisp;
    public:
	Lisp_sp lisp() { return this->_Lisp;};
	RequireFile(Path_sp path,Lisp_sp lisp)
	{_G();
	    this->_Lisp = lisp;
	    this->_path = path;
	    lisp->addModule(path->asString());
	    lisp->pushRequireLevel();
	    LOG(BF("  pushed require level to %d") % lisp->getRequireLevel()  );
	    lisp->load(path);
	}
	virtual ~RequireFile()
	{_OF();
	    this->_Lisp->popRequireLevel();
	    LOG(BF("  popped require level to %d") % this->_Lisp->getRequireLevel()  );
	}
    };



/*
  __BEGIN_DOC(candoScript.general.export,export)
  \scriptCmd{export}{symbols...}

  Tell the symbols that they can be exported.

  __END_DOC
*/
#define ARGS_af_export "(symDes &optional (packageDes *package*))"
#define DECL_af_export ""
#define DOCS_af_export "CLHS: export"
    void af_export(T_sp symDes,T_sp packageDes)	
    {_G();
	Cons_sp symbols = coerce::listOfSymbols(symDes);
	Package_sp package = coerce::packageDesignator(packageDes);
	package->_export(symbols);
    }




    
    
#define ARGS_af_exportToPython "(symbolsDesig)"
#define DECL_af_exportToPython ""
#define DOCS_af_exportToPython "exportToPython"
    void af_exportToPython(T_sp symbolsDesig)
    {_G();
	Cons_sp symbols = coerce::listOfSymbols(symbolsDesig);
	for ( Cons_sp cur = symbols; cur->notNil(); cur = cur->cdr() )
	{
	    Symbol_sp one = cur->ocar()->as<Symbol_O>();
	    LOG(BF("Exporting symbol[%s] to python") % one->__repr__() );
	    _lisp->exportToPython(one);
	}
    }



#define ARGS_af_intern "(symbol_name &optional (package-desig *package*))"
#define DECL_af_intern ""
#define DOCS_af_intern "See CLHS: intern"
    T_mv af_intern(Str_sp symbol_name, T_sp package_desig)
    {_G();
	Package_sp package = coerce::packageDesignator(package_desig);
	return(package->intern(symbol_name->get()));
    }





    
    
#define ARGS_af_universalErrorHandler "(continue-string datum initializers)"
#define DECL_af_universalErrorHandler ""
#define DOCS_af_universalErrorHandler "universalErrorHandler"
    T_mv af_universalErrorHandler(T_sp continueString, T_sp datum, Cons_sp initializers)
    {_G();
	stringstream ss;
	ss << "Low level universalErrorHandler datum: " << datum->__repr__() << " " << initializers->__repr__();
	printf("%s:%d %s\n", __FILE__, __LINE__, ss.str().c_str() );
	dbg_hook(ss.str().c_str());
	exit(1);
    };



    
#define ARGS_af_invokeInternalDebugger "(condition)"
#define DECL_af_invokeInternalDebugger ""
#define DOCS_af_invokeInternalDebugger "invokeInternalDebugger"
    void af_invokeInternalDebugger(T_sp condition)
    {_G();
	stringstream ss;
	_lisp->print(BF("%s:%d af_invokeInternalDebugger --> %s")
		     % __FILE__
		     % __LINE__ % condition->__repr__().c_str() );
	LispDebugger debugger(condition);
	debugger.invoke();
    };


extern "C"
{    

#define ARGS_af_invokeInternalDebuggerFromGdb "()"
#define DECL_af_invokeInternalDebuggerFromGdb ""
#define DOCS_af_invokeInternalDebuggerFromGdb "invokeInternalDebuggerFromGdb"
    void af_invokeInternalDebuggerFromGdb()
    {_G();
	eval::funcall(_sym_invokeInternalDebugger);
	SIMPLE_ERROR(BF("This should never happen"));
    };

};





#define ARGS_af_error "(datum &rest arguments)"
#define DECL_af_error ""
#define DOCS_af_error "See CLHS error"
    void af_error(T_sp datum, Cons_sp initializers)
    {_G();
	int nestedErrorDepth = _sym_STARnestedErrorDepthSTAR->symbolValue()->as<Fixnum_O>()->get();
	if ( nestedErrorDepth > 0 )
	{
	    // TODO: Disable this code once error handling and conditions work properly
	    // It's only here to identify errors that would cause infinite looping
	    // as we get error handling and conditions working properly
	    printf("%s:%d -- *nested-error-depth* --> %d  datum: %s\n", __FILE__, __LINE__, nestedErrorDepth, datum->__repr__().c_str() );
	    if ( initializers->notNil() )
	    {
		printf("               initializers: %s\n", initializers->__repr__().c_str() );
	    }
	}
	++nestedErrorDepth;
	DynamicScopeManager scope(_sym_STARnestedErrorDepthSTAR,Fixnum_O::create(nestedErrorDepth));
	if ( _sym_universalErrorHandler->fboundp() )
	{
	    Function_sp fn = _sym_universalErrorHandler->symbolFunction();
	    eval::funcall(fn,_Nil<T_O>(),datum,initializers);
	}
	THROW_HARD_ERROR(BF("af_error should never return because universal-error-handler should never return - but it did"));
    }



/*
  __BEGIN_DOC(candoScript.general.load,load)
  \scriptCmd{load}{Text::fileName}

  Open the \sa{fileName}, compile and evaluate its contents.
  It looks through all of the directories in the global variable PATH and then 
  the Scripts directory in the Cando application directory.

  __END_DOC
*/

    
    
#define ARGS_af_load "(filespec &key (verbose *load-verbose*) (print *load-print*) (if-does-not-exist t) (external-format :default))"
#define DECL_af_load ""
#define DOCS_af_load "CLHS: load"
    T_mv af_load(T_sp filespec, T_sp verbose, T_sp print, T_sp if_does_not_exist, Symbol_sp external_format)
    {_G();
	if ( external_format != kw::_sym_default )
	{
	    SIMPLE_ERROR(BF("I don't handle externalFormat - convert this to a warning"));
	}
	_lisp->load(filespec,verbose->isTrue(),print->isTrue(),if_does_not_exist->isTrue());
	return(Values(_lisp->_true()));
    }











/*
  __BEGIN_DOC(candoScript.general.isAssignableTo,isAssignableTo)
  \scriptInfixRet{Object::object}{isAssignableTo}{Class::classObject}{Bool::}

  Return true if \scriptArg{object} can be assigned to a C++ variable of class \scriptArg{classObject}.
  __END_DOC
*/
    
    
    
#define ARGS_af_isAssignableTo "(tag secondArgument)"
#define DECL_af_isAssignableTo ""
#define DOCS_af_isAssignableTo "isAssignableTo"
    T_mv af_isAssignableTo(T_sp tag, Class_sp mc)
    {_G();
	LOG(BF("Checking if instances of class(%s) is assignable to variables of class(%s)")% tag->className() % mc->className() );
	bool io = (tag->isAssignableToByClassSymbol(mc->name()));
	return(Values(_lisp->_boolean(io)));
    }

/*
  __BEGIN_DOC(candoScript.general.isSubClassOf,isSubClassOf)
  \scriptInfixRet{Object::object}{isSubClassOf}{Class::classObject}{Bool::}

  Return true if \scriptArg{object} can be assigned to a C++ variable of class \scriptArg{classObject}.
  __END_DOC
*/
    
    
    
#define ARGS_af_isSubClassOf "(tag mc)"
#define DECL_af_isSubClassOf ""
#define DOCS_af_isSubClassOf "isSubClassOf"
    T_mv af_isSubClassOf(Class_sp tag, Class_sp mc)
    {_G();
	LOG(BF("Checking if instances of class(%s) is assignable to variables of class(%s)")% tag->className() % mc->className() );
	bool io = tag->isSubClassOf(mc);
	return(Values(_lisp->_boolean(io)));
    }





/*
  __BEGIN_DOC(candoScript.general.repr,repr)
  \scriptCmdRet{repr}{object}{string}

  Return a string representation of the object.
  __END_DOC
*/
    
    
    
#define ARGS_af_repr "(arg)"
#define DECL_af_repr ""
#define DOCS_af_repr "Return a string representation of the object"
    T_mv af_repr(T_sp obj)
    {_G();
	Str_sp res = Str_O::create(obj->__repr__(),_lisp);
	return(Values(res));
    }


/*
  __BEGIN_DOC(candoScript.general.list,list)
  \scriptCmdRet{list}{object1 object2 ...}{list}\par
  \scriptCmdRet{:}{object1 object2 ...}{list}

  Return a list formed by evaluating the arguments.
  __END_DOC
*/








#if 0
/*
  __BEGIN_DOC(candoScript.general.mod,mod)
  \scriptCmdRet{mod}{valueA:number valueB:number}{number}\par

  Return the result of modulus of the arguments.
  __END_DOC
*/
    T_sp p r i m_mod(Function_sp e, Cons_sp args, Environment_sp environ, Lisp_sp lisp )
    {_G();
	IMPLEMENT_ME();
	Cons_sp p;
	T_sp o, res;
	if ( args->length() != 2 ) SIMPLE_ERROR(BF("Need two arguments"));
	T_sp o1 = args->ocar();
	T_sp o2 = args->ocadr();
	int d1,d2;
	d1 = safe_downcast<Fixnum_O>(o1)->get();
	d2 = safe_downcast<Fixnum_O>(o2)->get();
	return Fixnum_O::create(d1 % d2);
    }
#endif






#if 0
/*
  __BEGIN_DOC(candoScript.general.eq,eq)
  \scriptCmdRet{eq}{valueA valueB }{Bool::}\par
  \scriptMethodRet{valueA}{==}{valueB }{Bool::}

  Return true if the objects are equal. For some objects (numbers,strings,bools) it compares the objects values. For more complex objects it returns true if they are identical.
  __END_DOC
*/
    T_sp p r i m_eq(Function_sp e, Cons_sp args, Environment_sp environ, Lisp_sp lisp )
    {_G();
	if ( args->length() != 2 ) SIMPLE_ERROR(BF("eq needs two arguments"));
	T_sp o1 = args->ocar();
	T_sp o2 = args->ocadr();
	return lisp->_boolean(o1->equal(o2));
    }

/*
  __BEGIN_DOC(candoScript.general.ne,ne)
  \scriptCmdRet{ne}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{!=}{valueB }{bool}

  Return true if the objects are not equal. For some objects (numbers,strings,bools) it compares the objects values. For more complex objects it returns true if they are not identical.
  __END_DOC
*/
    T_sp p r i m_ne(Function_sp e, Cons_sp args, Environment_sp environ, Lisp_sp lisp )
    {_G();
	if ( args->length() != 2 ) SIMPLE_ERROR(BF("ne needs two arguments"));
	T_sp o1 = args->ocar();
	T_sp o2 = args->ocadr();
	return lisp->_boolean(o1->ne(o2));
    }


/*
  __BEGIN_DOC(candoScript.general.lt,lt)
  \scriptCmdRet{lt}{valueA valueB }{Bool::}\par
  \scriptMethodRet{valueA}{$<$}{valueB }{Bool::}

  Return true if valueA $<$ valueB.
  __END_DOC
*/
    T_sp p r i m_lt(Function_sp e, Cons_sp args, Environment_sp environ, Lisp_sp lisp )
    {_G();
	if ( args->length() != 2 ) SIMPLE_ERROR(BF("lt needs two arguments"));
	T_sp o1 = args->ocar();
	T_sp o2 = args->ocadr();
	return lisp->_boolean(o1->lt(o2));
    }


/*
  __BEGIN_DOC(candoScript.general.gt,gt)
  \scriptCmdRet{gt}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{$>$}{valueB }{bool}

  Return true if valueA $>$ valueB.
  __END_DOC
*/
    T_sp p r i m_gt(Function_sp e, Cons_sp args, Environment_sp environ, Lisp_sp lisp )
    {_G();
	if ( args->length() != 2 ) SIMPLE_ERROR(BF("gt needs two arguments"));
	T_sp o1 = args->ocar();
	T_sp o2 = args->ocadr();
	return lisp->_boolean(o1->gt(o2));
    }


/*
  __BEGIN_DOC(candoScript.general.le,le)
  \scriptCmdRet{le}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{$<$=}{valueB }{bool}

  Return true if valueA $<$= valueB.
  __END_DOC
*/
    T_sp prim_le(Function_sp e, Cons_sp args, Environment_sp environ, Lisp_sp lisp )
    {_G();
	if ( args->length() != 2 ) SIMPLE_ERROR(BF("le needs two arguments"));
	T_sp o1 = args->olistref(0);
	T_sp o2 = args->olistref(1);
	return lisp->_boolean(o1->le(o2));
    }


/*
  __BEGIN_DOC(candoScript.general.ge,ge)
  \scriptCmdRet{ge}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{$>=$}{valueB }{bool}

  Return true if valueA $>=$ valueB.
  __END_DOC
*/
    T_sp p r i m_ge(Function_sp e, Cons_sp args, Environment_sp environ, Lisp_sp lisp )
    {_G();
	if ( args->length() != 2 ) SIMPLE_ERROR(BF("ge needs two arguments"));
	T_sp o1 = args->olistref(0);
	T_sp o2 = args->olistref(1);
	return lisp->_boolean(o1->ge(o2));
    }

#endif


/*
  __BEGIN_DOC(candoScript.general.not,not)
  \scriptCmdRet{not}{boolA}{bool}\par

  Return not boolA.
  __END_DOC
*/



#define ARGS_af_not "(arg)"
#define DECL_af_not ""
#define DOCS_af_not "not"
    T_mv af_not(T_sp x)
    {_G();
	return(Values(_lisp->_boolean(!x->isTrue())));
    };




/*
  __BEGIN_DOC(candoScript.general.printPushPrefix,printPushPrefix)
  \scriptCmd{printPushPrefixln}{args ...}\par

  Push a prefix to be printed everytime print is called the arguments followed by a new line.
  __END_DOC
*/
    
    
    
#define ARGS_af_printPushPrefix "(pref)"
#define DECL_af_printPushPrefix ""
#define DOCS_af_printPushPrefix "Change the repl prompt"
    void af_printPushPrefix(Str_sp pref)
    {_G();
	printvPushPrefix(pref->get());
    }

/*
  __BEGIN_DOC(candoScript.general.printPopPrefix,printPopPrefix)
  \scriptCmd{printPopPrefixln}{args ...}\par

  Pop a prefix to be printed everytime print is called the arguments followed by a new line.
  __END_DOC
*/
    
    
    
#define ARGS_af_printPopPrefix ""
#define DECL_af_printPopPrefix ""
#define DOCS_af_printPopPrefix "printPopPrefix"
    void af_printPopPrefix()
    {_G();
	printvPopPrefix();
    }


/*
  __BEGIN_DOC(candoScript.general.print,print)
  \scriptCmd{println}{args ...}\par

  Print new line followed by string representations of the arguments.
  __END_DOC
*/


#define ARGS_af_princ "(obj &optional (output-stream-desig core::*stdout*))"
#define DECL_af_princ ""
#define DOCS_af_princ "See CLHS: princ"
    void af_princ(T_sp obj, T_sp output_stream_desig )
    {_G();
	DynamicScopeManager scope1(cl::_sym_STARprint_escapeSTAR,T_O::_nil);
	DynamicScopeManager scope2(cl::_sym_STARprint_readablySTAR,T_O::_nil);
	eval::funcall(cl::_sym_write,obj,kw::_sym_stream,output_stream_desig);
    }




#define ARGS_af_prin1 "(obj &optional (output-stream-desig core::*stdout*))"
#define DECL_af_prin1 ""
#define DOCS_af_prin1 "See CLHS: prin1"
    void af_prin1(T_sp obj, T_sp output_stream_desig )
    {_G();
	DynamicScopeManager scope(cl::_sym_STARprint_escapeSTAR,_lisp->_true());
	Stream_sp sout = coerce::outputStreamDesignator(output_stream_desig);
	eval::funcall(cl::_sym_write,obj,kw::_sym_stream,output_stream_desig);
    }

#define ARGS_af_print "(obj &optional (output-stream-desig core::*stdout*))"
#define DECL_af_print ""
#define DOCS_af_print "See CLHS: print"
    void af_print(T_sp obj, T_sp output_stream_desig )
    {_G();
	DynamicScopeManager scope(cl::_sym_STARprint_escapeSTAR,_lisp->_true());
	Stream_sp sout = coerce::outputStreamDesignator(output_stream_desig);
	sout->write("\n");
	af_prin1(obj,sout);
	sout->write(" ");
	sout->flush();
    }

    
    



    Symbol_sp Lisp_O::getClassSymbolForClassName(const string& name)
    {
	Class_sp mc = this->classFromClassName(name);
	Symbol_sp sym = mc->classSymbol();
	ASSERTNOTNULL(sym);
	return sym;
    }


    T_sp Lisp_O::createObjectOfClass(T_sp mc)
    {_G();
	if (mc->metaClassP())
	{
	    LOG(BF("createObjectOfClass(%s)") % mc->getPackagedName() );
	    IMPLEMENT_ME();
	    T_sp obj = mc->as<Class_O>()->allocate_newNil();
	    obj->initialize();
	    return obj;
	}
	SIMPLE_ERROR(BF("Handle createObjectOfClass when mc is not a Class"));
    }



    void Lisp_O::setEmbeddedInPython(bool b)
    {_OF();
	LOG(BF("EmbeddedInPython is being set to[%d]") % b);
	this->_EmbeddedInPython = b;
    }



    Class_sp Lisp_O::boot_setf_findClass(Symbol_sp className, Class_sp mc)
    {
	ASSERTF(this->_BootClassTableIsValid,
		BF("Never use Lisp_O::setf_findClass after boot - use af_setf_findClass"));
	this->_BootClassTable[className] = mc;
	return mc;
    }


    Class_sp Lisp_O::boot_findClass(Symbol_sp className, bool errorp) const
    {_G();
	ASSERTF(this->_BootClassTableIsValid,
		BF("Never use Lisp_O::findClass after boot - use cl::_sym_findClass"));
	SymbolMap<Class_O>::const_iterator fi = this->_BootClassTable.find(className);
	if ( fi == this->_BootClassTable.end() )
	{
	    if ( errorp )
	    {
		SIMPLE_ERROR(BF("No class named %s") % className->__repr__() );
	    }
	    return Class_O::_nil;
	}
	return fi->second;
    }


/*! After the core classes are defined and we have hash-tables, move all class definitions
  into the *class-name-hash-table*.  We do this because we can't put stuff into a hash-table
  until the hash-table class is defined and we need classes in the *class-name-hash-table* once
  CLOS starts up because that is where ECL expects to find them. */
    void Lisp_O::switchToClassNameHashTable()
    {_G();
	ASSERTF(this->_BootClassTableIsValid,BF("switchToClassNameHashTable should only be called once after boot"));
	HashTable_sp ht = _sym_STARclassNameHashTableSTAR->symbolValue()->as<HashTable_O>();
	for ( SymbolMap<Class_O>::iterator it=this->_BootClassTable.begin();
	      it!=this->_BootClassTable.end(); it++ )
	{
	    ht->hash_table_setf_gethash(it->first,it->second);
	}
	this->_BootClassTableIsValid = false;
    }





#define ARGS_Lisp_O_find_single_dispatch_generic_function "(gf-symbol &optional errorp)"
#define DECL_Lisp_O_find_single_dispatch_generic_function ""
#define DOCS_Lisp_O_find_single_dispatch_generic_function "Lookup a single dispatch generic function. If errorp is truen and the generic function isn't found throw an exception"
    SingleDispatchGenericFunction_sp Lisp_O::find_single_dispatch_generic_function(Symbol_sp gfSym, bool errorp)
    {_G();
	SymbolMap<SingleDispatchGenericFunction_O>::const_iterator fi = _lisp->_SingleDispatchGenericFunctionTable.find(gfSym);
	if ( fi == _lisp->_SingleDispatchGenericFunctionTable.end() )
	{
	    if ( errorp )
	    {
		SIMPLE_ERROR(BF("No single-dispatch-generic-function named %s") % gfSym->__repr__() );
	    }
	    return SingleDispatchGenericFunction_O::_nil;
	}
	return fi->second;
    }





#define ARGS_Lisp_O_setf_find_single_dispatch_generic_function "(gf-symbol gf)"
#define DECL_Lisp_O_setf_find_single_dispatch_generic_function ""
#define DOCS_Lisp_O_setf_find_single_dispatch_generic_function "Define a single dispatch generic function "
    SingleDispatchGenericFunction_sp Lisp_O::setf_find_single_dispatch_generic_function(Symbol_sp gfName, SingleDispatchGenericFunction_sp gf)
    {_G();
	_lisp->_SingleDispatchGenericFunctionTable[gfName] = gf;
	return gf;
    }


#define ARGS_Lisp_O_forget_all_single_dispatch_generic_functions ""
#define DECL_Lisp_O_forget_all_single_dispatch_generic_functions ""
#define DOCS_Lisp_O_forget_all_single_dispatch_generic_functions "Forget all single dispatch functions"
    void Lisp_O::forget_all_single_dispatch_generic_functions()
    {_G();
	_lisp->_SingleDispatchGenericFunctionTable.clear();
    }






#if 0
    GenericFunction_sp Lisp_O::setf_findGenericFunction(Symbol_sp gfName, GenericFunction_sp mc)
    {_OF();
	this->_GenericFunctionTable[gfName] = mc;
	return mc;
    }


    GenericFunction_sp Lisp_O::findGenericFunction(Symbol_sp gfName, bool errorp) const
    {_OF();
	SymbolMap<GenericFunction_O>::const_iterator fi = this->_GenericFunctionTable.find(gfName);
	if ( fi == this->_GenericFunctionTable.end() )
	{
	    if ( errorp )
	    {
		SIMPLE_ERROR(BF("No generic function named %s") % gfName->__repr__() );
	    }
	    return GenericFunction_O::_nil;
	}
	return fi->second;
    }

#endif
	  



    Class_sp Lisp_O::classFromClassSymbol(Symbol_sp cid) const
    {_G();
	DEPRECIATED();
#if 0
	return this->findClass(cid,true);
#endif
    }

    string Lisp_O::classNameFromClassSymbol(Symbol_sp cid)
    {
	DEPRECIATED();
#if 0
	Class_sp mc = this->classFromClassSymbol(cid);
	return mc->getPackagedName();
#endif
    }





    Class_sp Lisp_O::classFromClassName(const string& name)
    {_OF();
	DEPRECIATED();
#if 0
	Symbol_sp sym = this->findSymbol(name);
	if ( sym->isNil() )
	{
	    SIMPLE_ERROR(BF("Could not find class with name: %s") % name );
	}
	return _lisp->findClass(sym);
#endif
//    return sym->symbolValue()->as<Class_O>();
    }



    void Lisp_O::parseStringIntoPackageAndSymbolName(const string& name, bool& packageDefined, Package_sp& package, string& symbolName, bool& exported) const
    {_OF();
	packageDefined = true; // this will be true in most cases below
	LOG(BF("Parsing string[%s] into package and symbol name") % name );
	if ( name[0] == ':' )
	{
	    LOG(BF("It's a keyword"));
	    package = this->_KeywordPackage;
	    symbolName = name.substr(1,99999);
	    exported = true;
	    return;
	}
	if ( name[0] == '&' )
	{
	    LOG(BF("It's an & symbol"));
	    package = this->_CorePackage;
	    symbolName = name;
	    exported = true;
	    return;
	}
	size_t colonPos = name.find_first_of(":");
	exported = true;
	if ( colonPos == string::npos )
	{
	    LOG(BF("Package wasn't defined"));
	    symbolName = name;
	    packageDefined = false;
	    return;
	}
	bool doubleColon = false;
	size_t secondPart = colonPos+1;
	if ( name[secondPart] == ':' )
	{
	    LOG(BF("It's a non-exported symbol"));
	    exported = false;
	    doubleColon = true;
	    secondPart++;
	    if ( name.find_first_of(":",secondPart) != string::npos )
	    {
		SIMPLE_ERROR(BF("There can only be one ':' or '::' in a symbol name"));
	    }
	}
	package = this->findPackage(name.substr(0,colonPos));
	symbolName = name.substr(secondPart,99999);
	LOG(BF("It's a packaged symbol (%s :: %s)") % package->getName()% symbolName );
	return;
    }




    Symbol_sp Lisp_O::intern(const string& name, T_sp optionalPackageDesignator )
    {_G();
#if DEBUG_ENVIRONMENT_CREATION
//    ASSERT(this->_PackagesInitialized);
#endif
	Package_sp package;
	string symbolName;
	bool exported, packageDefined;
	this->parseStringIntoPackageAndSymbolName(name,packageDefined,package,symbolName,exported);
	if ( !packageDefined )
	{
	    package = coerce::packageDesignator(optionalPackageDesignator);
	}
	ASSERTNOTNULL(package);
	return package->intern(symbolName)->as<Symbol_O>();
    }

/*! The optionalPackageDesignator is nil */
    Symbol_sp Lisp_O::intern(string const& symbolName)
    {_G();
	Package_sp curPackage = this->getCurrentPackage();
	ASSERTNOTNULL(curPackage);
	return this->intern(symbolName,curPackage);
    }
    



    Symbol_sp Lisp_O::findSymbol(const string& name,T_sp optionalPackageDesignator) const
    {_G();
#if DEBUG_ENVIRONMENT_CREATION
	ASSERT(this->_PackagesInitialized);
#endif
	Package_sp package;
	string symbolName;
	bool exported,packageDefined;
	this->parseStringIntoPackageAndSymbolName(name,packageDefined,package,symbolName,exported);
	if ( !packageDefined )
	{
	    package = coerce::packageDesignator(optionalPackageDesignator);
	}
	return package->findSymbol(symbolName)->as<Symbol_O>();
    }


    Symbol_sp Lisp_O::findSymbol(const string& symbolName /*, T_sp optionalPackageDesignator = nil */) const
    {_G();
	return this->findSymbol(symbolName,T_O::_nil);
    }



    Symbol_sp Lisp_O::internWithPackageName(string const& packageName, string const& symbolName)
    {_G();
	Package_sp package = this->findPackage(packageName);
	return this->intern(symbolName,package);
    }




    Symbol_sp Lisp_O::internKeyword(const string& name)
    {_G();
	string realName = name;
	if ( name[0] == ':' )
	{
	    realName = name.substr(1,99999);
	}
	size_t colonPos = realName.find_first_of(":");
	if ( colonPos != string::npos )
	{
	    SIMPLE_ERROR(BF("You cannot intern[%s] as a keyword - it has package designating ':' characters in it at pos[%d]") % realName % colonPos);
	}
	return this->_KeywordPackage->intern(realName)->as<Symbol_O>();
    }




    bool Lisp_O::isClassName(const string& name)
    {
	DEPRECIATED();
#if 0
	Symbol_sp sym = this->intern(name);
	Class_sp cl = this->findClass(sym,false);
	return cl->notNil();
#endif
    }


#if 0
/*!
 * Look for the method in the class and its ancestor classes.
 * Return the method or nil if not found.
 * Return the class that contained the method
 *
 * I created this function on the plane to Orlando (2010) and I don't want
 * to recompile everything by adding this as an Lisp_O method
 * make this a Lisp_O method once we have power and can compile the entire
 * source code.
 */
    Function_sp searchAncestorsForMethod(Symbol_sp sym, Class_sp& mc, T_sp receiver, Lisp_O* lisp )
    {_G();
	LOG(BF("Looking for method(%s) in class(%s)")% sym->currentName() % mc->getPackagedName() );
	Function_sp exec = mc->getMethodOrNil(sym, receiver);
	if ( exec->notNil() ) 
	{
	    LOG(BF("Found it!"));
	    return exec;
	}
	Class_O::const_baseClassIterator mc_begin = mc->baseClasses_begin();
	Class_O::const_baseClassIterator mc_end = mc->baseClasses_end();
	for ( Class_O::const_baseClassIterator it = mc_begin; it!= mc_end; it++ )
	{
	    mc = *it;
	    Function_sp baseExec = searchAncestorsForMethod(sym,mc,receiver,lisp);
	    if ( baseExec->notNil() ) return baseExec;
	}
	LOG(BF("Could not find method"));
	return Function_O::_nil;
    }



    Function_sp Lisp_O::lookupMethod(Symbol_sp sym, Class_sp mc, T_sp receiver)
    {_G();
	return searchAncestorsForMethod(sym,mc,receiver,this);
    }
#endif





    bool Lisp_O::subClassOrder(Symbol_sp classSymbol1, Symbol_sp classSymbol2 )
    {_OF();
	Class_sp mc1 = this->classFromClassSymbol(classSymbol1);
	Class_sp mc2 = this->classFromClassSymbol(classSymbol2);
	return mc2->isSubClassOf(mc1);
    }


    void Lisp_O::dump_apropos(const char* part) const
    {_OF();
	string substring = part;
	Vector0<Package_O>	packages;
	for ( Vector0<Package_O>::iterator pi=_lisp->packages().begin();
	      pi != _lisp->packages().end(); pi++ )
	{
	    packages.push_back(*pi);
	}
	searchForApropos(packages,substring,true);
    }


    void Lisp_O::dump_backtrace(int numcol)
    {_OF();
	string bt = lisp_debugLog()->cppCallStack().asString();
	_lisp->print(BF("%s")%bt);
    }



    void Lisp_O::gdb_trace_by_name(const char* names)
    {_OF();
	string snames = lispify_symbol_name(names);
	if ( snames == "" )
	{
	    Set<Function_O>::iterator ti;
	    _lisp->print(BF("Tracing: "));
	    for ( ti=this->_TraceFunctions.begin(); ti!=this->_TraceFunctions.end(); ti++ )
	    {
		_lisp->print(BF("%s") % (*ti)->getFunctionName()->__repr__() );
	    }
	    return;
	}
	vector<string> vnames = split(snames," ");
	for ( vector<string>::iterator it=vnames.begin(); it!=vnames.end(); it++ ) 
	{
	    Symbol_sp sym = this->intern(*it);
	    if ( sym->fboundp() )
	    {
		Function_sp fn = sym->symbolFunction();
		this->_TraceFunctions.addUnique(fn,_lisp);
		_lisp->print(BF("trace: %s") % sym->__repr__() );
	    } else
	    {
		_lisp->print(BF("Cannot trace function[%s] - it doesnt' exist") % sym->__repr__() );
	    }
	}
    }




    void Lisp_O::gdb_untrace_by_name(const char* names)
    {_OF();
	string snames = lispify_symbol_name(names);
	if ( snames == "" )
	{
	    Set<Function_O>::iterator ti;
	    _lisp->print(BF("untracing all"));
	    this->_TraceFunctions.clear();
	    return;
	}
	vector<string> vnames = split(snames," ");
	for ( vector<string>::iterator it=vnames.begin(); it!=vnames.end(); it++ ) 
	{
	    Symbol_sp sym = this->intern(*it);
	    if ( sym->fboundp() )
	    {
		Function_sp fn = sym->symbolFunction();
		if (this->_TraceFunctions.count(fn)>0) this->_TraceFunctions.erase(fn);
	    }
	}
    }


#if 0
    string Lisp_O::backTraceAsString(int numcol) const
    {
	stringstream strace;
	Cons_sp btReversed = this->getBackTrace();
	Cons_sp bt = btReversed->reverse()->as<Cons_O>();;
	strace << "Cando-backtrace number of entries: " << bt->length() <<endl;
	while ( bt->notNil() )
	{
	    T_sp code = bt->ocar();
	    stringstream sline;
	    if ( code->consP() )
	    {
		Cons_sp entry = code->as<Cons_O>();
		if ( entry->hasParsePos() )
		{
		    sline << entry->sourceFileInfo()->permanentFileName() << ":" << entry->getParsePosLineNumber() << " " << entry->__repr__();
		} else
		{
		    sline << "no-function: " << entry->__repr__();
		}
	    } else
	    {
		sline << "no-function: " << code->__repr__();
	    }
	    strace << sline.str().substr(0,numcol) << endl;
	    bt = bt->cdr();
	}
	strace << "----- backtrace done ------" << endl;
	return strace.str();
    }
#endif



    void Lisp_O::run()
    {_G();
//	this->inPackage("CORE-USER");
	//
	// Compile and evaluate the .rc code to extend the environment in lisp
	//
	if ( !this->_dont_load_startup)
	{
	    LOG(BF("Initialization source file[%s]") % this->_RCFileName);
	    if ( this->_RCFileName != "" )
	    {_BLOCK_TRACEF(BF("Evaluating initialization code in(%s)") % this->_RCFileName );
		Path_sp initPath = Path_O::create(this->_Bundle->getLispDir());
		initPath->path_append(this->_RCFileName);
		LOG(BF("Physical path to init file[%s]") % initPath->asString() );
		this->load(initPath);
	    }
	    if ( !this->_ProgramCode._ScriptInFile
		 && this->_ProgramCode._FileNameOrCode != "" )
	    {
		LOG(BF("Compiling script in string: %s")% this->_ProgramCode._FileNameOrCode);
		StringInputStream_sp sin = StringInputStream_O::create(this->_ProgramCode._FileNameOrCode);
		this->load(sin);
	    } else
	    {
		string& scriptFileName = this->_ProgramCode._FileNameOrCode;
		if ( scriptFileName != "" )
		{
		    LOG(BF("About to compile script in fileName(%s)")% scriptFileName);
		    Path_sp loadPath = _lisp->translateLogicalPathnameUsingPaths(Str_O::create(scriptFileName,_lisp));
		    this->load(loadPath);
		} else
		{
		    LOG(BF("this->_ProgramCode._FileNameOrCode is empty"));
		}
	    }
	}
	//
	// Assume that if there is no program then
	// we want an interactive script
	//
	if ( this->_Interactive )
	{_BLOCK_TRACE("Interactive REPL");
	    //
	    // Implement a Read-Eval-Print-Loop
	    //
	    this->print(BF("BRIDGE-COMMON-LISP (copyright Christian E. Schafmeister 2013) - 1.0\n"));
	    while ( 1 )
	    {
		this->readEvalPrintInteractive();
	    }
	}
	LOG(BF("Leaving lisp run"));
    };


    void Lisp_O::mapClassNamesAndClasses(KeyValueMapper* mapper)
    {_G();
	if ( this->_BootClassTableIsValid )
	{
	    for ( SymbolMap<Class_O>::iterator it=this->_BootClassTable.begin();
		  it!=this->_BootClassTable.end(); it++ )
	    {
		if (!mapper->mapKeyValue(it->first,it->second)) break;
	    }
	} else
	{
	    HashTable_sp ht = _sym_STARclassNameHashTableSTAR->symbolValue()->as<HashTable_O>();
	    ht->lowLevelMapHash(mapper);
	}
    }


    string	Lisp_O::__repr__() const
    {_G();
	stringstream ss;
	ss << "Lisp_O object";
	return ss.str();
    };






    void Lisp_O::initializeGlobals(Lisp_sp lisp)
    {_G();
	LOG(BF("Lisp_O::initializeGlobals"));
	SYMBOL_EXPORT_SC_(CorePkg,selectPackage);
	Defun(selectPackage);
    }

    void Lisp_O::exposeCando()
    {_G();
	SYMBOL_SC_(CorePkg,find_single_dispatch_generic_function);
	af_def(CorePkg,"find-single-dispatch-generic-function",
	       &Lisp_O::find_single_dispatch_generic_function,
	       ARGS_Lisp_O_find_single_dispatch_generic_function,
	       DECL_Lisp_O_find_single_dispatch_generic_function,
	       DOCS_Lisp_O_find_single_dispatch_generic_function);
	SYMBOL_SC_(CorePkg,setf_find_single_dispatch_generic_function);
	af_def(CorePkg,"setf-find-single-dispatch-generic-function",
	       &Lisp_O::setf_find_single_dispatch_generic_function,
	       ARGS_Lisp_O_setf_find_single_dispatch_generic_function,
	       DECL_Lisp_O_setf_find_single_dispatch_generic_function,
	       DOCS_Lisp_O_setf_find_single_dispatch_generic_function);
	SYMBOL_SC_(CorePkg,forget_all_single_dispatch_generic_functions);
	af_def(CorePkg,"forget-all-single-dispatch-generic-functions",
	       &Lisp_O::forget_all_single_dispatch_generic_functions,
	       ARGS_Lisp_O_forget_all_single_dispatch_generic_functions,
	       DECL_Lisp_O_forget_all_single_dispatch_generic_functions,
	       DOCS_Lisp_O_forget_all_single_dispatch_generic_functions);

	SYMBOL_SC_(CorePkg,stackMonitor);
	Defun(stackMonitor);
	SYMBOL_SC_(CorePkg,setupStackMonitor);
	Defun(setupStackMonitor);

	SYMBOL_SC_(CorePkg,invokeInternalDebugger);
	Defun(invokeInternalDebugger);
	SYMBOL_SC_(CorePkg,invokeInternalDebuggerFromGdb);
	Defun(invokeInternalDebuggerFromGdb);
	SYMBOL_SC_(CorePkg,universalErrorHandler);
	Defun(universalErrorHandler);
	SYMBOL_SC_(CorePkg,stackUsed);
	Defun(stackUsed);
	SYMBOL_SC_(CorePkg,loadTimeValueArray);
	Defun(loadTimeValueArray);
	SYMBOL_SC_(CorePkg,exit);
	Defun(exit);
#if defined(XML_ARCHIVE)
	SYMBOL_SC_(CorePkg,saveArchive);
	Defun(saveArchive);
	SYMBOL_SC_(CorePkg,serialize_xml);
	Defun(serialize_xml);
	SYMBOL_SC_(CorePkg,deserialize_xml);
	Defun(deserialize_xml);
	SYMBOL_SC_(CorePkg,loadArchive);
	Defun(loadArchive);
	SYMBOL_SC_(CorePkg,render);
	Defun(render);
	SYMBOL_SC_(CorePkg,saveCando);
	Defun(saveCando);
	SYMBOL_SC_(CorePkg,loadCando);
	Defun(loadCando);
#endif // defined(XML_ARCHIVE)
	SYMBOL_SC_(CorePkg,getline);
	Defun(getline);

	SYMBOL_SC_(CorePkg,system);
	Defun(system);

	SYMBOL_EXPORT_SC_(ClPkg,apropos);
	Defun(apropos);

	af_def(CorePkg,"brcl-apropos",&af_apropos,ARGS_af_apropos,DECL_af_apropos,DOCS_af_apropos);

	SYMBOL_EXPORT_SC_(ClPkg,export);
	Defun(export);
	SYMBOL_EXPORT_SC_(ClPkg,intern);
	Defun(intern);
//	defNoWrapPackage(CorePkg,"apply", &prim_apply,_LISP);
	SYMBOL_SC_(CorePkg,isTopLevelScript);
	Defun(isTopLevelScript);

//	defNoWrapPackage(CorePkg,"allGlobalNames", &prim_allGlobalNames ,_LISP);
//	defNoWrapPackage(CorePkg,"locals", &prim_locals,_LISP);
	SYMBOL_SC_(CorePkg,sourceFileName);
	Defun(sourceFileName);
	SYMBOL_SC_(CorePkg,sourceLineColumn);
	Defun(sourceLineColumn);
//	SYMBOL_SC_(CorePkg,backtrace);
//	Defun(backtrace);
//	defNoWrapPackage(CorePkg,"globals", &prim_globals,_LISP);
	SYMBOL_EXPORT_SC_(ClPkg,load);
	Defun(load);
	SYMBOL_SC_(CorePkg,findFileInLispPath);
	Defun(findFileInLispPath);
	SYMBOL_SC_(CorePkg,printPushPrefix);
	Defun(printPushPrefix);
	SYMBOL_SC_(CorePkg,printPopPrefix);
	Defun(printPopPrefix);
	SYMBOL_EXPORT_SC_(ClPkg,print);
	Defun(print);
	SYMBOL_EXPORT_SC_(ClPkg,prin1);
	Defun(prin1);
	SYMBOL_EXPORT_SC_(ClPkg,princ);
	Defun(princ);

	SYMBOL_EXPORT_SC_(ClPkg,findClass);
	Defun(findClass);
	SYMBOL_SC_(CorePkg,setf_findClass);
	Defun(setf_findClass);

//	defNoWrapPackage(CorePkg,"print", &prim_print ,_LISP);

	SYMBOL_SC_(CorePkg,isAssignableTo);
	Defun(isAssignableTo);
	SYMBOL_SC_(CorePkg,isSubClassOf);
	Defun(isSubClassOf);

//	defNoWrapPackage(CorePkg,"derive", &prim_derive ,_LISP);
//	defNoWrapPackage(CorePkg,"isA", &prim_isA ,_LISP);

//	defNoWrapPackage(CorePkg,"parseConsOfStrings", &prim_parseConsOfStrings ,_LISP);

	SYMBOL_EXPORT_SC_(ClPkg,funcall);
	Defun(funcall);
	SYMBOL_EXPORT_SC_(ClPkg,apply);
	Defun(apply);
//	defNoWrapPackage(CorePkg,"sub", &prim_sub ,_LISP);
//	defNoWrapPackage(CorePkg,"-", &prim_sub ,_LISP);
//	defNoWrapPackage(CorePkg,"div", &prim_div ,_LISP);
//    defNoWrapPackage(CorePkg,"mod", &prim_mod ,_LISP);
//	defNoWrapPackage(CorePkg,"/", &prim_div ,_LISP);
//	defNoWrapPackage(CorePkg,"mul", &prim_mul ,_LISP);
//	defNoWrapPackage(CorePkg,"*", &prim_mul ,_LISP);
//	defNoWrapPackage(CorePkg,"className", &prim_className ,_LISP);

	SYMBOL_SC_(CorePkg,repr);
	Defun(repr);

	SYMBOL_EXPORT_SC_(ClPkg,error);
	Defun(error);
	SYMBOL_SC_(CorePkg,setenv);
	Defun(setenv);
	SYMBOL_SC_(CorePkg,getenv);
	Defun(getenv);
	SYMBOL_EXPORT_SC_(ClPkg,not);
	Defun(not);

	SYMBOL_SC_(CorePkg,debugLogOn);
	Defun(debugLogOn);
	SYMBOL_SC_(CorePkg,debugLogOff);
	Defun(debugLogOff);

	// mpi commands that are always built in
	SYMBOL_SC_(CorePkg,mpi_enabled);
	Defun(mpi_enabled);
	SYMBOL_SC_(CorePkg,mpi_rank);
	Defun(mpi_rank);
	SYMBOL_SC_(CorePkg,mpi_size);
	Defun(mpi_size);
	// Basic tests
//	defNoWrapPackage(CorePkg,"consp",&prim_consp,_LISP);
//	defNoWrapPackage(CorePkg,"symbolp",&prim_symbolp,_LISP);

	// aliases for "list" command

	SYMBOL_SC_(CorePkg,sorted);
	Defun(sorted);
	SYMBOL_EXPORT_SC_(ClPkg,sort);
	Defun(sort);
	SYMBOL_EXPORT_SC_(ClPkg,macroexpand_1);
	Defun(macroexpand_1);
	SYMBOL_EXPORT_SC_(ClPkg,macroexpand);
	Defun(macroexpand);

	// information functions
	SYMBOL_SC_(CorePkg,database_dir);
	Defun(database_dir);
	SYMBOL_SC_(CorePkg,script_dir);
	Defun(script_dir);
	SYMBOL_SC_(CorePkg,libraryPath);
	Defun(libraryPath);
	SYMBOL_SC_(CorePkg,lispCodePath);
	Defun(lispCodePath);
//	defNoWrapPackage(CorePkg,"dumpHidden", &prim_dumpHidden,_LISP);

	SYMBOL_SC_(CorePkg,setCurrentWorkingDirectory);
	Defun(setCurrentWorkingDirectory);
	
	SYMBOL_EXPORT_SC_(ClPkg,acons);
	Defun(acons);
	SYMBOL_EXPORT_SC_(ClPkg,assoc);
	Defun(assoc);
	SYMBOL_EXPORT_SC_(ClPkg,member);
	Defun(member);

	SYMBOL_SC_(CorePkg,member1);
	Defun(member1);

	SYMBOL_SC_(CorePkg,exportToPython);
	Defun(exportToPython);

	SYMBOL_EXPORT_SC_(ClPkg,find_package);
	Defun(find_package);

    }



    void Lisp_O::exposePython()
    {_G();
#if 0
	Symbol_sp (Lisp_O::*intern1)(const string&) = &Lisp_O::intern;
	PYTHON_CLASS(CorePkg,Lisp,"","",_lisp)
	    .def("intern",intern1)
#if 0
	    .def("true",&Lisp_O::_true)
	    .def("false",&Lisp_O::onil)
	    .def("nil",&Lisp_O::onil)
#endif
	    ;

//    boost::python::def("loadArchive",boost::python::wrapped_function(CorePkg,"loadArchive",&prim_loadArchive,ARGS_prim_loadArchive,DOCS_prim_loadArchive,lisp));
#if 0
//	boost::python::def_raw(CorePkg,"export",&prim_export,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"apply", &prim_apply,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"testomp", &prim_testomp,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"isTopLevelScript", &prim_isTopLevelScript ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"allGlobalNames", &prim_allGlobalNames ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"locals", &prim_locals,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"sourceFileLine", &prim_sourceFileLine,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"backtrace", &prim_backtrace,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"globals", &prim_globals,ARGS_empty,DOCS_empty,_LISP);

	boost::python::def_raw(CorePkg,"load", &prim_load,ARGS_prim_load,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"include",&prim_include,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"testScanner", &prim_testScanner ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"printPushPrefix", &prim_printPushPrefix ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"printPopPrefix", &prim_printPopPrefix ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"println", &prim_println ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"print", &prim_print ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"prin1", &prim_prin1 ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"prim-dump", &prim_dump ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"isAssignableTo", &prim_isAssignableTo ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"isSubClassOf", &prim_isSubClassOf,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"derive", &prim_derive ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"isA", &prim_isA ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"dumpln", &prim_dumpln ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"parseConsOfStrings", &prim_parseConsOfStrings ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"exit", &prim_exit ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"quit", &prim_exit ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"funcall", &prim_funcall ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"apply", &prim_apply ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"sub", &prim_sub ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"-", &prim_sub ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"div", &prim_div ,ARGS_empty,DOCS_empty,_LISP);
//    boost::python::def_raw(CorePkg,"mod", &prim_mod ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"/", &prim_div ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"mul", &prim_mul ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"*", &prim_mul ,ARGS_empty,DOCS_empty,_LISP);
#if 0
	boost::python::def_raw(CorePkg,"listref", &prim_listref ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"@", &prim_listref ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"car", &prim_car ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"cdr", &prim_cdr ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"cddr", &prim_cddr ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"cdddr", &prim_cdddr ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"cadr", &prim_cadr ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"caddr", &prim_caddr ,ARGS_empty,DOCS_empty,_LISP);
#endif
//    boost::python::def_raw(CorePkg,"cons", &prim_cons ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"className", &prim_className ,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"repr", &prim_repr ,ARGS_empty,DOCS_empty,_LISP);
#if 0  //These are now Object methods
	boost::python::def_raw(CorePkg,"eq", &prim_eq,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"==", &prim_eq,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"ne", &prim_ne,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"!=", &prim_ne,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"lt", &prim_lt,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"<", &prim_lt,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"gt", &prim_gt,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,">", &prim_gt,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"le", &prim_le,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"<=", &prim_le,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"ge", &prim_ge,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,">=", &prim_ge,ARGS_empty,DOCS_empty,_LISP);
#endif
//	boost::python::def_raw(CorePkg,"not", &prim_not,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"debugLogOn",&prim_debugLogOn,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"debugLogOff",&prim_debugLogOff,ARGS_empty,DOCS_empty,_LISP);
	boost::python::def_raw(CorePkg,"dumpClasses",&prim_dumpClasses,ARGS_empty,DOCS_empty,_LISP);

	// Basic tests
//	boost::python::def_raw(CorePkg,"consp",&prim_consp,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"symbolp",&prim_symbolp,ARGS_empty,DOCS_empty,_LISP);

	// aliases for "list" command

//	boost::python::def_raw(CorePkg,"comparer", &prim_list ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"sorted", &prim_sorted ,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"sort", &prim_sort,ARGS_empty,DOCS_empty,_LISP);
	// information functions
//	boost::python::def_raw(CorePkg,"databaseDir", &prim_databaseDir,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"scriptDir", &prim_scriptDir,ARGS_empty,DOCS_empty,_LISP);
//	boost::python::def_raw(CorePkg,"dumpHidden", &prim_dumpHidden,ARGS_empty,DOCS_empty,_LISP);

	boost::python::def_raw(CorePkg,"setCurrentWorkingDirectory",&prim_setCurrentWorkingDirectory,ARGS_empty,DOCS_empty,_LISP);
#endif
	initializePythonPrimitives(_LISP);
#endif
    }





    




    LispHolder::LispHolder(bool mpiEnabled, int mpiRank, int mpiSize )
    {
	this->_Lisp = Lisp_O::createLispEnvironment(mpiEnabled,mpiRank,mpiSize);
    }




    void LispHolder::startup(int argc, char* argv[], const string& appPathEnvironmentVariable )
    {
	this->_Lisp->_StackTop = (char*)&argc;
	mem::initialize_smart_pointers();
	Lisp_sp _lisp = this->_Lisp;
	const char* argv0 = "./";
	if ( argc > 0 ) argv0 = argv[0];
	Bundle* bundle = new Bundle();
	bundle->initialize(argv0,appPathEnvironmentVariable);
	this->_Lisp->startupLispEnvironment(bundle);
	if (_lisp->mpiEnabled())
	{
	    stringstream ss;
	    ss << "P"<<_lisp->mpiRank()<<":";
	    printvPushPrefix(ss.str());
	}
	_lisp->parseCommandLineArguments(argc,argv,true);
    }




    LispHolder::~LispHolder()
    {
	this->_Lisp->shutdownLispEnvironment();
    }




    PackageExposer::PackageExposer(Lisp_sp lisp, const string& packageName, const char* nicknames[])
    {_G();
	if ( !lisp->recognizesPackage(packageName) )
	{	
	    list<string> lnnames;
	    for ( int i=0; strcmp(nicknames[i],"")!=0; i++ )
	    {
		lnnames.push_front(nicknames[i]);
	    }
	    list<Package_sp> lp;
	    this->_Package = lisp->makePackage(packageName,lnnames,lp);
	} else
	{
	    this->_Package = lisp->findPackage(packageName);
	}
	this->_PackageName = packageName;
    }


    PackageExposer::PackageExposer(Lisp_sp lisp, const string& packageName )
    {_G();
	if ( !lisp->recognizesPackage(packageName) )
	{	
	    list<string> lnnames;
	    list<Package_sp> lpkgs;
	    this->_Package = lisp->makePackage(packageName,lnnames,lpkgs);
	} else
	{
	    this->_Package = lisp->findPackage(packageName);
	}
	this->_PackageName = packageName;
    }


    PackageExposer::~PackageExposer() {};





//    EXPOSE_CLASS(core,Lisp_O);


    ChangePackage::ChangePackage(Package_sp newPackage) : _SavedPackage(_lisp->getCurrentPackage())
    {
	_lisp->selectPackage(newPackage);
    }

    ChangePackage::~ChangePackage()
    {
	_lisp->selectPackage(this->_SavedPackage);
    }



};




