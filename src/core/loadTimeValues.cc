#define	DEBUG_LEVEL_FULL

#include "core/common.h"
#include "core/environment.h"
#include "core/str.h"
#include "loadTimeValues.h"
#include "core/wrappers.h"

#pragma GCC visibility push(default)

extern "C"
{
    /*! This stores a pointer to the smart_ptr to the run-time value vector.
      This is linked to by LLVM Modules generated by COMPILE.
      We use a pointer to the smart_ptr because we don't want
      to have to maintain this as a garbage collection root.
    */
    core::LoadTimeValues_sp* 	globalRunTimeValuesVector ATTR_WEAK = NULL;
};
#pragma GCC visibility pop

namespace core
{

// ----------------------------------------------------------------------
//


    
    
#define ARGS_cl_setRunTimeValuesVector "(name)"
#define DECL_cl_setRunTimeValuesVector ""
#define DOCS_cl_setRunTimeValuesVector "setRunTimeValuesVector - return true if its set and false if it was already set"
    bool cl_setRunTimeValuesVector(const string& name)
    {_G();
	if ( globalRunTimeValuesVector != NULL )
	{
	    return false;
	}
	LoadTimeValues_sp& runTimeLiterals = _lisp->getOrCreateLoadTimeValues(name);
	globalRunTimeValuesVector = &runTimeLiterals;
	return true;
    };


#define ARGS_af_loadTimeValueArray "(name &optional (data-size 0) (symbol-size 0))"
#define DECL_af_loadTimeValueArray ""
#define DOCS_af_loadTimeValueArray "loadTimeValueArray"
    LoadTimeValues_mv af_loadTimeValueArray(const string& name, int dataSize, int symbolSize )
    {_G();
	return(Values(_lisp->getOrCreateLoadTimeValues(name,dataSize, symbolSize)));
    };



    
    
#define ARGS_af_lookupLoadTimeValue "(name idx)"
#define DECL_af_lookupLoadTimeValue ""
#define DOCS_af_lookupLoadTimeValue "Return the load-time-value associated with array NAME and IDX"
    T_sp af_lookupLoadTimeValue(const string& name, int idx)
    {_G();
	LoadTimeValues_sp ltva = _lisp->findLoadTimeValues(name);
	if ( ltva.nilp() ) {
	    SIMPLE_ERROR(BF("Could not find load-time-values %s") % name);
	}
	if ( idx < 0 || idx >= ltva->numberOfValues() ) {
	    SIMPLE_ERROR(BF("Illegal index %d for load-time-value") % idx );
	}
	return ltva->data_element(idx);
    };


    
#define ARGS_af_lookupLoadTimeSymbol "(name idx)"
#define DECL_af_lookupLoadTimeSymbol ""
#define DOCS_af_lookupLoadTimeSymbol "Return the load-time-value associated with array NAME and IDX"
    Symbol_sp af_lookupLoadTimeSymbol(const string& name, int idx)
    {_G();
	LoadTimeValues_sp ltva = _lisp->findLoadTimeValues(name);
	if ( ltva.nilp() ) {
	    SIMPLE_ERROR(BF("Could not find load-time-values %s") % name);
	}
	if ( idx < 0 || idx >= ltva->numberOfValues() ) {
	    SIMPLE_ERROR(BF("Illegal index %d for load-time-symbol") % idx );
	}
	return ltva->symbols_element(idx);
    };



    
    
#define ARGS_af_loadTimeValuesIds "()"
#define DECL_af_loadTimeValuesIds ""
#define DOCS_af_loadTimeValuesIds "Return a cons of the load-time-values ids"
    Cons_mv af_loadTimeValuesIds()
    {_G();
	return(Values(_lisp->loadTimeValuesIds()));
    };

    
    
#define ARGS_af_loadTimeValuesDump "(name)"
#define DECL_af_loadTimeValuesDump ""
#define DOCS_af_loadTimeValuesDump "Dump the load-time-values for the id _name_(string)."
    void af_loadTimeValuesDump(Str_sp name)
    {_G();
	LoadTimeValues_sp ltv = _lisp->findLoadTimeValues(name->get());
	ltv->dump();
    };




    EXPOSE_CLASS(core,LoadTimeValues_O);


#define ARGS_LoadTimeValues_O_make "(dimension)"
#define DECL_LoadTimeValues_O_make ""
#define DOCS_LoadTimeValues_O_make "This is a thin wrapper around VectorObjectsWithFillPtr - it creates a place to store LoadTimeValues"
    LoadTimeValues_sp LoadTimeValues_O::make(int dataDimension, int symbolsDimension)
    {_G();
        GC_ALLOCATE(LoadTimeValues_O,vo );
	vo->_Objects = VectorObjectsWithFillPtr_O::make(_Nil<T_O>(),_Nil<Cons_O>(),dataDimension,0,false);
	vo->_Symbols.resize(symbolsDimension,_Nil<Symbol_O>());
	return vo;
    }


    void LoadTimeValues_O::exposeCando(::core::Lisp_sp lisp)
    {
	::core::class_<LoadTimeValues_O>()
	    .def("data_vectorPushExtend",&LoadTimeValues_O::data_vectorPushExtend)
	    .def("symbols_vectorPushExtend",&LoadTimeValues_O::symbols_vectorPushExtend)
	    ;
	Defun_maker(CorePkg,LoadTimeValues);
	SYMBOL_SC_(CorePkg,loadTimeValuesDump);
	Defun(loadTimeValuesDump);
	SYMBOL_SC_(CorePkg,loadTimeValuesIds);
	Defun(loadTimeValuesIds);
	SYMBOL_SC_(CorePkg,loadTimeValueArray);
	Defun(loadTimeValueArray);

	SYMBOL_SC_(CorePkg,lookupLoadTimeValue);
	Defun(lookupLoadTimeValue);
	SYMBOL_SC_(CorePkg,lookupLoadTimeSymbol);
	Defun(lookupLoadTimeSymbol);
	SYMBOL_EXPORT_SC_(CorePkg,setRunTimeValuesVector);
	ClDefun(setRunTimeValuesVector);
    }

    void LoadTimeValues_O::exposePython(::core::Lisp_sp lisp)
    {
#ifdef USEBOOSTPYTHON
	PYTHON_CLASS(Pkg(),LoadTimeValues,"","",_LISP)
//	.initArgs("(self)")
	    ;
#endif
    }



    void LoadTimeValues_O::dump()
    {_G();
	printf("LTV size %d  LTS size %lu\n", af_length(this->_Objects), this->_Symbols.size() );
	for (int i=0,iEnd(af_length(this->_Objects)); i<iEnd; i++ )
	{
            T_sp& obj = (*this->_Objects)[i];
	    printf("LTV[%4d]@%p --> %s(base@%p)\n", i, (void*)(&this->_Objects->operator[](i)), _rep_(obj).c_str(), obj.pointerp() ? gctools::tagged_base_ptr::toBasePtr(obj.px_ref()) : NULL );
	}
	int ic=0;
	for ( auto it=this->_Symbols.begin();
	      it!=this->_Symbols.end(); it++, ic++ )
	{
	    printf("LTV-symbol[%4d] --> %s\n", ic, _rep_((*it)).c_str() );
	}
    }



    void LoadTimeValues_O::data_setFillPointer(uint i)
    {_G();
	ASSERT(this->_Objects.pointerp());
	this->_Objects->setf_fillPointer(i);
    }


    T_sp& LoadTimeValues_O::data_element(uint i)
    {
	ASSERT(this->_Objects.pointerp());
	return this->_Objects->operator[](i);
    }

    int LoadTimeValues_O::data_vectorPushExtend(T_sp val, int extension)
    {
	ASSERT(this->_Objects.pointerp());
	return this->_Objects->vectorPushExtend(val,extension)->get();
    }




    void LoadTimeValues_O::symbols_setFillPointer(uint i)
    {_G();
	ASSERT(i==0);
	this->_Symbols.resize(i);
    }


    Symbol_sp& LoadTimeValues_O::symbols_element(uint i)
    {
	return this->_Symbols[i];
    }

    int LoadTimeValues_O::symbols_vectorPushExtend(Symbol_sp val, int extension)
    {
	int i = this->_Symbols.size();
	this->_Symbols.push_back(val);
	return i;
    }



    EXPOSE_CLASS(core,MemoryLockedLoadTimeValuesPointer_O);

    void MemoryLockedLoadTimeValuesPointer_O::exposeCando(::core::Lisp_sp lisp)
    {
	::core::class_<MemoryLockedLoadTimeValuesPointer_O>()
	    ;
    }

    void MemoryLockedLoadTimeValuesPointer_O::exposePython(::core::Lisp_sp lisp)
    {
#ifdef USEBOOSTPYTHON
	PYTHON_CLASS(Pkg(),MemoryLockedLoadTimeValuesPointer,"","",_LISP)
//	.initArgs("(self)")
	    ;
#endif
    }




    
}; /* core */
