_AnchorRestraint_debugEvalSerialize.cc:2:	node[01;31m-[00m>attributeIfNotDefault("evalx1", this[01;31m-[00m>eval.x1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:3: 	node[01;31m-[00m>attributeIfNotDefault("evaly1", this[01;31m-[00m>eval.y1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:4: 	node[01;31m-[00m>attributeIfNotDefault("evalz1", this[01;31m-[00m>eval.z1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:5: 	node[01;31m-[00m>attributeIfNotDefault("evalxa", this[01;31m-[00m>eval.xa, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:6: 	node[01;31m-[00m>attributeIfNotDefault("evalya", this[01;31m-[00m>eval.ya, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:7: 	node[01;31m-[00m>attributeIfNotDefault("evalza", this[01;31m-[00m>eval.za, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:8: 	node[01;31m-[00m>attributeIfNotDefault("evalka", this[01;31m-[00m>eval.ka, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:9: 	node[01;31m-[00m>attributeIfNotDefault("evalEnergy", this[01;31m-[00m>eval.Energy, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:10: 	node[01;31m-[00m>attributeIfNotDefault("evalfx1", this[01;31m-[00m>eval.fx1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:11: 	node[01;31m-[00m>attributeIfNotDefault("evalfy1", this[01;31m-[00m>eval.fy1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:12: 	node[01;31m-[00m>attributeIfNotDefault("evalfz1", this[01;31m-[00m>eval.fz1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:13: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx1x1", this[01;31m-[00m>eval.dhx1x1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:14: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy1y1", this[01;31m-[00m>eval.dhy1y1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:15: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz1z1", this[01;31m-[00m>eval.dhz1z1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:16: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y1", this[01;31m-[00m>eval.ohx1y1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:17: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z1", this[01;31m-[00m>eval.ohx1z1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:18: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z1", this[01;31m-[00m>eval.ohy1z1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:19: 	node[01;31m-[00m>attributeIfNotDefault("evalAnchorDeviation", this[01;31m-[00m>eval.AnchorDeviation, 0.0 );
_AnchorRestraint_debugEvalXml.cc:2:	xml[01;31m-[00m>addAttributeDoubleScientific ("x1", this[01;31m-[00m>eval.x1);
_AnchorRestraint_debugEvalXml.cc:3: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y1", this[01;31m-[00m>eval.y1);
_AnchorRestraint_debugEvalXml.cc:4: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z1", this[01;31m-[00m>eval.z1);
_AnchorRestraint_debugEvalXml.cc:5: 	xml[01;31m-[00m>addAttributeDoubleScientific ("xa", this[01;31m-[00m>eval.xa);
_AnchorRestraint_debugEvalXml.cc:6: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ya", this[01;31m-[00m>eval.ya);
_AnchorRestraint_debugEvalXml.cc:7: 	xml[01;31m-[00m>addAttributeDoubleScientific ("za", this[01;31m-[00m>eval.za);
_AnchorRestraint_debugEvalXml.cc:8: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ka", this[01;31m-[00m>eval.ka);
_AnchorRestraint_debugEvalXml.cc:9: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Energy", this[01;31m-[00m>eval.Energy);
_AnchorRestraint_debugEvalXml.cc:10: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx1", this[01;31m-[00m>eval.fx1);
_AnchorRestraint_debugEvalXml.cc:11: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy1", this[01;31m-[00m>eval.fy1);
_AnchorRestraint_debugEvalXml.cc:12: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz1", this[01;31m-[00m>eval.fz1);
_AnchorRestraint_debugEvalXml.cc:13: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx1x1", this[01;31m-[00m>eval.dhx1x1);
_AnchorRestraint_debugEvalXml.cc:14: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy1y1", this[01;31m-[00m>eval.dhy1y1);
_AnchorRestraint_debugEvalXml.cc:15: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz1z1", this[01;31m-[00m>eval.dhz1z1);
_AnchorRestraint_debugEvalXml.cc:16: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y1", this[01;31m-[00m>eval.ohx1y1);
_AnchorRestraint_debugEvalXml.cc:17: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z1", this[01;31m-[00m>eval.ohx1z1);
_AnchorRestraint_debugEvalXml.cc:18: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z1", this[01;31m-[00m>eval.ohy1z1);
_AnchorRestraint_debugEvalXml.cc:19: 	xml[01;31m-[00m>addAttributeDoubleScientific ("AnchorDeviation", this[01;31m-[00m>eval.AnchorDeviation);
_AnchorRestraint_debugFiniteDifference.cc:3:([01;31m-[00mdelta2 + x1, y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:8:(x1, [01;31m-[00mdelta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:13:(x1, y1, [01;31m-[00mdelta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:18:([01;31m-[00mdelta2 + x1, y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:25:([01;31m-[00mdelta2 + x1, [01;31m-[00mdelta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:26:(delta2 + x1, [01;31m-[00mdelta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:27:([01;31m-[00mdelta2 + x1, delta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:33:([01;31m-[00mdelta2 + x1, y1, [01;31m-[00mdelta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:34:(delta2 + x1, y1, [01;31m-[00mdelta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:35:([01;31m-[00mdelta2 + x1, y1, delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:40:(x1, [01;31m-[00mdelta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:47:(x1, [01;31m-[00mdelta2 + y1, [01;31m-[00mdelta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:48:(x1, delta2 + y1, [01;31m-[00mdelta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:49:(x1, [01;31m-[00mdelta2 + y1, delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:54:(x1, y1, [01;31m-[00mdelta2 + z1, xa, ya, za, ka),
_AnchorRestraint_termCode.cc:1:// C[01;31m-[00mcode
_AnchorRestraint_termCode.cc:10:	 tx1 = [01;31m-[00mxa; 		/* rule 9 */
_AnchorRestraint_termCode.cc:11:	 tx2 = [01;31m-[00mya; 		/* rule 10 */
_AnchorRestraint_termCode.cc:12:	 tx3 = [01;31m-[00mza; 		/* rule 11 */
_AnchorRestraint_termCode.cc:25:	 fx1 = [01;31m-[00mgx1; 		/* rule 24 */
_AnchorRestraint_termCode.cc:28:	 fy1 = [01;31m-[00mgy1; 		/* rule 27 */
_AnchorRestraint_termCode.cc:31:	 fz1 = [01;31m-[00mgz1; 		/* rule 30 */
_Angle_debugEvalSerialize.cc:2:	node[01;31m-[00m>attributeIfNotDefault("evalx1", this[01;31m-[00m>eval.x1, 0.0 );
_Angle_debugEvalSerialize.cc:3: 	node[01;31m-[00m>attributeIfNotDefault("evaly1", this[01;31m-[00m>eval.y1, 0.0 );
_Angle_debugEvalSerialize.cc:4: 	node[01;31m-[00m>attributeIfNotDefault("evalz1", this[01;31m-[00m>eval.z1, 0.0 );
_Angle_debugEvalSerialize.cc:5: 	node[01;31m-[00m>attributeIfNotDefault("evalx2", this[01;31m-[00m>eval.x2, 0.0 );
_Angle_debugEvalSerialize.cc:6: 	node[01;31m-[00m>attributeIfNotDefault("evaly2", this[01;31m-[00m>eval.y2, 0.0 );
_Angle_debugEvalSerialize.cc:7: 	node[01;31m-[00m>attributeIfNotDefault("evalz2", this[01;31m-[00m>eval.z2, 0.0 );
_Angle_debugEvalSerialize.cc:8: 	node[01;31m-[00m>attributeIfNotDefault("evalx3", this[01;31m-[00m>eval.x3, 0.0 );
_Angle_debugEvalSerialize.cc:9: 	node[01;31m-[00m>attributeIfNotDefault("evaly3", this[01;31m-[00m>eval.y3, 0.0 );
_Angle_debugEvalSerialize.cc:10: 	node[01;31m-[00m>attributeIfNotDefault("evalz3", this[01;31m-[00m>eval.z3, 0.0 );
_Angle_debugEvalSerialize.cc:11: 	node[01;31m-[00m>attributeIfNotDefault("evalt0", this[01;31m-[00m>eval.t0, 0.0 );
_Angle_debugEvalSerialize.cc:12: 	node[01;31m-[00m>attributeIfNotDefault("evalkt", this[01;31m-[00m>eval.kt, 0.0 );
_Angle_debugEvalSerialize.cc:13: 	node[01;31m-[00m>attributeIfNotDefault("evalEnergy", this[01;31m-[00m>eval.Energy, 0.0 );
_Angle_debugEvalSerialize.cc:14: 	node[01;31m-[00m>attributeIfNotDefault("evalfx1", this[01;31m-[00m>eval.fx1, 0.0 );
_Angle_debugEvalSerialize.cc:15: 	node[01;31m-[00m>attributeIfNotDefault("evalfy1", this[01;31m-[00m>eval.fy1, 0.0 );
_Angle_debugEvalSerialize.cc:16: 	node[01;31m-[00m>attributeIfNotDefault("evalfz1", this[01;31m-[00m>eval.fz1, 0.0 );
_Angle_debugEvalSerialize.cc:17: 	node[01;31m-[00m>attributeIfNotDefault("evalfx2", this[01;31m-[00m>eval.fx2, 0.0 );
_Angle_debugEvalSerialize.cc:18: 	node[01;31m-[00m>attributeIfNotDefault("evalfy2", this[01;31m-[00m>eval.fy2, 0.0 );
_Angle_debugEvalSerialize.cc:19: 	node[01;31m-[00m>attributeIfNotDefault("evalfz2", this[01;31m-[00m>eval.fz2, 0.0 );
_Angle_debugEvalSerialize.cc:20: 	node[01;31m-[00m>attributeIfNotDefault("evalfx3", this[01;31m-[00m>eval.fx3, 0.0 );
_Angle_debugEvalSerialize.cc:21: 	node[01;31m-[00m>attributeIfNotDefault("evalfy3", this[01;31m-[00m>eval.fy3, 0.0 );
_Angle_debugEvalSerialize.cc:22: 	node[01;31m-[00m>attributeIfNotDefault("evalfz3", this[01;31m-[00m>eval.fz3, 0.0 );
_Angle_debugEvalSerialize.cc:23: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx1x1", this[01;31m-[00m>eval.dhx1x1, 0.0 );
_Angle_debugEvalSerialize.cc:24: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy1y1", this[01;31m-[00m>eval.dhy1y1, 0.0 );
_Angle_debugEvalSerialize.cc:25: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz1z1", this[01;31m-[00m>eval.dhz1z1, 0.0 );
_Angle_debugEvalSerialize.cc:26: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx2x2", this[01;31m-[00m>eval.dhx2x2, 0.0 );
_Angle_debugEvalSerialize.cc:27: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy2y2", this[01;31m-[00m>eval.dhy2y2, 0.0 );
_Angle_debugEvalSerialize.cc:28: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz2z2", this[01;31m-[00m>eval.dhz2z2, 0.0 );
_Angle_debugEvalSerialize.cc:29: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx3x3", this[01;31m-[00m>eval.dhx3x3, 0.0 );
_Angle_debugEvalSerialize.cc:30: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy3y3", this[01;31m-[00m>eval.dhy3y3, 0.0 );
_Angle_debugEvalSerialize.cc:31: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz3z3", this[01;31m-[00m>eval.dhz3z3, 0.0 );
_Angle_debugEvalSerialize.cc:32: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y1", this[01;31m-[00m>eval.ohx1y1, 0.0 );
_Angle_debugEvalSerialize.cc:33: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z1", this[01;31m-[00m>eval.ohx1z1, 0.0 );
_Angle_debugEvalSerialize.cc:34: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x2", this[01;31m-[00m>eval.ohx1x2, 0.0 );
_Angle_debugEvalSerialize.cc:35: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y2", this[01;31m-[00m>eval.ohx1y2, 0.0 );
_Angle_debugEvalSerialize.cc:36: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z2", this[01;31m-[00m>eval.ohx1z2, 0.0 );
_Angle_debugEvalSerialize.cc:37: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x3", this[01;31m-[00m>eval.ohx1x3, 0.0 );
_Angle_debugEvalSerialize.cc:38: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y3", this[01;31m-[00m>eval.ohx1y3, 0.0 );
_Angle_debugEvalSerialize.cc:39: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z3", this[01;31m-[00m>eval.ohx1z3, 0.0 );
_Angle_debugEvalSerialize.cc:40: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z1", this[01;31m-[00m>eval.ohy1z1, 0.0 );
_Angle_debugEvalSerialize.cc:41: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x2", this[01;31m-[00m>eval.ohy1x2, 0.0 );
_Angle_debugEvalSerialize.cc:42: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y2", this[01;31m-[00m>eval.ohy1y2, 0.0 );
_Angle_debugEvalSerialize.cc:43: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z2", this[01;31m-[00m>eval.ohy1z2, 0.0 );
_Angle_debugEvalSerialize.cc:44: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x3", this[01;31m-[00m>eval.ohy1x3, 0.0 );
_Angle_debugEvalSerialize.cc:45: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y3", this[01;31m-[00m>eval.ohy1y3, 0.0 );
_Angle_debugEvalSerialize.cc:46: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z3", this[01;31m-[00m>eval.ohy1z3, 0.0 );
_Angle_debugEvalSerialize.cc:47: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x2", this[01;31m-[00m>eval.ohz1x2, 0.0 );
_Angle_debugEvalSerialize.cc:48: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y2", this[01;31m-[00m>eval.ohz1y2, 0.0 );
_Angle_debugEvalSerialize.cc:49: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z2", this[01;31m-[00m>eval.ohz1z2, 0.0 );
_Angle_debugEvalSerialize.cc:50: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x3", this[01;31m-[00m>eval.ohz1x3, 0.0 );
_Angle_debugEvalSerialize.cc:51: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y3", this[01;31m-[00m>eval.ohz1y3, 0.0 );
_Angle_debugEvalSerialize.cc:52: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z3", this[01;31m-[00m>eval.ohz1z3, 0.0 );
_Angle_debugEvalSerialize.cc:53: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y2", this[01;31m-[00m>eval.ohx2y2, 0.0 );
_Angle_debugEvalSerialize.cc:54: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z2", this[01;31m-[00m>eval.ohx2z2, 0.0 );
_Angle_debugEvalSerialize.cc:55: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2x3", this[01;31m-[00m>eval.ohx2x3, 0.0 );
_Angle_debugEvalSerialize.cc:56: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y3", this[01;31m-[00m>eval.ohx2y3, 0.0 );
_Angle_debugEvalSerialize.cc:57: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z3", this[01;31m-[00m>eval.ohx2z3, 0.0 );
_Angle_debugEvalSerialize.cc:58: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z2", this[01;31m-[00m>eval.ohy2z2, 0.0 );
_Angle_debugEvalSerialize.cc:59: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2x3", this[01;31m-[00m>eval.ohy2x3, 0.0 );
_Angle_debugEvalSerialize.cc:60: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2y3", this[01;31m-[00m>eval.ohy2y3, 0.0 );
_Angle_debugEvalSerialize.cc:61: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z3", this[01;31m-[00m>eval.ohy2z3, 0.0 );
_Angle_debugEvalSerialize.cc:62: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2x3", this[01;31m-[00m>eval.ohz2x3, 0.0 );
_Angle_debugEvalSerialize.cc:63: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2y3", this[01;31m-[00m>eval.ohz2y3, 0.0 );
_Angle_debugEvalSerialize.cc:64: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2z3", this[01;31m-[00m>eval.ohz2z3, 0.0 );
_Angle_debugEvalSerialize.cc:65: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3y3", this[01;31m-[00m>eval.ohx3y3, 0.0 );
_Angle_debugEvalSerialize.cc:66: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3z3", this[01;31m-[00m>eval.ohx3z3, 0.0 );
_Angle_debugEvalSerialize.cc:67: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3z3", this[01;31m-[00m>eval.ohy3z3, 0.0 );
_Angle_debugEvalSerialize.cc:68: 	node[01;31m-[00m>attributeIfNotDefault("evalAngleDeviation", this[01;31m-[00m>eval.AngleDeviation, 0.0 );
_Angle_debugEvalXml.cc:2:	xml[01;31m-[00m>addAttributeDoubleScientific ("x1", this[01;31m-[00m>eval.x1);
_Angle_debugEvalXml.cc:3: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y1", this[01;31m-[00m>eval.y1);
_Angle_debugEvalXml.cc:4: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z1", this[01;31m-[00m>eval.z1);
_Angle_debugEvalXml.cc:5: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x2", this[01;31m-[00m>eval.x2);
_Angle_debugEvalXml.cc:6: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y2", this[01;31m-[00m>eval.y2);
_Angle_debugEvalXml.cc:7: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z2", this[01;31m-[00m>eval.z2);
_Angle_debugEvalXml.cc:8: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x3", this[01;31m-[00m>eval.x3);
_Angle_debugEvalXml.cc:9: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y3", this[01;31m-[00m>eval.y3);
_Angle_debugEvalXml.cc:10: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z3", this[01;31m-[00m>eval.z3);
_Angle_debugEvalXml.cc:11: 	xml[01;31m-[00m>addAttributeDoubleScientific ("t0", this[01;31m-[00m>eval.t0);
_Angle_debugEvalXml.cc:12: 	xml[01;31m-[00m>addAttributeDoubleScientific ("kt", this[01;31m-[00m>eval.kt);
_Angle_debugEvalXml.cc:13: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Energy", this[01;31m-[00m>eval.Energy);
_Angle_debugEvalXml.cc:14: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx1", this[01;31m-[00m>eval.fx1);
_Angle_debugEvalXml.cc:15: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy1", this[01;31m-[00m>eval.fy1);
_Angle_debugEvalXml.cc:16: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz1", this[01;31m-[00m>eval.fz1);
_Angle_debugEvalXml.cc:17: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx2", this[01;31m-[00m>eval.fx2);
_Angle_debugEvalXml.cc:18: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy2", this[01;31m-[00m>eval.fy2);
_Angle_debugEvalXml.cc:19: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz2", this[01;31m-[00m>eval.fz2);
_Angle_debugEvalXml.cc:20: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx3", this[01;31m-[00m>eval.fx3);
_Angle_debugEvalXml.cc:21: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy3", this[01;31m-[00m>eval.fy3);
_Angle_debugEvalXml.cc:22: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz3", this[01;31m-[00m>eval.fz3);
_Angle_debugEvalXml.cc:23: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx1x1", this[01;31m-[00m>eval.dhx1x1);
_Angle_debugEvalXml.cc:24: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy1y1", this[01;31m-[00m>eval.dhy1y1);
_Angle_debugEvalXml.cc:25: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz1z1", this[01;31m-[00m>eval.dhz1z1);
_Angle_debugEvalXml.cc:26: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx2x2", this[01;31m-[00m>eval.dhx2x2);
_Angle_debugEvalXml.cc:27: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy2y2", this[01;31m-[00m>eval.dhy2y2);
_Angle_debugEvalXml.cc:28: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz2z2", this[01;31m-[00m>eval.dhz2z2);
_Angle_debugEvalXml.cc:29: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx3x3", this[01;31m-[00m>eval.dhx3x3);
_Angle_debugEvalXml.cc:30: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy3y3", this[01;31m-[00m>eval.dhy3y3);
_Angle_debugEvalXml.cc:31: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz3z3", this[01;31m-[00m>eval.dhz3z3);
_Angle_debugEvalXml.cc:32: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y1", this[01;31m-[00m>eval.ohx1y1);
_Angle_debugEvalXml.cc:33: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z1", this[01;31m-[00m>eval.ohx1z1);
_Angle_debugEvalXml.cc:34: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x2", this[01;31m-[00m>eval.ohx1x2);
_Angle_debugEvalXml.cc:35: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y2", this[01;31m-[00m>eval.ohx1y2);
_Angle_debugEvalXml.cc:36: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z2", this[01;31m-[00m>eval.ohx1z2);
_Angle_debugEvalXml.cc:37: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x3", this[01;31m-[00m>eval.ohx1x3);
_Angle_debugEvalXml.cc:38: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y3", this[01;31m-[00m>eval.ohx1y3);
_Angle_debugEvalXml.cc:39: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z3", this[01;31m-[00m>eval.ohx1z3);
_Angle_debugEvalXml.cc:40: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z1", this[01;31m-[00m>eval.ohy1z1);
_Angle_debugEvalXml.cc:41: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x2", this[01;31m-[00m>eval.ohy1x2);
_Angle_debugEvalXml.cc:42: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y2", this[01;31m-[00m>eval.ohy1y2);
_Angle_debugEvalXml.cc:43: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z2", this[01;31m-[00m>eval.ohy1z2);
_Angle_debugEvalXml.cc:44: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x3", this[01;31m-[00m>eval.ohy1x3);
_Angle_debugEvalXml.cc:45: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y3", this[01;31m-[00m>eval.ohy1y3);
_Angle_debugEvalXml.cc:46: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z3", this[01;31m-[00m>eval.ohy1z3);
_Angle_debugEvalXml.cc:47: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x2", this[01;31m-[00m>eval.ohz1x2);
_Angle_debugEvalXml.cc:48: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y2", this[01;31m-[00m>eval.ohz1y2);
_Angle_debugEvalXml.cc:49: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z2", this[01;31m-[00m>eval.ohz1z2);
_Angle_debugEvalXml.cc:50: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x3", this[01;31m-[00m>eval.ohz1x3);
_Angle_debugEvalXml.cc:51: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y3", this[01;31m-[00m>eval.ohz1y3);
_Angle_debugEvalXml.cc:52: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z3", this[01;31m-[00m>eval.ohz1z3);
_Angle_debugEvalXml.cc:53: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y2", this[01;31m-[00m>eval.ohx2y2);
_Angle_debugEvalXml.cc:54: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z2", this[01;31m-[00m>eval.ohx2z2);
_Angle_debugEvalXml.cc:55: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2x3", this[01;31m-[00m>eval.ohx2x3);
_Angle_debugEvalXml.cc:56: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y3", this[01;31m-[00m>eval.ohx2y3);
_Angle_debugEvalXml.cc:57: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z3", this[01;31m-[00m>eval.ohx2z3);
_Angle_debugEvalXml.cc:58: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z2", this[01;31m-[00m>eval.ohy2z2);
_Angle_debugEvalXml.cc:59: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2x3", this[01;31m-[00m>eval.ohy2x3);
_Angle_debugEvalXml.cc:60: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2y3", this[01;31m-[00m>eval.ohy2y3);
_Angle_debugEvalXml.cc:61: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z3", this[01;31m-[00m>eval.ohy2z3);
_Angle_debugEvalXml.cc:62: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2x3", this[01;31m-[00m>eval.ohz2x3);
_Angle_debugEvalXml.cc:63: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2y3", this[01;31m-[00m>eval.ohz2y3);
_Angle_debugEvalXml.cc:64: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2z3", this[01;31m-[00m>eval.ohz2z3);
_Angle_debugEvalXml.cc:65: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3y3", this[01;31m-[00m>eval.ohx3y3);
_Angle_debugEvalXml.cc:66: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3z3", this[01;31m-[00m>eval.ohx3z3);
_Angle_debugEvalXml.cc:67: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3z3", this[01;31m-[00m>eval.ohy3z3);
_Angle_debugEvalXml.cc:68: 	xml[01;31m-[00m>addAttributeDoubleScientific ("AngleDeviation", this[01;31m-[00m>eval.AngleDeviation);
_Angle_debugFiniteDifference.cc:3:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:8:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:13:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:18:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:23:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:33:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:38:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:43:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:48:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:55:([01;31m-[00mdelta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:56:(delta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:57:([01;31m-[00mdelta2 + x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:63:([01;31m-[00mdelta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:64:(delta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:65:([01;31m-[00mdelta2 + x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:71:([01;31m-[00mdelta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:72:(delta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:73:([01;31m-[00mdelta2 + x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:79:([01;31m-[00mdelta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:80:(delta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:81:([01;31m-[00mdelta2 + x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:87:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:88:(delta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:89:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:95:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:96:(delta2 + x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:97:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:103:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:104:(delta2 + x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:105:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:111:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:112:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:113:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:118:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:125:(x1, [01;31m-[00mdelta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:126:(x1, delta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:127:(x1, [01;31m-[00mdelta2 + y1, delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:133:(x1, [01;31m-[00mdelta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:134:(x1, delta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:135:(x1, [01;31m-[00mdelta2 + y1, z1, delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:141:(x1, [01;31m-[00mdelta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:142:(x1, delta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:143:(x1, [01;31m-[00mdelta2 + y1, z1, x2, delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:149:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:150:(x1, delta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:151:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:157:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:158:(x1, delta2 + y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:159:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:165:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:166:(x1, delta2 + y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:167:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:173:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:174:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:175:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:180:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:187:(x1, y1, [01;31m-[00mdelta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:188:(x1, y1, delta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:189:(x1, y1, [01;31m-[00mdelta2 + z1, delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:195:(x1, y1, [01;31m-[00mdelta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:196:(x1, y1, delta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:197:(x1, y1, [01;31m-[00mdelta2 + z1, x2, delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:203:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:204:(x1, y1, delta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:205:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:211:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:212:(x1, y1, delta2 + z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:213:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:219:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:220:(x1, y1, delta2 + z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:221:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:227:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:228:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:229:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:234:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:241:(x1, y1, z1, [01;31m-[00mdelta2 + x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:242:(x1, y1, z1, delta2 + x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:243:(x1, y1, z1, [01;31m-[00mdelta2 + x2, delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:249:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:250:(x1, y1, z1, delta2 + x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:251:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:257:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:258:(x1, y1, z1, delta2 + x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:259:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:265:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:266:(x1, y1, z1, delta2 + x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:267:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:273:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:274:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:275:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:280:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:287:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:288:(x1, y1, z1, x2, delta2 + y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:289:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:295:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:296:(x1, y1, z1, x2, delta2 + y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:297:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:303:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:304:(x1, y1, z1, x2, delta2 + y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:305:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:311:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:312:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:313:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:318:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:325:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:326:(x1, y1, z1, x2, y2, delta2 + z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:327:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:333:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:334:(x1, y1, z1, x2, y2, delta2 + z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:335:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:341:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:342:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:343:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:348:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:355:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:356:(x1, y1, z1, x2, y2, z2, delta2 + x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:357:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:363:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:364:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:365:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:370:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:377:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:378:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:379:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:384:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, t0, kt),
_Angle_termCode.cc:1:// C[01;31m-[00mcode
_Angle_termCode.cc:16:	 tx1 = [01;31m-[00mx2; 		/* rule 15 */
_Angle_termCode.cc:17:	 tx2 = [01;31m-[00my2; 		/* rule 16 */
_Angle_termCode.cc:18:	 tx3 = [01;31m-[00mz2; 		/* rule 17 */
_Angle_termCode.cc:43:	 tx24 = [01;31m-[00mt0; 		/* rule 42 */
_Angle_termCode.cc:47:	if(fabs(DotNormAbNormCb)>(1.0[01;31m-[00mVERYSMALL)) IllegalAngle=true;
_Angle_termCode.cc:58:	 tx31 = [01;31m-[00m(tx458*tzz498); 		/* rule 57 */
_Angle_termCode.cc:61:	 tzz474 = [01;31m-[00mtzz467; 		/* rule 60 */
_Angle_termCode.cc:71:	 tzz469 = [01;31m-[00m2.*tzz468; 		/* rule 70 */
_Angle_termCode.cc:73:	 fx1 = [01;31m-[00mgx1; 		/* rule 72 */
_Angle_termCode.cc:80:	 fy1 = [01;31m-[00mgy1; 		/* rule 79 */
_Angle_termCode.cc:87:	 fz1 = [01;31m-[00mgz1; 		/* rule 86 */
_Angle_termCode.cc:89:	 tx43 = [01;31m-[00mx1; 		/* rule 88 */
_Angle_termCode.cc:91:	 tx45 = [01;31m-[00mx3; 		/* rule 90 */
_Angle_termCode.cc:102:	 fx2 = [01;31m-[00mgx2; 		/* rule 101 */
_Angle_termCode.cc:104:	 tx52 = [01;31m-[00my1; 		/* rule 103 */
_Angle_termCode.cc:106:	 tx54 = [01;31m-[00my3; 		/* rule 105 */
_Angle_termCode.cc:115:	 fy2 = [01;31m-[00mgy2; 		/* rule 114 */
_Angle_termCode.cc:117:	 tx60 = [01;31m-[00mz1; 		/* rule 116 */
_Angle_termCode.cc:119:	 tx62 = [01;31m-[00mz3; 		/* rule 118 */
_Angle_termCode.cc:128:	 fz2 = [01;31m-[00mgz2; 		/* rule 127 */
_Angle_termCode.cc:131:	 tx69 = [01;31m-[00mtx50; 		/* rule 130 */
_Angle_termCode.cc:134:	 fx3 = [01;31m-[00mgx3; 		/* rule 133 */
_Angle_termCode.cc:136:	 tx71 = [01;31m-[00mtx58; 		/* rule 135 */
_Angle_termCode.cc:140:	 fy3 = [01;31m-[00mgy3; 		/* rule 139 */
_Angle_termCode.cc:142:	 tx74 = [01;31m-[00mtx66; 		/* rule 141 */
_Angle_termCode.cc:146:	 fz3 = [01;31m-[00mgz3; 		/* rule 145 */
_Angle_termCode.cc:154:	 tzz521 = [01;31m-[00m2.*tzz467; 		/* rule 153 */
_Angle_termCode.cc:157:	 tzz481 = [01;31m-[00m2.*tx458; 		/* rule 156 */
_Angle_termCode.cc:217:	 tx116 = [01;31m-[00m(tx23*tzz473); 		/* rule 216 */
_Angle_termCode.cc:225:	 tzz519 = [01;31m-[00m2.*tzz504; 		/* rule 224 */
_Angle_termCode.cc:276:	 tzz520 = [01;31m-[00m2.*tzz473; 		/* rule 275 */
_Angle_termCode.cc:335:	 tx196 = [01;31m-[00mtx226; 		/* rule 334 */
_Angle_termCode.cc:339:	 tzz487 = [01;31m-[00mtzz476; 		/* rule 338 */
_Angle_termCode.cc:342:	 tzz508 = [01;31m-[00m3*tzz478; 		/* rule 341 */
_Angle_termCode.cc:381:	 tx225 = [01;31m-[00mtx199; 		/* rule 380 */
_Angle_termCode.cc:391:	 tx233 = [01;31m-[00mtx210; 		/* rule 390 */
_Angle_termCode.cc:402:	 tx240 = [01;31m-[00mtx220; 		/* rule 401 */
_Angle_termCode.cc:463:	 tx284 = [01;31m-[00mtx262; 		/* rule 462 */
_Angle_termCode.cc:472:	 tx291 = [01;31m-[00mtx274; 		/* rule 471 */
_Angle_termCode.cc:528:	 tx332 = [01;31m-[00mtx313; 		/* rule 527 */
_Angle_termCode.cc:560:	 tzz507 = [01;31m-[00m3*tzz480; 		/* rule 559 */
_Angle_termCode.cc:565:	 tx360 = [01;31m-[00mtzz535; 		/* rule 564 */
_Angle_termCode.cc:573:	 tx365 = [01;31m-[00mtx341; 		/* rule 572 */
_Angle_termCode.cc:584:	 tx373 = [01;31m-[00mtx350; 		/* rule 583 */
_Angle_termCode.cc:607:	 tx390 = [01;31m-[00mtx339; 		/* rule 606 */
_Angle_termCode.cc:618:	 tx399 = [01;31m-[00mtzz532; 		/* rule 617 */
_Angle_termCode.cc:625:	 tx404 = [01;31m-[00mtx384; 		/* rule 624 */
_Angle_termCode.cc:636:	 tx412 = [01;31m-[00mtx348; 		/* rule 635 */
_Angle_termCode.cc:644:	 tx418 = [01;31m-[00mtx382; 		/* rule 643 */
_Angle_termCode.cc:655:	 tx427 = [01;31m-[00mtzz531; 		/* rule 654 */
_Angle_termCode.cc:662:	 tx432 = [01;31m-[00mtx367; 		/* rule 661 */
_Angle_termCode.cc:663:	 tx433 = [01;31m-[00mtx391; 		/* rule 662 */
_Angle_termCode.cc:670:	 tx438 = [01;31m-[00mtx375; 		/* rule 669 */
_Angle_termCode.cc:671:	 tx439 = [01;31m-[00mtx413; 		/* rule 670 */
_Angle_termCode.cc:678:	 tx444 = [01;31m-[00mtx406; 		/* rule 677 */
_Angle_termCode.cc:679:	 tx445 = [01;31m-[00mtx419; 		/* rule 678 */
_ChiralRestraint_debugEvalSerialize.cc:2:	node[01;31m-[00m>attributeIfNotDefault("evalx1", this[01;31m-[00m>eval.x1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:3: 	node[01;31m-[00m>attributeIfNotDefault("evaly1", this[01;31m-[00m>eval.y1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:4: 	node[01;31m-[00m>attributeIfNotDefault("evalz1", this[01;31m-[00m>eval.z1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:5: 	node[01;31m-[00m>attributeIfNotDefault("evalx2", this[01;31m-[00m>eval.x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:6: 	node[01;31m-[00m>attributeIfNotDefault("evaly2", this[01;31m-[00m>eval.y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:7: 	node[01;31m-[00m>attributeIfNotDefault("evalz2", this[01;31m-[00m>eval.z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:8: 	node[01;31m-[00m>attributeIfNotDefault("evalx3", this[01;31m-[00m>eval.x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:9: 	node[01;31m-[00m>attributeIfNotDefault("evaly3", this[01;31m-[00m>eval.y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:10: 	node[01;31m-[00m>attributeIfNotDefault("evalz3", this[01;31m-[00m>eval.z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:11: 	node[01;31m-[00m>attributeIfNotDefault("evalx4", this[01;31m-[00m>eval.x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:12: 	node[01;31m-[00m>attributeIfNotDefault("evaly4", this[01;31m-[00m>eval.y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:13: 	node[01;31m-[00m>attributeIfNotDefault("evalz4", this[01;31m-[00m>eval.z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:14: 	node[01;31m-[00m>attributeIfNotDefault("evalK", this[01;31m-[00m>eval.K, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:15: 	node[01;31m-[00m>attributeIfNotDefault("evalCO", this[01;31m-[00m>eval.CO, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:16: 	node[01;31m-[00m>attributeIfNotDefault("evalEnergy", this[01;31m-[00m>eval.Energy, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:17: 	node[01;31m-[00m>attributeIfNotDefault("evalfx1", this[01;31m-[00m>eval.fx1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:18: 	node[01;31m-[00m>attributeIfNotDefault("evalfy1", this[01;31m-[00m>eval.fy1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:19: 	node[01;31m-[00m>attributeIfNotDefault("evalfz1", this[01;31m-[00m>eval.fz1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:20: 	node[01;31m-[00m>attributeIfNotDefault("evalfx2", this[01;31m-[00m>eval.fx2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:21: 	node[01;31m-[00m>attributeIfNotDefault("evalfy2", this[01;31m-[00m>eval.fy2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:22: 	node[01;31m-[00m>attributeIfNotDefault("evalfz2", this[01;31m-[00m>eval.fz2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:23: 	node[01;31m-[00m>attributeIfNotDefault("evalfx3", this[01;31m-[00m>eval.fx3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:24: 	node[01;31m-[00m>attributeIfNotDefault("evalfy3", this[01;31m-[00m>eval.fy3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:25: 	node[01;31m-[00m>attributeIfNotDefault("evalfz3", this[01;31m-[00m>eval.fz3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:26: 	node[01;31m-[00m>attributeIfNotDefault("evalfx4", this[01;31m-[00m>eval.fx4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:27: 	node[01;31m-[00m>attributeIfNotDefault("evalfy4", this[01;31m-[00m>eval.fy4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:28: 	node[01;31m-[00m>attributeIfNotDefault("evalfz4", this[01;31m-[00m>eval.fz4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:29: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx1x1", this[01;31m-[00m>eval.dhx1x1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:30: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy1y1", this[01;31m-[00m>eval.dhy1y1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:31: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz1z1", this[01;31m-[00m>eval.dhz1z1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:32: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx2x2", this[01;31m-[00m>eval.dhx2x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:33: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy2y2", this[01;31m-[00m>eval.dhy2y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:34: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz2z2", this[01;31m-[00m>eval.dhz2z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:35: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx3x3", this[01;31m-[00m>eval.dhx3x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:36: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy3y3", this[01;31m-[00m>eval.dhy3y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:37: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz3z3", this[01;31m-[00m>eval.dhz3z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:38: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx4x4", this[01;31m-[00m>eval.dhx4x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:39: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy4y4", this[01;31m-[00m>eval.dhy4y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:40: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz4z4", this[01;31m-[00m>eval.dhz4z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:41: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y1", this[01;31m-[00m>eval.ohx1y1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:42: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z1", this[01;31m-[00m>eval.ohx1z1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:43: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x2", this[01;31m-[00m>eval.ohx1x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:44: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y2", this[01;31m-[00m>eval.ohx1y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:45: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z2", this[01;31m-[00m>eval.ohx1z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:46: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x3", this[01;31m-[00m>eval.ohx1x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:47: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y3", this[01;31m-[00m>eval.ohx1y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:48: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z3", this[01;31m-[00m>eval.ohx1z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:49: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x4", this[01;31m-[00m>eval.ohx1x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:50: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y4", this[01;31m-[00m>eval.ohx1y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:51: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z4", this[01;31m-[00m>eval.ohx1z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:52: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z1", this[01;31m-[00m>eval.ohy1z1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:53: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x2", this[01;31m-[00m>eval.ohy1x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:54: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y2", this[01;31m-[00m>eval.ohy1y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:55: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z2", this[01;31m-[00m>eval.ohy1z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:56: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x3", this[01;31m-[00m>eval.ohy1x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:57: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y3", this[01;31m-[00m>eval.ohy1y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:58: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z3", this[01;31m-[00m>eval.ohy1z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:59: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x4", this[01;31m-[00m>eval.ohy1x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:60: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y4", this[01;31m-[00m>eval.ohy1y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:61: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z4", this[01;31m-[00m>eval.ohy1z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:62: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x2", this[01;31m-[00m>eval.ohz1x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:63: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y2", this[01;31m-[00m>eval.ohz1y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:64: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z2", this[01;31m-[00m>eval.ohz1z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:65: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x3", this[01;31m-[00m>eval.ohz1x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:66: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y3", this[01;31m-[00m>eval.ohz1y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:67: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z3", this[01;31m-[00m>eval.ohz1z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:68: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x4", this[01;31m-[00m>eval.ohz1x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:69: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y4", this[01;31m-[00m>eval.ohz1y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:70: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z4", this[01;31m-[00m>eval.ohz1z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:71: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y2", this[01;31m-[00m>eval.ohx2y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:72: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z2", this[01;31m-[00m>eval.ohx2z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:73: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2x3", this[01;31m-[00m>eval.ohx2x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:74: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y3", this[01;31m-[00m>eval.ohx2y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:75: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z3", this[01;31m-[00m>eval.ohx2z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:76: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2x4", this[01;31m-[00m>eval.ohx2x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:77: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y4", this[01;31m-[00m>eval.ohx2y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:78: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z4", this[01;31m-[00m>eval.ohx2z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:79: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z2", this[01;31m-[00m>eval.ohy2z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:80: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2x3", this[01;31m-[00m>eval.ohy2x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:81: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2y3", this[01;31m-[00m>eval.ohy2y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:82: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z3", this[01;31m-[00m>eval.ohy2z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:83: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2x4", this[01;31m-[00m>eval.ohy2x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:84: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2y4", this[01;31m-[00m>eval.ohy2y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:85: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z4", this[01;31m-[00m>eval.ohy2z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:86: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2x3", this[01;31m-[00m>eval.ohz2x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:87: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2y3", this[01;31m-[00m>eval.ohz2y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:88: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2z3", this[01;31m-[00m>eval.ohz2z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:89: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2x4", this[01;31m-[00m>eval.ohz2x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:90: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2y4", this[01;31m-[00m>eval.ohz2y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:91: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2z4", this[01;31m-[00m>eval.ohz2z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:92: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3y3", this[01;31m-[00m>eval.ohx3y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:93: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3z3", this[01;31m-[00m>eval.ohx3z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:94: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3x4", this[01;31m-[00m>eval.ohx3x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:95: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3y4", this[01;31m-[00m>eval.ohx3y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:96: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3z4", this[01;31m-[00m>eval.ohx3z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:97: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3z3", this[01;31m-[00m>eval.ohy3z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:98: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3x4", this[01;31m-[00m>eval.ohy3x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:99: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3y4", this[01;31m-[00m>eval.ohy3y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:100: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3z4", this[01;31m-[00m>eval.ohy3z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:101: 	node[01;31m-[00m>attributeIfNotDefault("evalohz3x4", this[01;31m-[00m>eval.ohz3x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:102: 	node[01;31m-[00m>attributeIfNotDefault("evalohz3y4", this[01;31m-[00m>eval.ohz3y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:103: 	node[01;31m-[00m>attributeIfNotDefault("evalohz3z4", this[01;31m-[00m>eval.ohz3z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:104: 	node[01;31m-[00m>attributeIfNotDefault("evalohx4y4", this[01;31m-[00m>eval.ohx4y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:105: 	node[01;31m-[00m>attributeIfNotDefault("evalohx4z4", this[01;31m-[00m>eval.ohx4z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:106: 	node[01;31m-[00m>attributeIfNotDefault("evalohy4z4", this[01;31m-[00m>eval.ohy4z4, 0.0 );
_ChiralRestraint_debugEvalXml.cc:2:	xml[01;31m-[00m>addAttributeDoubleScientific ("x1", this[01;31m-[00m>eval.x1);
_ChiralRestraint_debugEvalXml.cc:3: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y1", this[01;31m-[00m>eval.y1);
_ChiralRestraint_debugEvalXml.cc:4: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z1", this[01;31m-[00m>eval.z1);
_ChiralRestraint_debugEvalXml.cc:5: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x2", this[01;31m-[00m>eval.x2);
_ChiralRestraint_debugEvalXml.cc:6: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y2", this[01;31m-[00m>eval.y2);
_ChiralRestraint_debugEvalXml.cc:7: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z2", this[01;31m-[00m>eval.z2);
_ChiralRestraint_debugEvalXml.cc:8: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x3", this[01;31m-[00m>eval.x3);
_ChiralRestraint_debugEvalXml.cc:9: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y3", this[01;31m-[00m>eval.y3);
_ChiralRestraint_debugEvalXml.cc:10: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z3", this[01;31m-[00m>eval.z3);
_ChiralRestraint_debugEvalXml.cc:11: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x4", this[01;31m-[00m>eval.x4);
_ChiralRestraint_debugEvalXml.cc:12: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y4", this[01;31m-[00m>eval.y4);
_ChiralRestraint_debugEvalXml.cc:13: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z4", this[01;31m-[00m>eval.z4);
_ChiralRestraint_debugEvalXml.cc:14: 	xml[01;31m-[00m>addAttributeDoubleScientific ("K", this[01;31m-[00m>eval.K);
_ChiralRestraint_debugEvalXml.cc:15: 	xml[01;31m-[00m>addAttributeDoubleScientific ("CO", this[01;31m-[00m>eval.CO);
_ChiralRestraint_debugEvalXml.cc:16: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Energy", this[01;31m-[00m>eval.Energy);
_ChiralRestraint_debugEvalXml.cc:17: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx1", this[01;31m-[00m>eval.fx1);
_ChiralRestraint_debugEvalXml.cc:18: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy1", this[01;31m-[00m>eval.fy1);
_ChiralRestraint_debugEvalXml.cc:19: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz1", this[01;31m-[00m>eval.fz1);
_ChiralRestraint_debugEvalXml.cc:20: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx2", this[01;31m-[00m>eval.fx2);
_ChiralRestraint_debugEvalXml.cc:21: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy2", this[01;31m-[00m>eval.fy2);
_ChiralRestraint_debugEvalXml.cc:22: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz2", this[01;31m-[00m>eval.fz2);
_ChiralRestraint_debugEvalXml.cc:23: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx3", this[01;31m-[00m>eval.fx3);
_ChiralRestraint_debugEvalXml.cc:24: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy3", this[01;31m-[00m>eval.fy3);
_ChiralRestraint_debugEvalXml.cc:25: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz3", this[01;31m-[00m>eval.fz3);
_ChiralRestraint_debugEvalXml.cc:26: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx4", this[01;31m-[00m>eval.fx4);
_ChiralRestraint_debugEvalXml.cc:27: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy4", this[01;31m-[00m>eval.fy4);
_ChiralRestraint_debugEvalXml.cc:28: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz4", this[01;31m-[00m>eval.fz4);
_ChiralRestraint_debugEvalXml.cc:29: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx1x1", this[01;31m-[00m>eval.dhx1x1);
_ChiralRestraint_debugEvalXml.cc:30: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy1y1", this[01;31m-[00m>eval.dhy1y1);
_ChiralRestraint_debugEvalXml.cc:31: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz1z1", this[01;31m-[00m>eval.dhz1z1);
_ChiralRestraint_debugEvalXml.cc:32: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx2x2", this[01;31m-[00m>eval.dhx2x2);
_ChiralRestraint_debugEvalXml.cc:33: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy2y2", this[01;31m-[00m>eval.dhy2y2);
_ChiralRestraint_debugEvalXml.cc:34: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz2z2", this[01;31m-[00m>eval.dhz2z2);
_ChiralRestraint_debugEvalXml.cc:35: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx3x3", this[01;31m-[00m>eval.dhx3x3);
_ChiralRestraint_debugEvalXml.cc:36: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy3y3", this[01;31m-[00m>eval.dhy3y3);
_ChiralRestraint_debugEvalXml.cc:37: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz3z3", this[01;31m-[00m>eval.dhz3z3);
_ChiralRestraint_debugEvalXml.cc:38: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx4x4", this[01;31m-[00m>eval.dhx4x4);
_ChiralRestraint_debugEvalXml.cc:39: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy4y4", this[01;31m-[00m>eval.dhy4y4);
_ChiralRestraint_debugEvalXml.cc:40: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz4z4", this[01;31m-[00m>eval.dhz4z4);
_ChiralRestraint_debugEvalXml.cc:41: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y1", this[01;31m-[00m>eval.ohx1y1);
_ChiralRestraint_debugEvalXml.cc:42: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z1", this[01;31m-[00m>eval.ohx1z1);
_ChiralRestraint_debugEvalXml.cc:43: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x2", this[01;31m-[00m>eval.ohx1x2);
_ChiralRestraint_debugEvalXml.cc:44: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y2", this[01;31m-[00m>eval.ohx1y2);
_ChiralRestraint_debugEvalXml.cc:45: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z2", this[01;31m-[00m>eval.ohx1z2);
_ChiralRestraint_debugEvalXml.cc:46: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x3", this[01;31m-[00m>eval.ohx1x3);
_ChiralRestraint_debugEvalXml.cc:47: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y3", this[01;31m-[00m>eval.ohx1y3);
_ChiralRestraint_debugEvalXml.cc:48: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z3", this[01;31m-[00m>eval.ohx1z3);
_ChiralRestraint_debugEvalXml.cc:49: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x4", this[01;31m-[00m>eval.ohx1x4);
_ChiralRestraint_debugEvalXml.cc:50: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y4", this[01;31m-[00m>eval.ohx1y4);
_ChiralRestraint_debugEvalXml.cc:51: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z4", this[01;31m-[00m>eval.ohx1z4);
_ChiralRestraint_debugEvalXml.cc:52: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z1", this[01;31m-[00m>eval.ohy1z1);
_ChiralRestraint_debugEvalXml.cc:53: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x2", this[01;31m-[00m>eval.ohy1x2);
_ChiralRestraint_debugEvalXml.cc:54: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y2", this[01;31m-[00m>eval.ohy1y2);
_ChiralRestraint_debugEvalXml.cc:55: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z2", this[01;31m-[00m>eval.ohy1z2);
_ChiralRestraint_debugEvalXml.cc:56: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x3", this[01;31m-[00m>eval.ohy1x3);
_ChiralRestraint_debugEvalXml.cc:57: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y3", this[01;31m-[00m>eval.ohy1y3);
_ChiralRestraint_debugEvalXml.cc:58: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z3", this[01;31m-[00m>eval.ohy1z3);
_ChiralRestraint_debugEvalXml.cc:59: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x4", this[01;31m-[00m>eval.ohy1x4);
_ChiralRestraint_debugEvalXml.cc:60: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y4", this[01;31m-[00m>eval.ohy1y4);
_ChiralRestraint_debugEvalXml.cc:61: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z4", this[01;31m-[00m>eval.ohy1z4);
_ChiralRestraint_debugEvalXml.cc:62: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x2", this[01;31m-[00m>eval.ohz1x2);
_ChiralRestraint_debugEvalXml.cc:63: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y2", this[01;31m-[00m>eval.ohz1y2);
_ChiralRestraint_debugEvalXml.cc:64: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z2", this[01;31m-[00m>eval.ohz1z2);
_ChiralRestraint_debugEvalXml.cc:65: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x3", this[01;31m-[00m>eval.ohz1x3);
_ChiralRestraint_debugEvalXml.cc:66: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y3", this[01;31m-[00m>eval.ohz1y3);
_ChiralRestraint_debugEvalXml.cc:67: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z3", this[01;31m-[00m>eval.ohz1z3);
_ChiralRestraint_debugEvalXml.cc:68: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x4", this[01;31m-[00m>eval.ohz1x4);
_ChiralRestraint_debugEvalXml.cc:69: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y4", this[01;31m-[00m>eval.ohz1y4);
_ChiralRestraint_debugEvalXml.cc:70: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z4", this[01;31m-[00m>eval.ohz1z4);
_ChiralRestraint_debugEvalXml.cc:71: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y2", this[01;31m-[00m>eval.ohx2y2);
_ChiralRestraint_debugEvalXml.cc:72: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z2", this[01;31m-[00m>eval.ohx2z2);
_ChiralRestraint_debugEvalXml.cc:73: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2x3", this[01;31m-[00m>eval.ohx2x3);
_ChiralRestraint_debugEvalXml.cc:74: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y3", this[01;31m-[00m>eval.ohx2y3);
_ChiralRestraint_debugEvalXml.cc:75: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z3", this[01;31m-[00m>eval.ohx2z3);
_ChiralRestraint_debugEvalXml.cc:76: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2x4", this[01;31m-[00m>eval.ohx2x4);
_ChiralRestraint_debugEvalXml.cc:77: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y4", this[01;31m-[00m>eval.ohx2y4);
_ChiralRestraint_debugEvalXml.cc:78: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z4", this[01;31m-[00m>eval.ohx2z4);
_ChiralRestraint_debugEvalXml.cc:79: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z2", this[01;31m-[00m>eval.ohy2z2);
_ChiralRestraint_debugEvalXml.cc:80: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2x3", this[01;31m-[00m>eval.ohy2x3);
_ChiralRestraint_debugEvalXml.cc:81: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2y3", this[01;31m-[00m>eval.ohy2y3);
_ChiralRestraint_debugEvalXml.cc:82: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z3", this[01;31m-[00m>eval.ohy2z3);
_ChiralRestraint_debugEvalXml.cc:83: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2x4", this[01;31m-[00m>eval.ohy2x4);
_ChiralRestraint_debugEvalXml.cc:84: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2y4", this[01;31m-[00m>eval.ohy2y4);
_ChiralRestraint_debugEvalXml.cc:85: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z4", this[01;31m-[00m>eval.ohy2z4);
_ChiralRestraint_debugEvalXml.cc:86: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2x3", this[01;31m-[00m>eval.ohz2x3);
_ChiralRestraint_debugEvalXml.cc:87: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2y3", this[01;31m-[00m>eval.ohz2y3);
_ChiralRestraint_debugEvalXml.cc:88: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2z3", this[01;31m-[00m>eval.ohz2z3);
_ChiralRestraint_debugEvalXml.cc:89: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2x4", this[01;31m-[00m>eval.ohz2x4);
_ChiralRestraint_debugEvalXml.cc:90: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2y4", this[01;31m-[00m>eval.ohz2y4);
_ChiralRestraint_debugEvalXml.cc:91: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2z4", this[01;31m-[00m>eval.ohz2z4);
_ChiralRestraint_debugEvalXml.cc:92: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3y3", this[01;31m-[00m>eval.ohx3y3);
_ChiralRestraint_debugEvalXml.cc:93: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3z3", this[01;31m-[00m>eval.ohx3z3);
_ChiralRestraint_debugEvalXml.cc:94: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3x4", this[01;31m-[00m>eval.ohx3x4);
_ChiralRestraint_debugEvalXml.cc:95: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3y4", this[01;31m-[00m>eval.ohx3y4);
_ChiralRestraint_debugEvalXml.cc:96: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3z4", this[01;31m-[00m>eval.ohx3z4);
_ChiralRestraint_debugEvalXml.cc:97: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3z3", this[01;31m-[00m>eval.ohy3z3);
_ChiralRestraint_debugEvalXml.cc:98: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3x4", this[01;31m-[00m>eval.ohy3x4);
_ChiralRestraint_debugEvalXml.cc:99: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3y4", this[01;31m-[00m>eval.ohy3y4);
_ChiralRestraint_debugEvalXml.cc:100: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3z4", this[01;31m-[00m>eval.ohy3z4);
_ChiralRestraint_debugEvalXml.cc:101: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz3x4", this[01;31m-[00m>eval.ohz3x4);
_ChiralRestraint_debugEvalXml.cc:102: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz3y4", this[01;31m-[00m>eval.ohz3y4);
_ChiralRestraint_debugEvalXml.cc:103: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz3z4", this[01;31m-[00m>eval.ohz3z4);
_ChiralRestraint_debugEvalXml.cc:104: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx4y4", this[01;31m-[00m>eval.ohx4y4);
_ChiralRestraint_debugEvalXml.cc:105: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx4z4", this[01;31m-[00m>eval.ohx4z4);
_ChiralRestraint_debugEvalXml.cc:106: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy4z4", this[01;31m-[00m>eval.ohy4z4);
_ChiralRestraint_debugFiniteDifference.cc:3:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:8:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:13:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:18:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:23:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:33:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:38:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:43:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:48:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:53:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:58:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:63:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:70:([01;31m-[00mdelta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:71:(delta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:72:([01;31m-[00mdelta2 + x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:78:([01;31m-[00mdelta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:79:(delta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:80:([01;31m-[00mdelta2 + x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:86:([01;31m-[00mdelta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:87:(delta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:88:([01;31m-[00mdelta2 + x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:94:([01;31m-[00mdelta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:95:(delta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:96:([01;31m-[00mdelta2 + x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:102:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:103:(delta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:104:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:110:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:111:(delta2 + x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:112:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:118:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:119:(delta2 + x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:120:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:126:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:127:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:128:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:134:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:135:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:136:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:142:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:143:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:144:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:150:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:151:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:152:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:157:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:164:(x1, [01;31m-[00mdelta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:165:(x1, delta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:166:(x1, [01;31m-[00mdelta2 + y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:172:(x1, [01;31m-[00mdelta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:173:(x1, delta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:174:(x1, [01;31m-[00mdelta2 + y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:180:(x1, [01;31m-[00mdelta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:181:(x1, delta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:182:(x1, [01;31m-[00mdelta2 + y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:188:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:189:(x1, delta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:190:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:196:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:197:(x1, delta2 + y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:198:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:204:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:205:(x1, delta2 + y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:206:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:212:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:213:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:214:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:220:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:221:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:222:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:228:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:229:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:230:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:236:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:237:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:238:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:243:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:250:(x1, y1, [01;31m-[00mdelta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:251:(x1, y1, delta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:252:(x1, y1, [01;31m-[00mdelta2 + z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:258:(x1, y1, [01;31m-[00mdelta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:259:(x1, y1, delta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:260:(x1, y1, [01;31m-[00mdelta2 + z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:266:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:267:(x1, y1, delta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:268:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:274:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:275:(x1, y1, delta2 + z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:276:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:282:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:283:(x1, y1, delta2 + z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:284:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:290:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:291:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:292:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:298:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:299:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:300:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:306:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:307:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:308:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:314:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:315:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:316:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:321:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:328:(x1, y1, z1, [01;31m-[00mdelta2 + x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:329:(x1, y1, z1, delta2 + x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:330:(x1, y1, z1, [01;31m-[00mdelta2 + x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:336:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:337:(x1, y1, z1, delta2 + x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:338:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:344:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:345:(x1, y1, z1, delta2 + x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:346:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:352:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:353:(x1, y1, z1, delta2 + x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:354:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:360:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:361:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:362:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:368:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:369:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:370:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:376:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:377:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:378:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:384:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:385:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:386:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:391:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:398:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:399:(x1, y1, z1, x2, delta2 + y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:400:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:406:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:407:(x1, y1, z1, x2, delta2 + y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:408:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:414:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:415:(x1, y1, z1, x2, delta2 + y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:416:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:422:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:423:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:424:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:430:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:431:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:432:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:438:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:439:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:440:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:446:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:447:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:448:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:453:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:460:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:461:(x1, y1, z1, x2, y2, delta2 + z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:462:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:468:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:469:(x1, y1, z1, x2, y2, delta2 + z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:470:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:476:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:477:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:478:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:484:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:485:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:486:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:492:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:493:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:494:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:500:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:501:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:502:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:507:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:514:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:515:(x1, y1, z1, x2, y2, z2, delta2 + x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:516:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:522:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:523:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:524:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:530:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:531:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:532:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:538:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:539:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:540:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:546:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:547:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:548:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:553:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:560:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:561:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:562:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:568:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:569:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:570:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:576:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:577:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:578:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:584:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:585:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:586:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:591:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:598:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:599:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:600:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:606:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:607:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:608:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:614:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:615:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:616:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:621:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:628:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:629:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:630:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:636:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:637:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:638:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:643:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:650:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:651:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:652:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:657:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, CO),
_ChiralRestraint_termCode.cc:1:// C[01;31m-[00mcode
_ChiralRestraint_termCode.cc:20:	 tx1 = [01;31m-[00mx3; 		/* rule 19 */
_ChiralRestraint_termCode.cc:21:	 tx2 = [01;31m-[00my3; 		/* rule 20 */
_ChiralRestraint_termCode.cc:22:	 tx3 = [01;31m-[00mz3; 		/* rule 21 */
_ChiralRestraint_termCode.cc:29:	 tx10 = [01;31m-[00m(x2*y1); 		/* rule 28 */
_ChiralRestraint_termCode.cc:39:	 tx20 = [01;31m-[00m(y2*z1); 		/* rule 38 */
_ChiralRestraint_termCode.cc:43:	 tx24 = [01;31m-[00m(x1*z2); 		/* rule 42 */
_ChiralRestraint_termCode.cc:87:	 tx56 = [01;31m-[00mz2; 		/* rule 86 */
_ChiralRestraint_termCode.cc:94:	 tx62 = [01;31m-[00m(tx5*tx52*tx60*tx797*tx800); 		/* rule 93 */
_ChiralRestraint_termCode.cc:98:	 fx1 = [01;31m-[00mgx1; 		/* rule 97 */
_ChiralRestraint_termCode.cc:100:	 tx66 = [01;31m-[00mx2; 		/* rule 99 */
_ChiralRestraint_termCode.cc:105:	 tx71 = [01;31m-[00m(tx12*tx52*tx60*tx797*tx800); 		/* rule 104 */
_ChiralRestraint_termCode.cc:109:	 fy1 = [01;31m-[00mgy1; 		/* rule 108 */
_ChiralRestraint_termCode.cc:111:	 tx74 = [01;31m-[00my2; 		/* rule 110 */
_ChiralRestraint_termCode.cc:116:	 tx79 = [01;31m-[00m(tx22*tx52*tx60*tx797*tx800); 		/* rule 115 */
_ChiralRestraint_termCode.cc:120:	 fz1 = [01;31m-[00mgz1; 		/* rule 119 */
_ChiralRestraint_termCode.cc:122:	 tx82 = [01;31m-[00my1; 		/* rule 121 */
_ChiralRestraint_termCode.cc:129:	 tx88 = [01;31m-[00m(tx52*tx7*tx794*tx800*tx86); 		/* rule 128 */
_ChiralRestraint_termCode.cc:133:	 fx2 = [01;31m-[00mgx2; 		/* rule 132 */
_ChiralRestraint_termCode.cc:135:	 tx91 = [01;31m-[00mz1; 		/* rule 134 */
_ChiralRestraint_termCode.cc:140:	 tx96 = [01;31m-[00m(tx15*tx52*tx794*tx800*tx86); 		/* rule 139 */
_ChiralRestraint_termCode.cc:144:	 fy2 = [01;31m-[00mgy2; 		/* rule 143 */
_ChiralRestraint_termCode.cc:146:	 tx99 = [01;31m-[00mx1; 		/* rule 145 */
_ChiralRestraint_termCode.cc:152:	 tx105 = [01;31m-[00m(tx27*tx52*tx794*tx800*tx86); 		/* rule 151 */
_ChiralRestraint_termCode.cc:155:	 fz2 = [01;31m-[00mgz2; 		/* rule 154 */
_ChiralRestraint_termCode.cc:160:	 tx110 = [01;31m-[00mtx26; 		/* rule 159 */
_ChiralRestraint_termCode.cc:176:	 fx3 = [01;31m-[00mgx3; 		/* rule 175 */
_ChiralRestraint_termCode.cc:180:	 tx126 = [01;31m-[00mtx19; 		/* rule 179 */
_ChiralRestraint_termCode.cc:195:	 fy3 = [01;31m-[00mgy3; 		/* rule 194 */
_ChiralRestraint_termCode.cc:199:	 tx142 = [01;31m-[00mtx14; 		/* rule 198 */
_ChiralRestraint_termCode.cc:214:	 fz3 = [01;31m-[00mgz3; 		/* rule 213 */
_ChiralRestraint_termCode.cc:216:	 tx156 = [01;31m-[00mtx121; 		/* rule 215 */
_ChiralRestraint_termCode.cc:220:	 fx4 = [01;31m-[00mgx4; 		/* rule 219 */
_ChiralRestraint_termCode.cc:222:	 tx159 = [01;31m-[00mtx136; 		/* rule 221 */
_ChiralRestraint_termCode.cc:226:	 fy4 = [01;31m-[00mgy4; 		/* rule 225 */
_ChiralRestraint_termCode.cc:228:	 tx162 = [01;31m-[00mtx152; 		/* rule 227 */
_ChiralRestraint_termCode.cc:232:	 fz4 = [01;31m-[00mgz4; 		/* rule 231 */
_ChiralRestraint_termCode.cc:240:	 tx167 = [01;31m-[00m(tx52*tx60*tx797*tx800); 		/* rule 239 */
_ChiralRestraint_termCode.cc:241:	 tx168 = [01;31m-[00m2.*tx5*tx60*tx61*tx797*tx800; 		/* rule 240 */
_ChiralRestraint_termCode.cc:249:	 tx174 = [01;31m-[00m2.*tx12*tx60*tx70*tx797*tx800; 		/* rule 248 */
_ChiralRestraint_termCode.cc:257:	 tx180 = [01;31m-[00m2.*tx22*tx60*tx78*tx797*tx800; 		/* rule 256 */
_ChiralRestraint_termCode.cc:268:	 tx187 = [01;31m-[00m(tx52*tx794*tx800*tx86); 		/* rule 267 */
_ChiralRestraint_termCode.cc:269:	 tx188 = [01;31m-[00m2.*tx7*tx794*tx800*tx86*tx87; 		/* rule 268 */
_ChiralRestraint_termCode.cc:277:	 tx194 = [01;31m-[00m2.*tx15*tx794*tx800*tx86*tx95; 		/* rule 276 */
_ChiralRestraint_termCode.cc:285:	 tx200 = [01;31m-[00m2.*tx103*tx27*tx794*tx800*tx86; 		/* rule 284 */
_ChiralRestraint_termCode.cc:295:	 tx206 = [01;31m-[00m(tx118*tx52*tx794*tx797); 		/* rule 294 */
_ChiralRestraint_termCode.cc:335:	 tx240 = [01;31m-[00m2.*tx118*tx48*tx794*tx797; 		/* rule 334 */
_ChiralRestraint_termCode.cc:342:	 tx245 = [01;31m-[00m2.*tx118*tx45*tx794*tx797; 		/* rule 341 */
_ChiralRestraint_termCode.cc:349:	 tx250 = [01;31m-[00m2.*tx118*tx43*tx794*tx797; 		/* rule 348 */
_ChiralRestraint_termCode.cc:359:	 tx256 = [01;31m-[00m(tx12*tx60*tx61*tx797*tx800); 		/* rule 358 */
_ChiralRestraint_termCode.cc:360:	 tx257 = [01;31m-[00m(tx5*tx60*tx70*tx797*tx800); 		/* rule 359 */
_ChiralRestraint_termCode.cc:367:	 tx262 = [01;31m-[00m(tx22*tx60*tx61*tx797*tx800); 		/* rule 366 */
_ChiralRestraint_termCode.cc:368:	 tx263 = [01;31m-[00m(tx5*tx60*tx78*tx797*tx800); 		/* rule 367 */
_ChiralRestraint_termCode.cc:375:	 tx268 = [01;31m-[00m(tx61*tx7*tx794*tx800*tx86); 		/* rule 374 */
_ChiralRestraint_termCode.cc:376:	 tx269 = [01;31m-[00m(tx5*tx60*tx797*tx800*tx87); 		/* rule 375 */
_ChiralRestraint_termCode.cc:384:	 tx275 = [01;31m-[00m(tx15*tx61*tx794*tx800*tx86); 		/* rule 383 */
_ChiralRestraint_termCode.cc:385:	 tx276 = [01;31m-[00m(tx5*tx60*tx797*tx800*tx95); 		/* rule 384 */
_ChiralRestraint_termCode.cc:391:	 tx280 = [01;31m-[00my4; 		/* rule 390 */
_ChiralRestraint_termCode.cc:394:	 tx283 = [01;31m-[00m(tx103*tx5*tx60*tx797*tx800); 		/* rule 393 */
_ChiralRestraint_termCode.cc:396:	 tx285 = [01;31m-[00m(tx27*tx61*tx794*tx800*tx86); 		/* rule 395 */
_ChiralRestraint_termCode.cc:402:	 tx289 = [01;31m-[00mtx267; 		/* rule 401 */
_ChiralRestraint_termCode.cc:403:	 tx290 = [01;31m-[00m3*tx165*tx38*tx52*tx797*tx800; 		/* rule 402 */
_ChiralRestraint_termCode.cc:404:	 tx291 = [01;31m-[00m(tx117*tx5*tx60*tx797*tx800); 		/* rule 403 */
_ChiralRestraint_termCode.cc:407:	 tx294 = [01;31m-[00m(tx118*tx5*tx52*tx60*tx797*tx8); 		/* rule 406 */
_ChiralRestraint_termCode.cc:415:	 tx300 = [01;31m-[00mz4; 		/* rule 414 */
_ChiralRestraint_termCode.cc:417:	 tx302 = [01;31m-[00mtx274; 		/* rule 416 */
_ChiralRestraint_termCode.cc:419:	 tx304 = [01;31m-[00m3*tx12*tx165*tx5*tx52*tx797*tx800; 		/* rule 418 */
_ChiralRestraint_termCode.cc:420:	 tx305 = [01;31m-[00m(tx134*tx5*tx60*tx797*tx800); 		/* rule 419 */
_ChiralRestraint_termCode.cc:421:	 tx306 = [01;31m-[00m(tx118*tx17*tx5*tx52*tx60*tx797); 		/* rule 420 */
_ChiralRestraint_termCode.cc:431:	 tx314 = [01;31m-[00mtx284; 		/* rule 430 */
_ChiralRestraint_termCode.cc:433:	 tx316 = [01;31m-[00m3*tx165*tx22*tx5*tx52*tx797*tx800; 		/* rule 432 */
_ChiralRestraint_termCode.cc:434:	 tx317 = [01;31m-[00m(tx150*tx5*tx60*tx797*tx800); 		/* rule 433 */
_ChiralRestraint_termCode.cc:438:	 tx321 = [01;31m-[00m(tx118*tx52*tx60*tx797*tx93); 		/* rule 437 */
_ChiralRestraint_termCode.cc:444:	 tx325 = [01;31m-[00mtx295; 		/* rule 443 */
_ChiralRestraint_termCode.cc:445:	 tx326 = [01;31m-[00m(tx42*tx5*tx60*tx797*tx800); 		/* rule 444 */
_ChiralRestraint_termCode.cc:452:	 tx331 = [01;31m-[00mtx307; 		/* rule 451 */
_ChiralRestraint_termCode.cc:454:	 tx333 = [01;31m-[00m(tx39*tx5*tx60*tx797*tx800); 		/* rule 453 */
_ChiralRestraint_termCode.cc:461:	 tx338 = [01;31m-[00mtx318; 		/* rule 460 */
_ChiralRestraint_termCode.cc:463:	 tx340 = [01;31m-[00m(tx37*tx5*tx60*tx797*tx800); 		/* rule 462 */
_ChiralRestraint_termCode.cc:471:	 tx346 = [01;31m-[00m(tx22*tx60*tx70*tx797*tx800); 		/* rule 470 */
_ChiralRestraint_termCode.cc:472:	 tx347 = [01;31m-[00m(tx12*tx60*tx78*tx797*tx800); 		/* rule 471 */
_ChiralRestraint_termCode.cc:481:	 tx354 = [01;31m-[00m(tx7*tx70*tx794*tx800*tx86); 		/* rule 480 */
_ChiralRestraint_termCode.cc:482:	 tx355 = [01;31m-[00m(tx12*tx60*tx797*tx800*tx87); 		/* rule 481 */
_ChiralRestraint_termCode.cc:489:	 tx360 = [01;31m-[00m(tx15*tx70*tx794*tx800*tx86); 		/* rule 488 */
_ChiralRestraint_termCode.cc:490:	 tx361 = [01;31m-[00m(tx12*tx60*tx797*tx800*tx95); 		/* rule 489 */
_ChiralRestraint_termCode.cc:496:	 tx365 = [01;31m-[00m(tx103*tx12*tx60*tx797*tx800); 		/* rule 495 */
_ChiralRestraint_termCode.cc:499:	 tx368 = [01;31m-[00m(tx27*tx70*tx794*tx800*tx86); 		/* rule 498 */
_ChiralRestraint_termCode.cc:506:	 tx373 = [01;31m-[00mtx353; 		/* rule 505 */
_ChiralRestraint_termCode.cc:508:	 tx375 = [01;31m-[00m(tx117*tx12*tx60*tx797*tx800); 		/* rule 507 */
_ChiralRestraint_termCode.cc:509:	 tx376 = [01;31m-[00m(tx102*tx118*tx52*tx60*tx797); 		/* rule 508 */
_ChiralRestraint_termCode.cc:518:	 tx383 = [01;31m-[00mtx359; 		/* rule 517 */
_ChiralRestraint_termCode.cc:519:	 tx384 = [01;31m-[00m3*tx165*tx31*tx52*tx797*tx800; 		/* rule 518 */
_ChiralRestraint_termCode.cc:520:	 tx385 = [01;31m-[00m(tx12*tx134*tx60*tx797*tx800); 		/* rule 519 */
_ChiralRestraint_termCode.cc:521:	 tx386 = [01;31m-[00m(tx118*tx12*tx17*tx52*tx60*tx797); 		/* rule 520 */
_ChiralRestraint_termCode.cc:530:	 tx393 = [01;31m-[00mx4; 		/* rule 529 */
_ChiralRestraint_termCode.cc:532:	 tx395 = [01;31m-[00mtx367; 		/* rule 531 */
_ChiralRestraint_termCode.cc:534:	 tx397 = [01;31m-[00m3*tx12*tx165*tx22*tx52*tx797*tx800; 		/* rule 533 */
_ChiralRestraint_termCode.cc:535:	 tx398 = [01;31m-[00m(tx12*tx150*tx60*tx797*tx800); 		/* rule 534 */
_ChiralRestraint_termCode.cc:536:	 tx399 = [01;31m-[00m(tx118*tx12*tx30*tx52*tx60*tx797); 		/* rule 535 */
_ChiralRestraint_termCode.cc:545:	 tx406 = [01;31m-[00mtx378; 		/* rule 544 */
_ChiralRestraint_termCode.cc:547:	 tx408 = [01;31m-[00m(tx12*tx42*tx60*tx797*tx800); 		/* rule 546 */
_ChiralRestraint_termCode.cc:554:	 tx413 = [01;31m-[00mtx387; 		/* rule 553 */
_ChiralRestraint_termCode.cc:555:	 tx414 = [01;31m-[00m(tx12*tx39*tx60*tx797*tx800); 		/* rule 554 */
_ChiralRestraint_termCode.cc:562:	 tx419 = [01;31m-[00mtx400; 		/* rule 561 */
_ChiralRestraint_termCode.cc:563:	 tx420 = [01;31m-[00m(tx12*tx37*tx60*tx797*tx800); 		/* rule 562 */
_ChiralRestraint_termCode.cc:573:	 tx428 = [01;31m-[00m(tx7*tx78*tx794*tx800*tx86); 		/* rule 572 */
_ChiralRestraint_termCode.cc:574:	 tx429 = [01;31m-[00m(tx22*tx60*tx797*tx800*tx87); 		/* rule 573 */
_ChiralRestraint_termCode.cc:583:	 tx436 = [01;31m-[00m(tx15*tx78*tx794*tx800*tx86); 		/* rule 582 */
_ChiralRestraint_termCode.cc:584:	 tx437 = [01;31m-[00m(tx22*tx60*tx797*tx800*tx95); 		/* rule 583 */
_ChiralRestraint_termCode.cc:590:	 tx441 = [01;31m-[00m(tx103*tx22*tx60*tx797*tx800); 		/* rule 589 */
_ChiralRestraint_termCode.cc:592:	 tx443 = [01;31m-[00m(tx27*tx78*tx794*tx800*tx86); 		/* rule 591 */
_ChiralRestraint_termCode.cc:599:	 tx448 = [01;31m-[00mtx427; 		/* rule 598 */
_ChiralRestraint_termCode.cc:601:	 tx450 = [01;31m-[00m(tx117*tx22*tx60*tx797*tx800); 		/* rule 600 */
_ChiralRestraint_termCode.cc:603:	 tx452 = [01;31m-[00m(tx118*tx22*tx52*tx60*tx797*tx8); 		/* rule 602 */
_ChiralRestraint_termCode.cc:612:	 tx459 = [01;31m-[00mtx435; 		/* rule 611 */
_ChiralRestraint_termCode.cc:614:	 tx461 = [01;31m-[00m(tx134*tx22*tx60*tx797*tx800); 		/* rule 613 */
_ChiralRestraint_termCode.cc:617:	 tx464 = [01;31m-[00m(tx118*tx52*tx60*tx797*tx84); 		/* rule 616 */
_ChiralRestraint_termCode.cc:624:	 tx469 = [01;31m-[00mtx442; 		/* rule 623 */
_ChiralRestraint_termCode.cc:625:	 tx470 = [01;31m-[00m3*tx165*tx34*tx52*tx797*tx800; 		/* rule 624 */
_ChiralRestraint_termCode.cc:626:	 tx471 = [01;31m-[00m(tx150*tx22*tx60*tx797*tx800); 		/* rule 625 */
_ChiralRestraint_termCode.cc:627:	 tx472 = [01;31m-[00m(tx118*tx22*tx30*tx52*tx60*tx797); 		/* rule 626 */
_ChiralRestraint_termCode.cc:636:	 tx479 = [01;31m-[00mtx453; 		/* rule 635 */
_ChiralRestraint_termCode.cc:637:	 tx480 = [01;31m-[00m(tx22*tx42*tx60*tx797*tx800); 		/* rule 636 */
_ChiralRestraint_termCode.cc:645:	 tx486 = [01;31m-[00mtx462; 		/* rule 644 */
_ChiralRestraint_termCode.cc:646:	 tx487 = [01;31m-[00m(tx22*tx39*tx60*tx797*tx800); 		/* rule 645 */
_ChiralRestraint_termCode.cc:654:	 tx493 = [01;31m-[00mtx473; 		/* rule 653 */
_ChiralRestraint_termCode.cc:655:	 tx494 = [01;31m-[00m(tx22*tx37*tx60*tx797*tx800); 		/* rule 654 */
_ChiralRestraint_termCode.cc:663:	 tx500 = [01;31m-[00m(tx15*tx794*tx800*tx86*tx87); 		/* rule 662 */
_ChiralRestraint_termCode.cc:664:	 tx501 = [01;31m-[00m(tx7*tx794*tx800*tx86*tx95); 		/* rule 663 */
_ChiralRestraint_termCode.cc:671:	 tx506 = [01;31m-[00m(tx103*tx7*tx794*tx800*tx86); 		/* rule 670 */
_ChiralRestraint_termCode.cc:672:	 tx507 = [01;31m-[00m(tx27*tx794*tx800*tx86*tx87); 		/* rule 671 */
_ChiralRestraint_termCode.cc:678:	 tx511 = [01;31m-[00m3*tx185*tx40*tx52*tx794*tx800; 		/* rule 677 */
_ChiralRestraint_termCode.cc:680:	 tx513 = [01;31m-[00m(tx117*tx7*tx794*tx800*tx86); 		/* rule 679 */
_ChiralRestraint_termCode.cc:681:	 tx514 = [01;31m-[00m(tx118*tx52*tx7*tx794*tx8*tx86); 		/* rule 680 */
_ChiralRestraint_termCode.cc:692:	 tx523 = [01;31m-[00m3*tx15*tx185*tx52*tx7*tx794*tx800; 		/* rule 691 */
_ChiralRestraint_termCode.cc:693:	 tx524 = [01;31m-[00m(tx134*tx7*tx794*tx800*tx86); 		/* rule 692 */
_ChiralRestraint_termCode.cc:694:	 tx525 = [01;31m-[00m(tx118*tx52*tx76*tx794*tx86); 		/* rule 693 */
_ChiralRestraint_termCode.cc:705:	 tx534 = [01;31m-[00m3*tx185*tx27*tx52*tx7*tx794*tx800; 		/* rule 704 */
_ChiralRestraint_termCode.cc:706:	 tx535 = [01;31m-[00m(tx150*tx7*tx794*tx800*tx86); 		/* rule 705 */
_ChiralRestraint_termCode.cc:707:	 tx536 = [01;31m-[00m(tx118*tx30*tx52*tx7*tx794*tx86); 		/* rule 706 */
_ChiralRestraint_termCode.cc:716:	 tx543 = [01;31m-[00mtx516; 		/* rule 715 */
_ChiralRestraint_termCode.cc:717:	 tx544 = [01;31m-[00m(tx42*tx7*tx794*tx800*tx86); 		/* rule 716 */
_ChiralRestraint_termCode.cc:725:	 tx550 = [01;31m-[00mtx526; 		/* rule 724 */
_ChiralRestraint_termCode.cc:726:	 tx551 = [01;31m-[00m(tx39*tx7*tx794*tx800*tx86); 		/* rule 725 */
_ChiralRestraint_termCode.cc:733:	 tx556 = [01;31m-[00mtx537; 		/* rule 732 */
_ChiralRestraint_termCode.cc:735:	 tx558 = [01;31m-[00m(tx37*tx7*tx794*tx800*tx86); 		/* rule 734 */
_ChiralRestraint_termCode.cc:743:	 tx564 = [01;31m-[00m(tx103*tx15*tx794*tx800*tx86); 		/* rule 742 */
_ChiralRestraint_termCode.cc:744:	 tx565 = [01;31m-[00m(tx27*tx794*tx800*tx86*tx95); 		/* rule 743 */
_ChiralRestraint_termCode.cc:752:	 tx571 = [01;31m-[00m(tx117*tx15*tx794*tx800*tx86); 		/* rule 751 */
_ChiralRestraint_termCode.cc:753:	 tx572 = [01;31m-[00m(tx118*tx15*tx52*tx794*tx8*tx86); 		/* rule 752 */
_ChiralRestraint_termCode.cc:762:	 tx579 = [01;31m-[00m3*tx185*tx32*tx52*tx794*tx800; 		/* rule 761 */
_ChiralRestraint_termCode.cc:763:	 tx580 = [01;31m-[00m(tx134*tx15*tx794*tx800*tx86); 		/* rule 762 */
_ChiralRestraint_termCode.cc:764:	 tx581 = [01;31m-[00m(tx118*tx15*tx17*tx52*tx794*tx86); 		/* rule 763 */
_ChiralRestraint_termCode.cc:774:	 tx589 = [01;31m-[00m3*tx15*tx185*tx27*tx52*tx794*tx800; 		/* rule 773 */
_ChiralRestraint_termCode.cc:776:	 tx591 = [01;31m-[00m(tx15*tx150*tx794*tx800*tx86); 		/* rule 775 */
_ChiralRestraint_termCode.cc:777:	 tx592 = [01;31m-[00m(tx118*tx52*tx58*tx794*tx86); 		/* rule 776 */
_ChiralRestraint_termCode.cc:786:	 tx599 = [01;31m-[00mtx574; 		/* rule 785 */
_ChiralRestraint_termCode.cc:787:	 tx600 = [01;31m-[00m(tx15*tx42*tx794*tx800*tx86); 		/* rule 786 */
_ChiralRestraint_termCode.cc:795:	 tx606 = [01;31m-[00mtx582; 		/* rule 794 */
_ChiralRestraint_termCode.cc:796:	 tx607 = [01;31m-[00m(tx15*tx39*tx794*tx800*tx86); 		/* rule 795 */
_ChiralRestraint_termCode.cc:804:	 tx613 = [01;31m-[00mtx593; 		/* rule 803 */
_ChiralRestraint_termCode.cc:805:	 tx614 = [01;31m-[00m(tx15*tx37*tx794*tx800*tx86); 		/* rule 804 */
_ChiralRestraint_termCode.cc:816:	 tx623 = [01;31m-[00m(tx117*tx27*tx794*tx800*tx86); 		/* rule 815 */
_ChiralRestraint_termCode.cc:817:	 tx624 = [01;31m-[00m(tx118*tx52*tx69*tx794*tx86); 		/* rule 816 */
_ChiralRestraint_termCode.cc:829:	 tx634 = [01;31m-[00m(tx134*tx27*tx794*tx800*tx86); 		/* rule 828 */
_ChiralRestraint_termCode.cc:830:	 tx635 = [01;31m-[00m(tx118*tx17*tx27*tx52*tx794*tx86); 		/* rule 829 */
_ChiralRestraint_termCode.cc:837:	 tx640 = [01;31m-[00m3*tx185*tx35*tx52*tx794*tx800; 		/* rule 836 */
_ChiralRestraint_termCode.cc:840:	 tx643 = [01;31m-[00m(tx150*tx27*tx794*tx800*tx86); 		/* rule 839 */
_ChiralRestraint_termCode.cc:841:	 tx644 = [01;31m-[00m(tx118*tx27*tx30*tx52*tx794*tx86); 		/* rule 840 */
_ChiralRestraint_termCode.cc:848:	 tx649 = [01;31m-[00mtx622; 		/* rule 847 */
_ChiralRestraint_termCode.cc:849:	 tx650 = [01;31m-[00m(tx27*tx42*tx794*tx800*tx86); 		/* rule 848 */
_ChiralRestraint_termCode.cc:857:	 tx656 = [01;31m-[00mtx630; 		/* rule 856 */
_ChiralRestraint_termCode.cc:858:	 tx657 = [01;31m-[00m(tx27*tx39*tx794*tx800*tx86); 		/* rule 857 */
_ChiralRestraint_termCode.cc:865:	 tx662 = [01;31m-[00mtx639; 		/* rule 864 */
_ChiralRestraint_termCode.cc:866:	 tx663 = [01;31m-[00m(tx27*tx37*tx794*tx800*tx86); 		/* rule 865 */
_ChiralRestraint_termCode.cc:899:	 tx690 = [01;31m-[00m3*tx205*tx41*tx52*tx794*tx797; 		/* rule 898 */
_ChiralRestraint_termCode.cc:901:	 tx692 = [01;31m-[00m(tx117*tx118*tx794*tx797*tx8); 		/* rule 900 */
_ChiralRestraint_termCode.cc:910:	 tx699 = [01;31m-[00mtx668; 		/* rule 909 */
_ChiralRestraint_termCode.cc:912:	 tx701 = [01;31m-[00m3*tx17*tx205*tx52*tx794*tx797*tx8; 		/* rule 911 */
_ChiralRestraint_termCode.cc:921:	 tx708 = [01;31m-[00mtx678; 		/* rule 920 */
_ChiralRestraint_termCode.cc:923:	 tx710 = [01;31m-[00m3*tx205*tx30*tx52*tx794*tx797*tx8; 		/* rule 922 */
_ChiralRestraint_termCode.cc:945:	 tx728 = [01;31m-[00mtx671; 		/* rule 944 */
_ChiralRestraint_termCode.cc:952:	 tx733 = [01;31m-[00m(tx118*tx134*tx17*tx794*tx797); 		/* rule 951 */
_ChiralRestraint_termCode.cc:954:	 tx735 = [01;31m-[00m3*tx205*tx33*tx52*tx794*tx797; 		/* rule 953 */
_ChiralRestraint_termCode.cc:964:	 tx743 = [01;31m-[00m3*tx17*tx205*tx30*tx52*tx794*tx797; 		/* rule 963 */
_ChiralRestraint_termCode.cc:966:	 tx745 = [01;31m-[00mtx716; 		/* rule 965 */
_ChiralRestraint_termCode.cc:976:	 tx753 = [01;31m-[00mtx681; 		/* rule 975 */
_ChiralRestraint_termCode.cc:986:	 tx761 = [01;31m-[00mtx715; 		/* rule 985 */
_ChiralRestraint_termCode.cc:993:	 tx766 = [01;31m-[00m(tx118*tx150*tx30*tx794*tx797); 		/* rule 992 */
_ChiralRestraint_termCode.cc:995:	 tx768 = [01;31m-[00m3*tx205*tx36*tx52*tx794*tx797; 		/* rule 994 */
_ChiralRestraint_termCode.cc:1003:	 tx774 = [01;31m-[00mtx700; 		/* rule 1002 */
_ChiralRestraint_termCode.cc:1004:	 tx775 = [01;31m-[00mtx725; 		/* rule 1003 */
_ChiralRestraint_termCode.cc:1010:	 tx779 = [01;31m-[00mtx709; 		/* rule 1009 */
_ChiralRestraint_termCode.cc:1011:	 tx780 = [01;31m-[00mtx750; 		/* rule 1010 */
_ChiralRestraint_termCode.cc:1017:	 tx784 = [01;31m-[00mtx741; 		/* rule 1016 */
_ChiralRestraint_termCode.cc:1018:	 tx785 = [01;31m-[00mtx758; 		/* rule 1017 */
_Dihedral_debugEvalSerialize.cc:2:	node[01;31m-[00m>attributeIfNotDefault("evalx1", this[01;31m-[00m>eval.x1, 0.0 );
_Dihedral_debugEvalSerialize.cc:3: 	node[01;31m-[00m>attributeIfNotDefault("evaly1", this[01;31m-[00m>eval.y1, 0.0 );
_Dihedral_debugEvalSerialize.cc:4: 	node[01;31m-[00m>attributeIfNotDefault("evalz1", this[01;31m-[00m>eval.z1, 0.0 );
_Dihedral_debugEvalSerialize.cc:5: 	node[01;31m-[00m>attributeIfNotDefault("evalx2", this[01;31m-[00m>eval.x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:6: 	node[01;31m-[00m>attributeIfNotDefault("evaly2", this[01;31m-[00m>eval.y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:7: 	node[01;31m-[00m>attributeIfNotDefault("evalz2", this[01;31m-[00m>eval.z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:8: 	node[01;31m-[00m>attributeIfNotDefault("evalx3", this[01;31m-[00m>eval.x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:9: 	node[01;31m-[00m>attributeIfNotDefault("evaly3", this[01;31m-[00m>eval.y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:10: 	node[01;31m-[00m>attributeIfNotDefault("evalz3", this[01;31m-[00m>eval.z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:11: 	node[01;31m-[00m>attributeIfNotDefault("evalx4", this[01;31m-[00m>eval.x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:12: 	node[01;31m-[00m>attributeIfNotDefault("evaly4", this[01;31m-[00m>eval.y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:13: 	node[01;31m-[00m>attributeIfNotDefault("evalz4", this[01;31m-[00m>eval.z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:14: 	node[01;31m-[00m>attributeIfNotDefault("evalV", this[01;31m-[00m>eval.V, 0.0 );
_Dihedral_debugEvalSerialize.cc:15: 	node[01;31m-[00m>attributeIfNotDefault("evalDN", this[01;31m-[00m>eval.DN, 0.0 );
_Dihedral_debugEvalSerialize.cc:16: 	node[01;31m-[00m>attributeIfNotDefault("evalIN", this[01;31m-[00m>eval.IN, 0.0 );
_Dihedral_debugEvalSerialize.cc:17: 	node[01;31m-[00m>attributeIfNotDefault("evalcosPhase", this[01;31m-[00m>eval.cosPhase, 0.0 );
_Dihedral_debugEvalSerialize.cc:18: 	node[01;31m-[00m>attributeIfNotDefault("evalsinPhase", this[01;31m-[00m>eval.sinPhase, 0.0 );
_Dihedral_debugEvalSerialize.cc:19: 	node[01;31m-[00m>attributeIfNotDefault("evalEnergy", this[01;31m-[00m>eval.Energy, 0.0 );
_Dihedral_debugEvalSerialize.cc:20: 	node[01;31m-[00m>attributeIfNotDefault("evalfx1", this[01;31m-[00m>eval.fx1, 0.0 );
_Dihedral_debugEvalSerialize.cc:21: 	node[01;31m-[00m>attributeIfNotDefault("evalfy1", this[01;31m-[00m>eval.fy1, 0.0 );
_Dihedral_debugEvalSerialize.cc:22: 	node[01;31m-[00m>attributeIfNotDefault("evalfz1", this[01;31m-[00m>eval.fz1, 0.0 );
_Dihedral_debugEvalSerialize.cc:23: 	node[01;31m-[00m>attributeIfNotDefault("evalfx2", this[01;31m-[00m>eval.fx2, 0.0 );
_Dihedral_debugEvalSerialize.cc:24: 	node[01;31m-[00m>attributeIfNotDefault("evalfy2", this[01;31m-[00m>eval.fy2, 0.0 );
_Dihedral_debugEvalSerialize.cc:25: 	node[01;31m-[00m>attributeIfNotDefault("evalfz2", this[01;31m-[00m>eval.fz2, 0.0 );
_Dihedral_debugEvalSerialize.cc:26: 	node[01;31m-[00m>attributeIfNotDefault("evalfx3", this[01;31m-[00m>eval.fx3, 0.0 );
_Dihedral_debugEvalSerialize.cc:27: 	node[01;31m-[00m>attributeIfNotDefault("evalfy3", this[01;31m-[00m>eval.fy3, 0.0 );
_Dihedral_debugEvalSerialize.cc:28: 	node[01;31m-[00m>attributeIfNotDefault("evalfz3", this[01;31m-[00m>eval.fz3, 0.0 );
_Dihedral_debugEvalSerialize.cc:29: 	node[01;31m-[00m>attributeIfNotDefault("evalfx4", this[01;31m-[00m>eval.fx4, 0.0 );
_Dihedral_debugEvalSerialize.cc:30: 	node[01;31m-[00m>attributeIfNotDefault("evalfy4", this[01;31m-[00m>eval.fy4, 0.0 );
_Dihedral_debugEvalSerialize.cc:31: 	node[01;31m-[00m>attributeIfNotDefault("evalfz4", this[01;31m-[00m>eval.fz4, 0.0 );
_Dihedral_debugEvalSerialize.cc:32: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx1x1", this[01;31m-[00m>eval.dhx1x1, 0.0 );
_Dihedral_debugEvalSerialize.cc:33: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy1y1", this[01;31m-[00m>eval.dhy1y1, 0.0 );
_Dihedral_debugEvalSerialize.cc:34: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz1z1", this[01;31m-[00m>eval.dhz1z1, 0.0 );
_Dihedral_debugEvalSerialize.cc:35: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx2x2", this[01;31m-[00m>eval.dhx2x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:36: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy2y2", this[01;31m-[00m>eval.dhy2y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:37: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz2z2", this[01;31m-[00m>eval.dhz2z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:38: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx3x3", this[01;31m-[00m>eval.dhx3x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:39: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy3y3", this[01;31m-[00m>eval.dhy3y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:40: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz3z3", this[01;31m-[00m>eval.dhz3z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:41: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx4x4", this[01;31m-[00m>eval.dhx4x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:42: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy4y4", this[01;31m-[00m>eval.dhy4y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:43: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz4z4", this[01;31m-[00m>eval.dhz4z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:44: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y1", this[01;31m-[00m>eval.ohx1y1, 0.0 );
_Dihedral_debugEvalSerialize.cc:45: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z1", this[01;31m-[00m>eval.ohx1z1, 0.0 );
_Dihedral_debugEvalSerialize.cc:46: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x2", this[01;31m-[00m>eval.ohx1x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:47: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y2", this[01;31m-[00m>eval.ohx1y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:48: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z2", this[01;31m-[00m>eval.ohx1z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:49: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x3", this[01;31m-[00m>eval.ohx1x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:50: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y3", this[01;31m-[00m>eval.ohx1y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:51: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z3", this[01;31m-[00m>eval.ohx1z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:52: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x4", this[01;31m-[00m>eval.ohx1x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:53: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y4", this[01;31m-[00m>eval.ohx1y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:54: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z4", this[01;31m-[00m>eval.ohx1z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:55: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z1", this[01;31m-[00m>eval.ohy1z1, 0.0 );
_Dihedral_debugEvalSerialize.cc:56: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x2", this[01;31m-[00m>eval.ohy1x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:57: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y2", this[01;31m-[00m>eval.ohy1y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:58: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z2", this[01;31m-[00m>eval.ohy1z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:59: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x3", this[01;31m-[00m>eval.ohy1x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:60: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y3", this[01;31m-[00m>eval.ohy1y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:61: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z3", this[01;31m-[00m>eval.ohy1z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:62: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x4", this[01;31m-[00m>eval.ohy1x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:63: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y4", this[01;31m-[00m>eval.ohy1y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:64: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z4", this[01;31m-[00m>eval.ohy1z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:65: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x2", this[01;31m-[00m>eval.ohz1x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:66: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y2", this[01;31m-[00m>eval.ohz1y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:67: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z2", this[01;31m-[00m>eval.ohz1z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:68: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x3", this[01;31m-[00m>eval.ohz1x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:69: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y3", this[01;31m-[00m>eval.ohz1y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:70: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z3", this[01;31m-[00m>eval.ohz1z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:71: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x4", this[01;31m-[00m>eval.ohz1x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:72: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y4", this[01;31m-[00m>eval.ohz1y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:73: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z4", this[01;31m-[00m>eval.ohz1z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:74: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y2", this[01;31m-[00m>eval.ohx2y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:75: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z2", this[01;31m-[00m>eval.ohx2z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:76: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2x3", this[01;31m-[00m>eval.ohx2x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:77: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y3", this[01;31m-[00m>eval.ohx2y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:78: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z3", this[01;31m-[00m>eval.ohx2z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:79: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2x4", this[01;31m-[00m>eval.ohx2x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:80: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y4", this[01;31m-[00m>eval.ohx2y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:81: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z4", this[01;31m-[00m>eval.ohx2z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:82: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z2", this[01;31m-[00m>eval.ohy2z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:83: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2x3", this[01;31m-[00m>eval.ohy2x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:84: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2y3", this[01;31m-[00m>eval.ohy2y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:85: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z3", this[01;31m-[00m>eval.ohy2z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:86: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2x4", this[01;31m-[00m>eval.ohy2x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:87: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2y4", this[01;31m-[00m>eval.ohy2y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:88: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z4", this[01;31m-[00m>eval.ohy2z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:89: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2x3", this[01;31m-[00m>eval.ohz2x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:90: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2y3", this[01;31m-[00m>eval.ohz2y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:91: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2z3", this[01;31m-[00m>eval.ohz2z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:92: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2x4", this[01;31m-[00m>eval.ohz2x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:93: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2y4", this[01;31m-[00m>eval.ohz2y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:94: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2z4", this[01;31m-[00m>eval.ohz2z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:95: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3y3", this[01;31m-[00m>eval.ohx3y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:96: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3z3", this[01;31m-[00m>eval.ohx3z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:97: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3x4", this[01;31m-[00m>eval.ohx3x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:98: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3y4", this[01;31m-[00m>eval.ohx3y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:99: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3z4", this[01;31m-[00m>eval.ohx3z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:100: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3z3", this[01;31m-[00m>eval.ohy3z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:101: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3x4", this[01;31m-[00m>eval.ohy3x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:102: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3y4", this[01;31m-[00m>eval.ohy3y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:103: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3z4", this[01;31m-[00m>eval.ohy3z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:104: 	node[01;31m-[00m>attributeIfNotDefault("evalohz3x4", this[01;31m-[00m>eval.ohz3x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:105: 	node[01;31m-[00m>attributeIfNotDefault("evalohz3y4", this[01;31m-[00m>eval.ohz3y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:106: 	node[01;31m-[00m>attributeIfNotDefault("evalohz3z4", this[01;31m-[00m>eval.ohz3z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:107: 	node[01;31m-[00m>attributeIfNotDefault("evalohx4y4", this[01;31m-[00m>eval.ohx4y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:108: 	node[01;31m-[00m>attributeIfNotDefault("evalohx4z4", this[01;31m-[00m>eval.ohx4z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:109: 	node[01;31m-[00m>attributeIfNotDefault("evalohy4z4", this[01;31m-[00m>eval.ohy4z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:110: 	node[01;31m-[00m>attributeIfNotDefault("evalDihedralDeviation", this[01;31m-[00m>eval.DihedralDeviation, 0.0 );
_Dihedral_debugEvalXml.cc:2:	xml[01;31m-[00m>addAttributeDoubleScientific ("x1", this[01;31m-[00m>eval.x1);
_Dihedral_debugEvalXml.cc:3: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y1", this[01;31m-[00m>eval.y1);
_Dihedral_debugEvalXml.cc:4: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z1", this[01;31m-[00m>eval.z1);
_Dihedral_debugEvalXml.cc:5: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x2", this[01;31m-[00m>eval.x2);
_Dihedral_debugEvalXml.cc:6: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y2", this[01;31m-[00m>eval.y2);
_Dihedral_debugEvalXml.cc:7: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z2", this[01;31m-[00m>eval.z2);
_Dihedral_debugEvalXml.cc:8: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x3", this[01;31m-[00m>eval.x3);
_Dihedral_debugEvalXml.cc:9: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y3", this[01;31m-[00m>eval.y3);
_Dihedral_debugEvalXml.cc:10: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z3", this[01;31m-[00m>eval.z3);
_Dihedral_debugEvalXml.cc:11: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x4", this[01;31m-[00m>eval.x4);
_Dihedral_debugEvalXml.cc:12: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y4", this[01;31m-[00m>eval.y4);
_Dihedral_debugEvalXml.cc:13: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z4", this[01;31m-[00m>eval.z4);
_Dihedral_debugEvalXml.cc:14: 	xml[01;31m-[00m>addAttributeDoubleScientific ("V", this[01;31m-[00m>eval.V);
_Dihedral_debugEvalXml.cc:15: 	xml[01;31m-[00m>addAttributeDoubleScientific ("DN", this[01;31m-[00m>eval.DN);
_Dihedral_debugEvalXml.cc:16: 	xml[01;31m-[00m>addAttributeDoubleScientific ("IN", this[01;31m-[00m>eval.IN);
_Dihedral_debugEvalXml.cc:17: 	xml[01;31m-[00m>addAttributeDoubleScientific ("cosPhase", this[01;31m-[00m>eval.cosPhase);
_Dihedral_debugEvalXml.cc:18: 	xml[01;31m-[00m>addAttributeDoubleScientific ("sinPhase", this[01;31m-[00m>eval.sinPhase);
_Dihedral_debugEvalXml.cc:19: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Energy", this[01;31m-[00m>eval.Energy);
_Dihedral_debugEvalXml.cc:20: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx1", this[01;31m-[00m>eval.fx1);
_Dihedral_debugEvalXml.cc:21: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy1", this[01;31m-[00m>eval.fy1);
_Dihedral_debugEvalXml.cc:22: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz1", this[01;31m-[00m>eval.fz1);
_Dihedral_debugEvalXml.cc:23: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx2", this[01;31m-[00m>eval.fx2);
_Dihedral_debugEvalXml.cc:24: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy2", this[01;31m-[00m>eval.fy2);
_Dihedral_debugEvalXml.cc:25: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz2", this[01;31m-[00m>eval.fz2);
_Dihedral_debugEvalXml.cc:26: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx3", this[01;31m-[00m>eval.fx3);
_Dihedral_debugEvalXml.cc:27: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy3", this[01;31m-[00m>eval.fy3);
_Dihedral_debugEvalXml.cc:28: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz3", this[01;31m-[00m>eval.fz3);
_Dihedral_debugEvalXml.cc:29: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx4", this[01;31m-[00m>eval.fx4);
_Dihedral_debugEvalXml.cc:30: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy4", this[01;31m-[00m>eval.fy4);
_Dihedral_debugEvalXml.cc:31: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz4", this[01;31m-[00m>eval.fz4);
_Dihedral_debugEvalXml.cc:32: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx1x1", this[01;31m-[00m>eval.dhx1x1);
_Dihedral_debugEvalXml.cc:33: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy1y1", this[01;31m-[00m>eval.dhy1y1);
_Dihedral_debugEvalXml.cc:34: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz1z1", this[01;31m-[00m>eval.dhz1z1);
_Dihedral_debugEvalXml.cc:35: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx2x2", this[01;31m-[00m>eval.dhx2x2);
_Dihedral_debugEvalXml.cc:36: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy2y2", this[01;31m-[00m>eval.dhy2y2);
_Dihedral_debugEvalXml.cc:37: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz2z2", this[01;31m-[00m>eval.dhz2z2);
_Dihedral_debugEvalXml.cc:38: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx3x3", this[01;31m-[00m>eval.dhx3x3);
_Dihedral_debugEvalXml.cc:39: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy3y3", this[01;31m-[00m>eval.dhy3y3);
_Dihedral_debugEvalXml.cc:40: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz3z3", this[01;31m-[00m>eval.dhz3z3);
_Dihedral_debugEvalXml.cc:41: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx4x4", this[01;31m-[00m>eval.dhx4x4);
_Dihedral_debugEvalXml.cc:42: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy4y4", this[01;31m-[00m>eval.dhy4y4);
_Dihedral_debugEvalXml.cc:43: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz4z4", this[01;31m-[00m>eval.dhz4z4);
_Dihedral_debugEvalXml.cc:44: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y1", this[01;31m-[00m>eval.ohx1y1);
_Dihedral_debugEvalXml.cc:45: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z1", this[01;31m-[00m>eval.ohx1z1);
_Dihedral_debugEvalXml.cc:46: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x2", this[01;31m-[00m>eval.ohx1x2);
_Dihedral_debugEvalXml.cc:47: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y2", this[01;31m-[00m>eval.ohx1y2);
_Dihedral_debugEvalXml.cc:48: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z2", this[01;31m-[00m>eval.ohx1z2);
_Dihedral_debugEvalXml.cc:49: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x3", this[01;31m-[00m>eval.ohx1x3);
_Dihedral_debugEvalXml.cc:50: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y3", this[01;31m-[00m>eval.ohx1y3);
_Dihedral_debugEvalXml.cc:51: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z3", this[01;31m-[00m>eval.ohx1z3);
_Dihedral_debugEvalXml.cc:52: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x4", this[01;31m-[00m>eval.ohx1x4);
_Dihedral_debugEvalXml.cc:53: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y4", this[01;31m-[00m>eval.ohx1y4);
_Dihedral_debugEvalXml.cc:54: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z4", this[01;31m-[00m>eval.ohx1z4);
_Dihedral_debugEvalXml.cc:55: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z1", this[01;31m-[00m>eval.ohy1z1);
_Dihedral_debugEvalXml.cc:56: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x2", this[01;31m-[00m>eval.ohy1x2);
_Dihedral_debugEvalXml.cc:57: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y2", this[01;31m-[00m>eval.ohy1y2);
_Dihedral_debugEvalXml.cc:58: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z2", this[01;31m-[00m>eval.ohy1z2);
_Dihedral_debugEvalXml.cc:59: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x3", this[01;31m-[00m>eval.ohy1x3);
_Dihedral_debugEvalXml.cc:60: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y3", this[01;31m-[00m>eval.ohy1y3);
_Dihedral_debugEvalXml.cc:61: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z3", this[01;31m-[00m>eval.ohy1z3);
_Dihedral_debugEvalXml.cc:62: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x4", this[01;31m-[00m>eval.ohy1x4);
_Dihedral_debugEvalXml.cc:63: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y4", this[01;31m-[00m>eval.ohy1y4);
_Dihedral_debugEvalXml.cc:64: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z4", this[01;31m-[00m>eval.ohy1z4);
_Dihedral_debugEvalXml.cc:65: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x2", this[01;31m-[00m>eval.ohz1x2);
_Dihedral_debugEvalXml.cc:66: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y2", this[01;31m-[00m>eval.ohz1y2);
_Dihedral_debugEvalXml.cc:67: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z2", this[01;31m-[00m>eval.ohz1z2);
_Dihedral_debugEvalXml.cc:68: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x3", this[01;31m-[00m>eval.ohz1x3);
_Dihedral_debugEvalXml.cc:69: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y3", this[01;31m-[00m>eval.ohz1y3);
_Dihedral_debugEvalXml.cc:70: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z3", this[01;31m-[00m>eval.ohz1z3);
_Dihedral_debugEvalXml.cc:71: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x4", this[01;31m-[00m>eval.ohz1x4);
_Dihedral_debugEvalXml.cc:72: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y4", this[01;31m-[00m>eval.ohz1y4);
_Dihedral_debugEvalXml.cc:73: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z4", this[01;31m-[00m>eval.ohz1z4);
_Dihedral_debugEvalXml.cc:74: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y2", this[01;31m-[00m>eval.ohx2y2);
_Dihedral_debugEvalXml.cc:75: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z2", this[01;31m-[00m>eval.ohx2z2);
_Dihedral_debugEvalXml.cc:76: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2x3", this[01;31m-[00m>eval.ohx2x3);
_Dihedral_debugEvalXml.cc:77: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y3", this[01;31m-[00m>eval.ohx2y3);
_Dihedral_debugEvalXml.cc:78: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z3", this[01;31m-[00m>eval.ohx2z3);
_Dihedral_debugEvalXml.cc:79: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2x4", this[01;31m-[00m>eval.ohx2x4);
_Dihedral_debugEvalXml.cc:80: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y4", this[01;31m-[00m>eval.ohx2y4);
_Dihedral_debugEvalXml.cc:81: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z4", this[01;31m-[00m>eval.ohx2z4);
_Dihedral_debugEvalXml.cc:82: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z2", this[01;31m-[00m>eval.ohy2z2);
_Dihedral_debugEvalXml.cc:83: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2x3", this[01;31m-[00m>eval.ohy2x3);
_Dihedral_debugEvalXml.cc:84: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2y3", this[01;31m-[00m>eval.ohy2y3);
_Dihedral_debugEvalXml.cc:85: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z3", this[01;31m-[00m>eval.ohy2z3);
_Dihedral_debugEvalXml.cc:86: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2x4", this[01;31m-[00m>eval.ohy2x4);
_Dihedral_debugEvalXml.cc:87: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2y4", this[01;31m-[00m>eval.ohy2y4);
_Dihedral_debugEvalXml.cc:88: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z4", this[01;31m-[00m>eval.ohy2z4);
_Dihedral_debugEvalXml.cc:89: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2x3", this[01;31m-[00m>eval.ohz2x3);
_Dihedral_debugEvalXml.cc:90: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2y3", this[01;31m-[00m>eval.ohz2y3);
_Dihedral_debugEvalXml.cc:91: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2z3", this[01;31m-[00m>eval.ohz2z3);
_Dihedral_debugEvalXml.cc:92: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2x4", this[01;31m-[00m>eval.ohz2x4);
_Dihedral_debugEvalXml.cc:93: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2y4", this[01;31m-[00m>eval.ohz2y4);
_Dihedral_debugEvalXml.cc:94: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2z4", this[01;31m-[00m>eval.ohz2z4);
_Dihedral_debugEvalXml.cc:95: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3y3", this[01;31m-[00m>eval.ohx3y3);
_Dihedral_debugEvalXml.cc:96: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3z3", this[01;31m-[00m>eval.ohx3z3);
_Dihedral_debugEvalXml.cc:97: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3x4", this[01;31m-[00m>eval.ohx3x4);
_Dihedral_debugEvalXml.cc:98: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3y4", this[01;31m-[00m>eval.ohx3y4);
_Dihedral_debugEvalXml.cc:99: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3z4", this[01;31m-[00m>eval.ohx3z4);
_Dihedral_debugEvalXml.cc:100: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3z3", this[01;31m-[00m>eval.ohy3z3);
_Dihedral_debugEvalXml.cc:101: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3x4", this[01;31m-[00m>eval.ohy3x4);
_Dihedral_debugEvalXml.cc:102: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3y4", this[01;31m-[00m>eval.ohy3y4);
_Dihedral_debugEvalXml.cc:103: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3z4", this[01;31m-[00m>eval.ohy3z4);
_Dihedral_debugEvalXml.cc:104: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz3x4", this[01;31m-[00m>eval.ohz3x4);
_Dihedral_debugEvalXml.cc:105: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz3y4", this[01;31m-[00m>eval.ohz3y4);
_Dihedral_debugEvalXml.cc:106: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz3z4", this[01;31m-[00m>eval.ohz3z4);
_Dihedral_debugEvalXml.cc:107: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx4y4", this[01;31m-[00m>eval.ohx4y4);
_Dihedral_debugEvalXml.cc:108: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx4z4", this[01;31m-[00m>eval.ohx4z4);
_Dihedral_debugEvalXml.cc:109: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy4z4", this[01;31m-[00m>eval.ohy4z4);
_Dihedral_debugEvalXml.cc:110: 	xml[01;31m-[00m>addAttributeDoubleScientific ("DihedralDeviation", this[01;31m-[00m>eval.DihedralDeviation);
_Dihedral_debugFiniteDifference.cc:3:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:8:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:13:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:18:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:23:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:33:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:38:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:43:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:48:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:53:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:58:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:63:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:70:([01;31m-[00mdelta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:71:(delta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:72:([01;31m-[00mdelta2 + x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:78:([01;31m-[00mdelta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:79:(delta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:80:([01;31m-[00mdelta2 + x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:86:([01;31m-[00mdelta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:87:(delta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:88:([01;31m-[00mdelta2 + x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:94:([01;31m-[00mdelta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:95:(delta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:96:([01;31m-[00mdelta2 + x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:102:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:103:(delta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:104:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:110:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:111:(delta2 + x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:112:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:118:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:119:(delta2 + x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:120:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:126:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:127:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:128:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:134:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:135:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:136:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:142:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:143:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:144:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:150:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:151:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:152:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:157:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:164:(x1, [01;31m-[00mdelta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:165:(x1, delta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:166:(x1, [01;31m-[00mdelta2 + y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:172:(x1, [01;31m-[00mdelta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:173:(x1, delta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:174:(x1, [01;31m-[00mdelta2 + y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:180:(x1, [01;31m-[00mdelta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:181:(x1, delta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:182:(x1, [01;31m-[00mdelta2 + y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:188:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:189:(x1, delta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:190:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:196:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:197:(x1, delta2 + y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:198:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:204:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:205:(x1, delta2 + y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:206:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:212:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:213:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:214:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:220:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:221:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:222:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:228:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:229:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:230:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:236:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:237:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:238:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:243:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:250:(x1, y1, [01;31m-[00mdelta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:251:(x1, y1, delta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:252:(x1, y1, [01;31m-[00mdelta2 + z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:258:(x1, y1, [01;31m-[00mdelta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:259:(x1, y1, delta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:260:(x1, y1, [01;31m-[00mdelta2 + z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:266:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:267:(x1, y1, delta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:268:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:274:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:275:(x1, y1, delta2 + z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:276:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:282:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:283:(x1, y1, delta2 + z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:284:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:290:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:291:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:292:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:298:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:299:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:300:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:306:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:307:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:308:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:314:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:315:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:316:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:321:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:328:(x1, y1, z1, [01;31m-[00mdelta2 + x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:329:(x1, y1, z1, delta2 + x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:330:(x1, y1, z1, [01;31m-[00mdelta2 + x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:336:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:337:(x1, y1, z1, delta2 + x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:338:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:344:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:345:(x1, y1, z1, delta2 + x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:346:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:352:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:353:(x1, y1, z1, delta2 + x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:354:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:360:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:361:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:362:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:368:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:369:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:370:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:376:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:377:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:378:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:384:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:385:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:386:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:391:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:398:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:399:(x1, y1, z1, x2, delta2 + y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:400:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:406:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:407:(x1, y1, z1, x2, delta2 + y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:408:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:414:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:415:(x1, y1, z1, x2, delta2 + y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:416:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:422:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:423:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:424:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:430:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:431:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:432:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:438:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:439:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:440:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:446:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:447:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:448:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:453:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:460:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:461:(x1, y1, z1, x2, y2, delta2 + z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:462:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:468:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:469:(x1, y1, z1, x2, y2, delta2 + z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:470:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:476:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:477:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:478:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:484:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:485:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:486:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:492:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:493:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:494:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:500:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:501:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:502:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:507:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:514:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:515:(x1, y1, z1, x2, y2, z2, delta2 + x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:516:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:522:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:523:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:524:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:530:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:531:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:532:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:538:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:539:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:540:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:546:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:547:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:548:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:553:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:560:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:561:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:562:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:568:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:569:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:570:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:576:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:577:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:578:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:584:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:585:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:586:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:591:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:598:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:599:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:600:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:606:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:607:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:608:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:614:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:615:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:616:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:621:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:628:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:629:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:630:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:636:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:637:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:638:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:643:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:650:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:651:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:652:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:657:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_termCode.cc:1:// C[01;31m-[00mcode
_Dihedral_termCode.cc:23:	 tx1 = [01;31m-[00m(x2*y1); 		/* rule 22 */
_Dihedral_termCode.cc:26:	 tx4 = [01;31m-[00m(x3*y2); 		/* rule 25 */
_Dihedral_termCode.cc:27:	 tx5 = [01;31m-[00m(x1*y3); 		/* rule 26 */
_Dihedral_termCode.cc:30:	 tx8 = [01;31m-[00m(x3*z1); 		/* rule 29 */
_Dihedral_termCode.cc:31:	 tx9 = [01;31m-[00m(y2*z1); 		/* rule 30 */
_Dihedral_termCode.cc:33:	 tx11 = [01;31m-[00m(x1*z2); 		/* rule 32 */
_Dihedral_termCode.cc:36:	 tx14 = [01;31m-[00m(y3*z2); 		/* rule 35 */
_Dihedral_termCode.cc:38:	 tx16 = [01;31m-[00m(x2*z3); 		/* rule 37 */
_Dihedral_termCode.cc:39:	 tx17 = [01;31m-[00m(y1*z3); 		/* rule 38 */
_Dihedral_termCode.cc:50:	 tx27 = [01;31m-[00m(x4*y3); 		/* rule 49 */
_Dihedral_termCode.cc:51:	 tx28 = [01;31m-[00m(x2*y4); 		/* rule 50 */
_Dihedral_termCode.cc:53:	 tx30 = [01;31m-[00m(x4*z2); 		/* rule 52 */
_Dihedral_termCode.cc:56:	 tx33 = [01;31m-[00m(y4*z3); 		/* rule 55 */
_Dihedral_termCode.cc:58:	 tx35 = [01;31m-[00m(x3*z4); 		/* rule 57 */
_Dihedral_termCode.cc:59:	 tx36 = [01;31m-[00m(y2*z4); 		/* rule 58 */
_Dihedral_termCode.cc:81:	 tx49 = [01;31m-[00mx3; 		/* rule 80 */
_Dihedral_termCode.cc:82:	 tx50 = [01;31m-[00my3; 		/* rule 81 */
_Dihedral_termCode.cc:83:	 tx51 = [01;31m-[00mz3; 		/* rule 82 */
_Dihedral_termCode.cc:100:	CosPhi=MAX([01;31m-[00m1.0,MIN(1.0,CosPhi));
_Dihedral_termCode.cc:112:	 tx70 = [01;31m-[00m(CosNPhi*sinPhase); 		/* rule 111 */
_Dihedral_termCode.cc:114:	 DeDPhi = [01;31m-[00m(DN*EraseLinearDihedral*tx71*V); 		/* rule 113 */
_Dihedral_termCode.cc:116:	 gx1 = [01;31m-[00m(DeDPhi*tx21*tx65*tx72); 		/* rule 115 */
_Dihedral_termCode.cc:117:	 fx1 = [01;31m-[00mgx1; 		/* rule 116 */
_Dihedral_termCode.cc:119:	 gy1 = [01;31m-[00m(DeDPhi*tx20*tx65*tx72); 		/* rule 118 */
_Dihedral_termCode.cc:120:	 fy1 = [01;31m-[00mgy1; 		/* rule 119 */
_Dihedral_termCode.cc:122:	 gz1 = [01;31m-[00m(DeDPhi*tx19*tx65*tx72); 		/* rule 121 */
_Dihedral_termCode.cc:123:	 fz1 = [01;31m-[00mgz1; 		/* rule 122 */
_Dihedral_termCode.cc:125:	 tx73 = [01;31m-[00mx2; 		/* rule 124 */
_Dihedral_termCode.cc:126:	 tx74 = [01;31m-[00my2; 		/* rule 125 */
_Dihedral_termCode.cc:127:	 tx75 = [01;31m-[00mz2; 		/* rule 126 */
_Dihedral_termCode.cc:142:	 tx90 = [01;31m-[00m(tx39*tx85*tx87*tx908); 		/* rule 141 */
_Dihedral_termCode.cc:146:	 fx2 = [01;31m-[00mgx2; 		/* rule 145 */
_Dihedral_termCode.cc:149:	 tx94 = [01;31m-[00m(tx38*tx85*tx87*tx908); 		/* rule 148 */
_Dihedral_termCode.cc:153:	 fy2 = [01;31m-[00mgy2; 		/* rule 152 */
_Dihedral_termCode.cc:156:	 tx98 = [01;31m-[00m(tx40*tx85*tx87*tx908); 		/* rule 155 */
_Dihedral_termCode.cc:160:	 fz2 = [01;31m-[00mgz2; 		/* rule 159 */
_Dihedral_termCode.cc:162:	 tx101 = [01;31m-[00m(tx39*tx65*tx85); 		/* rule 161 */
_Dihedral_termCode.cc:164:	 tx103 = [01;31m-[00mtx91; 		/* rule 163 */
_Dihedral_termCode.cc:167:	 fx3 = [01;31m-[00mgx3; 		/* rule 166 */
_Dihedral_termCode.cc:169:	 tx105 = [01;31m-[00m(tx38*tx65*tx85); 		/* rule 168 */
_Dihedral_termCode.cc:171:	 tx107 = [01;31m-[00mtx95; 		/* rule 170 */
_Dihedral_termCode.cc:174:	 fy3 = [01;31m-[00mgy3; 		/* rule 173 */
_Dihedral_termCode.cc:176:	 tx109 = [01;31m-[00m(tx40*tx65*tx85); 		/* rule 175 */
_Dihedral_termCode.cc:178:	 tx111 = [01;31m-[00mtx99; 		/* rule 177 */
_Dihedral_termCode.cc:181:	 fz3 = [01;31m-[00mgz3; 		/* rule 180 */
_Dihedral_termCode.cc:184:	 fx4 = [01;31m-[00mgx4; 		/* rule 183 */
_Dihedral_termCode.cc:187:	 fy4 = [01;31m-[00mgy4; 		/* rule 186 */
_Dihedral_termCode.cc:190:	 fz4 = [01;31m-[00mgz4; 		/* rule 189 */
_Dihedral_termCode.cc:212:	 tx131 = [01;31m-[00m2.*tx3*y3; 		/* rule 211 */
_Dihedral_termCode.cc:215:	 tx134 = [01;31m-[00m2.*tx15*z2; 		/* rule 214 */
_Dihedral_termCode.cc:225:	 tx144 = [01;31m-[00m(tx139*tx141*tx142*tx24*tx907*V); 		/* rule 224 */
_Dihedral_termCode.cc:237:	 tx154 = [01;31m-[00m2.*tx2*x2; 		/* rule 236 */
_Dihedral_termCode.cc:250:	 tx167 = [01;31m-[00m2.*tx13*z3; 		/* rule 249 */
_Dihedral_termCode.cc:254:	 tx171 = [01;31m-[00m(tx139*tx141*tx142*tx23*tx907*V); 		/* rule 253 */
_Dihedral_termCode.cc:267:	 tx182 = [01;31m-[00m2.*tx7*x3; 		/* rule 266 */
_Dihedral_termCode.cc:269:	 tx184 = [01;31m-[00m2.*tx10*y2; 		/* rule 268 */
_Dihedral_termCode.cc:281:	 tx196 = [01;31m-[00m(tx139*tx141*tx142*tx22*tx907*V); 		/* rule 280 */
_Dihedral_termCode.cc:286:	 tx199 = [01;31m-[00mtx123; 		/* rule 285 */
_Dihedral_termCode.cc:287:	 tx200 = [01;31m-[00mtx124; 		/* rule 286 */
_Dihedral_termCode.cc:288:	 tx201 = [01;31m-[00mtx125; 		/* rule 287 */
_Dihedral_termCode.cc:289:	 tx202 = [01;31m-[00mtx126; 		/* rule 288 */
_Dihedral_termCode.cc:305:	 tx218 = [01;31m-[00m(tx3*y1); 		/* rule 304 */
_Dihedral_termCode.cc:324:	 tx237 = [01;31m-[00m2.*tx129; 		/* rule 323 */
_Dihedral_termCode.cc:325:	 tx238 = [01;31m-[00m2.*tx133; 		/* rule 324 */
_Dihedral_termCode.cc:326:	 tx239 = [01;31m-[00mtx226; 		/* rule 325 */
_Dihedral_termCode.cc:348:	 tx261 = [01;31m-[00m2.*tx26*y3; 		/* rule 347 */
_Dihedral_termCode.cc:356:	 tx269 = [01;31m-[00m2.*tx32*z2; 		/* rule 355 */
_Dihedral_termCode.cc:362:	 tx275 = [01;31m-[00m(tx12*z4); 		/* rule 361 */
_Dihedral_termCode.cc:364:	 tx277 = [01;31m-[00m(tx32*z4); 		/* rule 363 */
_Dihedral_termCode.cc:375:	 tx289 = [01;31m-[00m(tx283*tx286*tx39*tx85); 		/* rule 374 */
_Dihedral_termCode.cc:376:	 tx290 = [01;31m-[00m2.*tx141*tx281*tx908; 		/* rule 375 */
_Dihedral_termCode.cc:377:	 tx291 = [01;31m-[00m2.*tx284*tx285*tx39*tx87*tx908; 		/* rule 376 */
_Dihedral_termCode.cc:382:	 tx296 = [01;31m-[00m(tx139*tx142*tx294*V); 		/* rule 381 */
_Dihedral_termCode.cc:387:	 tx299 = [01;31m-[00mtx158; 		/* rule 386 */
_Dihedral_termCode.cc:388:	 tx300 = [01;31m-[00mtx159; 		/* rule 387 */
_Dihedral_termCode.cc:389:	 tx301 = [01;31m-[00mtx160; 		/* rule 388 */
_Dihedral_termCode.cc:390:	 tx302 = [01;31m-[00mtx161; 		/* rule 389 */
_Dihedral_termCode.cc:413:	 tx325 = [01;31m-[00m(tx13*z1); 		/* rule 412 */
_Dihedral_termCode.cc:423:	 tx335 = [01;31m-[00m2.*tx153; 		/* rule 422 */
_Dihedral_termCode.cc:424:	 tx336 = [01;31m-[00m2.*tx164; 		/* rule 423 */
_Dihedral_termCode.cc:425:	 tx337 = [01;31m-[00mtx312; 		/* rule 424 */
_Dihedral_termCode.cc:436:	 tx348 = [01;31m-[00m2.*tx29*x2; 		/* rule 435 */
_Dihedral_termCode.cc:441:	 tx353 = [01;31m-[00m(tx29*x4); 		/* rule 440 */
_Dihedral_termCode.cc:442:	 tx354 = [01;31m-[00m(tx6*x4); 		/* rule 441 */
_Dihedral_termCode.cc:459:	 tx371 = [01;31m-[00m2.*tx31*z3; 		/* rule 458 */
_Dihedral_termCode.cc:471:	 tx385 = [01;31m-[00m(tx286*tx38*tx381*tx85); 		/* rule 470 */
_Dihedral_termCode.cc:472:	 tx386 = [01;31m-[00m2.*tx141*tx379*tx908; 		/* rule 471 */
_Dihedral_termCode.cc:473:	 tx387 = [01;31m-[00m2.*tx285*tx38*tx382*tx87*tx908; 		/* rule 472 */
_Dihedral_termCode.cc:478:	 tx392 = [01;31m-[00m(tx139*tx142*tx390*V); 		/* rule 477 */
_Dihedral_termCode.cc:483:	 tx395 = [01;31m-[00mtx188; 		/* rule 482 */
_Dihedral_termCode.cc:484:	 tx396 = [01;31m-[00mtx189; 		/* rule 483 */
_Dihedral_termCode.cc:485:	 tx397 = [01;31m-[00mtx190; 		/* rule 484 */
_Dihedral_termCode.cc:486:	 tx398 = [01;31m-[00mtx191; 		/* rule 485 */
_Dihedral_termCode.cc:494:	 tx406 = [01;31m-[00m(tx7*x1); 		/* rule 493 */
_Dihedral_termCode.cc:517:	 tx429 = [01;31m-[00m2.*tx181; 		/* rule 516 */
_Dihedral_termCode.cc:518:	 tx430 = [01;31m-[00m2.*tx183; 		/* rule 517 */
_Dihedral_termCode.cc:519:	 tx431 = [01;31m-[00mtx411; 		/* rule 518 */
_Dihedral_termCode.cc:533:	 tx445 = [01;31m-[00m2.*tx34*x3; 		/* rule 532 */
_Dihedral_termCode.cc:541:	 tx453 = [01;31m-[00m2.*tx37*y2; 		/* rule 540 */
_Dihedral_termCode.cc:546:	 tx458 = [01;31m-[00m(tx18*y4); 		/* rule 545 */
_Dihedral_termCode.cc:548:	 tx460 = [01;31m-[00m(tx37*y4); 		/* rule 547 */
_Dihedral_termCode.cc:565:	 tx479 = [01;31m-[00m(tx286*tx40*tx475*tx85); 		/* rule 564 */
_Dihedral_termCode.cc:566:	 tx480 = [01;31m-[00m2.*tx141*tx473*tx908; 		/* rule 565 */
_Dihedral_termCode.cc:567:	 tx481 = [01;31m-[00m2.*tx285*tx40*tx476*tx87*tx908; 		/* rule 566 */
_Dihedral_termCode.cc:572:	 tx486 = [01;31m-[00m(tx139*tx142*tx483*V); 		/* rule 571 */
_Dihedral_termCode.cc:575:	 tx487 = [01;31m-[00mtx253; 		/* rule 574 */
_Dihedral_termCode.cc:576:	 tx488 = [01;31m-[00mtx254; 		/* rule 575 */
_Dihedral_termCode.cc:577:	 tx489 = [01;31m-[00mtx255; 		/* rule 576 */
_Dihedral_termCode.cc:578:	 tx490 = [01;31m-[00mtx256; 		/* rule 577 */
_Dihedral_termCode.cc:579:	 tx491 = [01;31m-[00mtx263; 		/* rule 578 */
_Dihedral_termCode.cc:580:	 tx492 = [01;31m-[00m2.*tx266; 		/* rule 579 */
_Dihedral_termCode.cc:581:	 tx493 = [01;31m-[00mtx266; 		/* rule 580 */
_Dihedral_termCode.cc:582:	 tx494 = [01;31m-[00m2.*tx272; 		/* rule 581 */
_Dihedral_termCode.cc:604:	 tx518 = [01;31m-[00m2.*tx283*tx285*tx39*tx65; 		/* rule 603 */
_Dihedral_termCode.cc:605:	 tx519 = [01;31m-[00m2.*tx285*tx517*tx908; 		/* rule 604 */
_Dihedral_termCode.cc:609:	 tx523 = [01;31m-[00m(tx139*tx142*tx520*V); 		/* rule 608 */
_Dihedral_termCode.cc:612:	 tx524 = [01;31m-[00m2.*tx349; 		/* rule 611 */
_Dihedral_termCode.cc:613:	 tx525 = [01;31m-[00mtx361; 		/* rule 612 */
_Dihedral_termCode.cc:614:	 tx526 = [01;31m-[00mtx362; 		/* rule 613 */
_Dihedral_termCode.cc:615:	 tx527 = [01;31m-[00mtx363; 		/* rule 614 */
_Dihedral_termCode.cc:616:	 tx528 = [01;31m-[00mtx364; 		/* rule 615 */
_Dihedral_termCode.cc:617:	 tx529 = [01;31m-[00m2.*tx373; 		/* rule 616 */
_Dihedral_termCode.cc:618:	 tx530 = [01;31m-[00mtx373; 		/* rule 617 */
_Dihedral_termCode.cc:619:	 tx531 = [01;31m-[00mtx375; 		/* rule 618 */
_Dihedral_termCode.cc:641:	 tx555 = [01;31m-[00m2.*tx285*tx38*tx381*tx65; 		/* rule 640 */
_Dihedral_termCode.cc:642:	 tx556 = [01;31m-[00m2.*tx285*tx554*tx908; 		/* rule 641 */
_Dihedral_termCode.cc:646:	 tx560 = [01;31m-[00m(tx139*tx142*tx557*V); 		/* rule 645 */
_Dihedral_termCode.cc:649:	 tx561 = [01;31m-[00m2.*tx447; 		/* rule 648 */
_Dihedral_termCode.cc:650:	 tx562 = [01;31m-[00mtx447; 		/* rule 649 */
_Dihedral_termCode.cc:651:	 tx563 = [01;31m-[00mtx450; 		/* rule 650 */
_Dihedral_termCode.cc:652:	 tx564 = [01;31m-[00m2.*tx454; 		/* rule 651 */
_Dihedral_termCode.cc:653:	 tx565 = [01;31m-[00mtx466; 		/* rule 652 */
_Dihedral_termCode.cc:654:	 tx566 = [01;31m-[00mtx467; 		/* rule 653 */
_Dihedral_termCode.cc:655:	 tx567 = [01;31m-[00mtx468; 		/* rule 654 */
_Dihedral_termCode.cc:656:	 tx568 = [01;31m-[00mtx469; 		/* rule 655 */
_Dihedral_termCode.cc:678:	 tx592 = [01;31m-[00m2.*tx285*tx40*tx475*tx65; 		/* rule 677 */
_Dihedral_termCode.cc:679:	 tx593 = [01;31m-[00m2.*tx285*tx591*tx908; 		/* rule 678 */
_Dihedral_termCode.cc:683:	 tx597 = [01;31m-[00m(tx139*tx142*tx594*V); 		/* rule 682 */
_Dihedral_termCode.cc:687:	 tx599 = [01;31m-[00m(tx139*tx142*tx285*tx42*tx907*V); 		/* rule 686 */
_Dihedral_termCode.cc:691:	 tx601 = [01;31m-[00m(tx139*tx142*tx285*tx41*tx907*V); 		/* rule 690 */
_Dihedral_termCode.cc:695:	 tx603 = [01;31m-[00m(tx139*tx142*tx285*tx43*tx907*V); 		/* rule 694 */
_Dihedral_termCode.cc:704:	 tx608 = [01;31m-[00m(tx139*tx141*tx142*tx20*tx21*tx907*V); 		/* rule 703 */
_Dihedral_termCode.cc:711:	 tx613 = [01;31m-[00m(tx139*tx141*tx142*tx19*tx21*tx907*V); 		/* rule 710 */
_Dihedral_termCode.cc:714:	 tx614 = [01;31m-[00m2.*tx140*tx141*tx21*tx65; 		/* rule 713 */
_Dihedral_termCode.cc:724:	 tx622 = [01;31m-[00m(tx141*tx606*tx65); 		/* rule 723 */
_Dihedral_termCode.cc:734:	 tx630 = [01;31m-[00m(tx141*tx611*tx65); 		/* rule 733 */
_Dihedral_termCode.cc:741:	 tx635 = [01;31m-[00m(DeDPhi*tx615); 		/* rule 740 */
_Dihedral_termCode.cc:745:	 tx637 = [01;31m-[00m(DeDPhi*tx623); 		/* rule 744 */
_Dihedral_termCode.cc:749:	 tx639 = [01;31m-[00m(DeDPhi*tx631); 		/* rule 748 */
_Dihedral_termCode.cc:763:	 tx645 = [01;31m-[00m(tx139*tx141*tx142*tx19*tx20*tx907*V); 		/* rule 762 */
_Dihedral_termCode.cc:775:	 tx653 = [01;31m-[00m2.*tx141*tx169*tx20*tx65; 		/* rule 774 */
_Dihedral_termCode.cc:785:	 tx661 = [01;31m-[00m(tx141*tx643*tx65); 		/* rule 784 */
_Dihedral_termCode.cc:792:	 tx666 = [01;31m-[00m(DeDPhi*tx649); 		/* rule 791 */
_Dihedral_termCode.cc:796:	 tx668 = [01;31m-[00m(DeDPhi*tx654); 		/* rule 795 */
_Dihedral_termCode.cc:800:	 tx670 = [01;31m-[00m(DeDPhi*tx662); 		/* rule 799 */
_Dihedral_termCode.cc:828:	 tx686 = [01;31m-[00m2.*tx141*tx19*tx194*tx65; 		/* rule 827 */
_Dihedral_termCode.cc:835:	 tx691 = [01;31m-[00m(DeDPhi*tx675); 		/* rule 834 */
_Dihedral_termCode.cc:839:	 tx693 = [01;31m-[00m(DeDPhi*tx682); 		/* rule 838 */
_Dihedral_termCode.cc:843:	 tx695 = [01;31m-[00m(DeDPhi*tx687); 		/* rule 842 */
_Dihedral_termCode.cc:862:	 tx706 = [01;31m-[00mtx623; 		/* rule 861 */
_Dihedral_termCode.cc:863:	 tx707 = [01;31m-[00mtx649; 		/* rule 862 */
_Dihedral_termCode.cc:866:	 tx710 = [01;31m-[00m0.5*tx286*tx704*tx85; 		/* rule 865 */
_Dihedral_termCode.cc:867:	 tx711 = [01;31m-[00m(tx285*tx705*tx87*tx908); 		/* rule 866 */
_Dihedral_termCode.cc:871:	 tx715 = [01;31m-[00m(tx139*tx142*tx92*tx96*V); 		/* rule 870 */
_Dihedral_termCode.cc:883:	 tx725 = [01;31m-[00mtx631; 		/* rule 882 */
_Dihedral_termCode.cc:885:	 tx727 = [01;31m-[00mtx675; 		/* rule 884 */
_Dihedral_termCode.cc:887:	 tx729 = [01;31m-[00m0.5*tx286*tx723*tx85; 		/* rule 886 */
_Dihedral_termCode.cc:888:	 tx730 = [01;31m-[00m(tx285*tx724*tx87*tx908); 		/* rule 887 */
_Dihedral_termCode.cc:892:	 tx734 = [01;31m-[00m(tx100*tx139*tx142*tx92*V); 		/* rule 891 */
_Dihedral_termCode.cc:895:	 tx735 = [01;31m-[00mtx288; 		/* rule 894 */
_Dihedral_termCode.cc:899:	 tx739 = [01;31m-[00m2.*tx141*tx21*tx282*tx88*tx908; 		/* rule 898 */
_Dihedral_termCode.cc:902:	 tx742 = [01;31m-[00m(tx104*tx139*tx142*tx92*V); 		/* rule 901 */
_Dihedral_termCode.cc:908:	 tx746 = [01;31m-[00mtx712; 		/* rule 907 */
_Dihedral_termCode.cc:909:	 tx747 = [01;31m-[00m0.5*tx286*tx606*tx72; 		/* rule 908 */
_Dihedral_termCode.cc:915:	 tx753 = [01;31m-[00m(tx108*tx139*tx142*tx92*V); 		/* rule 914 */
_Dihedral_termCode.cc:921:	 tx757 = [01;31m-[00m0.5*tx286*tx611*tx72; 		/* rule 920 */
_Dihedral_termCode.cc:922:	 tx758 = [01;31m-[00mtx731; 		/* rule 921 */
_Dihedral_termCode.cc:928:	 tx764 = [01;31m-[00m(tx112*tx139*tx142*tx92*V); 		/* rule 927 */
_Dihedral_termCode.cc:931:	 tx765 = [01;31m-[00m(DeDPhi*tx737); 		/* rule 930 */
_Dihedral_termCode.cc:935:	 tx767 = [01;31m-[00m(DeDPhi*tx749); 		/* rule 934 */
_Dihedral_termCode.cc:939:	 tx769 = [01;31m-[00m(DeDPhi*tx760); 		/* rule 938 */
_Dihedral_termCode.cc:953:	 tx781 = [01;31m-[00mtx662; 		/* rule 952 */
_Dihedral_termCode.cc:954:	 tx782 = [01;31m-[00mtx682; 		/* rule 953 */
_Dihedral_termCode.cc:956:	 tx784 = [01;31m-[00m0.5*tx286*tx778*tx85; 		/* rule 955 */
_Dihedral_termCode.cc:957:	 tx785 = [01;31m-[00m(tx285*tx779*tx87*tx908); 		/* rule 956 */
_Dihedral_termCode.cc:961:	 tx789 = [01;31m-[00m(tx100*tx139*tx142*tx96*V); 		/* rule 960 */
_Dihedral_termCode.cc:970:	 tx796 = [01;31m-[00m(tx104*tx139*tx142*tx96*V); 		/* rule 969 */
_Dihedral_termCode.cc:973:	 tx797 = [01;31m-[00mtx384; 		/* rule 972 */
_Dihedral_termCode.cc:977:	 tx801 = [01;31m-[00m2.*tx141*tx20*tx380*tx88*tx908; 		/* rule 976 */
_Dihedral_termCode.cc:980:	 tx804 = [01;31m-[00m(tx108*tx139*tx142*tx96*V); 		/* rule 979 */
_Dihedral_termCode.cc:986:	 tx808 = [01;31m-[00m0.5*tx286*tx643*tx72; 		/* rule 985 */
_Dihedral_termCode.cc:987:	 tx809 = [01;31m-[00mtx786; 		/* rule 986 */
_Dihedral_termCode.cc:993:	 tx815 = [01;31m-[00m(tx112*tx139*tx142*tx96*V); 		/* rule 992 */
_Dihedral_termCode.cc:996:	 tx816 = [01;31m-[00m(DeDPhi*tx793); 		/* rule 995 */
_Dihedral_termCode.cc:1000:	 tx818 = [01;31m-[00m(DeDPhi*tx799); 		/* rule 999 */
_Dihedral_termCode.cc:1004:	 tx820 = [01;31m-[00m(DeDPhi*tx811); 		/* rule 1003 */
_Dihedral_termCode.cc:1014:	 tx828 = [01;31m-[00m(tx100*tx104*tx139*tx142*V); 		/* rule 1013 */
_Dihedral_termCode.cc:1023:	 tx835 = [01;31m-[00m(tx100*tx108*tx139*tx142*V); 		/* rule 1022 */
_Dihedral_termCode.cc:1026:	 tx836 = [01;31m-[00mtx478; 		/* rule 1025 */
_Dihedral_termCode.cc:1030:	 tx840 = [01;31m-[00m2.*tx141*tx19*tx474*tx88*tx908; 		/* rule 1029 */
_Dihedral_termCode.cc:1033:	 tx843 = [01;31m-[00m(tx100*tx112*tx139*tx142*V); 		/* rule 1032 */
_Dihedral_termCode.cc:1036:	 tx844 = [01;31m-[00m(DeDPhi*tx825); 		/* rule 1035 */
_Dihedral_termCode.cc:1040:	 tx846 = [01;31m-[00m(DeDPhi*tx832); 		/* rule 1039 */
_Dihedral_termCode.cc:1044:	 tx848 = [01;31m-[00m(DeDPhi*tx838); 		/* rule 1043 */
_Dihedral_termCode.cc:1048:	 tx850 = [01;31m-[00m(tx285*tx65*tx704); 		/* rule 1047 */
_Dihedral_termCode.cc:1049:	 tx851 = [01;31m-[00mtx749; 		/* rule 1048 */
_Dihedral_termCode.cc:1050:	 tx852 = [01;31m-[00mtx793; 		/* rule 1049 */
_Dihedral_termCode.cc:1053:	 tx855 = [01;31m-[00m(tx104*tx108*tx139*tx142*V); 		/* rule 1052 */
_Dihedral_termCode.cc:1056:	 tx856 = [01;31m-[00m(tx285*tx65*tx723); 		/* rule 1055 */
_Dihedral_termCode.cc:1057:	 tx857 = [01;31m-[00mtx760; 		/* rule 1056 */
_Dihedral_termCode.cc:1058:	 tx858 = [01;31m-[00mtx825; 		/* rule 1057 */
_Dihedral_termCode.cc:1061:	 tx861 = [01;31m-[00m(tx104*tx112*tx139*tx142*V); 		/* rule 1060 */
_Dihedral_termCode.cc:1082:	 tx874 = [01;31m-[00m(tx285*tx65*tx778); 		/* rule 1081 */
_Dihedral_termCode.cc:1083:	 tx875 = [01;31m-[00mtx811; 		/* rule 1082 */
_Dihedral_termCode.cc:1084:	 tx876 = [01;31m-[00mtx832; 		/* rule 1083 */
_Dihedral_termCode.cc:1087:	 tx879 = [01;31m-[00m(tx108*tx112*tx139*tx142*V); 		/* rule 1086 */
_Dihedral_termCode.cc:1124:	 tx902 = [01;31m-[00m(tx139*tx142*tx285*tx38*tx39*tx907*V); 		/* rule 1123 */
_Dihedral_termCode.cc:1128:	 tx904 = [01;31m-[00m(tx139*tx142*tx285*tx39*tx40*tx907*V); 		/* rule 1127 */
_Dihedral_termCode.cc:1132:	 tx906 = [01;31m-[00m(tx139*tx142*tx285*tx38*tx40*tx907*V); 		/* rule 1131 */
_FixedNonbond_debugEvalSerialize.cc:2:	node[01;31m-[00m>attributeIfNotDefault("evalx1", this[01;31m-[00m>eval.x1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:3: 	node[01;31m-[00m>attributeIfNotDefault("evaly1", this[01;31m-[00m>eval.y1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:4: 	node[01;31m-[00m>attributeIfNotDefault("evalz1", this[01;31m-[00m>eval.z1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:5: 	node[01;31m-[00m>attributeIfNotDefault("evalxf", this[01;31m-[00m>eval.xf, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:6: 	node[01;31m-[00m>attributeIfNotDefault("evalyf", this[01;31m-[00m>eval.yf, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:7: 	node[01;31m-[00m>attributeIfNotDefault("evalzf", this[01;31m-[00m>eval.zf, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:8: 	node[01;31m-[00m>attributeIfNotDefault("evaldA", this[01;31m-[00m>eval.dA, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:9: 	node[01;31m-[00m>attributeIfNotDefault("evaldC", this[01;31m-[00m>eval.dC, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:10: 	node[01;31m-[00m>attributeIfNotDefault("evaldQ1Q2", this[01;31m-[00m>eval.dQ1Q2, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:11: 	node[01;31m-[00m>attributeIfNotDefault("evalEnergy", this[01;31m-[00m>eval.Energy, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:12: 	node[01;31m-[00m>attributeIfNotDefault("evalEfvdw", this[01;31m-[00m>eval.Efvdw, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:13: 	node[01;31m-[00m>attributeIfNotDefault("evalEfeel", this[01;31m-[00m>eval.Efeel, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:14: 	node[01;31m-[00m>attributeIfNotDefault("evalfx1", this[01;31m-[00m>eval.fx1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:15: 	node[01;31m-[00m>attributeIfNotDefault("evalfy1", this[01;31m-[00m>eval.fy1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:16: 	node[01;31m-[00m>attributeIfNotDefault("evalfz1", this[01;31m-[00m>eval.fz1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:17: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx1x1", this[01;31m-[00m>eval.dhx1x1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:18: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy1y1", this[01;31m-[00m>eval.dhy1y1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:19: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz1z1", this[01;31m-[00m>eval.dhz1z1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:20: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y1", this[01;31m-[00m>eval.ohx1y1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:21: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z1", this[01;31m-[00m>eval.ohx1z1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:22: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z1", this[01;31m-[00m>eval.ohy1z1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:23: 	node[01;31m-[00m>attributeIfNotDefault("evalfixedNonbondDistance", this[01;31m-[00m>eval.fixedNonbondDistance, 0.0 );
_FixedNonbond_debugFiniteDifference.cc:3:([01;31m-[00mdelta2 + x1, y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:8:(x1, [01;31m-[00mdelta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:13:(x1, y1, [01;31m-[00mdelta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:18:([01;31m-[00mdelta2 + x1, y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:25:([01;31m-[00mdelta2 + x1, [01;31m-[00mdelta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:26:(delta2 + x1, [01;31m-[00mdelta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:27:([01;31m-[00mdelta2 + x1, delta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:33:([01;31m-[00mdelta2 + x1, y1, [01;31m-[00mdelta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:34:(delta2 + x1, y1, [01;31m-[00mdelta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:35:([01;31m-[00mdelta2 + x1, y1, delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:40:(x1, [01;31m-[00mdelta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:47:(x1, [01;31m-[00mdelta2 + y1, [01;31m-[00mdelta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:48:(x1, delta2 + y1, [01;31m-[00mdelta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:49:(x1, [01;31m-[00mdelta2 + y1, delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:54:(x1, y1, [01;31m-[00mdelta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_termCode.cc:1:// C[01;31m-[00mcode
_FixedNonbond_termCode.cc:12:	 tx1 = [01;31m-[00mxf; 		/* rule 11 */
_FixedNonbond_termCode.cc:13:	 tx2 = [01;31m-[00myf; 		/* rule 12 */
_FixedNonbond_termCode.cc:14:	 tx3 = [01;31m-[00mzf; 		/* rule 13 */
_FixedNonbond_termCode.cc:29:	 tx14 = [01;31m-[00m(dC*tx12); 		/* rule 28 */
_FixedNonbond_termCode.cc:42:	 tx19 = [01;31m-[00m12.*dA*tx16*tx4; 		/* rule 41 */
_FixedNonbond_termCode.cc:44:	 tx21 = [01;31m-[00m(dQ1Q2*tx18*tx4); 		/* rule 43 */
_FixedNonbond_termCode.cc:46:	 fx1 = [01;31m-[00mgx1; 		/* rule 45 */
_FixedNonbond_termCode.cc:48:	 tx22 = [01;31m-[00m12.*dA*tx16*tx5; 		/* rule 47 */
_FixedNonbond_termCode.cc:50:	 tx24 = [01;31m-[00m(dQ1Q2*tx18*tx5); 		/* rule 49 */
_FixedNonbond_termCode.cc:52:	 fy1 = [01;31m-[00mgy1; 		/* rule 51 */
_FixedNonbond_termCode.cc:54:	 tx25 = [01;31m-[00m12.*dA*tx16*tx6; 		/* rule 53 */
_FixedNonbond_termCode.cc:56:	 tx27 = [01;31m-[00m(dQ1Q2*tx18*tx6); 		/* rule 55 */
_FixedNonbond_termCode.cc:58:	 fz1 = [01;31m-[00mgz1; 		/* rule 57 */
_FixedNonbond_termCode.cc:67:	 tx31 = [01;31m-[00m12.*dA*tx16; 		/* rule 66 */
_FixedNonbond_termCode.cc:69:	 tx33 = [01;31m-[00m(dQ1Q2*tx18); 		/* rule 68 */
_FixedNonbond_termCode.cc:71:	 tx35 = [01;31m-[00m48*dC*tx29*tx7; 		/* rule 70 */
_FixedNonbond_termCode.cc:76:	 tx38 = [01;31m-[00m48*dC*tx29*tx8; 		/* rule 75 */
_FixedNonbond_termCode.cc:81:	 tx41 = [01;31m-[00m48*dC*tx29*tx9; 		/* rule 80 */
_FixedNonbond_termCode.cc:88:	 tx44 = [01;31m-[00m48*dC*tx29*tx4*tx5; 		/* rule 87 */
_FixedNonbond_termCode.cc:93:	 tx47 = [01;31m-[00m48*dC*tx29*tx4*tx6; 		/* rule 92 */
_FixedNonbond_termCode.cc:98:	 tx50 = [01;31m-[00m48*dC*tx29*tx5*tx6; 		/* rule 97 */
_ImproperRestraint_debugEvalSerialize.cc:2:	node[01;31m-[00m>attributeIfNotDefault("evalx1", this[01;31m-[00m>eval.x1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:3: 	node[01;31m-[00m>attributeIfNotDefault("evaly1", this[01;31m-[00m>eval.y1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:4: 	node[01;31m-[00m>attributeIfNotDefault("evalz1", this[01;31m-[00m>eval.z1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:5: 	node[01;31m-[00m>attributeIfNotDefault("evalx2", this[01;31m-[00m>eval.x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:6: 	node[01;31m-[00m>attributeIfNotDefault("evaly2", this[01;31m-[00m>eval.y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:7: 	node[01;31m-[00m>attributeIfNotDefault("evalz2", this[01;31m-[00m>eval.z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:8: 	node[01;31m-[00m>attributeIfNotDefault("evalx3", this[01;31m-[00m>eval.x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:9: 	node[01;31m-[00m>attributeIfNotDefault("evaly3", this[01;31m-[00m>eval.y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:10: 	node[01;31m-[00m>attributeIfNotDefault("evalz3", this[01;31m-[00m>eval.z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:11: 	node[01;31m-[00m>attributeIfNotDefault("evalx4", this[01;31m-[00m>eval.x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:12: 	node[01;31m-[00m>attributeIfNotDefault("evaly4", this[01;31m-[00m>eval.y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:13: 	node[01;31m-[00m>attributeIfNotDefault("evalz4", this[01;31m-[00m>eval.z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:14: 	node[01;31m-[00m>attributeIfNotDefault("evalK", this[01;31m-[00m>eval.K, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:15: 	node[01;31m-[00m>attributeIfNotDefault("evalL", this[01;31m-[00m>eval.L, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:16: 	node[01;31m-[00m>attributeIfNotDefault("evalU", this[01;31m-[00m>eval.U, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:17: 	node[01;31m-[00m>attributeIfNotDefault("evalEnergy", this[01;31m-[00m>eval.Energy, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:18: 	node[01;31m-[00m>attributeIfNotDefault("evalfx1", this[01;31m-[00m>eval.fx1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:19: 	node[01;31m-[00m>attributeIfNotDefault("evalfy1", this[01;31m-[00m>eval.fy1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:20: 	node[01;31m-[00m>attributeIfNotDefault("evalfz1", this[01;31m-[00m>eval.fz1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:21: 	node[01;31m-[00m>attributeIfNotDefault("evalfx2", this[01;31m-[00m>eval.fx2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:22: 	node[01;31m-[00m>attributeIfNotDefault("evalfy2", this[01;31m-[00m>eval.fy2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:23: 	node[01;31m-[00m>attributeIfNotDefault("evalfz2", this[01;31m-[00m>eval.fz2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:24: 	node[01;31m-[00m>attributeIfNotDefault("evalfx3", this[01;31m-[00m>eval.fx3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:25: 	node[01;31m-[00m>attributeIfNotDefault("evalfy3", this[01;31m-[00m>eval.fy3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:26: 	node[01;31m-[00m>attributeIfNotDefault("evalfz3", this[01;31m-[00m>eval.fz3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:27: 	node[01;31m-[00m>attributeIfNotDefault("evalfx4", this[01;31m-[00m>eval.fx4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:28: 	node[01;31m-[00m>attributeIfNotDefault("evalfy4", this[01;31m-[00m>eval.fy4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:29: 	node[01;31m-[00m>attributeIfNotDefault("evalfz4", this[01;31m-[00m>eval.fz4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:30: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx1x1", this[01;31m-[00m>eval.dhx1x1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:31: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy1y1", this[01;31m-[00m>eval.dhy1y1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:32: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz1z1", this[01;31m-[00m>eval.dhz1z1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:33: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx2x2", this[01;31m-[00m>eval.dhx2x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:34: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy2y2", this[01;31m-[00m>eval.dhy2y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:35: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz2z2", this[01;31m-[00m>eval.dhz2z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:36: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx3x3", this[01;31m-[00m>eval.dhx3x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:37: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy3y3", this[01;31m-[00m>eval.dhy3y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:38: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz3z3", this[01;31m-[00m>eval.dhz3z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:39: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx4x4", this[01;31m-[00m>eval.dhx4x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:40: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy4y4", this[01;31m-[00m>eval.dhy4y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:41: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz4z4", this[01;31m-[00m>eval.dhz4z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:42: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y1", this[01;31m-[00m>eval.ohx1y1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:43: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z1", this[01;31m-[00m>eval.ohx1z1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:44: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x2", this[01;31m-[00m>eval.ohx1x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:45: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y2", this[01;31m-[00m>eval.ohx1y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:46: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z2", this[01;31m-[00m>eval.ohx1z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:47: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x3", this[01;31m-[00m>eval.ohx1x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:48: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y3", this[01;31m-[00m>eval.ohx1y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:49: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z3", this[01;31m-[00m>eval.ohx1z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:50: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x4", this[01;31m-[00m>eval.ohx1x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:51: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y4", this[01;31m-[00m>eval.ohx1y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:52: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z4", this[01;31m-[00m>eval.ohx1z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:53: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z1", this[01;31m-[00m>eval.ohy1z1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:54: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x2", this[01;31m-[00m>eval.ohy1x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:55: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y2", this[01;31m-[00m>eval.ohy1y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:56: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z2", this[01;31m-[00m>eval.ohy1z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:57: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x3", this[01;31m-[00m>eval.ohy1x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:58: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y3", this[01;31m-[00m>eval.ohy1y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:59: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z3", this[01;31m-[00m>eval.ohy1z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:60: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x4", this[01;31m-[00m>eval.ohy1x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:61: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y4", this[01;31m-[00m>eval.ohy1y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:62: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z4", this[01;31m-[00m>eval.ohy1z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:63: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x2", this[01;31m-[00m>eval.ohz1x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:64: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y2", this[01;31m-[00m>eval.ohz1y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:65: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z2", this[01;31m-[00m>eval.ohz1z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:66: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x3", this[01;31m-[00m>eval.ohz1x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:67: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y3", this[01;31m-[00m>eval.ohz1y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:68: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z3", this[01;31m-[00m>eval.ohz1z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:69: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x4", this[01;31m-[00m>eval.ohz1x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:70: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y4", this[01;31m-[00m>eval.ohz1y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:71: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z4", this[01;31m-[00m>eval.ohz1z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:72: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y2", this[01;31m-[00m>eval.ohx2y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:73: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z2", this[01;31m-[00m>eval.ohx2z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:74: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2x3", this[01;31m-[00m>eval.ohx2x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:75: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y3", this[01;31m-[00m>eval.ohx2y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:76: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z3", this[01;31m-[00m>eval.ohx2z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:77: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2x4", this[01;31m-[00m>eval.ohx2x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:78: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y4", this[01;31m-[00m>eval.ohx2y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:79: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z4", this[01;31m-[00m>eval.ohx2z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:80: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z2", this[01;31m-[00m>eval.ohy2z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:81: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2x3", this[01;31m-[00m>eval.ohy2x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:82: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2y3", this[01;31m-[00m>eval.ohy2y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:83: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z3", this[01;31m-[00m>eval.ohy2z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:84: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2x4", this[01;31m-[00m>eval.ohy2x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:85: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2y4", this[01;31m-[00m>eval.ohy2y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:86: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z4", this[01;31m-[00m>eval.ohy2z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:87: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2x3", this[01;31m-[00m>eval.ohz2x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:88: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2y3", this[01;31m-[00m>eval.ohz2y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:89: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2z3", this[01;31m-[00m>eval.ohz2z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:90: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2x4", this[01;31m-[00m>eval.ohz2x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:91: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2y4", this[01;31m-[00m>eval.ohz2y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:92: 	node[01;31m-[00m>attributeIfNotDefault("evalohz2z4", this[01;31m-[00m>eval.ohz2z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:93: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3y3", this[01;31m-[00m>eval.ohx3y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:94: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3z3", this[01;31m-[00m>eval.ohx3z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:95: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3x4", this[01;31m-[00m>eval.ohx3x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:96: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3y4", this[01;31m-[00m>eval.ohx3y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:97: 	node[01;31m-[00m>attributeIfNotDefault("evalohx3z4", this[01;31m-[00m>eval.ohx3z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:98: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3z3", this[01;31m-[00m>eval.ohy3z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:99: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3x4", this[01;31m-[00m>eval.ohy3x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:100: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3y4", this[01;31m-[00m>eval.ohy3y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:101: 	node[01;31m-[00m>attributeIfNotDefault("evalohy3z4", this[01;31m-[00m>eval.ohy3z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:102: 	node[01;31m-[00m>attributeIfNotDefault("evalohz3x4", this[01;31m-[00m>eval.ohz3x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:103: 	node[01;31m-[00m>attributeIfNotDefault("evalohz3y4", this[01;31m-[00m>eval.ohz3y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:104: 	node[01;31m-[00m>attributeIfNotDefault("evalohz3z4", this[01;31m-[00m>eval.ohz3z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:105: 	node[01;31m-[00m>attributeIfNotDefault("evalohx4y4", this[01;31m-[00m>eval.ohx4y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:106: 	node[01;31m-[00m>attributeIfNotDefault("evalohx4z4", this[01;31m-[00m>eval.ohx4z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:107: 	node[01;31m-[00m>attributeIfNotDefault("evalohy4z4", this[01;31m-[00m>eval.ohy4z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:108: 	node[01;31m-[00m>attributeIfNotDefault("evalPhi", this[01;31m-[00m>eval.Phi, 0.0 );
_ImproperRestraint_debugEvalXml.cc:2:	xml[01;31m-[00m>addAttributeDoubleScientific ("x1", this[01;31m-[00m>eval.x1);
_ImproperRestraint_debugEvalXml.cc:3: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y1", this[01;31m-[00m>eval.y1);
_ImproperRestraint_debugEvalXml.cc:4: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z1", this[01;31m-[00m>eval.z1);
_ImproperRestraint_debugEvalXml.cc:5: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x2", this[01;31m-[00m>eval.x2);
_ImproperRestraint_debugEvalXml.cc:6: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y2", this[01;31m-[00m>eval.y2);
_ImproperRestraint_debugEvalXml.cc:7: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z2", this[01;31m-[00m>eval.z2);
_ImproperRestraint_debugEvalXml.cc:8: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x3", this[01;31m-[00m>eval.x3);
_ImproperRestraint_debugEvalXml.cc:9: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y3", this[01;31m-[00m>eval.y3);
_ImproperRestraint_debugEvalXml.cc:10: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z3", this[01;31m-[00m>eval.z3);
_ImproperRestraint_debugEvalXml.cc:11: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x4", this[01;31m-[00m>eval.x4);
_ImproperRestraint_debugEvalXml.cc:12: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y4", this[01;31m-[00m>eval.y4);
_ImproperRestraint_debugEvalXml.cc:13: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z4", this[01;31m-[00m>eval.z4);
_ImproperRestraint_debugEvalXml.cc:14: 	xml[01;31m-[00m>addAttributeDoubleScientific ("K", this[01;31m-[00m>eval.K);
_ImproperRestraint_debugEvalXml.cc:15: 	xml[01;31m-[00m>addAttributeDoubleScientific ("L", this[01;31m-[00m>eval.L);
_ImproperRestraint_debugEvalXml.cc:16: 	xml[01;31m-[00m>addAttributeDoubleScientific ("U", this[01;31m-[00m>eval.U);
_ImproperRestraint_debugEvalXml.cc:17: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Energy", this[01;31m-[00m>eval.Energy);
_ImproperRestraint_debugEvalXml.cc:18: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx1", this[01;31m-[00m>eval.fx1);
_ImproperRestraint_debugEvalXml.cc:19: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy1", this[01;31m-[00m>eval.fy1);
_ImproperRestraint_debugEvalXml.cc:20: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz1", this[01;31m-[00m>eval.fz1);
_ImproperRestraint_debugEvalXml.cc:21: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx2", this[01;31m-[00m>eval.fx2);
_ImproperRestraint_debugEvalXml.cc:22: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy2", this[01;31m-[00m>eval.fy2);
_ImproperRestraint_debugEvalXml.cc:23: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz2", this[01;31m-[00m>eval.fz2);
_ImproperRestraint_debugEvalXml.cc:24: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx3", this[01;31m-[00m>eval.fx3);
_ImproperRestraint_debugEvalXml.cc:25: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy3", this[01;31m-[00m>eval.fy3);
_ImproperRestraint_debugEvalXml.cc:26: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz3", this[01;31m-[00m>eval.fz3);
_ImproperRestraint_debugEvalXml.cc:27: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx4", this[01;31m-[00m>eval.fx4);
_ImproperRestraint_debugEvalXml.cc:28: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy4", this[01;31m-[00m>eval.fy4);
_ImproperRestraint_debugEvalXml.cc:29: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz4", this[01;31m-[00m>eval.fz4);
_ImproperRestraint_debugEvalXml.cc:30: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx1x1", this[01;31m-[00m>eval.dhx1x1);
_ImproperRestraint_debugEvalXml.cc:31: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy1y1", this[01;31m-[00m>eval.dhy1y1);
_ImproperRestraint_debugEvalXml.cc:32: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz1z1", this[01;31m-[00m>eval.dhz1z1);
_ImproperRestraint_debugEvalXml.cc:33: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx2x2", this[01;31m-[00m>eval.dhx2x2);
_ImproperRestraint_debugEvalXml.cc:34: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy2y2", this[01;31m-[00m>eval.dhy2y2);
_ImproperRestraint_debugEvalXml.cc:35: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz2z2", this[01;31m-[00m>eval.dhz2z2);
_ImproperRestraint_debugEvalXml.cc:36: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx3x3", this[01;31m-[00m>eval.dhx3x3);
_ImproperRestraint_debugEvalXml.cc:37: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy3y3", this[01;31m-[00m>eval.dhy3y3);
_ImproperRestraint_debugEvalXml.cc:38: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz3z3", this[01;31m-[00m>eval.dhz3z3);
_ImproperRestraint_debugEvalXml.cc:39: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx4x4", this[01;31m-[00m>eval.dhx4x4);
_ImproperRestraint_debugEvalXml.cc:40: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy4y4", this[01;31m-[00m>eval.dhy4y4);
_ImproperRestraint_debugEvalXml.cc:41: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz4z4", this[01;31m-[00m>eval.dhz4z4);
_ImproperRestraint_debugEvalXml.cc:42: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y1", this[01;31m-[00m>eval.ohx1y1);
_ImproperRestraint_debugEvalXml.cc:43: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z1", this[01;31m-[00m>eval.ohx1z1);
_ImproperRestraint_debugEvalXml.cc:44: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x2", this[01;31m-[00m>eval.ohx1x2);
_ImproperRestraint_debugEvalXml.cc:45: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y2", this[01;31m-[00m>eval.ohx1y2);
_ImproperRestraint_debugEvalXml.cc:46: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z2", this[01;31m-[00m>eval.ohx1z2);
_ImproperRestraint_debugEvalXml.cc:47: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x3", this[01;31m-[00m>eval.ohx1x3);
_ImproperRestraint_debugEvalXml.cc:48: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y3", this[01;31m-[00m>eval.ohx1y3);
_ImproperRestraint_debugEvalXml.cc:49: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z3", this[01;31m-[00m>eval.ohx1z3);
_ImproperRestraint_debugEvalXml.cc:50: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x4", this[01;31m-[00m>eval.ohx1x4);
_ImproperRestraint_debugEvalXml.cc:51: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y4", this[01;31m-[00m>eval.ohx1y4);
_ImproperRestraint_debugEvalXml.cc:52: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z4", this[01;31m-[00m>eval.ohx1z4);
_ImproperRestraint_debugEvalXml.cc:53: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z1", this[01;31m-[00m>eval.ohy1z1);
_ImproperRestraint_debugEvalXml.cc:54: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x2", this[01;31m-[00m>eval.ohy1x2);
_ImproperRestraint_debugEvalXml.cc:55: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y2", this[01;31m-[00m>eval.ohy1y2);
_ImproperRestraint_debugEvalXml.cc:56: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z2", this[01;31m-[00m>eval.ohy1z2);
_ImproperRestraint_debugEvalXml.cc:57: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x3", this[01;31m-[00m>eval.ohy1x3);
_ImproperRestraint_debugEvalXml.cc:58: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y3", this[01;31m-[00m>eval.ohy1y3);
_ImproperRestraint_debugEvalXml.cc:59: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z3", this[01;31m-[00m>eval.ohy1z3);
_ImproperRestraint_debugEvalXml.cc:60: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x4", this[01;31m-[00m>eval.ohy1x4);
_ImproperRestraint_debugEvalXml.cc:61: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y4", this[01;31m-[00m>eval.ohy1y4);
_ImproperRestraint_debugEvalXml.cc:62: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z4", this[01;31m-[00m>eval.ohy1z4);
_ImproperRestraint_debugEvalXml.cc:63: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x2", this[01;31m-[00m>eval.ohz1x2);
_ImproperRestraint_debugEvalXml.cc:64: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y2", this[01;31m-[00m>eval.ohz1y2);
_ImproperRestraint_debugEvalXml.cc:65: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z2", this[01;31m-[00m>eval.ohz1z2);
_ImproperRestraint_debugEvalXml.cc:66: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x3", this[01;31m-[00m>eval.ohz1x3);
_ImproperRestraint_debugEvalXml.cc:67: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y3", this[01;31m-[00m>eval.ohz1y3);
_ImproperRestraint_debugEvalXml.cc:68: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z3", this[01;31m-[00m>eval.ohz1z3);
_ImproperRestraint_debugEvalXml.cc:69: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x4", this[01;31m-[00m>eval.ohz1x4);
_ImproperRestraint_debugEvalXml.cc:70: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y4", this[01;31m-[00m>eval.ohz1y4);
_ImproperRestraint_debugEvalXml.cc:71: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z4", this[01;31m-[00m>eval.ohz1z4);
_ImproperRestraint_debugEvalXml.cc:72: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y2", this[01;31m-[00m>eval.ohx2y2);
_ImproperRestraint_debugEvalXml.cc:73: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z2", this[01;31m-[00m>eval.ohx2z2);
_ImproperRestraint_debugEvalXml.cc:74: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2x3", this[01;31m-[00m>eval.ohx2x3);
_ImproperRestraint_debugEvalXml.cc:75: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y3", this[01;31m-[00m>eval.ohx2y3);
_ImproperRestraint_debugEvalXml.cc:76: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z3", this[01;31m-[00m>eval.ohx2z3);
_ImproperRestraint_debugEvalXml.cc:77: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2x4", this[01;31m-[00m>eval.ohx2x4);
_ImproperRestraint_debugEvalXml.cc:78: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y4", this[01;31m-[00m>eval.ohx2y4);
_ImproperRestraint_debugEvalXml.cc:79: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z4", this[01;31m-[00m>eval.ohx2z4);
_ImproperRestraint_debugEvalXml.cc:80: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z2", this[01;31m-[00m>eval.ohy2z2);
_ImproperRestraint_debugEvalXml.cc:81: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2x3", this[01;31m-[00m>eval.ohy2x3);
_ImproperRestraint_debugEvalXml.cc:82: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2y3", this[01;31m-[00m>eval.ohy2y3);
_ImproperRestraint_debugEvalXml.cc:83: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z3", this[01;31m-[00m>eval.ohy2z3);
_ImproperRestraint_debugEvalXml.cc:84: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2x4", this[01;31m-[00m>eval.ohy2x4);
_ImproperRestraint_debugEvalXml.cc:85: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2y4", this[01;31m-[00m>eval.ohy2y4);
_ImproperRestraint_debugEvalXml.cc:86: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z4", this[01;31m-[00m>eval.ohy2z4);
_ImproperRestraint_debugEvalXml.cc:87: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2x3", this[01;31m-[00m>eval.ohz2x3);
_ImproperRestraint_debugEvalXml.cc:88: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2y3", this[01;31m-[00m>eval.ohz2y3);
_ImproperRestraint_debugEvalXml.cc:89: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2z3", this[01;31m-[00m>eval.ohz2z3);
_ImproperRestraint_debugEvalXml.cc:90: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2x4", this[01;31m-[00m>eval.ohz2x4);
_ImproperRestraint_debugEvalXml.cc:91: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2y4", this[01;31m-[00m>eval.ohz2y4);
_ImproperRestraint_debugEvalXml.cc:92: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz2z4", this[01;31m-[00m>eval.ohz2z4);
_ImproperRestraint_debugEvalXml.cc:93: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3y3", this[01;31m-[00m>eval.ohx3y3);
_ImproperRestraint_debugEvalXml.cc:94: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3z3", this[01;31m-[00m>eval.ohx3z3);
_ImproperRestraint_debugEvalXml.cc:95: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3x4", this[01;31m-[00m>eval.ohx3x4);
_ImproperRestraint_debugEvalXml.cc:96: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3y4", this[01;31m-[00m>eval.ohx3y4);
_ImproperRestraint_debugEvalXml.cc:97: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx3z4", this[01;31m-[00m>eval.ohx3z4);
_ImproperRestraint_debugEvalXml.cc:98: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3z3", this[01;31m-[00m>eval.ohy3z3);
_ImproperRestraint_debugEvalXml.cc:99: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3x4", this[01;31m-[00m>eval.ohy3x4);
_ImproperRestraint_debugEvalXml.cc:100: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3y4", this[01;31m-[00m>eval.ohy3y4);
_ImproperRestraint_debugEvalXml.cc:101: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy3z4", this[01;31m-[00m>eval.ohy3z4);
_ImproperRestraint_debugEvalXml.cc:102: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz3x4", this[01;31m-[00m>eval.ohz3x4);
_ImproperRestraint_debugEvalXml.cc:103: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz3y4", this[01;31m-[00m>eval.ohz3y4);
_ImproperRestraint_debugEvalXml.cc:104: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz3z4", this[01;31m-[00m>eval.ohz3z4);
_ImproperRestraint_debugEvalXml.cc:105: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx4y4", this[01;31m-[00m>eval.ohx4y4);
_ImproperRestraint_debugEvalXml.cc:106: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx4z4", this[01;31m-[00m>eval.ohx4z4);
_ImproperRestraint_debugEvalXml.cc:107: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy4z4", this[01;31m-[00m>eval.ohy4z4);
_ImproperRestraint_debugEvalXml.cc:108: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Phi", this[01;31m-[00m>eval.Phi);
_ImproperRestraint_debugFiniteDifference.cc:3:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:8:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:13:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:18:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:23:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:33:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:38:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:43:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:48:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:53:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:58:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:63:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:70:([01;31m-[00mdelta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:71:(delta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:72:([01;31m-[00mdelta2 + x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:78:([01;31m-[00mdelta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:79:(delta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:80:([01;31m-[00mdelta2 + x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:86:([01;31m-[00mdelta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:87:(delta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:88:([01;31m-[00mdelta2 + x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:94:([01;31m-[00mdelta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:95:(delta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:96:([01;31m-[00mdelta2 + x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:102:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:103:(delta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:104:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:110:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:111:(delta2 + x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:112:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:118:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:119:(delta2 + x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:120:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:126:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:127:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:128:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:134:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:135:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:136:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:142:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:143:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:144:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:150:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:151:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:152:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:157:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:164:(x1, [01;31m-[00mdelta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:165:(x1, delta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:166:(x1, [01;31m-[00mdelta2 + y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:172:(x1, [01;31m-[00mdelta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:173:(x1, delta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:174:(x1, [01;31m-[00mdelta2 + y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:180:(x1, [01;31m-[00mdelta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:181:(x1, delta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:182:(x1, [01;31m-[00mdelta2 + y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:188:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:189:(x1, delta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:190:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:196:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:197:(x1, delta2 + y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:198:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:204:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:205:(x1, delta2 + y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:206:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:212:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:213:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:214:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:220:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:221:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:222:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:228:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:229:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:230:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:236:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:237:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:238:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:243:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:250:(x1, y1, [01;31m-[00mdelta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:251:(x1, y1, delta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:252:(x1, y1, [01;31m-[00mdelta2 + z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:258:(x1, y1, [01;31m-[00mdelta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:259:(x1, y1, delta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:260:(x1, y1, [01;31m-[00mdelta2 + z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:266:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:267:(x1, y1, delta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:268:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:274:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:275:(x1, y1, delta2 + z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:276:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:282:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:283:(x1, y1, delta2 + z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:284:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:290:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:291:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:292:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:298:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:299:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:300:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:306:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:307:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:308:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:314:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:315:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:316:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:321:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:328:(x1, y1, z1, [01;31m-[00mdelta2 + x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:329:(x1, y1, z1, delta2 + x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:330:(x1, y1, z1, [01;31m-[00mdelta2 + x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:336:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:337:(x1, y1, z1, delta2 + x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:338:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:344:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:345:(x1, y1, z1, delta2 + x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:346:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:352:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:353:(x1, y1, z1, delta2 + x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:354:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:360:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:361:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:362:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:368:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:369:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:370:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:376:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:377:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:378:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:384:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:385:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:386:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:391:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:398:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:399:(x1, y1, z1, x2, delta2 + y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:400:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:406:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:407:(x1, y1, z1, x2, delta2 + y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:408:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:414:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:415:(x1, y1, z1, x2, delta2 + y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:416:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:422:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:423:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:424:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:430:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:431:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:432:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:438:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:439:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:440:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:446:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:447:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:448:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:453:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:460:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:461:(x1, y1, z1, x2, y2, delta2 + z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:462:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:468:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:469:(x1, y1, z1, x2, y2, delta2 + z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:470:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:476:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:477:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:478:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:484:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:485:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:486:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:492:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:493:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:494:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:500:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:501:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:502:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:507:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:514:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:515:(x1, y1, z1, x2, y2, z2, delta2 + x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:516:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:522:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:523:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:524:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:530:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:531:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:532:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:538:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:539:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:540:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:546:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:547:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:548:(x1, y1, z1, x2, y2, z2, [01;31m-[00mdelta2 + x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:553:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:560:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:561:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:562:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:568:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:569:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:570:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:576:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:577:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:578:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:584:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:585:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:586:(x1, y1, z1, x2, y2, z2, x3, [01;31m-[00mdelta2 + y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:591:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:598:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:599:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:600:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:606:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:607:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:608:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:614:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:615:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:616:(x1, y1, z1, x2, y2, z2, x3, y3, [01;31m-[00mdelta2 + z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:621:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:628:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:629:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:630:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:636:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:637:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:638:(x1, y1, z1, x2, y2, z2, x3, y3, z3, [01;31m-[00mdelta2 + x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:643:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:650:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:651:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:652:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, [01;31m-[00mdelta2 + y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:657:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, [01;31m-[00mdelta2 + z4, K, L, U),
_ImproperRestraint_termCode.cc:1:// C[01;31m-[00mcode
_ImproperRestraint_termCode.cc:113:	 tx1 = [01;31m-[00m(x2*y1); 		/* rule 21 */
_ImproperRestraint_termCode.cc:116:	 tx4 = [01;31m-[00m(x3*y2); 		/* rule 24 */
_ImproperRestraint_termCode.cc:117:	 tx5 = [01;31m-[00m(x1*y3); 		/* rule 25 */
_ImproperRestraint_termCode.cc:120:	 tx8 = [01;31m-[00m(x3*z1); 		/* rule 28 */
_ImproperRestraint_termCode.cc:121:	 tx9 = [01;31m-[00m(y2*z1); 		/* rule 29 */
_ImproperRestraint_termCode.cc:123:	 tx11 = [01;31m-[00m(x1*z2); 		/* rule 31 */
_ImproperRestraint_termCode.cc:126:	 tx14 = [01;31m-[00m(y3*z2); 		/* rule 34 */
_ImproperRestraint_termCode.cc:128:	 tx16 = [01;31m-[00m(x2*z3); 		/* rule 36 */
_ImproperRestraint_termCode.cc:129:	 tx17 = [01;31m-[00m(y1*z3); 		/* rule 37 */
_ImproperRestraint_termCode.cc:140:	 tx27 = [01;31m-[00m(x4*y3); 		/* rule 48 */
_ImproperRestraint_termCode.cc:141:	 tx28 = [01;31m-[00m(x2*y4); 		/* rule 49 */
_ImproperRestraint_termCode.cc:143:	 tx30 = [01;31m-[00m(x4*z2); 		/* rule 51 */
_ImproperRestraint_termCode.cc:146:	 tx33 = [01;31m-[00m(y4*z3); 		/* rule 54 */
_ImproperRestraint_termCode.cc:148:	 tx35 = [01;31m-[00m(x3*z4); 		/* rule 56 */
_ImproperRestraint_termCode.cc:149:	 tx36 = [01;31m-[00m(y2*z4); 		/* rule 57 */
_ImproperRestraint_termCode.cc:171:	 tx49 = [01;31m-[00mx3; 		/* rule 79 */
_ImproperRestraint_termCode.cc:172:	 tx50 = [01;31m-[00my3; 		/* rule 80 */
_ImproperRestraint_termCode.cc:173:	 tx51 = [01;31m-[00mz3; 		/* rule 81 */
_ImproperRestraint_termCode.cc:190:	CosPhi=MAX([01;31m-[00m1.0,MIN(1.0,CosPhi));
_ImproperRestraint_termCode.cc:234:	 tx67 = [01;31m-[00mL; 		/* rule 111 */
_ImproperRestraint_termCode.cc:240:	 tx72 = [01;31m-[00mtx71; 		/* rule 117 */
_ImproperRestraint_termCode.cc:251:	 gx1 = [01;31m-[00m(DEImproperRestraintDPhi*tx21*tx65*tx77); 		/* rule 128 */
_ImproperRestraint_termCode.cc:252:	 fx1 = [01;31m-[00mgx1; 		/* rule 129 */
_ImproperRestraint_termCode.cc:254:	 gy1 = [01;31m-[00m(DEImproperRestraintDPhi*tx20*tx65*tx77); 		/* rule 131 */
_ImproperRestraint_termCode.cc:255:	 fy1 = [01;31m-[00mgy1; 		/* rule 132 */
_ImproperRestraint_termCode.cc:257:	 gz1 = [01;31m-[00m(DEImproperRestraintDPhi*tx19*tx65*tx77); 		/* rule 134 */
_ImproperRestraint_termCode.cc:258:	 fz1 = [01;31m-[00mgz1; 		/* rule 135 */
_ImproperRestraint_termCode.cc:260:	 tx78 = [01;31m-[00mx2; 		/* rule 137 */
_ImproperRestraint_termCode.cc:261:	 tx79 = [01;31m-[00my2; 		/* rule 138 */
_ImproperRestraint_termCode.cc:262:	 tx80 = [01;31m-[00mz2; 		/* rule 139 */
_ImproperRestraint_termCode.cc:277:	 tx95 = [01;31m-[00m(tx39*tx90*tx918*tx92); 		/* rule 154 */
_ImproperRestraint_termCode.cc:281:	 fx2 = [01;31m-[00mgx2; 		/* rule 158 */
_ImproperRestraint_termCode.cc:284:	 tx99 = [01;31m-[00m(tx38*tx90*tx918*tx92); 		/* rule 161 */
_ImproperRestraint_termCode.cc:288:	 fy2 = [01;31m-[00mgy2; 		/* rule 165 */
_ImproperRestraint_termCode.cc:291:	 tx103 = [01;31m-[00m(tx40*tx90*tx918*tx92); 		/* rule 168 */
_ImproperRestraint_termCode.cc:295:	 fz2 = [01;31m-[00mgz2; 		/* rule 172 */
_ImproperRestraint_termCode.cc:297:	 tx106 = [01;31m-[00m(tx39*tx65*tx90); 		/* rule 174 */
_ImproperRestraint_termCode.cc:299:	 tx108 = [01;31m-[00mtx96; 		/* rule 176 */
_ImproperRestraint_termCode.cc:302:	 fx3 = [01;31m-[00mgx3; 		/* rule 179 */
_ImproperRestraint_termCode.cc:304:	 tx110 = [01;31m-[00mtx100; 		/* rule 181 */
_ImproperRestraint_termCode.cc:305:	 tx111 = [01;31m-[00m(tx38*tx65*tx90); 		/* rule 182 */
_ImproperRestraint_termCode.cc:309:	 fy3 = [01;31m-[00mgy3; 		/* rule 186 */
_ImproperRestraint_termCode.cc:311:	 tx114 = [01;31m-[00mtx104; 		/* rule 188 */
_ImproperRestraint_termCode.cc:312:	 tx115 = [01;31m-[00m(tx40*tx65*tx90); 		/* rule 189 */
_ImproperRestraint_termCode.cc:316:	 fz3 = [01;31m-[00mgz3; 		/* rule 193 */
_ImproperRestraint_termCode.cc:319:	 fx4 = [01;31m-[00mgx4; 		/* rule 196 */
_ImproperRestraint_termCode.cc:322:	 fy4 = [01;31m-[00mgy4; 		/* rule 199 */
_ImproperRestraint_termCode.cc:325:	 fz4 = [01;31m-[00mgz4; 		/* rule 202 */
_ImproperRestraint_termCode.cc:352:	 tx141 = [01;31m-[00m2.*tx3*y3; 		/* rule 229 */
_ImproperRestraint_termCode.cc:355:	 tx144 = [01;31m-[00m2.*tx15*z2; 		/* rule 232 */
_ImproperRestraint_termCode.cc:376:	 tx163 = [01;31m-[00m2.*tx2*x2; 		/* rule 253 */
_ImproperRestraint_termCode.cc:389:	 tx176 = [01;31m-[00m2.*tx13*z3; 		/* rule 266 */
_ImproperRestraint_termCode.cc:406:	 tx191 = [01;31m-[00m2.*tx7*x3; 		/* rule 283 */
_ImproperRestraint_termCode.cc:408:	 tx193 = [01;31m-[00m2.*tx10*y2; 		/* rule 285 */
_ImproperRestraint_termCode.cc:425:	 tx208 = [01;31m-[00mtx133; 		/* rule 302 */
_ImproperRestraint_termCode.cc:426:	 tx209 = [01;31m-[00mtx134; 		/* rule 303 */
_ImproperRestraint_termCode.cc:427:	 tx210 = [01;31m-[00mtx135; 		/* rule 304 */
_ImproperRestraint_termCode.cc:428:	 tx211 = [01;31m-[00mtx136; 		/* rule 305 */
_ImproperRestraint_termCode.cc:444:	 tx227 = [01;31m-[00m(tx3*y1); 		/* rule 321 */
_ImproperRestraint_termCode.cc:463:	 tx246 = [01;31m-[00m2.*tx139; 		/* rule 340 */
_ImproperRestraint_termCode.cc:464:	 tx247 = [01;31m-[00m2.*tx143; 		/* rule 341 */
_ImproperRestraint_termCode.cc:465:	 tx248 = [01;31m-[00mtx235; 		/* rule 342 */
_ImproperRestraint_termCode.cc:487:	 tx270 = [01;31m-[00m2.*tx26*y3; 		/* rule 364 */
_ImproperRestraint_termCode.cc:495:	 tx278 = [01;31m-[00m2.*tx32*z2; 		/* rule 372 */
_ImproperRestraint_termCode.cc:501:	 tx284 = [01;31m-[00m(tx12*z4); 		/* rule 378 */
_ImproperRestraint_termCode.cc:503:	 tx286 = [01;31m-[00m(tx32*z4); 		/* rule 380 */
_ImproperRestraint_termCode.cc:514:	 tx298 = [01;31m-[00m(tx292*tx295*tx39*tx90); 		/* rule 391 */
_ImproperRestraint_termCode.cc:515:	 tx299 = [01;31m-[00m2.*tx151*tx290*tx918; 		/* rule 392 */
_ImproperRestraint_termCode.cc:516:	 tx300 = [01;31m-[00m2.*tx293*tx294*tx39*tx918*tx92; 		/* rule 393 */
_ImproperRestraint_termCode.cc:526:	 tx308 = [01;31m-[00mtx167; 		/* rule 403 */
_ImproperRestraint_termCode.cc:527:	 tx309 = [01;31m-[00mtx168; 		/* rule 404 */
_ImproperRestraint_termCode.cc:528:	 tx310 = [01;31m-[00mtx169; 		/* rule 405 */
_ImproperRestraint_termCode.cc:529:	 tx311 = [01;31m-[00mtx170; 		/* rule 406 */
_ImproperRestraint_termCode.cc:552:	 tx334 = [01;31m-[00m(tx13*z1); 		/* rule 429 */
_ImproperRestraint_termCode.cc:562:	 tx344 = [01;31m-[00m2.*tx162; 		/* rule 439 */
_ImproperRestraint_termCode.cc:563:	 tx345 = [01;31m-[00m2.*tx173; 		/* rule 440 */
_ImproperRestraint_termCode.cc:564:	 tx346 = [01;31m-[00mtx321; 		/* rule 441 */
_ImproperRestraint_termCode.cc:575:	 tx357 = [01;31m-[00m2.*tx29*x2; 		/* rule 452 */
_ImproperRestraint_termCode.cc:580:	 tx362 = [01;31m-[00m(tx29*x4); 		/* rule 457 */
_ImproperRestraint_termCode.cc:581:	 tx363 = [01;31m-[00m(tx6*x4); 		/* rule 458 */
_ImproperRestraint_termCode.cc:598:	 tx380 = [01;31m-[00m2.*tx31*z3; 		/* rule 475 */
_ImproperRestraint_termCode.cc:610:	 tx394 = [01;31m-[00m(tx295*tx38*tx390*tx90); 		/* rule 487 */
_ImproperRestraint_termCode.cc:611:	 tx395 = [01;31m-[00m2.*tx151*tx388*tx918; 		/* rule 488 */
_ImproperRestraint_termCode.cc:612:	 tx396 = [01;31m-[00m2.*tx294*tx38*tx391*tx918*tx92; 		/* rule 489 */
_ImproperRestraint_termCode.cc:622:	 tx404 = [01;31m-[00mtx197; 		/* rule 499 */
_ImproperRestraint_termCode.cc:623:	 tx405 = [01;31m-[00mtx198; 		/* rule 500 */
_ImproperRestraint_termCode.cc:624:	 tx406 = [01;31m-[00mtx199; 		/* rule 501 */
_ImproperRestraint_termCode.cc:625:	 tx407 = [01;31m-[00mtx200; 		/* rule 502 */
_ImproperRestraint_termCode.cc:633:	 tx415 = [01;31m-[00m(tx7*x1); 		/* rule 510 */
_ImproperRestraint_termCode.cc:656:	 tx438 = [01;31m-[00m2.*tx190; 		/* rule 533 */
_ImproperRestraint_termCode.cc:657:	 tx439 = [01;31m-[00m2.*tx192; 		/* rule 534 */
_ImproperRestraint_termCode.cc:658:	 tx440 = [01;31m-[00mtx420; 		/* rule 535 */
_ImproperRestraint_termCode.cc:672:	 tx454 = [01;31m-[00m2.*tx34*x3; 		/* rule 549 */
_ImproperRestraint_termCode.cc:680:	 tx462 = [01;31m-[00m2.*tx37*y2; 		/* rule 557 */
_ImproperRestraint_termCode.cc:685:	 tx467 = [01;31m-[00m(tx18*y4); 		/* rule 562 */
_ImproperRestraint_termCode.cc:687:	 tx469 = [01;31m-[00m(tx37*y4); 		/* rule 564 */
_ImproperRestraint_termCode.cc:704:	 tx488 = [01;31m-[00m(tx295*tx40*tx484*tx90); 		/* rule 581 */
_ImproperRestraint_termCode.cc:705:	 tx489 = [01;31m-[00m2.*tx151*tx482*tx918; 		/* rule 582 */
_ImproperRestraint_termCode.cc:706:	 tx490 = [01;31m-[00m2.*tx294*tx40*tx485*tx918*tx92; 		/* rule 583 */
_ImproperRestraint_termCode.cc:714:	 tx496 = [01;31m-[00mtx262; 		/* rule 591 */
_ImproperRestraint_termCode.cc:715:	 tx497 = [01;31m-[00mtx263; 		/* rule 592 */
_ImproperRestraint_termCode.cc:716:	 tx498 = [01;31m-[00mtx264; 		/* rule 593 */
_ImproperRestraint_termCode.cc:717:	 tx499 = [01;31m-[00mtx265; 		/* rule 594 */
_ImproperRestraint_termCode.cc:718:	 tx500 = [01;31m-[00mtx272; 		/* rule 595 */
_ImproperRestraint_termCode.cc:719:	 tx501 = [01;31m-[00m2.*tx275; 		/* rule 596 */
_ImproperRestraint_termCode.cc:720:	 tx502 = [01;31m-[00mtx275; 		/* rule 597 */
_ImproperRestraint_termCode.cc:721:	 tx503 = [01;31m-[00m2.*tx281; 		/* rule 598 */
_ImproperRestraint_termCode.cc:743:	 tx527 = [01;31m-[00m2.*tx292*tx294*tx39*tx65; 		/* rule 620 */
_ImproperRestraint_termCode.cc:744:	 tx528 = [01;31m-[00m2.*tx294*tx526*tx918; 		/* rule 621 */
_ImproperRestraint_termCode.cc:751:	 tx533 = [01;31m-[00m2.*tx358; 		/* rule 628 */
_ImproperRestraint_termCode.cc:752:	 tx534 = [01;31m-[00mtx370; 		/* rule 629 */
_ImproperRestraint_termCode.cc:753:	 tx535 = [01;31m-[00mtx371; 		/* rule 630 */
_ImproperRestraint_termCode.cc:754:	 tx536 = [01;31m-[00mtx372; 		/* rule 631 */
_ImproperRestraint_termCode.cc:755:	 tx537 = [01;31m-[00mtx373; 		/* rule 632 */
_ImproperRestraint_termCode.cc:756:	 tx538 = [01;31m-[00m2.*tx382; 		/* rule 633 */
_ImproperRestraint_termCode.cc:757:	 tx539 = [01;31m-[00mtx382; 		/* rule 634 */
_ImproperRestraint_termCode.cc:758:	 tx540 = [01;31m-[00mtx384; 		/* rule 635 */
_ImproperRestraint_termCode.cc:780:	 tx564 = [01;31m-[00m2.*tx294*tx38*tx390*tx65; 		/* rule 657 */
_ImproperRestraint_termCode.cc:781:	 tx565 = [01;31m-[00m2.*tx294*tx563*tx918; 		/* rule 658 */
_ImproperRestraint_termCode.cc:788:	 tx570 = [01;31m-[00m2.*tx456; 		/* rule 665 */
_ImproperRestraint_termCode.cc:789:	 tx571 = [01;31m-[00mtx456; 		/* rule 666 */
_ImproperRestraint_termCode.cc:790:	 tx572 = [01;31m-[00mtx459; 		/* rule 667 */
_ImproperRestraint_termCode.cc:791:	 tx573 = [01;31m-[00m2.*tx463; 		/* rule 668 */
_ImproperRestraint_termCode.cc:792:	 tx574 = [01;31m-[00mtx475; 		/* rule 669 */
_ImproperRestraint_termCode.cc:793:	 tx575 = [01;31m-[00mtx476; 		/* rule 670 */
_ImproperRestraint_termCode.cc:794:	 tx576 = [01;31m-[00mtx477; 		/* rule 671 */
_ImproperRestraint_termCode.cc:795:	 tx577 = [01;31m-[00mtx478; 		/* rule 672 */
_ImproperRestraint_termCode.cc:817:	 tx601 = [01;31m-[00m2.*tx294*tx40*tx484*tx65; 		/* rule 694 */
_ImproperRestraint_termCode.cc:818:	 tx602 = [01;31m-[00m2.*tx294*tx600*tx918; 		/* rule 695 */
_ImproperRestraint_termCode.cc:826:	 tx608 = [01;31m-[00m6.*EraseLinearDihedral*K*TWOPI*tx292*tx294*tx39*tx65*tx70*tx75*tx76; 		/* rule 703 */
_ImproperRestraint_termCode.cc:830:	 tx610 = [01;31m-[00m6.*EraseLinearDihedral*K*TWOPI*tx294*tx38*tx390*tx65*tx70*tx75*tx76; 		/* rule 707 */
_ImproperRestraint_termCode.cc:834:	 tx612 = [01;31m-[00m6.*EraseLinearDihedral*K*TWOPI*tx294*tx40*tx484*tx65*tx70*tx75*tx76; 		/* rule 711 */
_ImproperRestraint_termCode.cc:853:	 tx623 = [01;31m-[00m2.*tx150*tx151*tx21*tx65; 		/* rule 730 */
_ImproperRestraint_termCode.cc:857:	 tx627 = [01;31m-[00m(tx149*tx94*tx97); 		/* rule 734 */
_ImproperRestraint_termCode.cc:863:	 tx631 = [01;31m-[00m(tx151*tx615*tx65); 		/* rule 740 */
_ImproperRestraint_termCode.cc:867:	 tx635 = [01;31m-[00m(tx101*tx149*tx94); 		/* rule 744 */
_ImproperRestraint_termCode.cc:873:	 tx639 = [01;31m-[00m(tx151*tx620*tx65); 		/* rule 750 */
_ImproperRestraint_termCode.cc:877:	 tx643 = [01;31m-[00m(tx105*tx149*tx94); 		/* rule 754 */
_ImproperRestraint_termCode.cc:880:	 tx644 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx624*tx70*tx75*tx76; 		/* rule 757 */
_ImproperRestraint_termCode.cc:881:	 tx645 = [01;31m-[00m(tx109*tx149*tx94); 		/* rule 758 */
_ImproperRestraint_termCode.cc:884:	 tx646 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx632*tx70*tx75*tx76; 		/* rule 761 */
_ImproperRestraint_termCode.cc:885:	 tx647 = [01;31m-[00m(tx113*tx149*tx94); 		/* rule 762 */
_ImproperRestraint_termCode.cc:888:	 tx648 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx640*tx70*tx75*tx76; 		/* rule 765 */
_ImproperRestraint_termCode.cc:889:	 tx649 = [01;31m-[00m(tx117*tx149*tx94); 		/* rule 766 */
_ImproperRestraint_termCode.cc:892:	 ohx1x4 = [01;31m-[00m(tx149*tx46*tx77*tx90*tx917); 		/* rule 769 */
_ImproperRestraint_termCode.cc:894:	 ohx1y4 = [01;31m-[00m(tx149*tx21*tx38*tx77*tx90*tx917); 		/* rule 771 */
_ImproperRestraint_termCode.cc:896:	 ohx1z4 = [01;31m-[00m(tx149*tx21*tx40*tx77*tx90*tx917); 		/* rule 773 */
_ImproperRestraint_termCode.cc:911:	 tx661 = [01;31m-[00m(tx149*tx97*tx98); 		/* rule 788 */
_ImproperRestraint_termCode.cc:914:	 tx662 = [01;31m-[00m2.*tx151*tx178*tx20*tx65; 		/* rule 791 */
_ImproperRestraint_termCode.cc:918:	 tx666 = [01;31m-[00m(tx101*tx149*tx98); 		/* rule 795 */
_ImproperRestraint_termCode.cc:924:	 tx670 = [01;31m-[00m(tx151*tx65*tx652); 		/* rule 801 */
_ImproperRestraint_termCode.cc:928:	 tx674 = [01;31m-[00m(tx105*tx149*tx98); 		/* rule 805 */
_ImproperRestraint_termCode.cc:931:	 tx675 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx658*tx70*tx75*tx76; 		/* rule 808 */
_ImproperRestraint_termCode.cc:932:	 tx676 = [01;31m-[00m(tx109*tx149*tx98); 		/* rule 809 */
_ImproperRestraint_termCode.cc:935:	 tx677 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx663*tx70*tx75*tx76; 		/* rule 812 */
_ImproperRestraint_termCode.cc:936:	 tx678 = [01;31m-[00m(tx113*tx149*tx98); 		/* rule 813 */
_ImproperRestraint_termCode.cc:939:	 tx679 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx671*tx70*tx75*tx76; 		/* rule 816 */
_ImproperRestraint_termCode.cc:940:	 tx680 = [01;31m-[00m(tx117*tx149*tx98); 		/* rule 817 */
_ImproperRestraint_termCode.cc:943:	 ohy1x4 = [01;31m-[00m(tx149*tx20*tx39*tx77*tx90*tx917); 		/* rule 820 */
_ImproperRestraint_termCode.cc:945:	 ohy1y4 = [01;31m-[00m(tx149*tx45*tx77*tx90*tx917); 		/* rule 822 */
_ImproperRestraint_termCode.cc:947:	 ohy1z4 = [01;31m-[00m(tx149*tx20*tx40*tx77*tx90*tx917); 		/* rule 824 */
_ImproperRestraint_termCode.cc:955:	 tx687 = [01;31m-[00m(tx102*tx149*tx97); 		/* rule 832 */
_ImproperRestraint_termCode.cc:963:	 tx693 = [01;31m-[00m(tx101*tx102*tx149); 		/* rule 840 */
_ImproperRestraint_termCode.cc:967:	 tx695 = [01;31m-[00m2.*tx151*tx19*tx203*tx65; 		/* rule 844 */
_ImproperRestraint_termCode.cc:970:	 tx698 = [01;31m-[00m(tx102*tx105*tx149); 		/* rule 847 */
_ImproperRestraint_termCode.cc:974:	 tx700 = [01;31m-[00m(tx102*tx109*tx149); 		/* rule 851 */
_ImproperRestraint_termCode.cc:975:	 tx701 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx684*tx70*tx75*tx76; 		/* rule 852 */
_ImproperRestraint_termCode.cc:978:	 tx702 = [01;31m-[00m(tx102*tx113*tx149); 		/* rule 855 */
_ImproperRestraint_termCode.cc:979:	 tx703 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx691*tx70*tx75*tx76; 		/* rule 856 */
_ImproperRestraint_termCode.cc:982:	 tx704 = [01;31m-[00m(tx102*tx117*tx149); 		/* rule 859 */
_ImproperRestraint_termCode.cc:983:	 tx705 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx696*tx70*tx75*tx76; 		/* rule 860 */
_ImproperRestraint_termCode.cc:986:	 ohz1x4 = [01;31m-[00m(tx149*tx19*tx39*tx77*tx90*tx917); 		/* rule 863 */
_ImproperRestraint_termCode.cc:988:	 ohz1y4 = [01;31m-[00m(tx149*tx19*tx38*tx77*tx90*tx917); 		/* rule 865 */
_ImproperRestraint_termCode.cc:990:	 ohz1z4 = [01;31m-[00m(tx149*tx47*tx77*tx90*tx917); 		/* rule 867 */
_ImproperRestraint_termCode.cc:1001:	 tx715 = [01;31m-[00mtx632; 		/* rule 878 */
_ImproperRestraint_termCode.cc:1003:	 tx717 = [01;31m-[00mtx658; 		/* rule 880 */
_ImproperRestraint_termCode.cc:1005:	 tx719 = [01;31m-[00m0.5*tx295*tx713*tx90; 		/* rule 882 */
_ImproperRestraint_termCode.cc:1006:	 tx720 = [01;31m-[00m(tx294*tx714*tx918*tx92); 		/* rule 883 */
_ImproperRestraint_termCode.cc:1022:	 tx734 = [01;31m-[00mtx640; 		/* rule 899 */
_ImproperRestraint_termCode.cc:1024:	 tx736 = [01;31m-[00mtx684; 		/* rule 901 */
_ImproperRestraint_termCode.cc:1026:	 tx738 = [01;31m-[00m0.5*tx295*tx732*tx90; 		/* rule 903 */
_ImproperRestraint_termCode.cc:1027:	 tx739 = [01;31m-[00m(tx294*tx733*tx918*tx92); 		/* rule 904 */
_ImproperRestraint_termCode.cc:1034:	 tx744 = [01;31m-[00mtx297; 		/* rule 911 */
_ImproperRestraint_termCode.cc:1038:	 tx748 = [01;31m-[00m2.*tx151*tx21*tx291*tx918*tx93; 		/* rule 915 */
_ImproperRestraint_termCode.cc:1047:	 tx755 = [01;31m-[00mtx721; 		/* rule 924 */
_ImproperRestraint_termCode.cc:1048:	 tx756 = [01;31m-[00m0.5*tx295*tx615*tx77; 		/* rule 925 */
_ImproperRestraint_termCode.cc:1060:	 tx766 = [01;31m-[00mtx740; 		/* rule 937 */
_ImproperRestraint_termCode.cc:1061:	 tx767 = [01;31m-[00m0.5*tx295*tx620*tx77; 		/* rule 938 */
_ImproperRestraint_termCode.cc:1070:	 tx774 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx746*tx75*tx76; 		/* rule 947 */
_ImproperRestraint_termCode.cc:1074:	 tx776 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx758*tx76; 		/* rule 951 */
_ImproperRestraint_termCode.cc:1078:	 tx778 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx769; 		/* rule 955 */
_ImproperRestraint_termCode.cc:1092:	 tx790 = [01;31m-[00mtx671; 		/* rule 969 */
_ImproperRestraint_termCode.cc:1093:	 tx791 = [01;31m-[00mtx691; 		/* rule 970 */
_ImproperRestraint_termCode.cc:1095:	 tx793 = [01;31m-[00m0.5*tx295*tx787*tx90; 		/* rule 972 */
_ImproperRestraint_termCode.cc:1096:	 tx794 = [01;31m-[00m(tx294*tx788*tx918*tx92); 		/* rule 973 */
_ImproperRestraint_termCode.cc:1112:	 tx806 = [01;31m-[00mtx393; 		/* rule 989 */
_ImproperRestraint_termCode.cc:1116:	 tx810 = [01;31m-[00m2.*tx151*tx20*tx389*tx918*tx93; 		/* rule 993 */
_ImproperRestraint_termCode.cc:1125:	 tx817 = [01;31m-[00m0.5*tx295*tx652*tx77; 		/* rule 1002 */
_ImproperRestraint_termCode.cc:1126:	 tx818 = [01;31m-[00mtx795; 		/* rule 1003 */
_ImproperRestraint_termCode.cc:1135:	 tx825 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx802; 		/* rule 1012 */
_ImproperRestraint_termCode.cc:1139:	 tx827 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx808; 		/* rule 1016 */
_ImproperRestraint_termCode.cc:1143:	 tx829 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx820; 		/* rule 1020 */
_ImproperRestraint_termCode.cc:1165:	 tx845 = [01;31m-[00mtx487; 		/* rule 1042 */
_ImproperRestraint_termCode.cc:1169:	 tx849 = [01;31m-[00m2.*tx151*tx19*tx483*tx918*tx93; 		/* rule 1046 */
_ImproperRestraint_termCode.cc:1175:	 tx853 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx834; 		/* rule 1052 */
_ImproperRestraint_termCode.cc:1179:	 tx855 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx841; 		/* rule 1056 */
_ImproperRestraint_termCode.cc:1183:	 tx857 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx847; 		/* rule 1060 */
_ImproperRestraint_termCode.cc:1187:	 tx859 = [01;31m-[00m(tx294*tx65*tx713); 		/* rule 1064 */
_ImproperRestraint_termCode.cc:1188:	 tx860 = [01;31m-[00mtx758; 		/* rule 1065 */
_ImproperRestraint_termCode.cc:1189:	 tx861 = [01;31m-[00mtx802; 		/* rule 1066 */
_ImproperRestraint_termCode.cc:1195:	 tx865 = [01;31m-[00m(tx294*tx65*tx732); 		/* rule 1072 */
_ImproperRestraint_termCode.cc:1196:	 tx866 = [01;31m-[00mtx769; 		/* rule 1073 */
_ImproperRestraint_termCode.cc:1197:	 tx867 = [01;31m-[00mtx834; 		/* rule 1074 */
_ImproperRestraint_termCode.cc:1221:	 tx883 = [01;31m-[00m(tx294*tx65*tx787); 		/* rule 1098 */
_ImproperRestraint_termCode.cc:1222:	 tx884 = [01;31m-[00mtx820; 		/* rule 1099 */
_ImproperRestraint_termCode.cc:1223:	 tx885 = [01;31m-[00mtx841; 		/* rule 1100 */
_ImproperRestraint_termCode.cc:1263:	 tx911 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx875; 		/* rule 1140 */
_ImproperRestraint_termCode.cc:1267:	 tx913 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx879; 		/* rule 1144 */
_ImproperRestraint_termCode.cc:1271:	 tx915 = [01;31m-[00m3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx896; 		/* rule 1148 */
_Nonbond_debugEvalSerialize.cc:2:	node[01;31m-[00m>attributeIfNotDefault("evalx1", this[01;31m-[00m>eval.x1, 0.0 );
_Nonbond_debugEvalSerialize.cc:3: 	node[01;31m-[00m>attributeIfNotDefault("evaly1", this[01;31m-[00m>eval.y1, 0.0 );
_Nonbond_debugEvalSerialize.cc:4: 	node[01;31m-[00m>attributeIfNotDefault("evalz1", this[01;31m-[00m>eval.z1, 0.0 );
_Nonbond_debugEvalSerialize.cc:5: 	node[01;31m-[00m>attributeIfNotDefault("evalx2", this[01;31m-[00m>eval.x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:6: 	node[01;31m-[00m>attributeIfNotDefault("evaly2", this[01;31m-[00m>eval.y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:7: 	node[01;31m-[00m>attributeIfNotDefault("evalz2", this[01;31m-[00m>eval.z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:8: 	node[01;31m-[00m>attributeIfNotDefault("evaldA", this[01;31m-[00m>eval.dA, 0.0 );
_Nonbond_debugEvalSerialize.cc:9: 	node[01;31m-[00m>attributeIfNotDefault("evaldC", this[01;31m-[00m>eval.dC, 0.0 );
_Nonbond_debugEvalSerialize.cc:10: 	node[01;31m-[00m>attributeIfNotDefault("evaldQ1Q2", this[01;31m-[00m>eval.dQ1Q2, 0.0 );
_Nonbond_debugEvalSerialize.cc:11: 	node[01;31m-[00m>attributeIfNotDefault("evalEnergy", this[01;31m-[00m>eval.Energy, 0.0 );
_Nonbond_debugEvalSerialize.cc:12: 	node[01;31m-[00m>attributeIfNotDefault("evalEvdw", this[01;31m-[00m>eval.Evdw, 0.0 );
_Nonbond_debugEvalSerialize.cc:13: 	node[01;31m-[00m>attributeIfNotDefault("evalEeel", this[01;31m-[00m>eval.Eeel, 0.0 );
_Nonbond_debugEvalSerialize.cc:14: 	node[01;31m-[00m>attributeIfNotDefault("evalfx1", this[01;31m-[00m>eval.fx1, 0.0 );
_Nonbond_debugEvalSerialize.cc:15: 	node[01;31m-[00m>attributeIfNotDefault("evalfy1", this[01;31m-[00m>eval.fy1, 0.0 );
_Nonbond_debugEvalSerialize.cc:16: 	node[01;31m-[00m>attributeIfNotDefault("evalfz1", this[01;31m-[00m>eval.fz1, 0.0 );
_Nonbond_debugEvalSerialize.cc:17: 	node[01;31m-[00m>attributeIfNotDefault("evalfx2", this[01;31m-[00m>eval.fx2, 0.0 );
_Nonbond_debugEvalSerialize.cc:18: 	node[01;31m-[00m>attributeIfNotDefault("evalfy2", this[01;31m-[00m>eval.fy2, 0.0 );
_Nonbond_debugEvalSerialize.cc:19: 	node[01;31m-[00m>attributeIfNotDefault("evalfz2", this[01;31m-[00m>eval.fz2, 0.0 );
_Nonbond_debugEvalSerialize.cc:20: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx1x1", this[01;31m-[00m>eval.dhx1x1, 0.0 );
_Nonbond_debugEvalSerialize.cc:21: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy1y1", this[01;31m-[00m>eval.dhy1y1, 0.0 );
_Nonbond_debugEvalSerialize.cc:22: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz1z1", this[01;31m-[00m>eval.dhz1z1, 0.0 );
_Nonbond_debugEvalSerialize.cc:23: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx2x2", this[01;31m-[00m>eval.dhx2x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:24: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy2y2", this[01;31m-[00m>eval.dhy2y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:25: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz2z2", this[01;31m-[00m>eval.dhz2z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:26: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y1", this[01;31m-[00m>eval.ohx1y1, 0.0 );
_Nonbond_debugEvalSerialize.cc:27: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z1", this[01;31m-[00m>eval.ohx1z1, 0.0 );
_Nonbond_debugEvalSerialize.cc:28: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x2", this[01;31m-[00m>eval.ohx1x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:29: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y2", this[01;31m-[00m>eval.ohx1y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:30: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z2", this[01;31m-[00m>eval.ohx1z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:31: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z1", this[01;31m-[00m>eval.ohy1z1, 0.0 );
_Nonbond_debugEvalSerialize.cc:32: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x2", this[01;31m-[00m>eval.ohy1x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:33: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y2", this[01;31m-[00m>eval.ohy1y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:34: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z2", this[01;31m-[00m>eval.ohy1z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:35: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x2", this[01;31m-[00m>eval.ohz1x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:36: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y2", this[01;31m-[00m>eval.ohz1y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:37: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z2", this[01;31m-[00m>eval.ohz1z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:38: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y2", this[01;31m-[00m>eval.ohx2y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:39: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z2", this[01;31m-[00m>eval.ohx2z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:40: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z2", this[01;31m-[00m>eval.ohy2z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:41: 	node[01;31m-[00m>attributeIfNotDefault("evalNonbondDistance", this[01;31m-[00m>eval.NonbondDistance, 0.0 );
_Nonbond_debugEvalXml.cc:2:	xml[01;31m-[00m>addAttributeDoubleScientific ("x1", this[01;31m-[00m>eval.x1);
_Nonbond_debugEvalXml.cc:3: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y1", this[01;31m-[00m>eval.y1);
_Nonbond_debugEvalXml.cc:4: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z1", this[01;31m-[00m>eval.z1);
_Nonbond_debugEvalXml.cc:5: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x2", this[01;31m-[00m>eval.x2);
_Nonbond_debugEvalXml.cc:6: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y2", this[01;31m-[00m>eval.y2);
_Nonbond_debugEvalXml.cc:7: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z2", this[01;31m-[00m>eval.z2);
_Nonbond_debugEvalXml.cc:8: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dA", this[01;31m-[00m>eval.dA);
_Nonbond_debugEvalXml.cc:9: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dC", this[01;31m-[00m>eval.dC);
_Nonbond_debugEvalXml.cc:10: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dQ1Q2", this[01;31m-[00m>eval.dQ1Q2);
_Nonbond_debugEvalXml.cc:11: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Energy", this[01;31m-[00m>eval.Energy);
_Nonbond_debugEvalXml.cc:12: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Evdw", this[01;31m-[00m>eval.Evdw);
_Nonbond_debugEvalXml.cc:13: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Eeel", this[01;31m-[00m>eval.Eeel);
_Nonbond_debugEvalXml.cc:14: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx1", this[01;31m-[00m>eval.fx1);
_Nonbond_debugEvalXml.cc:15: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy1", this[01;31m-[00m>eval.fy1);
_Nonbond_debugEvalXml.cc:16: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz1", this[01;31m-[00m>eval.fz1);
_Nonbond_debugEvalXml.cc:17: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx2", this[01;31m-[00m>eval.fx2);
_Nonbond_debugEvalXml.cc:18: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy2", this[01;31m-[00m>eval.fy2);
_Nonbond_debugEvalXml.cc:19: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz2", this[01;31m-[00m>eval.fz2);
_Nonbond_debugEvalXml.cc:20: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx1x1", this[01;31m-[00m>eval.dhx1x1);
_Nonbond_debugEvalXml.cc:21: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy1y1", this[01;31m-[00m>eval.dhy1y1);
_Nonbond_debugEvalXml.cc:22: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz1z1", this[01;31m-[00m>eval.dhz1z1);
_Nonbond_debugEvalXml.cc:23: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx2x2", this[01;31m-[00m>eval.dhx2x2);
_Nonbond_debugEvalXml.cc:24: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy2y2", this[01;31m-[00m>eval.dhy2y2);
_Nonbond_debugEvalXml.cc:25: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz2z2", this[01;31m-[00m>eval.dhz2z2);
_Nonbond_debugEvalXml.cc:26: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y1", this[01;31m-[00m>eval.ohx1y1);
_Nonbond_debugEvalXml.cc:27: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z1", this[01;31m-[00m>eval.ohx1z1);
_Nonbond_debugEvalXml.cc:28: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x2", this[01;31m-[00m>eval.ohx1x2);
_Nonbond_debugEvalXml.cc:29: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y2", this[01;31m-[00m>eval.ohx1y2);
_Nonbond_debugEvalXml.cc:30: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z2", this[01;31m-[00m>eval.ohx1z2);
_Nonbond_debugEvalXml.cc:31: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z1", this[01;31m-[00m>eval.ohy1z1);
_Nonbond_debugEvalXml.cc:32: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x2", this[01;31m-[00m>eval.ohy1x2);
_Nonbond_debugEvalXml.cc:33: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y2", this[01;31m-[00m>eval.ohy1y2);
_Nonbond_debugEvalXml.cc:34: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z2", this[01;31m-[00m>eval.ohy1z2);
_Nonbond_debugEvalXml.cc:35: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x2", this[01;31m-[00m>eval.ohz1x2);
_Nonbond_debugEvalXml.cc:36: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y2", this[01;31m-[00m>eval.ohz1y2);
_Nonbond_debugEvalXml.cc:37: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z2", this[01;31m-[00m>eval.ohz1z2);
_Nonbond_debugEvalXml.cc:38: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y2", this[01;31m-[00m>eval.ohx2y2);
_Nonbond_debugEvalXml.cc:39: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z2", this[01;31m-[00m>eval.ohx2z2);
_Nonbond_debugEvalXml.cc:40: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z2", this[01;31m-[00m>eval.ohy2z2);
_Nonbond_debugEvalXml.cc:41: 	xml[01;31m-[00m>addAttributeDoubleScientific ("NonbondDistance", this[01;31m-[00m>eval.NonbondDistance);
_Nonbond_debugFiniteDifference.cc:3:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:8:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:13:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:18:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:23:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:33:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:40:([01;31m-[00mdelta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:41:(delta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:42:([01;31m-[00mdelta2 + x1, delta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:48:([01;31m-[00mdelta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:49:(delta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:50:([01;31m-[00mdelta2 + x1, y1, delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:56:([01;31m-[00mdelta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:57:(delta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:58:([01;31m-[00mdelta2 + x1, y1, z1, delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:64:([01;31m-[00mdelta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:65:(delta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:66:([01;31m-[00mdelta2 + x1, y1, z1, x2, delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:72:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:73:(delta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:74:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:79:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:86:(x1, [01;31m-[00mdelta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:87:(x1, delta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:88:(x1, [01;31m-[00mdelta2 + y1, delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:94:(x1, [01;31m-[00mdelta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:95:(x1, delta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:96:(x1, [01;31m-[00mdelta2 + y1, z1, delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:102:(x1, [01;31m-[00mdelta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:103:(x1, delta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:104:(x1, [01;31m-[00mdelta2 + y1, z1, x2, delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:110:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:111:(x1, delta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:112:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:117:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:124:(x1, y1, [01;31m-[00mdelta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:125:(x1, y1, delta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:126:(x1, y1, [01;31m-[00mdelta2 + z1, delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:132:(x1, y1, [01;31m-[00mdelta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:133:(x1, y1, delta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:134:(x1, y1, [01;31m-[00mdelta2 + z1, x2, delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:140:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:141:(x1, y1, delta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:142:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:147:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:154:(x1, y1, z1, [01;31m-[00mdelta2 + x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:155:(x1, y1, z1, delta2 + x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:156:(x1, y1, z1, [01;31m-[00mdelta2 + x2, delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:162:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:163:(x1, y1, z1, delta2 + x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:164:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:169:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:176:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:177:(x1, y1, z1, x2, delta2 + y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:178:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:183:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, dA, dC, dQ1Q2),
_Nonbond_termCode.cc:1:// C[01;31m-[00mcode
_Nonbond_termCode.cc:13:	 tx1 = [01;31m-[00mx2; 		/* rule 12 */
_Nonbond_termCode.cc:14:	 tx2 = [01;31m-[00my2; 		/* rule 13 */
_Nonbond_termCode.cc:15:	 tx3 = [01;31m-[00mz2; 		/* rule 14 */
_Nonbond_termCode.cc:30:	 tx14 = [01;31m-[00m(dC*tx12); 		/* rule 29 */
_Nonbond_termCode.cc:44:	 tx40 = [01;31m-[00m12.*tzz98; 		/* rule 43 */
_Nonbond_termCode.cc:50:	 tx42 = [01;31m-[00mtx60; 		/* rule 49 */
_Nonbond_termCode.cc:53:	 fx1 = [01;31m-[00mgx1; 		/* rule 52 */
_Nonbond_termCode.cc:59:	 fy1 = [01;31m-[00mgy1; 		/* rule 58 */
_Nonbond_termCode.cc:65:	 fz1 = [01;31m-[00mgz1; 		/* rule 64 */
_Nonbond_termCode.cc:69:	 tx59 = [01;31m-[00m6.*tzz97; 		/* rule 68 */
_Nonbond_termCode.cc:73:	 fx2 = [01;31m-[00mgx2; 		/* rule 72 */
_Nonbond_termCode.cc:79:	 fy2 = [01;31m-[00mgy2; 		/* rule 78 */
_Nonbond_termCode.cc:85:	 fz2 = [01;31m-[00mgz2; 		/* rule 84 */
_Nonbond_termCode.cc:98:	 tzz107 = [01;31m-[00m48*tzz95; 		/* rule 97 */
_Nonbond_termCode.cc:137:	 tzz108 = [01;31m-[00m168*tzz96; 		/* rule 136 */
_Nonbond_termCode.cc:141:	 tzz106 = [01;31m-[00m3*tzz94; 		/* rule 140 */
_Stretch_debugEvalSerialize.cc:2:	node[01;31m-[00m>attributeIfNotDefault("evalx1", this[01;31m-[00m>eval.x1, 0.0 );
_Stretch_debugEvalSerialize.cc:3: 	node[01;31m-[00m>attributeIfNotDefault("evaly1", this[01;31m-[00m>eval.y1, 0.0 );
_Stretch_debugEvalSerialize.cc:4: 	node[01;31m-[00m>attributeIfNotDefault("evalz1", this[01;31m-[00m>eval.z1, 0.0 );
_Stretch_debugEvalSerialize.cc:5: 	node[01;31m-[00m>attributeIfNotDefault("evalx2", this[01;31m-[00m>eval.x2, 0.0 );
_Stretch_debugEvalSerialize.cc:6: 	node[01;31m-[00m>attributeIfNotDefault("evaly2", this[01;31m-[00m>eval.y2, 0.0 );
_Stretch_debugEvalSerialize.cc:7: 	node[01;31m-[00m>attributeIfNotDefault("evalz2", this[01;31m-[00m>eval.z2, 0.0 );
_Stretch_debugEvalSerialize.cc:8: 	node[01;31m-[00m>attributeIfNotDefault("evalr0", this[01;31m-[00m>eval.r0, 0.0 );
_Stretch_debugEvalSerialize.cc:9: 	node[01;31m-[00m>attributeIfNotDefault("evalkb", this[01;31m-[00m>eval.kb, 0.0 );
_Stretch_debugEvalSerialize.cc:10: 	node[01;31m-[00m>attributeIfNotDefault("evalEnergy", this[01;31m-[00m>eval.Energy, 0.0 );
_Stretch_debugEvalSerialize.cc:11: 	node[01;31m-[00m>attributeIfNotDefault("evalfx1", this[01;31m-[00m>eval.fx1, 0.0 );
_Stretch_debugEvalSerialize.cc:12: 	node[01;31m-[00m>attributeIfNotDefault("evalfy1", this[01;31m-[00m>eval.fy1, 0.0 );
_Stretch_debugEvalSerialize.cc:13: 	node[01;31m-[00m>attributeIfNotDefault("evalfz1", this[01;31m-[00m>eval.fz1, 0.0 );
_Stretch_debugEvalSerialize.cc:14: 	node[01;31m-[00m>attributeIfNotDefault("evalfx2", this[01;31m-[00m>eval.fx2, 0.0 );
_Stretch_debugEvalSerialize.cc:15: 	node[01;31m-[00m>attributeIfNotDefault("evalfy2", this[01;31m-[00m>eval.fy2, 0.0 );
_Stretch_debugEvalSerialize.cc:16: 	node[01;31m-[00m>attributeIfNotDefault("evalfz2", this[01;31m-[00m>eval.fz2, 0.0 );
_Stretch_debugEvalSerialize.cc:17: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx1x1", this[01;31m-[00m>eval.dhx1x1, 0.0 );
_Stretch_debugEvalSerialize.cc:18: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy1y1", this[01;31m-[00m>eval.dhy1y1, 0.0 );
_Stretch_debugEvalSerialize.cc:19: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz1z1", this[01;31m-[00m>eval.dhz1z1, 0.0 );
_Stretch_debugEvalSerialize.cc:20: 	node[01;31m-[00m>attributeIfNotDefault("evaldhx2x2", this[01;31m-[00m>eval.dhx2x2, 0.0 );
_Stretch_debugEvalSerialize.cc:21: 	node[01;31m-[00m>attributeIfNotDefault("evaldhy2y2", this[01;31m-[00m>eval.dhy2y2, 0.0 );
_Stretch_debugEvalSerialize.cc:22: 	node[01;31m-[00m>attributeIfNotDefault("evaldhz2z2", this[01;31m-[00m>eval.dhz2z2, 0.0 );
_Stretch_debugEvalSerialize.cc:23: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y1", this[01;31m-[00m>eval.ohx1y1, 0.0 );
_Stretch_debugEvalSerialize.cc:24: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z1", this[01;31m-[00m>eval.ohx1z1, 0.0 );
_Stretch_debugEvalSerialize.cc:25: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1x2", this[01;31m-[00m>eval.ohx1x2, 0.0 );
_Stretch_debugEvalSerialize.cc:26: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1y2", this[01;31m-[00m>eval.ohx1y2, 0.0 );
_Stretch_debugEvalSerialize.cc:27: 	node[01;31m-[00m>attributeIfNotDefault("evalohx1z2", this[01;31m-[00m>eval.ohx1z2, 0.0 );
_Stretch_debugEvalSerialize.cc:28: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z1", this[01;31m-[00m>eval.ohy1z1, 0.0 );
_Stretch_debugEvalSerialize.cc:29: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1x2", this[01;31m-[00m>eval.ohy1x2, 0.0 );
_Stretch_debugEvalSerialize.cc:30: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1y2", this[01;31m-[00m>eval.ohy1y2, 0.0 );
_Stretch_debugEvalSerialize.cc:31: 	node[01;31m-[00m>attributeIfNotDefault("evalohy1z2", this[01;31m-[00m>eval.ohy1z2, 0.0 );
_Stretch_debugEvalSerialize.cc:32: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1x2", this[01;31m-[00m>eval.ohz1x2, 0.0 );
_Stretch_debugEvalSerialize.cc:33: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1y2", this[01;31m-[00m>eval.ohz1y2, 0.0 );
_Stretch_debugEvalSerialize.cc:34: 	node[01;31m-[00m>attributeIfNotDefault("evalohz1z2", this[01;31m-[00m>eval.ohz1z2, 0.0 );
_Stretch_debugEvalSerialize.cc:35: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2y2", this[01;31m-[00m>eval.ohx2y2, 0.0 );
_Stretch_debugEvalSerialize.cc:36: 	node[01;31m-[00m>attributeIfNotDefault("evalohx2z2", this[01;31m-[00m>eval.ohx2z2, 0.0 );
_Stretch_debugEvalSerialize.cc:37: 	node[01;31m-[00m>attributeIfNotDefault("evalohy2z2", this[01;31m-[00m>eval.ohy2z2, 0.0 );
_Stretch_debugEvalSerialize.cc:38: 	node[01;31m-[00m>attributeIfNotDefault("evalStretchDeviation", this[01;31m-[00m>eval.StretchDeviation, 0.0 );
_Stretch_debugEvalXml.cc:2:	xml[01;31m-[00m>addAttributeDoubleScientific ("x1", this[01;31m-[00m>eval.x1);
_Stretch_debugEvalXml.cc:3: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y1", this[01;31m-[00m>eval.y1);
_Stretch_debugEvalXml.cc:4: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z1", this[01;31m-[00m>eval.z1);
_Stretch_debugEvalXml.cc:5: 	xml[01;31m-[00m>addAttributeDoubleScientific ("x2", this[01;31m-[00m>eval.x2);
_Stretch_debugEvalXml.cc:6: 	xml[01;31m-[00m>addAttributeDoubleScientific ("y2", this[01;31m-[00m>eval.y2);
_Stretch_debugEvalXml.cc:7: 	xml[01;31m-[00m>addAttributeDoubleScientific ("z2", this[01;31m-[00m>eval.z2);
_Stretch_debugEvalXml.cc:8: 	xml[01;31m-[00m>addAttributeDoubleScientific ("r0", this[01;31m-[00m>eval.r0);
_Stretch_debugEvalXml.cc:9: 	xml[01;31m-[00m>addAttributeDoubleScientific ("kb", this[01;31m-[00m>eval.kb);
_Stretch_debugEvalXml.cc:10: 	xml[01;31m-[00m>addAttributeDoubleScientific ("Energy", this[01;31m-[00m>eval.Energy);
_Stretch_debugEvalXml.cc:11: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx1", this[01;31m-[00m>eval.fx1);
_Stretch_debugEvalXml.cc:12: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy1", this[01;31m-[00m>eval.fy1);
_Stretch_debugEvalXml.cc:13: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz1", this[01;31m-[00m>eval.fz1);
_Stretch_debugEvalXml.cc:14: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fx2", this[01;31m-[00m>eval.fx2);
_Stretch_debugEvalXml.cc:15: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fy2", this[01;31m-[00m>eval.fy2);
_Stretch_debugEvalXml.cc:16: 	xml[01;31m-[00m>addAttributeDoubleScientific ("fz2", this[01;31m-[00m>eval.fz2);
_Stretch_debugEvalXml.cc:17: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx1x1", this[01;31m-[00m>eval.dhx1x1);
_Stretch_debugEvalXml.cc:18: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy1y1", this[01;31m-[00m>eval.dhy1y1);
_Stretch_debugEvalXml.cc:19: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz1z1", this[01;31m-[00m>eval.dhz1z1);
_Stretch_debugEvalXml.cc:20: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhx2x2", this[01;31m-[00m>eval.dhx2x2);
_Stretch_debugEvalXml.cc:21: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhy2y2", this[01;31m-[00m>eval.dhy2y2);
_Stretch_debugEvalXml.cc:22: 	xml[01;31m-[00m>addAttributeDoubleScientific ("dhz2z2", this[01;31m-[00m>eval.dhz2z2);
_Stretch_debugEvalXml.cc:23: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y1", this[01;31m-[00m>eval.ohx1y1);
_Stretch_debugEvalXml.cc:24: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z1", this[01;31m-[00m>eval.ohx1z1);
_Stretch_debugEvalXml.cc:25: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1x2", this[01;31m-[00m>eval.ohx1x2);
_Stretch_debugEvalXml.cc:26: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1y2", this[01;31m-[00m>eval.ohx1y2);
_Stretch_debugEvalXml.cc:27: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx1z2", this[01;31m-[00m>eval.ohx1z2);
_Stretch_debugEvalXml.cc:28: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z1", this[01;31m-[00m>eval.ohy1z1);
_Stretch_debugEvalXml.cc:29: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1x2", this[01;31m-[00m>eval.ohy1x2);
_Stretch_debugEvalXml.cc:30: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1y2", this[01;31m-[00m>eval.ohy1y2);
_Stretch_debugEvalXml.cc:31: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy1z2", this[01;31m-[00m>eval.ohy1z2);
_Stretch_debugEvalXml.cc:32: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1x2", this[01;31m-[00m>eval.ohz1x2);
_Stretch_debugEvalXml.cc:33: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1y2", this[01;31m-[00m>eval.ohz1y2);
_Stretch_debugEvalXml.cc:34: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohz1z2", this[01;31m-[00m>eval.ohz1z2);
_Stretch_debugEvalXml.cc:35: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2y2", this[01;31m-[00m>eval.ohx2y2);
_Stretch_debugEvalXml.cc:36: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohx2z2", this[01;31m-[00m>eval.ohx2z2);
_Stretch_debugEvalXml.cc:37: 	xml[01;31m-[00m>addAttributeDoubleScientific ("ohy2z2", this[01;31m-[00m>eval.ohy2z2);
_Stretch_debugEvalXml.cc:38: 	xml[01;31m-[00m>addAttributeDoubleScientific ("StretchDeviation", this[01;31m-[00m>eval.StretchDeviation);
_Stretch_debugFiniteDifference.cc:4:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:9:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:14:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:19:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:24:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:29:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:34:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:41:([01;31m-[00mdelta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:42:(delta2 + x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:43:([01;31m-[00mdelta2 + x1, delta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:49:([01;31m-[00mdelta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:50:(delta2 + x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:51:([01;31m-[00mdelta2 + x1, y1, delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:57:([01;31m-[00mdelta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:58:(delta2 + x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:59:([01;31m-[00mdelta2 + x1, y1, z1, delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:65:([01;31m-[00mdelta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:66:(delta2 + x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:67:([01;31m-[00mdelta2 + x1, y1, z1, x2, delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:73:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:74:(delta2 + x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:75:([01;31m-[00mdelta2 + x1, y1, z1, x2, y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:80:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:87:(x1, [01;31m-[00mdelta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:88:(x1, delta2 + y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:89:(x1, [01;31m-[00mdelta2 + y1, delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:95:(x1, [01;31m-[00mdelta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:96:(x1, delta2 + y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:97:(x1, [01;31m-[00mdelta2 + y1, z1, delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:103:(x1, [01;31m-[00mdelta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:104:(x1, delta2 + y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:105:(x1, [01;31m-[00mdelta2 + y1, z1, x2, delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:111:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:112:(x1, delta2 + y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:113:(x1, [01;31m-[00mdelta2 + y1, z1, x2, y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:118:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:125:(x1, y1, [01;31m-[00mdelta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:126:(x1, y1, delta2 + z1, [01;31m-[00mdelta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:127:(x1, y1, [01;31m-[00mdelta2 + z1, delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:133:(x1, y1, [01;31m-[00mdelta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:134:(x1, y1, delta2 + z1, x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:135:(x1, y1, [01;31m-[00mdelta2 + z1, x2, delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:141:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:142:(x1, y1, delta2 + z1, x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:143:(x1, y1, [01;31m-[00mdelta2 + z1, x2, y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:148:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:155:(x1, y1, z1, [01;31m-[00mdelta2 + x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:156:(x1, y1, z1, delta2 + x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:157:(x1, y1, z1, [01;31m-[00mdelta2 + x2, delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:163:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:164:(x1, y1, z1, delta2 + x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:165:(x1, y1, z1, [01;31m-[00mdelta2 + x2, y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:170:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:177:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:178:(x1, y1, z1, x2, delta2 + y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:179:(x1, y1, z1, x2, [01;31m-[00mdelta2 + y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:184:(x1, y1, z1, x2, y2, [01;31m-[00mdelta2 + z2, r0, kb),
_Stretch_termCode.cc:1:// C[01;31m-[00mcode
_Stretch_termCode.cc:12:	 tx1 = [01;31m-[00mx1; 		/* rule 11 */
_Stretch_termCode.cc:13:	 tx2 = [01;31m-[00my1; 		/* rule 12 */
_Stretch_termCode.cc:14:	 tx3 = [01;31m-[00mz1; 		/* rule 13 */
_Stretch_termCode.cc:22:	 tx11 = [01;31m-[00mr0; 		/* rule 21 */
_Stretch_termCode.cc:34:	 tx29 = [01;31m-[00m2.*tzz50; 		/* rule 33 */
_Stretch_termCode.cc:36:	 fx1 = [01;31m-[00mgx1; 		/* rule 35 */
_Stretch_termCode.cc:39:	 fy1 = [01;31m-[00mgy1; 		/* rule 38 */
_Stretch_termCode.cc:42:	 fz1 = [01;31m-[00mgz1; 		/* rule 41 */
_Stretch_termCode.cc:46:	 fx2 = [01;31m-[00mgx2; 		/* rule 45 */
_Stretch_termCode.cc:49:	 fy2 = [01;31m-[00mgy2; 		/* rule 48 */
_Stretch_termCode.cc:52:	 fz2 = [01;31m-[00mgz2; 		/* rule 51 */
_Stretch_termCode.cc:59:	 tzz54 = [01;31m-[00m2.*tzz48; 		/* rule 58 */
_Stretch_termCode.cc:94:	 tzz53 = [01;31m-[00m2.*tzz49; 		/* rule 93 */
_gaff_Parser.cc:3:/* Skeleton implementation for Bison's Yacc[01;31m-[00mlike parsers in C
_gaff_Parser.cc:35:   simplifying the original so[01;31m-[00mcalled "semantic" parser.  */
_gaff_Parser.cc:255:#define YYSIZE_MAXIMUM ((YYSIZE_T) [01;31m-[00m1)
_gaff_Parser.cc:261:#   define YY_(msgid) dgettext ("bison[01;31m-[00mruntime", msgid)
_gaff_Parser.cc:269:/* Suppress unused[01;31m-[00mvariable warnings by "using" E.  */
_gaff_Parser.cc:323:   /* Pacify GCC's `empty if[01;31m-[00mbody' warning.  */
_gaff_Parser.cc:329:       to allow for a few compiler[01;31m-[00mallocated temporary stack slots.  */
_gaff_Parser.cc:378:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) [01;31m-[00m 1)
_gaff_Parser.cc:413:	YYCOPY (&yyptr[01;31m-[00m>Stack_alloc, Stack, yysize);			\
_gaff_Parser.cc:414:	Stack = &yyptr[01;31m-[00m>Stack_alloc;					\
_gaff_Parser.cc:422:/* YYFINAL [01;31m-[00m[01;31m-[00m State number of the termination state.  */
_gaff_Parser.cc:424:/* YYLAST [01;31m-[00m[01;31m-[00m Last index in YYTABLE.  */
_gaff_Parser.cc:427:/* YYNTOKENS [01;31m-[00m[01;31m-[00m Number of terminals.  */
_gaff_Parser.cc:429:/* YYNNTS [01;31m-[00m[01;31m-[00m Number of nonterminals.  */
_gaff_Parser.cc:431:/* YYNRULES [01;31m-[00m[01;31m-[00m Number of rules.  */
_gaff_Parser.cc:433:/* YYNRULES [01;31m-[00m[01;31m-[00m Number of states.  */
_gaff_Parser.cc:436:/* YYTRANSLATE(YYLEX) [01;31m-[00m[01;31m-[00m Bison symbol number corresponding to YYLEX.  */
_gaff_Parser.cc:443:/* YYTRANSLATE[YYLEX] [01;31m-[00m[01;31m-[00m Bison symbol number corresponding to YYLEX.  */
_gaff_Parser.cc:478:/* YYPRHS[YYN] [01;31m-[00m[01;31m-[00m Index of the first RHS symbol of rule number YYN in
_gaff_Parser.cc:490:/* YYRHS [01;31m-[00m[01;31m-[00m A `[01;31m-[00m1'[01;31m-[00mseparated list of the rules' RHS.  */
_gaff_Parser.cc:493:      28,     0,    [01;31m-[00m1,    25,    29,    [01;31m-[00m1,    30,    32,    33,    34,
_gaff_Parser.cc:494:      35,    36,    37,    38,    39,     3,    [01;31m-[00m1,    30,    32,    33,
_gaff_Parser.cc:495:      34,    35,    36,    37,    38,     3,    [01;31m-[00m1,    30,    32,    33,
_gaff_Parser.cc:496:      34,    35,    36,    37,     3,    [01;31m-[00m1,    30,    32,    33,    34,
_gaff_Parser.cc:497:      35,    36,     3,    [01;31m-[00m1,    30,    32,    33,    34,    35,     3,
_gaff_Parser.cc:498:      [01;31m-[00m1,    30,    32,    33,    34,     3,    [01;31m-[00m1,    30,    32,    33,
_gaff_Parser.cc:499:       3,    [01;31m-[00m1,    30,    32,     3,    [01;31m-[00m1,    30,     3,    [01;31m-[00m1,    31,
_gaff_Parser.cc:500:      [01;31m-[00m1,    31,    14,    20,    [01;31m-[00m1,    31,    14,    20,    31,    [01;31m-[00m1,
_gaff_Parser.cc:501:      31,    14,    31,    [01;31m-[00m1,    21,    [01;31m-[00m1,     4,    [01;31m-[00m1,     6,    [01;31m-[00m1,
_gaff_Parser.cc:502:       6,    [01;31m-[00m1,    20,    [01;31m-[00m1,     6,    [01;31m-[00m1,    20,    [01;31m-[00m1,     6,    [01;31m-[00m1,
_gaff_Parser.cc:503:      20,    [01;31m-[00m1,     6,    [01;31m-[00m1,    20,    [01;31m-[00m1,     6,    [01;31m-[00m1,     9,    40,
_gaff_Parser.cc:504:      11,    [01;31m-[00m1,     6,    [01;31m-[00m1,    42,    [01;31m-[00m1,    21,    15,    21,    15,
_gaff_Parser.cc:505:      19,    [01;31m-[00m1,    41,    [01;31m-[00m1,    40,    13,    40,    [01;31m-[00m1,    40,    14,
_gaff_Parser.cc:506:      40,    [01;31m-[00m1,    19,    [01;31m-[00m1,    20,    19,    [01;31m-[00m1,    19,    23,    [01;31m-[00m1,
_gaff_Parser.cc:507:      19,    24,    [01;31m-[00m1,    16,    [01;31m-[00m1,    17,    [01;31m-[00m1,    17,    20,    [01;31m-[00m1,
_gaff_Parser.cc:508:      20,    17,    20,    [01;31m-[00m1,    18,    [01;31m-[00m1,     7,    43,     8,    [01;31m-[00m1,
_gaff_Parser.cc:509:      44,    [01;31m-[00m1,    43,    13,    44,    [01;31m-[00m1,    45,    [01;31m-[00m1,    45,    42,
_gaff_Parser.cc:510:      [01;31m-[00m1,    46,    20,    47,    48,    [01;31m-[00m1,    46,    47,    48,    [01;31m-[00m1,
_gaff_Parser.cc:511:       4,    [01;31m-[00m1,     5,    [01;31m-[00m1,    [01;31m-[00m1,     9,    40,    11,    [01;31m-[00m1,    [01;31m-[00m1,
_gaff_Parser.cc:512:      10,    21,    12,    [01;31m-[00m1
_gaff_Parser.cc:515:/* YYRLINE[YYN] [01;31m-[00m[01;31m-[00m source line where rule number YYN was defined.  */
_gaff_Parser.cc:528:/* YYTNAME[SYMBOL[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m String name of the symbol SYMBOL[01;31m-[00mNUM.
_gaff_Parser.cc:551:/* YYTOKNUM[YYLEX[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m Internal token number corresponding to
_gaff_Parser.cc:552:   token YYLEX[01;31m-[00mNUM.  */
_gaff_Parser.cc:561:/* YYR1[YYN] [01;31m-[00m[01;31m-[00m Symbol number of symbol that rule YYN derives.  */
_gaff_Parser.cc:572:/* YYR2[YYN] [01;31m-[00m[01;31m-[00m Number of symbols composing right hand side of rule YYN.  */
_gaff_Parser.cc:583:/* YYDEFACT[STATE[01;31m-[00mNAME] [01;31m-[00m[01;31m-[00m Default rule to reduce with in state
_gaff_Parser.cc:584:   STATE[01;31m-[00mNUM when YYTABLE doesn't specify something else to do.  Zero
_gaff_Parser.cc:599:/* YYDEFGOTO[NTERM[01;31m-[00mNUM].  */
_gaff_Parser.cc:602:      [01;31m-[00m1,     2,     5,     6,     7,    11,    16,    22,    27,    31,
_gaff_Parser.cc:607:/* YYPACT[STATE[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m Index in YYTABLE of the portion describing
_gaff_Parser.cc:608:   STATE[01;31m-[00mNUM.  */
_gaff_Parser.cc:609:#define YYPACT_NINF [01;31m-[00m43
_gaff_Parser.cc:612:      [01;31m-[00m9,    10,    28,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,    50,    30,   [01;31m-[00m43,   [01;31m-[00m43,
_gaff_Parser.cc:613:     [01;31m-[00m43,    [01;31m-[00m1,     0,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,     3,    10,   [01;31m-[00m43,   [01;31m-[00m43,
_gaff_Parser.cc:614:     [01;31m-[00m43,   [01;31m-[00m43,     4,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,     5,   [01;31m-[00m43,   [01;31m-[00m43,
_gaff_Parser.cc:615:     [01;31m-[00m43,    24,   [01;31m-[00m43,   [01;31m-[00m43,    22,    40,   [01;31m-[00m43,    16,   [01;31m-[00m43,    11,
_gaff_Parser.cc:616:     [01;31m-[00m16,    37,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,    53,    [01;31m-[00m3,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,
_gaff_Parser.cc:617:     [01;31m-[00m43,    25,   [01;31m-[00m43,   [01;31m-[00m43,    22,    22,   [01;31m-[00m43,   [01;31m-[00m43,     9,   [01;31m-[00m43,
_gaff_Parser.cc:618:      42,     6,   [01;31m-[00m43,    44,    57,   [01;31m-[00m43,    47,   [01;31m-[00m43,   [01;31m-[00m43,    53,
_gaff_Parser.cc:619:     [01;31m-[00m43,    22,    54,    52,    43,   [01;31m-[00m43,   [01;31m-[00m43,    41,    52,    45,
_gaff_Parser.cc:620:     [01;31m-[00m43,    55,   [01;31m-[00m43,   [01;31m-[00m43,    56,    46,   [01;31m-[00m43,   [01;31m-[00m43
_gaff_Parser.cc:623:/* YYPGOTO[NTERM[01;31m-[00mNUM].  */
_gaff_Parser.cc:626:     [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,    20,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,
_gaff_Parser.cc:627:     [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m42,   [01;31m-[00m43,     7,   [01;31m-[00m43,     2,   [01;31m-[00m43,   [01;31m-[00m43,
_gaff_Parser.cc:628:       1,    [01;31m-[00m6
_gaff_Parser.cc:631:/* YYTABLE[YYPACT[STATE[01;31m-[00mNUM]].  What to do in state STATE[01;31m-[00mNUM.  If
_gaff_Parser.cc:635:#define YYTABLE_NINF [01;31m-[00m1
_gaff_Parser.cc:656:       3,    14,    10,     9,    21,    19,    21,    60,    12,    [01;31m-[00m1,
_gaff_Parser.cc:660:/* YYSTOS[STATE[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m The (internal number of the) accessing
_gaff_Parser.cc:661:   symbol of state STATE[01;31m-[00mNUM.  */
_gaff_Parser.cc:677:#define YYEMPTY		([01;31m-[00m2)
_gaff_Parser.cc:695:     [01;31m-[00mWunused[01;31m-[00mmacros.  Normally we don't worry about that warning, but
_gaff_Parser.cc:724:/* YYLLOC_DEFAULT [01;31m-[00m[01;31m-[00m Set CURRENT to span from RHS[1] to RHS[N].
_gaff_Parser.cc:750:/* YY_LOCATION_PRINT [01;31m-[00m[01;31m-[00m Print the location on the stream.
_gaff_Parser.cc:757:     fprintf (File, "%d.%d[01;31m-[00m%d.%d",			\
_gaff_Parser.cc:766:/* YYLEX [01;31m-[00m[01;31m-[00m calling `yylex' with the right arguments.  */
_gaff_Parser.cc:800:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:802:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:837:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:839:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:866:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:867:| yy_stack_print [01;31m-[00m[01;31m-[00m Print the state stack from its BOTTOM up to its |
_gaff_Parser.cc:869:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:898:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:900:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:919:	     yyrule [01;31m-[00m 1, yylno);
_gaff_Parser.cc:925:		       &(yyvsp[(yyi + 1) [01;31m-[00m (yynrhs)])
_gaff_Parser.cc:926:		       , &(yylsp[(yyi + 1) [01;31m-[00m (yynrhs)])		       , data);
_gaff_Parser.cc:948:/* YYINITDEPTH [01;31m-[00m[01;31m-[00m initial size of the parser's stacks.  */
_gaff_Parser.cc:953:/* YYMAXDEPTH [01;31m-[00m[01;31m-[00m maximum size the stacks can grow to (effective only
_gaff_Parser.cc:954:   if the built[01;31m-[00min stack extension method is used).
_gaff_Parser.cc:958:   evaluated with infinite[01;31m-[00mprecision integer arithmetic.  */
_gaff_Parser.cc:1014:  return yyd [01;31m-[00m 1;
_gaff_Parser.cc:1022:   heuristic is that double[01;31m-[00mquoting is unnecessary unless the string
_gaff_Parser.cc:1024:   backslash[01;31m-[00mbackslash).  YYSTR is taken from yytname.  If YYRES is
_gaff_Parser.cc:1063:  return yystpcpy (yyres, yystr) [01;31m-[00m yyres;
_gaff_Parser.cc:1107:		    + sizeof yyexpecting [01;31m-[00m 1
_gaff_Parser.cc:1108:		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM [01;31m-[00m 2)
_gaff_Parser.cc:1109:		       * (sizeof yyor [01;31m-[00m 1))];
_gaff_Parser.cc:1112:      /* Start YYX at [01;31m-[00mYYN if negative to avoid negative indexes in
_gaff_Parser.cc:1114:      int yyxbegin = yyn < 0 ? [01;31m-[00myyn : 0;
_gaff_Parser.cc:1117:      int yychecklim = YYLAST [01;31m-[00m yyn + 1;
_gaff_Parser.cc:1131:		yyformat[sizeof yyunexpected [01;31m-[00m 1] = '\0';
_gaff_Parser.cc:1177:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:1179:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:1210:	{ if ((yyvaluep[01;31m-[00m>antechamberRoot)!=NULL) delete ((yyvaluep[01;31m-[00m>antechamberRoot)); };
_gaff_Parser.cc:1219:	{ if ((yyvaluep[01;31m-[00m>residueList)!=NULL) delete ((yyvaluep[01;31m-[00m>residueList)); };
_gaff_Parser.cc:1228:	{ if ((yyvaluep[01;31m-[00m>logical)!=NULL) delete ((yyvaluep[01;31m-[00m>logical)); };
_gaff_Parser.cc:1237:	{ if ((yyvaluep[01;31m-[00m>bondListMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>bondListMatchNode)); };
_gaff_Parser.cc:1246:	{ if ((yyvaluep[01;31m-[00m>afterMatchBondTest)!=NULL) delete ((yyvaluep[01;31m-[00m>afterMatchBondTest)); };
_gaff_Parser.cc:1255:	{ if ((yyvaluep[01;31m-[00m>logical)!=NULL) delete ((yyvaluep[01;31m-[00m>logical)); };
_gaff_Parser.cc:1264:	{ if ((yyvaluep[01;31m-[00m>atomTest)!=NULL) delete ((yyvaluep[01;31m-[00m>atomTest)); };
_gaff_Parser.cc:1273:	{ if ((yyvaluep[01;31m-[00m>bondListMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>bondListMatchNode)); };
_gaff_Parser.cc:1282:	{ if ((yyvaluep[01;31m-[00m>bondListMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>bondListMatchNode)); };
_gaff_Parser.cc:1291:	{ if ((yyvaluep[01;31m-[00m>bondListMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>bondListMatchNode)); };
_gaff_Parser.cc:1300:	{ if ((yyvaluep[01;31m-[00m>antechamberBondTest)!=NULL) delete ((yyvaluep[01;31m-[00m>antechamberBondTest)); };
_gaff_Parser.cc:1309:	{ if ((yyvaluep[01;31m-[00m>logical)!=NULL) delete ((yyvaluep[01;31m-[00m>logical)); };
_gaff_Parser.cc:1320:/* Prevent warnings from [01;31m-[00mWmissing[01;31m-[00mprototypes.  */
_gaff_Parser.cc:1339:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:1341:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:1425:#define YYPOPSTACK(N)   (yyvsp [01;31m-[00m= (N), yyssp [01;31m-[00m= (N), yylsp [01;31m-[00m= (N))
_gaff_Parser.cc:1460:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:1461:| yynewstate [01;31m-[00m[01;31m-[00m Push a new state, which is found in yystate.  |
_gaff_Parser.cc:1462:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:1471:  if (yyss + yystacksize [01;31m-[00m 1 <= yyssp)
_gaff_Parser.cc:1474:      YYSIZE_T yysize = yyssp [01;31m-[00m yyss + 1;
_gaff_Parser.cc:1526:      yyssp = yyss + yysize [01;31m-[00m 1;
_gaff_Parser.cc:1527:      yyvsp = yyvs + yysize [01;31m-[00m 1;
_gaff_Parser.cc:1528:      yylsp = yyls + yysize [01;31m-[00m 1;
_gaff_Parser.cc:1533:      if (yyss + yystacksize [01;31m-[00m 1 <= yyssp)
_gaff_Parser.cc:1544:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:1546:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:1587:      yyn = [01;31m-[00myyn;
_gaff_Parser.cc:1594:    yyerrstatus[01;31m-[00m[01;31m-[00m;
_gaff_Parser.cc:1608:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:1609:| yydefault [01;31m-[00m[01;31m-[00m do the default action for the current state.  |
_gaff_Parser.cc:1610:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:1618:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:1619:| yyreduce [01;31m-[00m[01;31m-[00m Do a reduction.  |
_gaff_Parser.cc:1620:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:1633:  yyval = yyvsp[1[01;31m-[00myylen];
_gaff_Parser.cc:1636:  YYLLOC_DEFAULT (yyloc, (yylsp [01;31m-[00m yylen), yylen);
_gaff_Parser.cc:1644:    { data[01;31m-[00m>expression = (yyvsp[(2) [01;31m-[00m (2)].antechamberRoot)[01;31m-[00m>_obj; LOG(BF("Got AntechamberMatch tree=%0X") % (yyvsp[(2) [01;31m-[00m (2)].antechamberRoot) ); ;}
_gaff_Parser.cc:1654:                    focus = chemInfo::O_AntechamberFocusAtomMatch::create( (yyvsp[(2) [01;31m-[00m (10)].residueList)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (10)].ival), (yyvsp[(4) [01;31m-[00m (10)].ival), (yyvsp[(5) [01;31m-[00m (10)].ival), (yyvsp[(6) [01;31m-[00m (10)].ival), (yyvsp[(7) [01;31m-[00m (10)].logical)[01;31m-[00m>_obj, GP()[01;31m-[00m>lisp );
_gaff_Parser.cc:1655:                    (yyval.antechamberRoot) = new Hold<chemInfo::O_AntechamberRoot>(chemInfo::O_AntechamberRoot::create((yyvsp[(1) [01;31m-[00m (10)].carr),focus,(yyvsp[(8) [01;31m-[00m (10)].bondListMatchNode)[01;31m-[00m>_obj,(yyvsp[(9) [01;31m-[00m (10)].afterMatchBondTest)[01;31m-[00m>_obj,GP()[01;31m-[00m>lisp)); 
_gaff_Parser.cc:1666:                    focus = chemInfo::O_AntechamberFocusAtomMatch::create( (yyvsp[(2) [01;31m-[00m (9)].residueList)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (9)].ival), (yyvsp[(4) [01;31m-[00m (9)].ival), (yyvsp[(5) [01;31m-[00m (9)].ival), (yyvsp[(6) [01;31m-[00m (9)].ival), (yyvsp[(7) [01;31m-[00m (9)].logical)[01;31m-[00m>_obj, GP()[01;31m-[00m>lisp );
_gaff_Parser.cc:1667:                    (yyval.antechamberRoot) = new Hold<chemInfo::O_AntechamberRoot>(chemInfo::O_AntechamberRoot::create((yyvsp[(1) [01;31m-[00m (9)].carr),focus,(yyvsp[(8) [01;31m-[00m (9)].bondListMatchNode)[01;31m-[00m>_obj,GP()[01;31m-[00m>lisp)); 
_gaff_Parser.cc:1678:                    focus = chemInfo::O_AntechamberFocusAtomMatch::create( (yyvsp[(2) [01;31m-[00m (8)].residueList)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (8)].ival), (yyvsp[(4) [01;31m-[00m (8)].ival), (yyvsp[(5) [01;31m-[00m (8)].ival), (yyvsp[(6) [01;31m-[00m (8)].ival), (yyvsp[(7) [01;31m-[00m (8)].logical)[01;31m-[00m>_obj ,GP()[01;31m-[00m>lisp);
_gaff_Parser.cc:1679:                    (yyval.antechamberRoot) = new Hold<chemInfo::O_AntechamberRoot>(chemInfo::O_AntechamberRoot::create((yyvsp[(1) [01;31m-[00m (8)].carr),focus,GP()[01;31m-[00m>lisp)); 
_gaff_Parser.cc:1691:		    temp = chemInfo::O_AtomOrBondMatchNode::nil(GP()[01;31m-[00m>lisp);
_gaff_Parser.cc:1692:                    focus = chemInfo::O_AntechamberFocusAtomMatch::create( (yyvsp[(2) [01;31m-[00m (7)].residueList)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (7)].ival), (yyvsp[(4) [01;31m-[00m (7)].ival), (yyvsp[(5) [01;31m-[00m (7)].ival), (yyvsp[(6) [01;31m-[00m (7)].ival), temp ,GP()[01;31m-[00m>lisp);
_gaff_Parser.cc:1693:                    (yyval.antechamberRoot) = new Hold<chemInfo::O_AntechamberRoot>(chemInfo::O_AntechamberRoot::create((yyvsp[(1) [01;31m-[00m (7)].carr),focus,GP()[01;31m-[00m>lisp)); 
_gaff_Parser.cc:1704:                    focus = chemInfo::O_AntechamberFocusAtomMatch::create( (yyvsp[(2) [01;31m-[00m (6)].residueList)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (6)].ival), (yyvsp[(4) [01;31m-[00m (6)].ival), (yyvsp[(5) [01;31m-[00m (6)].ival), [01;31m-[00m1,GP()[01;31m-[00m>lisp);
_gaff_Parser.cc:1705:                    (yyval.antechamberRoot) = new Hold<chemInfo::O_AntechamberRoot>(chemInfo::O_AntechamberRoot::create((yyvsp[(1) [01;31m-[00m (6)].carr),focus,GP()[01;31m-[00m>lisp)); 
_gaff_Parser.cc:1716:		    focus = chemInfo::O_AntechamberFocusAtomMatch::create( (yyvsp[(2) [01;31m-[00m (5)].residueList)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (5)].ival), (yyvsp[(4) [01;31m-[00m (5)].ival), [01;31m-[00m1, [01;31m-[00m1,GP()[01;31m-[00m>lisp);
_gaff_Parser.cc:1717:                    (yyval.antechamberRoot) = new Hold<chemInfo::O_AntechamberRoot>(chemInfo::O_AntechamberRoot::create((yyvsp[(1) [01;31m-[00m (5)].carr),focus,GP()[01;31m-[00m>lisp));
_gaff_Parser.cc:1728:                    focus = chemInfo::O_AntechamberFocusAtomMatch::create( (yyvsp[(2) [01;31m-[00m (4)].residueList)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (4)].ival), [01;31m-[00m1, [01;31m-[00m1, [01;31m-[00m1 ,GP()[01;31m-[00m>lisp);
_gaff_Parser.cc:1729:                    (yyval.antechamberRoot) = new Hold<chemInfo::O_AntechamberRoot>(chemInfo::O_AntechamberRoot::create((yyvsp[(1) [01;31m-[00m (4)].carr),focus,GP()[01;31m-[00m>lisp)); 
_gaff_Parser.cc:1740:                    focus = chemInfo::O_AntechamberFocusAtomMatch::create( (yyvsp[(2) [01;31m-[00m (3)].residueList)[01;31m-[00m>_obj, [01;31m-[00m1, [01;31m-[00m1, [01;31m-[00m1, [01;31m-[00m1,GP()[01;31m-[00m>lisp);
_gaff_Parser.cc:1741:                    (yyval.antechamberRoot) = new Hold<chemInfo::O_AntechamberRoot>(chemInfo::O_AntechamberRoot::create((yyvsp[(1) [01;31m-[00m (3)].carr),focus,GP()[01;31m-[00m>lisp)); 
_gaff_Parser.cc:1752:		    focus = chemInfo::O_AntechamberFocusAtomMatch::nil(GP()[01;31m-[00m>lisp);
_gaff_Parser.cc:1753:                    (yyval.antechamberRoot) = new Hold<chemInfo::O_AntechamberRoot>(chemInfo::O_AntechamberRoot::create((yyvsp[(1) [01;31m-[00m (2)].carr),focus,GP()[01;31m-[00m>lisp));
_gaff_Parser.cc:1761:    { strcpy((yyval.carr),(yyvsp[(1) [01;31m-[00m (1)].carr)); ;}
_gaff_Parser.cc:1768:    { stringstream ss; ss << (yyvsp[(1) [01;31m-[00m (3)].carr) << "." << (yyvsp[(3) [01;31m-[00m (3)].ival); strcpy((yyval.carr),ss.str().c_str()); ;}
_gaff_Parser.cc:1775:    { stringstream ss; ss << (yyvsp[(1) [01;31m-[00m (4)].carr) << "." << (yyvsp[(3) [01;31m-[00m (4)].ival) << (yyvsp[(4) [01;31m-[00m (4)].carr); strcpy((yyval.carr),ss.str().c_str()); ;}
_gaff_Parser.cc:1782:    { stringstream ss; ss << (yyvsp[(1) [01;31m-[00m (3)].carr) << "." << (yyvsp[(3) [01;31m-[00m (3)].carr); strcpy((yyval.carr),ss.str().c_str()); ;}
_gaff_Parser.cc:1789:    { strcpy((yyval.carr),(yyvsp[(1) [01;31m-[00m (1)].carr)); ;}
_gaff_Parser.cc:1796:    { strcpy((yyval.carr),(yyvsp[(1) [01;31m-[00m (1)].carr)); ;}
_gaff_Parser.cc:1803:    { (yyval.residueList) = new Hold<chemInfo::O_ResidueList>(GP()[01;31m-[00m>lisp); ;}
_gaff_Parser.cc:1810:    { (yyval.ival) = [01;31m-[00m1; ;}
_gaff_Parser.cc:1817:    { (yyval.ival) = (yyvsp[(1) [01;31m-[00m (1)].ival); ;}
_gaff_Parser.cc:1824:    { (yyval.ival) = [01;31m-[00m1; ;}
_gaff_Parser.cc:1831:    { (yyval.ival) = (yyvsp[(1) [01;31m-[00m (1)].ival); ;}
_gaff_Parser.cc:1838:    { (yyval.ival) = [01;31m-[00m1; ;}
_gaff_Parser.cc:1845:    { (yyval.ival) = (yyvsp[(1) [01;31m-[00m (1)].ival); ;}
_gaff_Parser.cc:1852:    { (yyval.ival) = [01;31m-[00m1; ;}
_gaff_Parser.cc:1859:    { (yyval.ival) = (yyvsp[(1) [01;31m-[00m (1)].ival); ;}
_gaff_Parser.cc:1866:    { _BT(); (yyval.logical) = new Hold<chemInfo::O_Logical>(GP()[01;31m-[00m>lisp); ;}
_gaff_Parser.cc:1875:		(yyval.logical) = new Hold<chemInfo::O_Logical>((yyvsp[(2) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj); ;}
_gaff_Parser.cc:1882:    { _BT(); (yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(GP()[01;31m-[00m>lisp); ;}
_gaff_Parser.cc:1889:    { _BT(); (yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>((yyvsp[(1) [01;31m-[00m (1)].bondListMatchNode)[01;31m-[00m>_obj); ;}
_gaff_Parser.cc:1896:    {_BT(); (yyval.afterMatchBondTest) = new Hold<chemInfo::O_AfterMatchBondTest>(chemInfo::O_AfterMatchBondTest::create( (yyvsp[(1) [01;31m-[00m (5)].carr), (yyvsp[(3) [01;31m-[00m (5)].carr), (yyvsp[(5) [01;31m-[00m (5)].benum) ,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1903:    {_BT(); (yyval.logical) = new Hold<chemInfo::O_Logical>(chemInfo::O_Logical::create( chemInfo::logIdentity, (yyvsp[(1) [01;31m-[00m (1)].atomTest)[01;31m-[00m>_obj ,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1910:    { _BT();(yyval.logical) = new Hold<chemInfo::O_Logical>(chemInfo::O_Logical::create(chemInfo::logHighPrecedenceAnd, (yyvsp[(1) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj ,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1917:    {_BT(); (yyval.logical) = new Hold<chemInfo::O_Logical>(chemInfo::O_Logical::create(chemInfo::logOr, (yyvsp[(1) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj ,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1924:    { _BT(); (yyval.atomTest) = new Hold<chemInfo::O_AtomTest>(chemInfo::O_AtomTest::create(chemInfo::SAPInBond, (yyvsp[(1) [01;31m-[00m (1)].benum), 1,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1931:    { _BT(); (yyval.atomTest) = new Hold<chemInfo::O_AtomTest>(chemInfo::O_AtomTest::create(chemInfo::SAPInBond, (yyvsp[(2) [01;31m-[00m (2)].benum), (yyvsp[(1) [01;31m-[00m (2)].ival),GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1938:    { _BT(); (yyval.atomTest) = new Hold<chemInfo::O_AtomTest>(chemInfo::O_AtomTest::create(chemInfo::SAPNotBondedToPrevious,(yyvsp[(1) [01;31m-[00m (2)].benum),GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1945:    { _BT(); (yyval.atomTest) = new Hold<chemInfo::O_AtomTest>(chemInfo::O_AtomTest::create(chemInfo::SAPBondedToPrevious,(yyvsp[(1) [01;31m-[00m (2)].benum),GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1952:    { _BT(); (yyval.atomTest) = new Hold<chemInfo::O_AtomTest>(chemInfo::O_AtomTest::create(chemInfo::SAPArLevel, (yyvsp[(1) [01;31m-[00m (1)].ival) ,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1959:    { _BT(); (yyval.atomTest) = new Hold<chemInfo::O_AtomTest>(chemInfo::O_AtomTest::create(chemInfo::SAPRingSize, 1 ,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1966:    { _BT(); (yyval.atomTest) = new Hold<chemInfo::O_AtomTest>(chemInfo::O_AtomTest::create(chemInfo::SAPRingSize, (yyvsp[(2) [01;31m-[00m (2)].ival) ,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1973:    { _BT(); (yyval.atomTest) = new Hold<chemInfo::O_AtomTest>(chemInfo::O_AtomTest::create(chemInfo::SAPRingSize, (yyvsp[(3) [01;31m-[00m (3)].ival), (yyvsp[(1) [01;31m-[00m (3)].ival) ,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1980:    { _BT(); (yyval.atomTest) = new Hold<chemInfo::O_AtomTest>(chemInfo::O_AtomTest::create(chemInfo::SAPNoRing,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:1987:    { _BT(); (yyval.bondListMatchNode)=(yyvsp[(2) [01;31m-[00m (3)].bondListMatchNode); ;}
_gaff_Parser.cc:1994:    { _BT(); (yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>((yyvsp[(1) [01;31m-[00m (1)].bondListMatchNode)[01;31m-[00m>_obj); ;}
_gaff_Parser.cc:2001:    { _BT(); (yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Branch::create((yyvsp[(1) [01;31m-[00m (3)].bondListMatchNode)[01;31m-[00m>_obj,(yyvsp[(3) [01;31m-[00m (3)].bondListMatchNode)[01;31m-[00m>_obj,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:2008:    { _BT();(yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Chain::create((yyvsp[(1) [01;31m-[00m (1)].antechamberBondTest)[01;31m-[00m>_obj,GP()[01;31m-[00m>lisp));;}
_gaff_Parser.cc:2015:    { _BT(); (yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Chain::create((yyvsp[(1) [01;31m-[00m (2)].antechamberBondTest)[01;31m-[00m>_obj,(yyvsp[(2) [01;31m-[00m (2)].bondListMatchNode)[01;31m-[00m>_obj,GP()[01;31m-[00m>lisp)); ;}
_gaff_Parser.cc:2023:                    (yyval.antechamberBondTest) = new Hold<chemInfo::O_AntechamberBondTest>(chemInfo::O_AntechamberBondTest::create((yyvsp[(1) [01;31m-[00m (4)].carr),(yyvsp[(2) [01;31m-[00m (4)].ival),(yyvsp[(3) [01;31m-[00m (4)].logical)[01;31m-[00m>_obj,(yyvsp[(4) [01;31m-[00m (4)].carr),GP()[01;31m-[00m>lisp)); 
_gaff_Parser.cc:2032:                    (yyval.antechamberBondTest) = new Hold<chemInfo::O_AntechamberBondTest>(chemInfo::O_AntechamberBondTest::create((yyvsp[(1) [01;31m-[00m (3)].carr), [01;31m-[00m1, (yyvsp[(2) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (3)].carr),GP()[01;31m-[00m>lisp));
_gaff_Parser.cc:2040:    { _BT(); strcpy((yyval.carr),(yyvsp[(1) [01;31m-[00m (1)].carr)); ;}
_gaff_Parser.cc:2047:    { _BT(); strcpy((yyval.carr),(yyvsp[(1) [01;31m-[00m (1)].carr)); ;}
_gaff_Parser.cc:2054:    { _BT(); (yyval.logical) = new Hold<chemInfo::O_Logical>(GP()[01;31m-[00m>lisp); ;}
_gaff_Parser.cc:2061:    { _BT(); (yyval.logical) = new Hold<chemInfo::O_Logical>((yyvsp[(2) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj); ;}
_gaff_Parser.cc:2075:    { _BT(); strcpy((yyval.carr),(yyvsp[(2) [01;31m-[00m (3)].carr)); ;}
_gaff_Parser.cc:2084:  YY_SYMBOL_PRINT ("[01;31m-[00m> $$ =", yyr1[yyn], &yyval, &yyloc);
_gaff_Parser.cc:2099:  yystate = yypgoto[yyn [01;31m-[00m YYNTOKENS] + *yyssp;
_gaff_Parser.cc:2103:    yystate = yydefgoto[yyn [01;31m-[00m YYNTOKENS];
_gaff_Parser.cc:2108:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:2109:| yyerrlab [01;31m-[00m[01;31m-[00m here on detecting error |
_gaff_Parser.cc:2110:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:2179:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:2180:| yyerrorlab [01;31m-[00m[01;31m-[00m error raised explicitly by YYERROR.  |
_gaff_Parser.cc:2181:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:2190:  yyerror_range[1] = yylsp[1[01;31m-[00myylen];
_gaff_Parser.cc:2200:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:2201:| yyerrlab1 [01;31m-[00m[01;31m-[00m common code for both syntax error and YYERROR.  |
_gaff_Parser.cc:2202:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:2247:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:2248:| yyacceptlab [01;31m-[00m[01;31m-[00m YYACCEPT comes here.  |
_gaff_Parser.cc:2249:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:2254:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:2255:| yyabortlab [01;31m-[00m[01;31m-[00m YYABORT comes here.  |
_gaff_Parser.cc:2256:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:2262:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_gaff_Parser.cc:2263:| yyexhaustedlab [01;31m-[00m[01;31m-[00m memory exhaustion comes here.  |
_gaff_Parser.cc:2264:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_gaff_Parser.cc:2421:    *(data[01;31m-[00m>gaffErrorStream) << "Error: " << message << endl;
_gaff_Parser.cc:2429:	ichar = data[01;31m-[00m>acLexStream[01;31m-[00m>get();	 // Read one character
_gaff_Parser.cc:2432:    } while (!data[01;31m-[00m>acLexStream[01;31m-[00m>eof() && ichar <= ' ' );
_gaff_Parser.cc:2433:    if ( data[01;31m-[00m>acLexStream[01;31m-[00m>eof() ) return 0;
_gaff_Parser.cc:2438:    if ( data[01;31m-[00m>wildElementDictionary[01;31m-[00m>notNil() ) {
_gaff_Parser.cc:2439:        if ( data[01;31m-[00m>wildElementDictionary[01;31m-[00m>lexWildNameMatches2Char(ichar,
_gaff_Parser.cc:2440:                                        data[01;31m-[00m>acLexStream[01;31m-[00m>peek()) )
_gaff_Parser.cc:2442:            int ichar2 = data[01;31m-[00m>acLexStream[01;31m-[00m>get();
_gaff_Parser.cc:2443:            gaff_lval[01;31m-[00m>carr[0] = ichar;
_gaff_Parser.cc:2444:            gaff_lval[01;31m-[00m>carr[1] = ichar2;
_gaff_Parser.cc:2445:            gaff_lval[01;31m-[00m>carr[2] = '\0';
_gaff_Parser.cc:2447:                                gaff_lval[01;31m-[00m>carr));
_gaff_Parser.cc:2450:        if ( data[01;31m-[00m>wildElementDictionary[01;31m-[00m>lexWildNameMatches1Char(ichar) ) {
_gaff_Parser.cc:2451:            gaff_lval[01;31m-[00m>carr[0] = ichar;
_gaff_Parser.cc:2452:            gaff_lval[01;31m-[00m>carr[1] = '\0';
_gaff_Parser.cc:2454:                                gaff_lval[01;31m-[00m>carr));
_gaff_Parser.cc:2517:    LOG(BF("peek(%c)") % (acLexStream[01;31m-[00m>peek() ) ); // vp0(( "peek(%c)", acLexStream[01;31m-[00m>peek() ));
_gaff_Parser.cc:2519:    if ( ichar == 'A' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'T' ) {
_gaff_Parser.cc:2520:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();
_gaff_Parser.cc:2521:        LOG(BF("peek2(%c)") % (acLexStream[01;31m-[00m>peek() ) ); // vp0(( "peek2(%c)", acLexStream[01;31m-[00m>peek() ));
_gaff_Parser.cc:2522:        if ( data[01;31m-[00m>acLexStream[01;31m-[00m>peek() != 'D' ) {
_gaff_Parser.cc:2525:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();
_gaff_Parser.cc:2531:    if (ichar == 'A' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'R') {
_gaff_Parser.cc:2532:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();
_gaff_Parser.cc:2533:        int aridx = data[01;31m-[00m>acLexStream[01;31m-[00m>get()[01;31m-[00m'0';
_gaff_Parser.cc:2535:            gaff_lval[01;31m-[00m>ival = aridx;
_gaff_Parser.cc:2544:    if (ichar == 'R' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'G') {
_gaff_Parser.cc:2545:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();	
_gaff_Parser.cc:2551:    if (ichar == 'N' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'G') {
_gaff_Parser.cc:2552:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();	
_gaff_Parser.cc:2558:    if (ichar == 'S' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'B') {
_gaff_Parser.cc:2559:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();	
_gaff_Parser.cc:2561:        gaff_lval[01;31m-[00m>benum = chemInfo::SABSingleBond;
_gaff_Parser.cc:2564:    if (ichar == 'D' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'B') {
_gaff_Parser.cc:2565:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();	
_gaff_Parser.cc:2567:        gaff_lval[01;31m-[00m>benum = chemInfo::SABDoubleBond;
_gaff_Parser.cc:2570:    if (ichar == 'D' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'L') {
_gaff_Parser.cc:2571:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();	
_gaff_Parser.cc:2573:        gaff_lval[01;31m-[00m>benum = chemInfo::SABDelocalizedBond;
_gaff_Parser.cc:2576:    if (ichar == 'T' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'B') {
_gaff_Parser.cc:2577:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();	
_gaff_Parser.cc:2579:        gaff_lval[01;31m-[00m>benum = chemInfo::SABTripleBond;
_gaff_Parser.cc:2582:    if (ichar == 's' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'b') {
_gaff_Parser.cc:2583:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();	
_gaff_Parser.cc:2585:        gaff_lval[01;31m-[00m>benum = chemInfo::SABSingleOrAromaticBond;
_gaff_Parser.cc:2588:    if (ichar == 'd' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'b') {
_gaff_Parser.cc:2589:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();	
_gaff_Parser.cc:2591:        gaff_lval[01;31m-[00m>benum = chemInfo::SABDoubleOrAromaticBond;
_gaff_Parser.cc:2594:    if (ichar == 't' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'b') {
_gaff_Parser.cc:2595:        data[01;31m-[00m>acLexStream[01;31m-[00m>get();	
_gaff_Parser.cc:2597:        gaff_lval[01;31m-[00m>benum = chemInfo::SABTripleBond;
_gaff_Parser.cc:2600:    if (ichar == 'a' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == 'n') {
_gaff_Parser.cc:2601:        data[01;31m-[00m>acLexStream[01;31m-[00m>get(); // eat 'n'
_gaff_Parser.cc:2602:        char fc = data[01;31m-[00m>acLexStream[01;31m-[00m>get(); // eat 'y'
_gaff_Parser.cc:2607:        gaff_lval[01;31m-[00m>benum = chemInfo::SABAnyBond;
_gaff_Parser.cc:2612:        if ( data[01;31m-[00m>acLexStream[01;31m-[00m>peek() == '\'' ) {
_gaff_Parser.cc:2613:            data[01;31m-[00m>acLexStream[01;31m-[00m>get();
_gaff_Parser.cc:2625:		if ( acElementTable[i][1] == data[01;31m-[00m>acLexStream[01;31m-[00m>peek() ) {
_gaff_Parser.cc:2626:		    data[01;31m-[00m>acLexStream[01;31m-[00m>get();
_gaff_Parser.cc:2629:		    strcpy( gaff_lval[01;31m-[00m>carr ,  acElementTable[i] );
_gaff_Parser.cc:2630://		    gaff_lval[01;31m-[00m>eval = acElementTable[i];
_gaff_Parser.cc:2636:                strcpy( gaff_lval[01;31m-[00m>carr, acElementTable[i] );
_gaff_Parser.cc:2637://		gaff_lval[01;31m-[00m>eval = acElementTable[i];
_gaff_Parser.cc:2646:        while ( (data[01;31m-[00m>acLexStream[01;31m-[00m>peek()>='a'&&data[01;31m-[00m>acLexStream[01;31m-[00m>peek()<='z') ||
_gaff_Parser.cc:2647:                (data[01;31m-[00m>acLexStream[01;31m-[00m>peek()>='A'&&data[01;31m-[00m>acLexStream[01;31m-[00m>peek()<='Z') ||
_gaff_Parser.cc:2648:                (data[01;31m-[00m>acLexStream[01;31m-[00m>peek()>='0'&&data[01;31m-[00m>acLexStream[01;31m-[00m>peek()<='9') ) {
_gaff_Parser.cc:2649:            ichar = data[01;31m-[00m>acLexStream[01;31m-[00m>get();
_gaff_Parser.cc:2652:        strcpy(gaff_lval[01;31m-[00m>carr,tagStr.c_str());
_gaff_Parser.cc:2653:        LOG(BF("Got tag(%s)") % (gaff_lval[01;31m-[00m>carr) ); // vp0(( "Got tag(%s)",gaff_lval[01;31m-[00m>carr));
_gaff_Parser.cc:2666:	    while ( data[01;31m-[00m>acLexStream[01;31m-[00m>peek()>='0' && data[01;31m-[00m>acLexStream[01;31m-[00m>peek()<='9' ) 
_gaff_Parser.cc:2668:		    ichar = data[01;31m-[00m>acLexStream[01;31m-[00m>get();
_gaff_Parser.cc:2672:	    gaff_lval[01;31m-[00m>ival = atoi(numStr.c_str());
_gaff_Parser.cc:2673:	    LEXDPRINT(("APNumber(%d)", gaff_lval[01;31m-[00m>ival));
_gaff_Parser.cc:2695:    p.expression = lisp[01;31m-[00m>nil<O_AntechamberRoot>();
_gaff_Parser.cc:2702:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("%s") % (p.gaffErrorStream[01;31m-[00m>str())));
_lisp_Lexer.cc:17:/* First, we deal with  platform[01;31m-[00mspecific or compiler[01;31m-[00mspecific issues. */
_lisp_Lexer.cc:32:/* C99 systems have <inttypes.h>. Non[01;31m-[00mC99 systems may or may not. */
_lisp_Lexer.cc:61:#define INT8_MIN               ([01;31m-[00m128)
_lisp_Lexer.cc:64:#define INT16_MIN              ([01;31m-[00m32767[01;31m-[00m1)
_lisp_Lexer.cc:67:#define INT32_MIN              ([01;31m-[00m2147483647[01;31m-[00m1)
_lisp_Lexer.cc:92:/* The "const" storage[01;31m-[00mclass[01;31m-[00mmodifier is valid. */
_lisp_Lexer.cc:111:/* Returned upon end[01;31m-[00mof[01;31m-[00mfile. */
_lisp_Lexer.cc:116: * we want to instead treat it as an 8[01;31m-[00mbit unsigned char, hence the
_lisp_Lexer.cc:129:#define yyin yyg[01;31m-[00m>yyin_r
_lisp_Lexer.cc:130:#define yyout yyg[01;31m-[00m>yyout_r
_lisp_Lexer.cc:131:#define yyextra yyg[01;31m-[00m>yyextra_r
_lisp_Lexer.cc:132:#define yyleng yyg[01;31m-[00m>yyleng_r
_lisp_Lexer.cc:133:#define yytext yyg[01;31m-[00m>yytext_r
_lisp_Lexer.cc:134:#define yylineno (YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_bs_lineno)
_lisp_Lexer.cc:135:#define yycolumn (YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_bs_column)
_lisp_Lexer.cc:136:#define yy_flex_debug yyg[01;31m-[00m>yy_flex_debug_r
_lisp_Lexer.cc:139: * but we do it the disgusting crufty way forced on us by the ()[01;31m-[00mless
_lisp_Lexer.cc:142:#define BEGIN yyg[01;31m-[00m>yy_start = 1 + 2 *
_lisp_Lexer.cc:148:#define YY_START ((yyg[01;31m-[00m>yy_start [01;31m-[00m 1) / 2)
_lisp_Lexer.cc:186:     *       a 5% performance hit in a non[01;31m-[00myylineno scanner, because yy_act is
_lisp_Lexer.cc:187:     *       normally declared as a register variable[01;31m-[00m[01;31m-[00m so it is not worth it.
_lisp_Lexer.cc:194:                        [01;31m-[00m[01;31m-[00myylineno;\
_lisp_Lexer.cc:204:		*yy_cp = yyg[01;31m-[00m>yy_hold_char; \
_lisp_Lexer.cc:206:		yyg[01;31m-[00m>yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg [01;31m-[00m YY_MORE_ADJ; \
_lisp_Lexer.cc:211:#define unput(c) yyunput( c, yyg[01;31m-[00m>yytext_ptr , yyscanner )
_lisp_Lexer.cc:232:	/* Whether we "own" the buffer [01;31m-[00m i.e., we know we created it,
_lisp_Lexer.cc:267:	 * possible backing[01;31m-[00mup.
_lisp_Lexer.cc:284:#define YY_CURRENT_BUFFER ( yyg[01;31m-[00m>yy_buffer_stack \
_lisp_Lexer.cc:285:                          ? yyg[01;31m-[00m>yy_buffer_stack[yyg[01;31m-[00m>yy_buffer_stack_top] \
_lisp_Lexer.cc:291:#define YY_CURRENT_BUFFER_LVALUE yyg[01;31m-[00m>yy_buffer_stack[yyg[01;31m-[00m>yy_buffer_stack_top]
_lisp_Lexer.cc:324:	YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_is_interactive = is_interactive; \
_lisp_Lexer.cc:334:	YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_at_bol = at_bol; \
_lisp_Lexer.cc:337:#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_at_bol)
_lisp_Lexer.cc:356: * corresponding action [01;31m-[00m sets up yytext.
_lisp_Lexer.cc:359:	yyg[01;31m-[00m>yytext_ptr = yy_bp; \
_lisp_Lexer.cc:360:	yyleng = (size_t) (yy_cp [01;31m-[00m yy_bp); \
_lisp_Lexer.cc:361:	yyg[01;31m-[00m>yy_hold_char = *yy_cp; \
_lisp_Lexer.cc:363:	yyg[01;31m-[00m>yy_c_buf_p = yy_cp;
_lisp_Lexer.cc:616:    {lisp_LOG(lispget_extra(yyscanner)[01;31m-[00m>lisp(),BF("Recognized[01;31m-[00m[%s]  matched rule: %d") % lispget_text(yyscanner) % yy_act ); \
_lisp_Lexer.cc:617:    yylloc[01;31m-[00m>first_line = yylineno; yylloc[01;31m-[00m>first_column = lispget_extra(yyscanner)[01;31m-[00m>colnum; lispget_extra(yyscanner)[01;31m-[00m>colnum+=yyleng; yylloc[01;31m-[00m>last_column=lispget_extra(yyscanner)[01;31m-[00m>colnum; yylloc[01;31m-[00m>last_line = yylineno;}
_lisp_Lexer.cc:645:    /* User[01;31m-[00mdefined. Not touched by flex. */
_lisp_Lexer.cc:648:    /* The rest are the same as the globals declared in the non[01;31m-[00mreentrant scanner. */
_lisp_Lexer.cc:683:    #    define yylval yyg[01;31m-[00m>yylval_r
_lisp_Lexer.cc:685:    #    define yylloc yyg[01;31m-[00m>yylloc_r
_lisp_Lexer.cc:692:   These are made visible to non[01;31m-[00mreentrant scanners for convenience. */
_lisp_Lexer.cc:778:	if ( YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_is_interactive ) \
_lisp_Lexer.cc:809:/* No semi[01;31m-[00mcolon after return; correct usage is to write "yyterminate();" [01;31m-[00m
_lisp_Lexer.cc:817:/* Number of entries by which start[01;31m-[00mcondition stack grows. */
_lisp_Lexer.cc:829:/* Default declaration of generated scanner [01;31m-[00m a define so the user can
_lisp_Lexer.cc:875:	    _F(param[01;31m-[00m>lisp());
_lisp_Lexer.cc:876:	    if ( lispget_extra(yyscanner)[01;31m-[00m>lispScannerQueue.notEmpty() )
_lisp_Lexer.cc:878:		int term = lispget_extra(yyscanner)[01;31m-[00m>lispScannerQueue.dequeue();
_lisp_Lexer.cc:888:	    if ( lispget_extra(yyscanner)[01;31m-[00m>switchToIndentStartCondition )
_lisp_Lexer.cc:891:		lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent = 0;
_lisp_Lexer.cc:892:		lispget_extra(yyscanner)[01;31m-[00m>switchToIndentStartCondition = false;
_lisp_Lexer.cc:893:		LEX_DEBUG(BF("Switching to indent start condition [01;31m-[00m start lexing"));
_lisp_Lexer.cc:905:	if ( !yyg[01;31m-[00m>yy_init )
_lisp_Lexer.cc:907:		yyg[01;31m-[00m>yy_init = 1;
_lisp_Lexer.cc:913:		if ( ! yyg[01;31m-[00m>yy_start )
_lisp_Lexer.cc:914:			yyg[01;31m-[00m>yy_start = 1;	/* first start state */
_lisp_Lexer.cc:931:	while ( 1 )		/* loops until end[01;31m-[00mof[01;31m-[00mfile is reached */
_lisp_Lexer.cc:933:		yy_cp = yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:936:		*yy_cp = yyg[01;31m-[00m>yy_hold_char;
_lisp_Lexer.cc:943:		yy_current_state = yyg[01;31m-[00m>yy_start;
_lisp_Lexer.cc:950:				yyg[01;31m-[00m>yy_last_accepting_state = yy_current_state;
_lisp_Lexer.cc:951:				yyg[01;31m-[00m>yy_last_accepting_cpos = yy_cp;
_lisp_Lexer.cc:963:		yy_cp = yyg[01;31m-[00m>yy_last_accepting_cpos;
_lisp_Lexer.cc:964:		yy_current_state = yyg[01;31m-[00m>yy_last_accepting_state;
_lisp_Lexer.cc:989:			*yy_cp = yyg[01;31m-[00m>yy_hold_char;
_lisp_Lexer.cc:990:			yy_cp = yyg[01;31m-[00m>yy_last_accepting_cpos;
_lisp_Lexer.cc:991:			yy_current_state = yyg[01;31m-[00m>yy_last_accepting_state;
_lisp_Lexer.cc:998:{ /* eat up entire one[01;31m-[00mline comments */
_lisp_Lexer.cc:999:    lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent = 0;
_lisp_Lexer.cc:1000:    lispget_extra(yyscanner)[01;31m-[00m>colnum = 1;
_lisp_Lexer.cc:1007:{ /* eat up hash[01;31m-[00mbang comments to allow script executables */
_lisp_Lexer.cc:1008:    lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent = 0;
_lisp_Lexer.cc:1009:    lispget_extra(yyscanner)[01;31m-[00m>colnum = 1;
_lisp_Lexer.cc:1015:{ lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent++; }
_lisp_Lexer.cc:1020:{ lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent = ( lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent + 8 ) & ~7; }
_lisp_Lexer.cc:1026:{ lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent = 0; /*Ignore blank lines*/
_lisp_Lexer.cc:1027:		  lispget_extra(yyscanner)[01;31m-[00m>colnum = 1; }
_lisp_Lexer.cc:1033:		    lisp_LOG(lispget_extra(yyscanner)[01;31m-[00m>lisp(),BF("Hit non[01;31m-[00mwhite space at xpos(%d) cur[01;31m-[00m>%s") 
_lisp_Lexer.cc:1034:		    		% lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent
_lisp_Lexer.cc:1035:		    		% lispget_extra(yyscanner)[01;31m-[00m>lispIndentStack.asString() );
_lisp_Lexer.cc:1036:		    LEX_DEBUG(BF("Hit first non[01;31m-[00mwhite space in indent mode"));
_lisp_Lexer.cc:1040:		    IndentOp op = handleIndent(lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent,lispget_extra(yyscanner));
_lisp_Lexer.cc:1051:			    return lispget_extra(yyscanner)[01;31m-[00m>lispScannerQueue.dequeue();
_lisp_Lexer.cc:1059:		    lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent = 0;
_lisp_Lexer.cc:1067:/* eat up end of line one[01;31m-[00mline comments */
_lisp_Lexer.cc:1074:			lispget_extra(yyscanner)[01;31m-[00m>colnum=1;
_lisp_Lexer.cc:1080:{ lispget_extra(yyscanner)[01;31m-[00m>colnum=1;/* Ignore comments */ }
_lisp_Lexer.cc:1086:{ lispget_extra(yyscanner)[01;31m-[00m>colnum=1;/* Eat continuation line codes */ }
_lisp_Lexer.cc:1093:    lispget_extra(yyscanner)[01;31m-[00m>currentLineIndent = 0;
_lisp_Lexer.cc:1094:    LEX_DEBUG("Switching to indent [01;31m-[00m returning lEol");
_lisp_Lexer.cc:1097:    lispget_extra(yyscanner)[01;31m-[00m>colnum=1;
_lisp_Lexer.cc:1135:	    lispget_extra(yyscanner)[01;31m-[00m>bracketDepth++;
_lisp_Lexer.cc:1145:    	    lispget_extra(yyscanner)[01;31m-[00m>bracketDepth[01;31m-[00m[01;31m-[00m;
_lisp_Lexer.cc:1146:	    if ( lispget_extra(yyscanner)[01;31m-[00m>bracketDepth == 0 ) BEGIN(INITIAL);
_lisp_Lexer.cc:1155:    	    lispget_extra(yyscanner)[01;31m-[00m>bracketDepth++;
_lisp_Lexer.cc:1166:    	    lispget_extra(yyscanner)[01;31m-[00m>bracketDepth[01;31m-[00m[01;31m-[00m;
_lisp_Lexer.cc:1167:	    if ( lispget_extra(yyscanner)[01;31m-[00m>bracketDepth == 0 ) BEGIN(INITIAL);
_lisp_Lexer.cc:1176:	    strcpy(lispget_lval(yyscanner)[01;31m-[00m>cval,lispget_text(yyscanner));
_lisp_Lexer.cc:1177:    	    LEX_TRACE_ARG(lSymbol,lispget_lval(yyscanner)[01;31m-[00m>cval);
_lisp_Lexer.cc:1185:	    strcpy(lispget_lval(yyscanner)[01;31m-[00m>cval,lispget_text(yyscanner));
_lisp_Lexer.cc:1186:    	    LEX_TRACE_ARG(lSymbol,lispget_lval(yyscanner)[01;31m-[00m>cval);
_lisp_Lexer.cc:1194:		lispget_lval(yyscanner)[01;31m-[00m>ival = atoi(lispget_text(yyscanner));
_lisp_Lexer.cc:1195:    	        LEX_TRACE_ARG(lInteger,lispget_lval(yyscanner)[01;31m-[00m>ival);
_lisp_Lexer.cc:1205:		ss >> (lispget_lval(yyscanner)[01;31m-[00m>llval);
_lisp_Lexer.cc:1206:    	        LEX_TRACE_ARG(lLongLongInteger,lispget_lval(yyscanner)[01;31m-[00m>llval);
_lisp_Lexer.cc:1230:	    strcpy(lispget_lval(yyscanner)[01;31m-[00m>cval,lispget_text(yyscanner));
_lisp_Lexer.cc:1231:	    LEX_TRACE_ARG(lKeyedName,lispget_lval(yyscanner)[01;31m-[00m>cval);
_lisp_Lexer.cc:1233:	    strcpy(lispget_lval(yyscanner)[01;31m-[00m>cval,":");
_lisp_Lexer.cc:1234:	    strcat(lispget_lval(yyscanner)[01;31m-[00m>cval,lispget_text(yyscanner));
_lisp_Lexer.cc:1235:	    lispget_lval(yyscanner)[01;31m-[00m>cval[strlen(lispget_lval(yyscanner)[01;31m-[00m>cval)[01;31m-[00m1] = '\0';
_lisp_Lexer.cc:1236:	    ss << "Parsed an old keyword("<<lispget_text(yyscanner)<<") [01;31m-[00m converted it to a new keyword symbol(" << lispget_lval(yyscanner)[01;31m-[00m>cval << ")";
_lisp_Lexer.cc:1249:	    strcpy(lispget_lval(yyscanner)[01;31m-[00m>cval,(&lispget_text(yyscanner)[1]));
_lisp_Lexer.cc:1250:	    LEX_TRACE_ARG(lSymbol,lispget_lval(yyscanner)[01;31m-[00m>cval);
_lisp_Lexer.cc:1259:	    strcpy(lispget_lval(yyscanner)[01;31m-[00m>cval,upper.c_str());
_lisp_Lexer.cc:1268:		lispget_lval(yyscanner)[01;31m-[00m>dval = atof(lispget_text(yyscanner));
_lisp_Lexer.cc:1269:	    	LEX_TRACE_ARG(lDouble,lispget_lval(yyscanner)[01;31m-[00m>dval);
_lisp_Lexer.cc:1277:		lispget_lval(yyscanner)[01;31m-[00m>dval = atof(lispget_text(yyscanner));
_lisp_Lexer.cc:1278:	    	LEX_TRACE_ARG(lDouble,lispget_lval(yyscanner)[01;31m-[00m>dval);
_lisp_Lexer.cc:1286:    	    lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr = lispget_extra(yyscanner)[01;31m-[00m>string_buf; 
_lisp_Lexer.cc:1287:	    lispget_extra(yyscanner)[01;31m-[00m>setStringSaveState(YY_START); // save the start condition
_lisp_Lexer.cc:1294:{ /* saw closing quote [01;31m-[00m all done */
_lisp_Lexer.cc:1296:	 BEGIN(lispget_extra(yyscanner)[01;31m-[00m>getStringSaveState()); // Return to the original start condition
_lisp_Lexer.cc:1297:	 *(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr) = '\0';
_lisp_Lexer.cc:1298:	 strcpy(lispget_lval(yyscanner)[01;31m-[00m>cval,lispget_extra(yyscanner)[01;31m-[00m>string_buf);
_lisp_Lexer.cc:1299:	 LEX_TRACE_ARG(lString,lispget_lval(yyscanner)[01;31m-[00m>cval);
_lisp_Lexer.cc:1308:		*(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr++) = '\n';
_lisp_Lexer.cc:1309:		lispget_extra(yyscanner)[01;31m-[00m>colnum=1;
_lisp_Lexer.cc:1320:		 /* error, constant is out[01;31m-[00mof[01;31m-[00mbounds */
_lisp_Lexer.cc:1321:	 *(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr++) = result;
_lisp_Lexer.cc:1329:	 /* generate error [01;31m-[00m bad escape sequence; something
_lisp_Lexer.cc:1337:*(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr++) = '\n';
_lisp_Lexer.cc:1342:*(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr++) = '\t';
_lisp_Lexer.cc:1347:*(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr++) = '\r';
_lisp_Lexer.cc:1352:*(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr++) = '\b';
_lisp_Lexer.cc:1357:*(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr++) = '\f';
_lisp_Lexer.cc:1363:*(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr++) = (lispget_text(yyscanner))[1];
_lisp_Lexer.cc:1372:		 *(lispget_extra(yyscanner)[01;31m-[00m>string_buf_ptr++) = *yptr++;
_lisp_Lexer.cc:1384:/*    if (!param[01;31m-[00m>lispIndentStack.empty())
_lisp_Lexer.cc:1386:	param[01;31m-[00m>lispIndentStack.pop();
_lisp_Lexer.cc:1389:    lispget_extra(yyscanner)[01;31m-[00m>eofToEol[01;31m-[00m[01;31m-[00m;
_lisp_Lexer.cc:1390:    if ( lispget_extra(yyscanner)[01;31m-[00m>eofToEol >= 0 ) 
_lisp_Lexer.cc:1396:  lispget_extra(yyscanner)[01;31m-[00m>lispScannerQueue.enqueue(0);
_lisp_Lexer.cc:1397:  lisp_LOG(lispget_extra(yyscanner)[01;31m-[00m>lisp(),BF("<<EOF>> hit, terminating ")); 
_lisp_Lexer.cc:1398:  return lispget_extra(yyscanner)[01;31m-[00m>lispScannerQueue.dequeue();
_lisp_Lexer.cc:1406:/*    if (!param[01;31m-[00m>lispIndentStack.empty())
_lisp_Lexer.cc:1408:	param[01;31m-[00m>lispIndentStack.pop();
_lisp_Lexer.cc:1411:    lispget_extra(yyscanner)[01;31m-[00m>eofToEol[01;31m-[00m[01;31m-[00m;
_lisp_Lexer.cc:1412:    if ( lispget_extra(yyscanner)[01;31m-[00m>eofToEol >= 0 ) 
_lisp_Lexer.cc:1418:	  lispget_extra(yyscanner)[01;31m-[00m>lispScannerQueue.enqueue(0);
_lisp_Lexer.cc:1419:    	  lisp_LOG(lispget_extra(yyscanner)[01;31m-[00m>lisp(),BF("<<EOF>> hit, terminating ")); 
_lisp_Lexer.cc:1420:	  return lispget_extra(yyscanner)[01;31m-[00m>lispScannerQueue.dequeue();
_lisp_Lexer.cc:1442:		int yy_amount_of_matched_text = (int) (yy_cp [01;31m-[00m yyg[01;31m-[00m>yytext_ptr) [01;31m-[00m 1;
_lisp_Lexer.cc:1445:		*yy_cp = yyg[01;31m-[00m>yy_hold_char;
_lisp_Lexer.cc:1448:		if ( YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buffer_status == YY_BUFFER_NEW )
_lisp_Lexer.cc:1457:			 * back[01;31m-[00mup) that will match for the new input source.
_lisp_Lexer.cc:1459:			yyg[01;31m-[00m>yy_n_chars = YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_n_chars;
_lisp_Lexer.cc:1460:			YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_input_file = yyin;
_lisp_Lexer.cc:1461:			YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buffer_status = YY_BUFFER_NORMAL;
_lisp_Lexer.cc:1468:		 * end[01;31m-[00mof[01;31m-[00mbuffer state).  Contrast this with the test
_lisp_Lexer.cc:1471:		if ( yyg[01;31m-[00m>yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[yyg[01;31m-[00m>yy_n_chars] )
_lisp_Lexer.cc:1475:			yyg[01;31m-[00m>yy_c_buf_p = yyg[01;31m-[00m>yytext_ptr + yy_amount_of_matched_text;
_lisp_Lexer.cc:1490:			yy_bp = yyg[01;31m-[00m>yytext_ptr + YY_MORE_ADJ;
_lisp_Lexer.cc:1495:				yy_cp = ++yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:1502:				yy_cp = yyg[01;31m-[00m>yy_last_accepting_cpos;
_lisp_Lexer.cc:1503:				yy_current_state = yyg[01;31m-[00m>yy_last_accepting_state;
_lisp_Lexer.cc:1512:				yyg[01;31m-[00m>yy_did_buffer_switch_on_eof = 0;
_lisp_Lexer.cc:1522:					 * YY_NULL, it'll still work [01;31m-[00m another
_lisp_Lexer.cc:1525:					yyg[01;31m-[00m>yy_c_buf_p = yyg[01;31m-[00m>yytext_ptr + YY_MORE_ADJ;
_lisp_Lexer.cc:1533:					if ( ! yyg[01;31m-[00m>yy_did_buffer_switch_on_eof )
_lisp_Lexer.cc:1540:				yyg[01;31m-[00m>yy_c_buf_p =
_lisp_Lexer.cc:1541:					yyg[01;31m-[00m>yytext_ptr + yy_amount_of_matched_text;
_lisp_Lexer.cc:1545:				yy_cp = yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:1546:				yy_bp = yyg[01;31m-[00m>yytext_ptr + YY_MORE_ADJ;
_lisp_Lexer.cc:1550:				yyg[01;31m-[00m>yy_c_buf_p =
_lisp_Lexer.cc:1551:				&YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[yyg[01;31m-[00m>yy_n_chars];
_lisp_Lexer.cc:1555:				yy_cp = yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:1556:				yy_bp = yyg[01;31m-[00m>yytext_ptr + YY_MORE_ADJ;
_lisp_Lexer.cc:1564:			"fatal flex scanner internal error[01;31m-[00m[01;31m-[00mno action found" );
_lisp_Lexer.cc:1569:/* yy_get_next_buffer [01;31m-[00m try to read in a new buffer
_lisp_Lexer.cc:1572: *	EOB_ACT_LAST_MATCH [01;31m-[00m
_lisp_Lexer.cc:1573: *	EOB_ACT_CONTINUE_SCAN [01;31m-[00m continue scanning from current position
_lisp_Lexer.cc:1574: *	EOB_ACT_END_OF_FILE [01;31m-[00m end of file
_lisp_Lexer.cc:1579:	register char *dest = YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf;
_lisp_Lexer.cc:1580:	register char *source = yyg[01;31m-[00m>yytext_ptr;
_lisp_Lexer.cc:1584:	if ( yyg[01;31m-[00m>yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[yyg[01;31m-[00m>yy_n_chars + 1] )
_lisp_Lexer.cc:1586:		"fatal flex scanner internal error[01;31m-[00m[01;31m-[00mend of buffer missed" );
_lisp_Lexer.cc:1588:	if ( YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_fill_buffer == 0 )
_lisp_Lexer.cc:1590:		if ( yyg[01;31m-[00m>yy_c_buf_p [01;31m-[00m yyg[01;31m-[00m>yytext_ptr [01;31m-[00m YY_MORE_ADJ == 1 )
_lisp_Lexer.cc:1610:	number_to_move = (int) (yyg[01;31m-[00m>yy_c_buf_p [01;31m-[00m yyg[01;31m-[00m>yytext_ptr) [01;31m-[00m 1;
_lisp_Lexer.cc:1615:	if ( YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buffer_status == YY_BUFFER_EOF_PENDING )
_lisp_Lexer.cc:1619:		YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_n_chars = yyg[01;31m-[00m>yy_n_chars = 0;
_lisp_Lexer.cc:1624:			YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buf_size [01;31m-[00m number_to_move [01;31m-[00m 1;
_lisp_Lexer.cc:1627:			{ /* Not enough room in the buffer [01;31m-[00m grow it. */
_lisp_Lexer.cc:1633:				(int) (yyg[01;31m-[00m>yy_c_buf_p [01;31m-[00m b[01;31m-[00m>yy_ch_buf);
_lisp_Lexer.cc:1635:			if ( b[01;31m-[00m>yy_is_our_buffer )
_lisp_Lexer.cc:1637:				yy_size_t new_size = b[01;31m-[00m>yy_buf_size * 2;
_lisp_Lexer.cc:1640:					b[01;31m-[00m>yy_buf_size += b[01;31m-[00m>yy_buf_size / 8;
_lisp_Lexer.cc:1642:					b[01;31m-[00m>yy_buf_size *= 2;
_lisp_Lexer.cc:1644:				b[01;31m-[00m>yy_ch_buf = (char *)
_lisp_Lexer.cc:1646:					lisprealloc((void *) b[01;31m-[00m>yy_ch_buf,b[01;31m-[00m>yy_buf_size + 2 ,yyscanner );
_lisp_Lexer.cc:1650:				b[01;31m-[00m>yy_ch_buf = 0;
_lisp_Lexer.cc:1652:			if ( ! b[01;31m-[00m>yy_ch_buf )
_lisp_Lexer.cc:1654:				"fatal error [01;31m-[00m scanner input buffer overflow" );
_lisp_Lexer.cc:1656:			yyg[01;31m-[00m>yy_c_buf_p = &b[01;31m-[00m>yy_ch_buf[yy_c_buf_p_offset];
_lisp_Lexer.cc:1658:			num_to_read = YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buf_size [01;31m-[00m
_lisp_Lexer.cc:1659:						number_to_move [01;31m-[00m 1;
_lisp_Lexer.cc:1667:		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[number_to_move]),
_lisp_Lexer.cc:1668:			yyg[01;31m-[00m>yy_n_chars, num_to_read );
_lisp_Lexer.cc:1670:		YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_n_chars = yyg[01;31m-[00m>yy_n_chars;
_lisp_Lexer.cc:1673:	if ( yyg[01;31m-[00m>yy_n_chars == 0 )
_lisp_Lexer.cc:1684:			YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buffer_status =
_lisp_Lexer.cc:1692:	if ((yy_size_t) (yyg[01;31m-[00m>yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buf_size) {
_lisp_Lexer.cc:1694:		yy_size_t new_size = yyg[01;31m-[00m>yy_n_chars + number_to_move + (yyg[01;31m-[00m>yy_n_chars >> 1);
_lisp_Lexer.cc:1695:		YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf = (char *) lisprealloc((void *) YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf,new_size ,yyscanner );
_lisp_Lexer.cc:1696:		if ( ! YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf )
_lisp_Lexer.cc:1700:	yyg[01;31m-[00m>yy_n_chars += number_to_move;
_lisp_Lexer.cc:1701:	YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[yyg[01;31m-[00m>yy_n_chars] = YY_END_OF_BUFFER_CHAR;
_lisp_Lexer.cc:1702:	YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[yyg[01;31m-[00m>yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
_lisp_Lexer.cc:1704:	yyg[01;31m-[00m>yytext_ptr = &YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[0];
_lisp_Lexer.cc:1709:/* yy_get_previous_state [01;31m-[00m get the state just before the EOB char was reached */
_lisp_Lexer.cc:1717:	yy_current_state = yyg[01;31m-[00m>yy_start;
_lisp_Lexer.cc:1719:	for ( yy_cp = yyg[01;31m-[00m>yytext_ptr + YY_MORE_ADJ; yy_cp < yyg[01;31m-[00m>yy_c_buf_p; ++yy_cp )
_lisp_Lexer.cc:1724:			yyg[01;31m-[00m>yy_last_accepting_state = yy_current_state;
_lisp_Lexer.cc:1725:			yyg[01;31m-[00m>yy_last_accepting_cpos = yy_cp;
_lisp_Lexer.cc:1739:/* yy_try_NUL_trans [01;31m-[00m try to make a transition on the NUL character
_lisp_Lexer.cc:1748:	register char *yy_cp = yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:1753:		yyg[01;31m-[00m>yy_last_accepting_state = yy_current_state;
_lisp_Lexer.cc:1754:		yyg[01;31m-[00m>yy_last_accepting_cpos = yy_cp;
_lisp_Lexer.cc:1773:    yy_cp = yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:1776:	*yy_cp = yyg[01;31m-[00m>yy_hold_char;
_lisp_Lexer.cc:1778:	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf + 2 )
_lisp_Lexer.cc:1781:		register yy_size_t number_to_move = yyg[01;31m-[00m>yy_n_chars + 2;
_lisp_Lexer.cc:1782:		register char *dest = &YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[
_lisp_Lexer.cc:1783:					YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buf_size + 2];
_lisp_Lexer.cc:1785:				&YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[number_to_move];
_lisp_Lexer.cc:1787:		while ( source > YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf )
_lisp_Lexer.cc:1788:			*[01;31m-[00m[01;31m-[00mdest = *[01;31m-[00m[01;31m-[00msource;
_lisp_Lexer.cc:1790:		yy_cp += (int) (dest [01;31m-[00m source);
_lisp_Lexer.cc:1791:		yy_bp += (int) (dest [01;31m-[00m source);
_lisp_Lexer.cc:1792:		YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_n_chars =
_lisp_Lexer.cc:1793:			yyg[01;31m-[00m>yy_n_chars = YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buf_size;
_lisp_Lexer.cc:1795:		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf + 2 )
_lisp_Lexer.cc:1796:			YY_FATAL_ERROR( "flex scanner push[01;31m-[00mback overflow" );
_lisp_Lexer.cc:1799:	*[01;31m-[00m[01;31m-[00myy_cp = (char) c;
_lisp_Lexer.cc:1802:        [01;31m-[00m[01;31m-[00myylineno;
_lisp_Lexer.cc:1805:	yyg[01;31m-[00m>yytext_ptr = yy_bp;
_lisp_Lexer.cc:1806:	yyg[01;31m-[00m>yy_hold_char = *yy_cp;
_lisp_Lexer.cc:1807:	yyg[01;31m-[00m>yy_c_buf_p = yy_cp;
_lisp_Lexer.cc:1821:	*yyg[01;31m-[00m>yy_c_buf_p = yyg[01;31m-[00m>yy_hold_char;
_lisp_Lexer.cc:1823:	if ( *yyg[01;31m-[00m>yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
_lisp_Lexer.cc:1829:		if ( yyg[01;31m-[00m>yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_ch_buf[yyg[01;31m-[00m>yy_n_chars] )
_lisp_Lexer.cc:1831:			*yyg[01;31m-[00m>yy_c_buf_p = '\0';
_lisp_Lexer.cc:1835:			yy_size_t offset = yyg[01;31m-[00m>yy_c_buf_p [01;31m-[00m yyg[01;31m-[00m>yytext_ptr;
_lisp_Lexer.cc:1836:			++yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:1861:					if ( ! yyg[01;31m-[00m>yy_did_buffer_switch_on_eof )
_lisp_Lexer.cc:1871:					yyg[01;31m-[00m>yy_c_buf_p = yyg[01;31m-[00m>yytext_ptr + offset;
_lisp_Lexer.cc:1877:	c = *(unsigned char *) yyg[01;31m-[00m>yy_c_buf_p;	/* cast for 8[01;31m-[00mbit char's */
_lisp_Lexer.cc:1878:	*yyg[01;31m-[00m>yy_c_buf_p = '\0';	/* preserve yytext */
_lisp_Lexer.cc:1879:	yyg[01;31m-[00m>yy_hold_char = *++yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:1931:		*yyg[01;31m-[00m>yy_c_buf_p = yyg[01;31m-[00m>yy_hold_char;
_lisp_Lexer.cc:1932:		YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buf_pos = yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:1933:		YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_n_chars = yyg[01;31m-[00m>yy_n_chars;
_lisp_Lexer.cc:1944:	yyg[01;31m-[00m>yy_did_buffer_switch_on_eof = 1;
_lisp_Lexer.cc:1950:	yyg[01;31m-[00m>yy_n_chars = YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_n_chars;
_lisp_Lexer.cc:1951:	yyg[01;31m-[00m>yytext_ptr = yyg[01;31m-[00m>yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buf_pos;
_lisp_Lexer.cc:1952:	yyin = YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_input_file;
_lisp_Lexer.cc:1953:	yyg[01;31m-[00m>yy_hold_char = *yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:1970:	b[01;31m-[00m>yy_buf_size = size;
_lisp_Lexer.cc:1973:	 * we need to put in 2 end[01;31m-[00mof[01;31m-[00mbuffer characters.
_lisp_Lexer.cc:1975:	b[01;31m-[00m>yy_ch_buf = (char *) lispalloc(b[01;31m-[00m>yy_buf_size + 2 ,yyscanner );
_lisp_Lexer.cc:1976:	if ( ! b[01;31m-[00m>yy_ch_buf )
_lisp_Lexer.cc:1979:	b[01;31m-[00m>yy_is_our_buffer = 1;
_lisp_Lexer.cc:2000:	if ( b[01;31m-[00m>yy_is_our_buffer )
_lisp_Lexer.cc:2001:		lispfree((void *) b[01;31m-[00m>yy_ch_buf ,yyscanner );
_lisp_Lexer.cc:2018:	b[01;31m-[00m>yy_input_file = file;
_lisp_Lexer.cc:2019:	b[01;31m-[00m>yy_fill_buffer = 1;
_lisp_Lexer.cc:2026:        b[01;31m-[00m>yy_bs_lineno = 1;
_lisp_Lexer.cc:2027:        b[01;31m-[00m>yy_bs_column = 0;
_lisp_Lexer.cc:2030:        b[01;31m-[00m>yy_is_interactive = 0;
_lisp_Lexer.cc:2045:	b[01;31m-[00m>yy_n_chars = 0;
_lisp_Lexer.cc:2047:	/* We always need two end[01;31m-[00mof[01;31m-[00mbuffer characters.  The first causes
_lisp_Lexer.cc:2048:	 * a transition to the end[01;31m-[00mof[01;31m-[00mbuffer state.  The second causes
_lisp_Lexer.cc:2051:	b[01;31m-[00m>yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
_lisp_Lexer.cc:2052:	b[01;31m-[00m>yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
_lisp_Lexer.cc:2054:	b[01;31m-[00m>yy_buf_pos = &b[01;31m-[00m>yy_ch_buf[0];
_lisp_Lexer.cc:2056:	b[01;31m-[00m>yy_at_bol = 1;
_lisp_Lexer.cc:2057:	b[01;31m-[00m>yy_buffer_status = YY_BUFFER_NEW;
_lisp_Lexer.cc:2081:		*yyg[01;31m-[00m>yy_c_buf_p = yyg[01;31m-[00m>yy_hold_char;
_lisp_Lexer.cc:2082:		YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_buf_pos = yyg[01;31m-[00m>yy_c_buf_p;
_lisp_Lexer.cc:2083:		YY_CURRENT_BUFFER_LVALUE[01;31m-[00m>yy_n_chars = yyg[01;31m-[00m>yy_n_chars;
_lisp_Lexer.cc:2088:		yyg[01;31m-[00m>yy_buffer_stack_top++;
_lisp_Lexer.cc:2093:	yyg[01;31m-[00m>yy_did_buffer_switch_on_eof = 1;
_lisp_Lexer.cc:2108:	if (yyg[01;31m-[00m>yy_buffer_stack_top > 0)
_lisp_Lexer.cc:2109:		[01;31m-[00m[01;31m-[00myyg[01;31m-[00m>yy_buffer_stack_top;
_lisp_Lexer.cc:2113:		yyg[01;31m-[00m>yy_did_buffer_switch_on_eof = 1;
_lisp_Lexer.cc:2125:	if (!yyg[01;31m-[00m>yy_buffer_stack) {
_lisp_Lexer.cc:2132:		yyg[01;31m-[00m>yy_buffer_stack = (struct yy_buffer_state**)lispalloc
_lisp_Lexer.cc:2135:		if ( ! yyg[01;31m-[00m>yy_buffer_stack )
_lisp_Lexer.cc:2138:		memset(yyg[01;31m-[00m>yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
_lisp_Lexer.cc:2140:		yyg[01;31m-[00m>yy_buffer_stack_max = num_to_alloc;
_lisp_Lexer.cc:2141:		yyg[01;31m-[00m>yy_buffer_stack_top = 0;
_lisp_Lexer.cc:2145:	if (yyg[01;31m-[00m>yy_buffer_stack_top >= (yyg[01;31m-[00m>yy_buffer_stack_max) [01;31m-[00m 1){
_lisp_Lexer.cc:2150:		num_to_alloc = yyg[01;31m-[00m>yy_buffer_stack_max + grow_size;
_lisp_Lexer.cc:2151:		yyg[01;31m-[00m>yy_buffer_stack = (struct yy_buffer_state**)lisprealloc
_lisp_Lexer.cc:2152:								(yyg[01;31m-[00m>yy_buffer_stack,
_lisp_Lexer.cc:2155:		if ( ! yyg[01;31m-[00m>yy_buffer_stack )
_lisp_Lexer.cc:2159:		memset(yyg[01;31m-[00m>yy_buffer_stack + yyg[01;31m-[00m>yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
_lisp_Lexer.cc:2160:		yyg[01;31m-[00m>yy_buffer_stack_max = num_to_alloc;
_lisp_Lexer.cc:2164:/** Setup the input buffer state to scan directly from a user[01;31m-[00mspecified character buffer.
_lisp_Lexer.cc:2175:	     base[size[01;31m-[00m2] != YY_END_OF_BUFFER_CHAR ||
_lisp_Lexer.cc:2176:	     base[size[01;31m-[00m1] != YY_END_OF_BUFFER_CHAR )
_lisp_Lexer.cc:2184:	b[01;31m-[00m>yy_buf_size = size [01;31m-[00m 2;	/* "[01;31m-[00m 2" to take care of EOB's */
_lisp_Lexer.cc:2185:	b[01;31m-[00m>yy_buf_pos = b[01;31m-[00m>yy_ch_buf = base;
_lisp_Lexer.cc:2186:	b[01;31m-[00m>yy_is_our_buffer = 0;
_lisp_Lexer.cc:2187:	b[01;31m-[00m>yy_input_file = 0;
_lisp_Lexer.cc:2188:	b[01;31m-[00m>yy_n_chars = b[01;31m-[00m>yy_buf_size;
_lisp_Lexer.cc:2189:	b[01;31m-[00m>yy_is_interactive = 0;
_lisp_Lexer.cc:2190:	b[01;31m-[00m>yy_at_bol = 1;
_lisp_Lexer.cc:2191:	b[01;31m-[00m>yy_fill_buffer = 0;
_lisp_Lexer.cc:2192:	b[01;31m-[00m>yy_buffer_status = YY_BUFFER_NEW;
_lisp_Lexer.cc:2201: * @param yystr a NUL[01;31m-[00mterminated string to scan
_lisp_Lexer.cc:2244:	b[01;31m-[00m>yy_is_our_buffer = 1;
_lisp_Lexer.cc:2268:		yytext[yyleng] = yyg[01;31m-[00m>yy_hold_char; \
_lisp_Lexer.cc:2269:		yyg[01;31m-[00m>yy_c_buf_p = yytext + yyless_macro_arg; \
_lisp_Lexer.cc:2270:		yyg[01;31m-[00m>yy_hold_char = *yyg[01;31m-[00m>yy_c_buf_p; \
_lisp_Lexer.cc:2271:		*yyg[01;31m-[00m>yy_c_buf_p = '\0'; \
_lisp_Lexer.cc:2278:/** Get the user[01;31m-[00mdefined data for this scanner.
_lisp_Lexer.cc:2350:/** Set the user[01;31m-[00mdefined data. This data is never touched by the scanner.
_lisp_Lexer.cc:2446:/* User[01;31m-[00mvisible API */
_lisp_Lexer.cc:2513:    /* Initialization is the same as for the non[01;31m-[00mreentrant scanner.
_lisp_Lexer.cc:2517:    yyg[01;31m-[00m>yy_buffer_stack = 0;
_lisp_Lexer.cc:2518:    yyg[01;31m-[00m>yy_buffer_stack_top = 0;
_lisp_Lexer.cc:2519:    yyg[01;31m-[00m>yy_buffer_stack_max = 0;
_lisp_Lexer.cc:2520:    yyg[01;31m-[00m>yy_c_buf_p = (char *) 0;
_lisp_Lexer.cc:2521:    yyg[01;31m-[00m>yy_init = 0;
_lisp_Lexer.cc:2522:    yyg[01;31m-[00m>yy_start = 0;
_lisp_Lexer.cc:2524:    yyg[01;31m-[00m>yy_start_stack_ptr = 0;
_lisp_Lexer.cc:2525:    yyg[01;31m-[00m>yy_start_stack_depth = 0;
_lisp_Lexer.cc:2526:    yyg[01;31m-[00m>yy_start_stack =  NULL;
_lisp_Lexer.cc:2543:/* lisplex_destroy is for both reentrant and non[01;31m-[00mreentrant scanners. */
_lisp_Lexer.cc:2556:	lispfree(yyg[01;31m-[00m>yy_buffer_stack ,yyscanner);
_lisp_Lexer.cc:2557:	yyg[01;31m-[00m>yy_buffer_stack = NULL;
_lisp_Lexer.cc:2560:        lispfree(yyg[01;31m-[00m>yy_start_stack ,yyscanner );
_lisp_Lexer.cc:2561:        yyg[01;31m-[00m>yy_start_stack = NULL;
_lisp_Lexer.cc:2563:    /* Reset the globals. This is important in a non[01;31m-[00mreentrant scanner so the next time
_lisp_Lexer.cc:2648:    string ss = (BF("[cond: %s bracket: %d indentStackDepth: %d pos: %d/%d]") % cond % context[01;31m-[00m>bracketDepth % context[01;31m-[00m>lispIndentStack.size() % location[01;31m-[00m>first_line % location[01;31m-[00m>first_column ).str();
_lisp_Lexer.cc:2657://    if ( context[01;31m-[00m>debugScannerLevel==0 ) return;
_lisp_Lexer.cc:2658://    mbb::printv(0context[01;31m-[00m>lisp(),"lisp_Lexer_TRACE: %s %s\n", fmt.str().c_str(), lexStatus(startState,location,context).c_str() );
_lisp_Lexer.cc:2659:    lisp_LOG(context[01;31m-[00m>lisp(),BF("lisp_Lexer_TRACE: %s %s") % fmt.str() % lexStatus(startState,location,context));
_lisp_Lexer.cc:2666:    lisp_LOG(context[01;31m-[00m>lisp(),BF("lisp_Lexer_DEBUG level=%d") % dbglevel );
_lisp_Lexer.cc:2667:    context[01;31m-[00m>debugScannerLevel = dbglevel;
_lisp_Lexer.cc:2674:    if ( context[01;31m-[00m>lispIndentStack.empty() || indentVal > context[01;31m-[00m>lispIndentStack.top() )
_lisp_Lexer.cc:2676:	lisp_LOG(context[01;31m-[00m>lisp(),BF("Pushing indent level: %d  returning opIndent") % indentVal );
_lisp_Lexer.cc:2677:	context[01;31m-[00m>lispIndentStack.push(indentVal);
_lisp_Lexer.cc:2680:    if ( indentVal == context[01;31m-[00m>lispIndentStack.top() ) 
_lisp_Lexer.cc:2682:	lisp_LOG(context[01;31m-[00m>lisp(),BF("Indent level remains the same, returning opNop"));
_lisp_Lexer.cc:2687:	lisp_ASSERT(context[01;31m-[00m>lisp(),context[01;31m-[00m>lispIndentStack.top()!=0);
_lisp_Lexer.cc:2688:	context[01;31m-[00m>lispIndentStack.pop();
_lisp_Lexer.cc:2689:	context[01;31m-[00m>lispScannerQueue.enqueue(lDedent);
_lisp_Lexer.cc:2690:	if ( context[01;31m-[00m>lispIndentStack.empty() ) break;
_lisp_Lexer.cc:2691:	if ( context[01;31m-[00m>lispIndentStack.top() <= indentVal ) break;
_lisp_Lexer.cc:2693:    if ( context[01;31m-[00m>lispIndentStack.top() != indentVal ) return opError;
_lisp_Lexer.cc:2709:    lisp_LOG(data[01;31m-[00m>lisp(),BF("lisp_unget was called"));
_lisp_Lexer.cc:2710:    data[01;31m-[00m>lispStream[01;31m-[00m>putback(c);
_lisp_Lexer.cc:2721:    {_F(data[01;31m-[00m>lisp());
_lisp_Lexer.cc:2724:	if ( data[01;31m-[00m>lispStream[01;31m-[00m>eof() ) goto GOT_EOF;
_lisp_Lexer.cc:2725:	c = data[01;31m-[00m>lispStream[01;31m-[00m>get();
_lisp_Lexer.cc:2727:	if ( !data[01;31m-[00m>lispStream[01;31m-[00m>good() || data[01;31m-[00m>lispStream[01;31m-[00m>eof() ) goto GOT_EOF;
_lisp_Lexer.cc:2730:	lisp_LOG(data[01;31m-[00m>lisp(),BF("got YY_INPUT[%d/%c] %s") % ic % c % lexStatus(startState,location,data) );
_lisp_Lexer.cc:2733:	if ( data[01;31m-[00m>eofToEol>0 )
_lisp_Lexer.cc:2735:	    data[01;31m-[00m>eofToEol[01;31m-[00m[01;31m-[00m;
_lisp_Lexer.cc:2738:	    lisp_LOG(data[01;31m-[00m>lisp(),BF("Appending trailing cr"));
_lisp_Lexer.cc:2741:	lisp_LOG(data[01;31m-[00m>lisp(),BF("hit YY_NULL"));
_lisp_Parser.cc:3:/* Skeleton implementation for Bison's Yacc[01;31m-[00mlike parsers in C
_lisp_Parser.cc:35:   simplifying the original so[01;31m-[00mcalled "semantic" parser.  */
_lisp_Parser.cc:269:#define YYSIZE_MAXIMUM ((YYSIZE_T) [01;31m-[00m1)
_lisp_Parser.cc:275:#   define YY_(msgid) dgettext ("bison[01;31m-[00mruntime", msgid)
_lisp_Parser.cc:283:/* Suppress unused[01;31m-[00mvariable warnings by "using" E.  */
_lisp_Parser.cc:337:   /* Pacify GCC's `empty if[01;31m-[00mbody' warning.  */
_lisp_Parser.cc:343:       to allow for a few compiler[01;31m-[00mallocated temporary stack slots.  */
_lisp_Parser.cc:392:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) [01;31m-[00m 1)
_lisp_Parser.cc:427:	YYCOPY (&yyptr[01;31m-[00m>Stack_alloc, Stack, yysize);			\
_lisp_Parser.cc:428:	Stack = &yyptr[01;31m-[00m>Stack_alloc;					\
_lisp_Parser.cc:436:/* YYFINAL [01;31m-[00m[01;31m-[00m State number of the termination state.  */
_lisp_Parser.cc:438:/* YYLAST [01;31m-[00m[01;31m-[00m Last index in YYTABLE.  */
_lisp_Parser.cc:441:/* YYNTOKENS [01;31m-[00m[01;31m-[00m Number of terminals.  */
_lisp_Parser.cc:443:/* YYNNTS [01;31m-[00m[01;31m-[00m Number of nonterminals.  */
_lisp_Parser.cc:445:/* YYNRULES [01;31m-[00m[01;31m-[00m Number of rules.  */
_lisp_Parser.cc:447:/* YYNRULES [01;31m-[00m[01;31m-[00m Number of states.  */
_lisp_Parser.cc:450:/* YYTRANSLATE(YYLEX) [01;31m-[00m[01;31m-[00m Bison symbol number corresponding to YYLEX.  */
_lisp_Parser.cc:457:/* YYTRANSLATE[YYLEX] [01;31m-[00m[01;31m-[00m Bison symbol number corresponding to YYLEX.  */
_lisp_Parser.cc:492:/* YYPRHS[YYN] [01;31m-[00m[01;31m-[00m Index of the first RHS symbol of rule number YYN in
_lisp_Parser.cc:503:/* YYRHS [01;31m-[00m[01;31m-[00m A `[01;31m-[00m1'[01;31m-[00mseparated list of the rules' RHS.  */
_lisp_Parser.cc:506:      27,     0,    [01;31m-[00m1,    29,    [01;31m-[00m1,    [01;31m-[00m1,     1,    [01;31m-[00m1,    29,    [01;31m-[00m1,
_lisp_Parser.cc:507:      29,    28,    [01;31m-[00m1,    30,    [01;31m-[00m1,    31,    [01;31m-[00m1,    32,     3,    [01;31m-[00m1,
_lisp_Parser.cc:508:      32,     3,     4,    28,     5,    [01;31m-[00m1,    31,     4,    28,     5,
_lisp_Parser.cc:509:      [01;31m-[00m1,    41,    33,     3,    [01;31m-[00m1,    41,     3,    [01;31m-[00m1,    10,    33,
_lisp_Parser.cc:510:      11,    [01;31m-[00m1,    10,    11,    [01;31m-[00m1,     8,    34,    34,    33,     9,
_lisp_Parser.cc:511:      [01;31m-[00m1,     8,    34,    34,     9,    [01;31m-[00m1,     8,    34,     9,    [01;31m-[00m1,
_lisp_Parser.cc:512:      34,    [01;31m-[00m1,    34,    33,    [01;31m-[00m1,    41,    [01;31m-[00m1,    32,    [01;31m-[00m1,    35,
_lisp_Parser.cc:513:      [01;31m-[00m1,    36,    [01;31m-[00m1,    39,    [01;31m-[00m1,    40,    [01;31m-[00m1,    37,    [01;31m-[00m1,    38,
_lisp_Parser.cc:514:      [01;31m-[00m1,    12,    20,    [01;31m-[00m1,    13,    20,    [01;31m-[00m1,    15,    20,    [01;31m-[00m1,
_lisp_Parser.cc:515:      15,    32,    [01;31m-[00m1,    16,    20,    [01;31m-[00m1,    16,    32,    [01;31m-[00m1,    12,
_lisp_Parser.cc:516:      32,    [01;31m-[00m1,    14,    32,    [01;31m-[00m1,    20,    [01;31m-[00m1,    22,    [01;31m-[00m1,    23,
_lisp_Parser.cc:517:      [01;31m-[00m1,    24,    [01;31m-[00m1,    25,    [01;31m-[00m1,    17,    [01;31m-[00m1,    18,    [01;31m-[00m1
_lisp_Parser.cc:520:/* YYRLINE[YYN] [01;31m-[00m[01;31m-[00m source line where rule number YYN was defined.  */
_lisp_Parser.cc:532:/* YYTNAME[SYMBOL[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m String name of the symbol SYMBOL[01;31m-[00mNUM.
_lisp_Parser.cc:549:/* YYTOKNUM[YYLEX[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m Internal token number corresponding to
_lisp_Parser.cc:550:   token YYLEX[01;31m-[00mNUM.  */
_lisp_Parser.cc:559:/* YYR1[YYN] [01;31m-[00m[01;31m-[00m Symbol number of symbol that rule YYN derives.  */
_lisp_Parser.cc:569:/* YYR2[YYN] [01;31m-[00m[01;31m-[00m Number of symbols composing right hand side of rule YYN.  */
_lisp_Parser.cc:579:/* YYDEFACT[STATE[01;31m-[00mNAME] [01;31m-[00m[01;31m-[00m Default rule to reduce with in state
_lisp_Parser.cc:580:   STATE[01;31m-[00mNUM when YYTABLE doesn't specify something else to do.  Zero
_lisp_Parser.cc:593:/* YYDEFGOTO[NTERM[01;31m-[00mNUM].  */
_lisp_Parser.cc:596:      [01;31m-[00m1,    11,    51,    52,    13,    14,    22,    32,    33,    24,
_lisp_Parser.cc:600:/* YYPACT[STATE[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m Index in YYTABLE of the portion describing
_lisp_Parser.cc:601:   STATE[01;31m-[00mNUM.  */
_lisp_Parser.cc:602:#define YYPACT_NINF [01;31m-[00m43
_lisp_Parser.cc:605:       5,   [01;31m-[00m43,   120,    66,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,
_lisp_Parser.cc:606:     [01;31m-[00m43,     4,   [01;31m-[00m43,   [01;31m-[00m43,     8,    28,    48,     6,   [01;31m-[00m12,    [01;31m-[00m1,
_lisp_Parser.cc:607:      30,    49,   [01;31m-[00m43,    84,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,
_lisp_Parser.cc:608:     [01;31m-[00m43,   [01;31m-[00m43,    25,   120,   [01;31m-[00m43,    24,    35,   [01;31m-[00m43,    40,   [01;31m-[00m43,
_lisp_Parser.cc:609:     [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   102,   [01;31m-[00m43,
_lisp_Parser.cc:610:     [01;31m-[00m43,    62,    24,    24,   [01;31m-[00m43,   [01;31m-[00m43,    36,   [01;31m-[00m43,   [01;31m-[00m43,    70,
_lisp_Parser.cc:611:     [01;31m-[00m43,   [01;31m-[00m43
_lisp_Parser.cc:614:/* YYPGOTO[NTERM[01;31m-[00mNUM].  */
_lisp_Parser.cc:617:     [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m42,    85,   [01;31m-[00m43,   [01;31m-[00m43,     0,   [01;31m-[00m15,     1,   [01;31m-[00m43,
_lisp_Parser.cc:618:     [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,   [01;31m-[00m43,     2
_lisp_Parser.cc:621:/* YYTABLE[YYPACT[STATE[01;31m-[00mNUM]].  What to do in state STATE[01;31m-[00mNUM.  If
_lisp_Parser.cc:625:#define YYTABLE_NINF [01;31m-[00m4
_lisp_Parser.cc:628:      15,    38,    16,    23,    34,    [01;31m-[00m3,     1,     2,    41,     3,
_lisp_Parser.cc:655:      14,    15,    16,    17,    18,     0,    20,    [01;31m-[00m1,    22,    23,
_lisp_Parser.cc:656:      24,    25,     8,     9,    10,    [01;31m-[00m1,    12,    13,    14,    15,
_lisp_Parser.cc:657:      16,    17,    18,    [01;31m-[00m1,    20,    [01;31m-[00m1,    22,    23,    24,    25,
_lisp_Parser.cc:658:       8,     9,    10,    [01;31m-[00m1,    12,    13,    14,    15,    16,    17,
_lisp_Parser.cc:659:      18,    [01;31m-[00m1,    20,    [01;31m-[00m1,    22,    23,    24,    25,     8,    [01;31m-[00m1,
_lisp_Parser.cc:660:      10,    [01;31m-[00m1,    12,    13,    14,    15,    16,    17,    18,    [01;31m-[00m1,
_lisp_Parser.cc:661:      20,    [01;31m-[00m1,    22,    23,    24,    25
_lisp_Parser.cc:664:/* YYSTOS[STATE[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m The (internal number of the) accessing
_lisp_Parser.cc:665:   symbol of state STATE[01;31m-[00mNUM.  */
_lisp_Parser.cc:679:#define YYEMPTY		([01;31m-[00m2)
_lisp_Parser.cc:697:     [01;31m-[00mWunused[01;31m-[00mmacros.  Normally we don't worry about that warning, but
_lisp_Parser.cc:726:/* YYLLOC_DEFAULT [01;31m-[00m[01;31m-[00m Set CURRENT to span from RHS[1] to RHS[N].
_lisp_Parser.cc:752:/* YY_LOCATION_PRINT [01;31m-[00m[01;31m-[00m Print the location on the stream.
_lisp_Parser.cc:759:     fprintf (File, "%d.%d[01;31m-[00m%d.%d",			\
_lisp_Parser.cc:768:/* YYLEX [01;31m-[00m[01;31m-[00m calling `yylex' with the right arguments.  */
_lisp_Parser.cc:802:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:804:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:839:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:841:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:868:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:869:| yy_stack_print [01;31m-[00m[01;31m-[00m Print the state stack from its BOTTOM up to its |
_lisp_Parser.cc:871:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:900:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:902:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:921:	     yyrule [01;31m-[00m 1, yylno);
_lisp_Parser.cc:927:		       &(yyvsp[(yyi + 1) [01;31m-[00m (yynrhs)])
_lisp_Parser.cc:928:		       , &(yylsp[(yyi + 1) [01;31m-[00m (yynrhs)])		       , data);
_lisp_Parser.cc:950:/* YYINITDEPTH [01;31m-[00m[01;31m-[00m initial size of the parser's stacks.  */
_lisp_Parser.cc:955:/* YYMAXDEPTH [01;31m-[00m[01;31m-[00m maximum size the stacks can grow to (effective only
_lisp_Parser.cc:956:   if the built[01;31m-[00min stack extension method is used).
_lisp_Parser.cc:960:   evaluated with infinite[01;31m-[00mprecision integer arithmetic.  */
_lisp_Parser.cc:1016:  return yyd [01;31m-[00m 1;
_lisp_Parser.cc:1024:   heuristic is that double[01;31m-[00mquoting is unnecessary unless the string
_lisp_Parser.cc:1026:   backslash[01;31m-[00mbackslash).  YYSTR is taken from yytname.  If YYRES is
_lisp_Parser.cc:1065:  return yystpcpy (yyres, yystr) [01;31m-[00m yyres;
_lisp_Parser.cc:1109:		    + sizeof yyexpecting [01;31m-[00m 1
_lisp_Parser.cc:1110:		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM [01;31m-[00m 2)
_lisp_Parser.cc:1111:		       * (sizeof yyor [01;31m-[00m 1))];
_lisp_Parser.cc:1114:      /* Start YYX at [01;31m-[00mYYN if negative to avoid negative indexes in
_lisp_Parser.cc:1116:      int yyxbegin = yyn < 0 ? [01;31m-[00myyn : 0;
_lisp_Parser.cc:1119:      int yychecklim = YYLAST [01;31m-[00m yyn + 1;
_lisp_Parser.cc:1133:		yyformat[sizeof yyunexpected [01;31m-[00m 1] = '\0';
_lisp_Parser.cc:1179:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:1181:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:1212:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1221:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1230:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1239:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1248:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1257:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1266:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1275:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1284:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1293:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1302:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1311:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1320:	{ if ((yyvaluep[01;31m-[00m>cons)!=NULL) delete ((yyvaluep[01;31m-[00m>cons));};
_lisp_Parser.cc:1331:/* Prevent warnings from [01;31m-[00mWmissing[01;31m-[00mprototypes.  */
_lisp_Parser.cc:1350:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:1352:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:1436:#define YYPOPSTACK(N)   (yyvsp [01;31m-[00m= (N), yyssp [01;31m-[00m= (N), yylsp [01;31m-[00m= (N))
_lisp_Parser.cc:1471:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:1472:| yynewstate [01;31m-[00m[01;31m-[00m Push a new state, which is found in yystate.  |
_lisp_Parser.cc:1473:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:1482:  if (yyss + yystacksize [01;31m-[00m 1 <= yyssp)
_lisp_Parser.cc:1485:      YYSIZE_T yysize = yyssp [01;31m-[00m yyss + 1;
_lisp_Parser.cc:1537:      yyssp = yyss + yysize [01;31m-[00m 1;
_lisp_Parser.cc:1538:      yyvsp = yyvs + yysize [01;31m-[00m 1;
_lisp_Parser.cc:1539:      yylsp = yyls + yysize [01;31m-[00m 1;
_lisp_Parser.cc:1544:      if (yyss + yystacksize [01;31m-[00m 1 <= yyssp)
_lisp_Parser.cc:1555:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:1557:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:1598:      yyn = [01;31m-[00myyn;
_lisp_Parser.cc:1605:    yyerrstatus[01;31m-[00m[01;31m-[00m;
_lisp_Parser.cc:1619:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:1620:| yydefault [01;31m-[00m[01;31m-[00m do the default action for the current state.  |
_lisp_Parser.cc:1621:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:1629:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:1630:| yyreduce [01;31m-[00m[01;31m-[00m Do a reduction.  |
_lisp_Parser.cc:1631:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:1644:  yyval = yyvsp[1[01;31m-[00myylen];
_lisp_Parser.cc:1647:  YYLLOC_DEFAULT (yyloc, (yylsp [01;31m-[00m yylen), yylen);
_lisp_Parser.cc:1655:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"input: top level form");
_lisp_Parser.cc:1656:	    LP()[01;31m-[00m>expression = (yyvsp[(1) [01;31m-[00m (1)].cons)[01;31m-[00m>_obj;
_lisp_Parser.cc:1665:    _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"empty");
_lisp_Parser.cc:1666:    LP()[01;31m-[00m>expression = LP()[01;31m-[00m>lisp()[01;31m-[00m>cnil();
_lisp_Parser.cc:1674:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"input: error");
_lisp_Parser.cc:1675:     lisp_TOSS(LP()[01;31m-[00m>lisp(),LP()[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Compile error in file(%s)") % LP()[01;31m-[00m>fileName));
_lisp_Parser.cc:1683:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: codeBlock>form");
_lisp_Parser.cc:1684:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("form= %s") % (yyvsp[(1) [01;31m-[00m (1)].cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__() );
_lisp_Parser.cc:1685:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1693:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: codeBlock> form codeBlock");
_lisp_Parser.cc:1694:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("form = %s" ) %  (yyvsp[(1) [01;31m-[00m (2)].cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__() );
_lisp_Parser.cc:1695:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("codeBlock= %s") % (yyvsp[(2) [01;31m-[00m (2)].cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__() );
_lisp_Parser.cc:1696:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (2)].cons);
_lisp_Parser.cc:1697:	    (yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>setCdr((yyvsp[(2) [01;31m-[00m (2)].cons)[01;31m-[00m>_obj);
_lisp_Parser.cc:1698:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$$[01;31m-[00m>_obj = %s") % (yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__() );
_lisp_Parser.cc:1706:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: form [01;31m-[00m> unknownTypeForm");
_lisp_Parser.cc:1707:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1708:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$$[01;31m-[00m>_obj = %s")% (yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__() );
_lisp_Parser.cc:1716:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: unknownTypeForm [01;31m-[00m>unbracketedStatement" );
_lisp_Parser.cc:1717:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1718:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$$[01;31m-[00m>_obj = %s") % (yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__() );
_lisp_Parser.cc:1726:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: bracketedStatement");
_lisp_Parser.cc:1727:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (2)].cons);
_lisp_Parser.cc:1728:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF( "$$[01;31m-[00m>_obj = %s") % (yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__() );
_lisp_Parser.cc:1736:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: bracketedStatement lIndent codeBlock lDedent");
_lisp_Parser.cc:1737:	    RPCons head = (yyvsp[(1) [01;31m-[00m (5)].cons)[01;31m-[00m>_obj;
_lisp_Parser.cc:1738:	    RPCons tail = (yyvsp[(4) [01;31m-[00m (5)].cons)[01;31m-[00m>_obj;
_lisp_Parser.cc:1739:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("head = %s") % (head[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "head = %s", head[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1740:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("tail = %s") % (tail[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "tail = %s", tail[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1741:	    head[01;31m-[00m>append(tail);
_lisp_Parser.cc:1742:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("combined= %s") % (head[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "combined= %s", head[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1743:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(head,O_Cons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (5)]),LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()  ));
_lisp_Parser.cc:1744:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$$[01;31m-[00m>_obj = %s") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "$$[01;31m-[00m>_obj = %s", $$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1752:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: | unbracketedStatement lIndent codeBlock lDedent " );
_lisp_Parser.cc:1753:	    RPCons head = (yyvsp[(1) [01;31m-[00m (4)].cons)[01;31m-[00m>_obj[01;31m-[00m>car<O_Cons>();
_lisp_Parser.cc:1754:	    RPCons tail = (yyvsp[(3) [01;31m-[00m (4)].cons)[01;31m-[00m>_obj;
_lisp_Parser.cc:1755:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("head = %s") % (head[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "head = %s", head[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1756:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("tail = %s") % (tail[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "tail = %s", tail[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1757:	    head[01;31m-[00m>append(tail);
_lisp_Parser.cc:1758:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("combined= %s") % (head[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "combined= %s", head[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1759:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(head,O_Cons::nil(LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:1760:	    			(yylsp[(1) [01;31m-[00m (4)]),
_lisp_Parser.cc:1762:				LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1764:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$$[01;31m-[00m>_obj = %s") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "$$[01;31m-[00m>_obj = %s", $$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1772:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: atom list eol" );
_lisp_Parser.cc:1773:	    RPCons head = (yyvsp[(1) [01;31m-[00m (3)].cons)[01;31m-[00m>_obj;
_lisp_Parser.cc:1774:	    RPCons tail = (yyvsp[(2) [01;31m-[00m (3)].cons)[01;31m-[00m>_obj;
_lisp_Parser.cc:1775:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("head = %s") % (head[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "head = %s", head[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1776:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("tail = %s") % (tail[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "tail = %s", tail[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1777:	    head[01;31m-[00m>append(tail);
_lisp_Parser.cc:1778:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(head,O_Cons::nil(LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:1779:	    			(yylsp[(1) [01;31m-[00m (3)]),
_lisp_Parser.cc:1781:				LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1783:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$$[01;31m-[00m>_obj = %s") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "$$[01;31m-[00m>_obj = %s", $$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1791:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: atom eol" );
_lisp_Parser.cc:1792:	    RPCons head = (yyvsp[(1) [01;31m-[00m (2)].cons)[01;31m-[00m>_obj;
_lisp_Parser.cc:1793:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("head = %s") % (head[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "head = %s", head[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1794:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(head,O_Cons::nil(LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:1795:	    			(yylsp[(1) [01;31m-[00m (2)]),
_lisp_Parser.cc:1797:				LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1799:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$$[01;31m-[00m>_obj = %s") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "$$[01;31m-[00m>_obj = %s", $$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1807:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: list");
_lisp_Parser.cc:1808:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create((yyvsp[(2) [01;31m-[00m (3)].cons)[01;31m-[00m>_obj,O_Cons::nil(LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:1809:	    			(yylsp[(1) [01;31m-[00m (3)]),LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1811:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$$[01;31m-[00m>_obj = %s") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(( "$$[01;31m-[00m>_obj = %s", $$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1819:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: []");
_lisp_Parser.cc:1820:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(O_Object::nil(LP()[01;31m-[00m>lisp()),O_Cons::nil(LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:1821:	    			(yylsp[(1) [01;31m-[00m (2)]),
_lisp_Parser.cc:1823:				LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1832:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: infix list > 2 elements");
_lisp_Parser.cc:1833:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$3[01;31m-[00m>_obj = |%s|") % ((yyvsp[(3) [01;31m-[00m (5)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ) ); // vp0(("$3[01;31m-[00m>_obj = |%s|", $3[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1834:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$2[01;31m-[00m>_obj = |%s|") % ((yyvsp[(2) [01;31m-[00m (5)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ) ); // vp0(("$2[01;31m-[00m>_obj = |%s|", $2[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1835:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$4[01;31m-[00m>_obj = |%s|") % ((yyvsp[(4) [01;31m-[00m (5)].cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("$4[01;31m-[00m>_obj = |%s|", $4[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1836:	    RPCons body = O_ParsingCons::create((yyvsp[(2) [01;31m-[00m (5)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar(),(yyvsp[(4) [01;31m-[00m (5)].cons)[01;31m-[00m>_obj,
_lisp_Parser.cc:1837:	    			(yylsp[(1) [01;31m-[00m (5)]),
_lisp_Parser.cc:1839:				LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1841:	    RPCons result = O_ParsingCons::create((yyvsp[(3) [01;31m-[00m (5)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar(),body,
_lisp_Parser.cc:1842:	    			(yylsp[(1) [01;31m-[00m (5)]),
_lisp_Parser.cc:1844:				LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1846:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("put it together = %s") % (result[01;31m-[00m>__repr__().c_str() ) ); // vp0(("put it together = %s", result[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1847:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(result,O_Cons::nil(LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:1848:	    			(yylsp[(1) [01;31m-[00m (5)]),
_lisp_Parser.cc:1850:				LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1859:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: infix list > 2 elements");
_lisp_Parser.cc:1860:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$3[01;31m-[00m>_obj = |%s|") % ((yyvsp[(3) [01;31m-[00m (4)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ) ); // vp0(("$3[01;31m-[00m>_obj = |%s|", $3[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1861:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$2[01;31m-[00m>_obj = |%s|") % ((yyvsp[(2) [01;31m-[00m (4)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ) ); // vp0(("$2[01;31m-[00m>_obj = |%s|", $2[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1862:	    RPCons receiver = O_ParsingCons::create((yyvsp[(2) [01;31m-[00m (4)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar(),
_lisp_Parser.cc:1863:	    			O_Cons::nil(LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:1864:	    			(yylsp[(1) [01;31m-[00m (4)]),LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1866:	    RPCons result = O_ParsingCons::create((yyvsp[(3) [01;31m-[00m (4)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar(),receiver,
_lisp_Parser.cc:1867:	    			(yylsp[(1) [01;31m-[00m (4)]),LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1869:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("put it together = %s") % (result[01;31m-[00m>__repr__().c_str() ) ); // vp0(("put it together = %s", result[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1870:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(result,O_Cons::nil(LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:1871:	    			(yylsp[(1) [01;31m-[00m (4)]),LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1880:    {_lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: infix list > 1 elements");
_lisp_Parser.cc:1881:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("$2[01;31m-[00m>_obj = |%s|") % ((yyvsp[(2) [01;31m-[00m (3)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ) ); // vp0(("$2[01;31m-[00m>_obj = |%s|", $2[01;31m-[00m>_obj[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1882:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create((yyvsp[(2) [01;31m-[00m (3)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar(),O_Cons::nil(LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:1883:	    			(yylsp[(1) [01;31m-[00m (3)]), LP()[01;31m-[00m>fileName, LP()[01;31m-[00m>lisp()
_lisp_Parser.cc:1892:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entryList> entry");
_lisp_Parser.cc:1893:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1901:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entryList> entry list");
_lisp_Parser.cc:1902:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (2)].cons);
_lisp_Parser.cc:1903:	    (yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>setCdr((yyvsp[(2) [01;31m-[00m (2)].cons)[01;31m-[00m>_obj);
_lisp_Parser.cc:1911:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entry>atom");
_lisp_Parser.cc:1912:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1913:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1921:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entry>bracketedStatement");
_lisp_Parser.cc:1922:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1923:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1931:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entry>quotedSymbol");
_lisp_Parser.cc:1932:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1933:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1941:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entry>sharpQuotedSymbol");
_lisp_Parser.cc:1942:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1943:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1951:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entry>quotedBracketedList");
_lisp_Parser.cc:1952:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1953:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1961:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entry>backQuotedBracketedList");
_lisp_Parser.cc:1962:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1963:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1971:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entry>commaSymbol");
_lisp_Parser.cc:1972:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1973:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1981:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: entry>commaAtSymbol");
_lisp_Parser.cc:1982:	    (yyval.cons) = (yyvsp[(1) [01;31m-[00m (1)].cons);
_lisp_Parser.cc:1983:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:1991:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: symbol");
_lisp_Parser.cc:1992:	    RPParsingCons qq = O_ParsingCons::createList(LP()[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_quote(),LP()[01;31m-[00m>lisp()[01;31m-[00m>intern((yyvsp[(2) [01;31m-[00m (2)].cval)),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:1993:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(qq,O_ParsingCons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:1994:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2002:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: #'symbol");
_lisp_Parser.cc:2003:	    RPParsingCons qq = O_ParsingCons::createList(LP()[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_function(),LP()[01;31m-[00m>lisp()[01;31m-[00m>intern((yyvsp[(2) [01;31m-[00m (2)].cval)),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2004:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(qq,O_ParsingCons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2005:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2013:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: comma symbol");
_lisp_Parser.cc:2014:	    RPParsingCons qq = O_ParsingCons::createList(LP()[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_comma(),LP()[01;31m-[00m>lisp()[01;31m-[00m>intern((yyvsp[(2) [01;31m-[00m (2)].cval)),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2015:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(qq,O_ParsingCons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2016:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2024:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: comma bracketedStatement");
_lisp_Parser.cc:2025:	    RPParsingCons qq = O_ParsingCons::createList(LP()[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_comma(),(yyvsp[(2) [01;31m-[00m (2)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar(),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2026:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(qq,O_ParsingCons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2027:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2035:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: commaAt symbol");
_lisp_Parser.cc:2036:	    RPParsingCons qq = O_ParsingCons::createList(LP()[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_commaAt(),LP()[01;31m-[00m>lisp()[01;31m-[00m>intern((yyvsp[(2) [01;31m-[00m (2)].cval)),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2037:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(qq,O_ParsingCons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2038:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2046:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: commaAt bracketedStatement");
_lisp_Parser.cc:2047:	    RPParsingCons qq = O_ParsingCons::createList(LP()[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_commaAt(),(yyvsp[(2) [01;31m-[00m (2)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar(),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2048:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(qq,O_ParsingCons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2049:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2057:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: symbol");
_lisp_Parser.cc:2058:	    RPParsingCons qq = O_ParsingCons::createList(LP()[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_quote(),(yyvsp[(2) [01;31m-[00m (2)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar(),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2059:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(qq,O_ParsingCons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2060:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2068:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: symbol");
_lisp_Parser.cc:2069:	    RPParsingCons qq = O_ParsingCons::createList(LP()[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_backQuote(),(yyvsp[(2) [01;31m-[00m (2)].cons)[01;31m-[00m>_obj[01;31m-[00m>ocar(),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2070:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(qq,O_ParsingCons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (2)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2071:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2079:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: symbol");
_lisp_Parser.cc:2080:	    RPObject symbolOrSpecialForm = LP()[01;31m-[00m>lisp()[01;31m-[00m>specialFormOrNil((yyvsp[(1) [01;31m-[00m (1)].cval));
_lisp_Parser.cc:2081:	    if ( symbolOrSpecialForm[01;31m-[00m>isNil() )
_lisp_Parser.cc:2083:		symbolOrSpecialForm = LP()[01;31m-[00m>lisp()[01;31m-[00m>intern((yyvsp[(1) [01;31m-[00m (1)].cval));
_lisp_Parser.cc:2086:	    		O_Cons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (1)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2087:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2095:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: integer");
_lisp_Parser.cc:2096:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(O_Int::create((yyvsp[(1) [01;31m-[00m (1)].ival),LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:2097:	    		O_Cons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (1)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2098:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2106:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: LongLongInt");
_lisp_Parser.cc:2107:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(O_LongLongInt::create((yyvsp[(1) [01;31m-[00m (1)].llval),LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:2108:	    		O_Cons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (1)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2109:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2117:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: double");
_lisp_Parser.cc:2118:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(O_Real::create((yyvsp[(1) [01;31m-[00m (1)].dval),LP()[01;31m-[00m>lisp()),
_lisp_Parser.cc:2119:	    		O_Cons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (1)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2120:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2128:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: string");
_lisp_Parser.cc:2129:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(LP()[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>((yyvsp[(1) [01;31m-[00m (1)].cval)),
_lisp_Parser.cc:2130:	    		O_Cons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (1)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2131:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2139:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: tee is symbolTrue");
_lisp_Parser.cc:2140:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(LP()[01;31m-[00m>lisp()[01;31m-[00m>_true(),
_lisp_Parser.cc:2141:	    			O_Cons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (1)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2142:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2150:    { _lisp_BLOCK_TRACE(LP()[01;31m-[00m>lisp(),"parse: eff is nil");
_lisp_Parser.cc:2151:	    (yyval.cons) = new Hold<O_Cons>(O_ParsingCons::create(LP()[01;31m-[00m>lisp()[01;31m-[00m>_false(),
_lisp_Parser.cc:2152:	    			O_Cons::nil(LP()[01;31m-[00m>lisp()),(yylsp[(1) [01;31m-[00m (1)]),LP()[01;31m-[00m>fileName,LP()[01;31m-[00m>lisp()));
_lisp_Parser.cc:2153:	    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Parsed|%s|") % ((yyval.cons)[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Parsed|%s|",$$[01;31m-[00m>_obj[01;31m-[00m>__repr__().c_str() ));
_lisp_Parser.cc:2163:  YY_SYMBOL_PRINT ("[01;31m-[00m> $$ =", yyr1[yyn], &yyval, &yyloc);
_lisp_Parser.cc:2178:  yystate = yypgoto[yyn [01;31m-[00m YYNTOKENS] + *yyssp;
_lisp_Parser.cc:2182:    yystate = yydefgoto[yyn [01;31m-[00m YYNTOKENS];
_lisp_Parser.cc:2187:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:2188:| yyerrlab [01;31m-[00m[01;31m-[00m here on detecting error |
_lisp_Parser.cc:2189:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:2258:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:2259:| yyerrorlab [01;31m-[00m[01;31m-[00m error raised explicitly by YYERROR.  |
_lisp_Parser.cc:2260:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:2269:  yyerror_range[1] = yylsp[1[01;31m-[00myylen];
_lisp_Parser.cc:2279:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:2280:| yyerrlab1 [01;31m-[00m[01;31m-[00m common code for both syntax error and YYERROR.  |
_lisp_Parser.cc:2281:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:2326:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:2327:| yyacceptlab [01;31m-[00m[01;31m-[00m YYACCEPT comes here.  |
_lisp_Parser.cc:2328:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:2333:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:2334:| yyabortlab [01;31m-[00m[01;31m-[00m YYABORT comes here.  |
_lisp_Parser.cc:2335:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:2341:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_lisp_Parser.cc:2342:| yyexhaustedlab [01;31m-[00m[01;31m-[00m memory exhaustion comes here.  |
_lisp_Parser.cc:2343:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_lisp_Parser.cc:2391:    c = lispStream[01;31m-[00m>get();
_lisp_Parser.cc:2392:    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("lispGetChar char=(%d/\"%c\")") % c % c );
_lisp_Parser.cc:2395:	LP()[01;31m-[00m>parserPos._LineNumber++;
_lisp_Parser.cc:2396:	LP()[01;31m-[00m>parserPos._Column=1;
_lisp_Parser.cc:2397:    } else LP()[01;31m-[00m>parserPos._Column++;
_lisp_Parser.cc:2405:    lispStream[01;31m-[00m>unget();
_lisp_Parser.cc:2414:    (data[01;31m-[00m>lispErrorStream) << (BF("lisperror file(%s) line(%d) column(%d): %s") % data[01;31m-[00m>fileName % yylloc[01;31m-[00m>first_line % yylloc[01;31m-[00m>first_column % msg ).str() << endl;
_lisp_Parser.cc:2415:    lisp_LOG(data[01;31m-[00m>lisp(),(BF("%s")%data[01;31m-[00m>lispErrorStream.str()));
_lisp_Parser.cc:2416:    lisp_TOSS(data[01;31m-[00m>lisp(),data[01;31m-[00m>lisp()[01;31m-[00m>create<O_LispError>((BF("%s")%data[01;31m-[00m>lispErrorStream.str())));
_lisp_Parser.cc:2426://    locp[01;31m-[00m>lisp()[01;31m-[00m>debugLog().writeText(ss.str());
_lisp_Parser.cc:2427://    lisp_THROW(locp[01;31m-[00m>lisp(),O_LispError(locp[01;31m-[00m>lisp(),ss.str()));
_lisp_Parser.cc:2435:{_F(LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2440:    lisp_lex_debug(2,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2441:    LP()[01;31m-[00m>parserPos._LineNumber = 1;
_lisp_Parser.cc:2442:    LP()[01;31m-[00m>parserPos._Column = 1;
_lisp_Parser.cc:2444:    lisp_LOG(LP()[01;31m-[00m>lisp(),BF("Starting scanner") ); // vp0(("Starting scanner"));
_lisp_Parser.cc:2446:    lisp_lex_debug(0,LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2449:	lisp_THROW(LP()[01;31m-[00m>lisp(),O_LispError(LP()[01;31m-[00m>lisp(),lispErrorStream.str()));
_lisp_Parser.cc:2450:	LP()[01;31m-[00m>expression = O_Cons::nil(LP()[01;31m-[00m>lisp());
_lisp_Parser.cc:2473:{_F(p[01;31m-[00m>lisp());
_lisp_Parser.cc:2474:    lisp_LOG(p[01;31m-[00m>lisp(),BF("Entering lispparse"));
_lisp_Parser.cc:2478:	lisp_THROW(p[01;31m-[00m>lisp(),O_LispError(p[01;31m-[00m>lisp(),p[01;31m-[00m>lispErrorStream.str()));
_msmarts_Parser.cc:3:/* Skeleton implementation for Bison's Yacc[01;31m-[00mlike parsers in C
_msmarts_Parser.cc:35:   simplifying the original so[01;31m-[00mcalled "semantic" parser.  */
_msmarts_Parser.cc:271:#define YYSIZE_MAXIMUM ((YYSIZE_T) [01;31m-[00m1)
_msmarts_Parser.cc:277:#   define YY_(msgid) dgettext ("bison[01;31m-[00mruntime", msgid)
_msmarts_Parser.cc:285:/* Suppress unused[01;31m-[00mvariable warnings by "using" E.  */
_msmarts_Parser.cc:339:   /* Pacify GCC's `empty if[01;31m-[00mbody' warning.  */
_msmarts_Parser.cc:345:       to allow for a few compiler[01;31m-[00mallocated temporary stack slots.  */
_msmarts_Parser.cc:394:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) [01;31m-[00m 1)
_msmarts_Parser.cc:429:	YYCOPY (&yyptr[01;31m-[00m>Stack_alloc, Stack, yysize);			\
_msmarts_Parser.cc:430:	Stack = &yyptr[01;31m-[00m>Stack_alloc;					\
_msmarts_Parser.cc:438:/* YYFINAL [01;31m-[00m[01;31m-[00m State number of the termination state.  */
_msmarts_Parser.cc:440:/* YYLAST [01;31m-[00m[01;31m-[00m Last index in YYTABLE.  */
_msmarts_Parser.cc:443:/* YYNTOKENS [01;31m-[00m[01;31m-[00m Number of terminals.  */
_msmarts_Parser.cc:445:/* YYNNTS [01;31m-[00m[01;31m-[00m Number of nonterminals.  */
_msmarts_Parser.cc:447:/* YYNRULES [01;31m-[00m[01;31m-[00m Number of rules.  */
_msmarts_Parser.cc:449:/* YYNRULES [01;31m-[00m[01;31m-[00m Number of states.  */
_msmarts_Parser.cc:452:/* YYTRANSLATE(YYLEX) [01;31m-[00m[01;31m-[00m Bison symbol number corresponding to YYLEX.  */
_msmarts_Parser.cc:459:/* YYTRANSLATE[YYLEX] [01;31m-[00m[01;31m-[00m Bison symbol number corresponding to YYLEX.  */
_msmarts_Parser.cc:495:/* YYPRHS[YYN] [01;31m-[00m[01;31m-[00m Index of the first RHS symbol of rule number YYN in
_msmarts_Parser.cc:508:/* YYRHS [01;31m-[00m[01;31m-[00m A `[01;31m-[00m1'[01;31m-[00mseparated list of the rules' RHS.  */
_msmarts_Parser.cc:511:      46,     0,    [01;31m-[00m1,    47,    [01;31m-[00m1,    [01;31m-[00m1,    51,    [01;31m-[00m1,    51,    48,
_msmarts_Parser.cc:512:      [01;31m-[00m1,    49,    48,    [01;31m-[00m1,    52,    48,    [01;31m-[00m1,    49,    [01;31m-[00m1,    52,
_msmarts_Parser.cc:513:      [01;31m-[00m1,     4,    51,    [01;31m-[00m1,    51,    [01;31m-[00m1,    27,    54,     8,    [01;31m-[00m1,
_msmarts_Parser.cc:514:      16,    [01;31m-[00m1,    55,    [01;31m-[00m1,    50,    26,    [01;31m-[00m1,    50,    [01;31m-[00m1,    28,
_msmarts_Parser.cc:515:      48,     9,    [01;31m-[00m1,    44,    [01;31m-[00m1,    11,    [01;31m-[00m1,    11,    56,    [01;31m-[00m1,
_msmarts_Parser.cc:516:      39,    [01;31m-[00m1,    39,    56,    [01;31m-[00m1,    22,    [01;31m-[00m1,    22,    56,    [01;31m-[00m1,
_msmarts_Parser.cc:517:      12,    26,    [01;31m-[00m1,    13,    26,    [01;31m-[00m1,    37,    [01;31m-[00m1,    37,    56,
_msmarts_Parser.cc:518:      [01;31m-[00m1,    38,    [01;31m-[00m1,    38,    56,    [01;31m-[00m1,    43,    [01;31m-[00m1,    43,    56,
_msmarts_Parser.cc:519:      [01;31m-[00m1,    10,    [01;31m-[00m1,    10,    56,    [01;31m-[00m1,    20,    56,    [01;31m-[00m1,    18,
_msmarts_Parser.cc:520:      [01;31m-[00m1,    21,    [01;31m-[00m1,    21,    56,    [01;31m-[00m1,    24,    56,    [01;31m-[00m1,    24,
_msmarts_Parser.cc:521:      [01;31m-[00m1,    24,    24,    [01;31m-[00m1,    24,    24,    24,    [01;31m-[00m1,    35,    56,
_msmarts_Parser.cc:522:      [01;31m-[00m1,    35,    [01;31m-[00m1,    35,    35,    [01;31m-[00m1,    35,    35,    35,    [01;31m-[00m1,
_msmarts_Parser.cc:523:      42,    56,    [01;31m-[00m1,    34,    56,    [01;31m-[00m1,    33,    [01;31m-[00m1,     5,    56,
_msmarts_Parser.cc:524:      [01;31m-[00m1,     6,    [01;31m-[00m1,     7,    [01;31m-[00m1,    56,    [01;31m-[00m1,    16,    [01;31m-[00m1,    17,
_msmarts_Parser.cc:525:      [01;31m-[00m1,    23,    [01;31m-[00m1,    23,    56,    [01;31m-[00m1,    55,    [01;31m-[00m1,    53,    [01;31m-[00m1,
_msmarts_Parser.cc:526:      31,    54,    [01;31m-[00m1,    54,    29,    54,    [01;31m-[00m1,    54,    32,    54,
_msmarts_Parser.cc:527:      [01;31m-[00m1,    54,    30,    54,    [01;31m-[00m1,    14,    28,    47,     9,    [01;31m-[00m1,
_msmarts_Parser.cc:528:      26,    [01;31m-[00m1
_msmarts_Parser.cc:531:/* YYRLINE[YYN] [01;31m-[00m[01;31m-[00m source line where rule number YYN was defined.  */
_msmarts_Parser.cc:545:/* YYTNAME[SYMBOL[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m String name of the symbol SYMBOL[01;31m-[00mNUM.
_msmarts_Parser.cc:568:/* YYTOKNUM[YYLEX[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m Internal token number corresponding to
_msmarts_Parser.cc:569:   token YYLEX[01;31m-[00mNUM.  */
_msmarts_Parser.cc:580:/* YYR1[YYN] [01;31m-[00m[01;31m-[00m Symbol number of symbol that rule YYN derives.  */
_msmarts_Parser.cc:592:/* YYR2[YYN] [01;31m-[00m[01;31m-[00m Number of symbols composing right hand side of rule YYN.  */
_msmarts_Parser.cc:604:/* YYDEFACT[STATE[01;31m-[00mNAME] [01;31m-[00m[01;31m-[00m Default rule to reduce with in state
_msmarts_Parser.cc:605:   STATE[01;31m-[00mNUM when YYTABLE doesn't specify something else to do.  Zero
_msmarts_Parser.cc:620:/* YYDEFGOTO[NTERM[01;31m-[00mNUM].  */
_msmarts_Parser.cc:623:      [01;31m-[00m1,     4,     5,    44,    45,     6,    46,    47,    36,    37,
_msmarts_Parser.cc:627:/* YYPACT[STATE[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m Index in YYTABLE of the portion describing
_msmarts_Parser.cc:628:   STATE[01;31m-[00mNUM.  */
_msmarts_Parser.cc:629:#define YYPACT_NINF [01;31m-[00m41
_msmarts_Parser.cc:632:      21,   [01;31m-[00m20,   [01;31m-[00m41,    65,    15,   [01;31m-[00m41,   [01;31m-[00m12,    27,   [01;31m-[00m41,    21,
_msmarts_Parser.cc:633:      [01;31m-[00m5,   [01;31m-[00m41,   [01;31m-[00m41,    [01;31m-[00m5,    [01;31m-[00m5,     6,    23,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,
_msmarts_Parser.cc:634:      [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,    14,   [01;31m-[00m41,    65,   [01;31m-[00m41,    [01;31m-[00m5,   [01;31m-[00m22,
_msmarts_Parser.cc:635:      [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,   [01;31m-[00m41,   [01;31m-[00m41,     4,   [01;31m-[00m41,   [01;31m-[00m41,
_msmarts_Parser.cc:636:     [01;31m-[00m41,   [01;31m-[00m41,    21,    27,   [01;31m-[00m41,    27,   [01;31m-[00m41,    27,    13,   [01;31m-[00m41,
_msmarts_Parser.cc:637:     [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,    26,   [01;31m-[00m41,
_msmarts_Parser.cc:638:     [01;31m-[00m41,   [01;31m-[00m41,    16,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,
_msmarts_Parser.cc:639:      65,    65,    65,   [01;31m-[00m41,    43,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,
_msmarts_Parser.cc:640:     [01;31m-[00m41,    10,    24,   [01;31m-[00m41
_msmarts_Parser.cc:643:/* YYPGOTO[NTERM[01;31m-[00mNUM].  */
_msmarts_Parser.cc:646:     [01;31m-[00m41,   [01;31m-[00m41,    47,   [01;31m-[00m40,   [01;31m-[00m41,   [01;31m-[00m41,     2,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m25,
_msmarts_Parser.cc:647:      [01;31m-[00m3,    [01;31m-[00m4
_msmarts_Parser.cc:650:/* YYTABLE[YYPACT[STATE[01;31m-[00mNUM]].  What to do in state STATE[01;31m-[00mNUM.  If
_msmarts_Parser.cc:654:#define YYTABLE_NINF [01;31m-[00m1
_msmarts_Parser.cc:677:      24,    35,     9,    29,    27,    28,     9,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,
_msmarts_Parser.cc:678:      [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    70,    71,    72,
_msmarts_Parser.cc:679:       5,     6,     7,    [01;31m-[00m1,    [01;31m-[00m1,    10,    11,    12,    13,    14,
_msmarts_Parser.cc:680:      [01;31m-[00m1,    16,    17,    18,    [01;31m-[00m1,    20,    21,    22,    23,    24,
_msmarts_Parser.cc:681:      [01;31m-[00m1,    26,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    31,    [01;31m-[00m1,    33,    34,
_msmarts_Parser.cc:682:      35,    [01;31m-[00m1,    37,    38,    39,    [01;31m-[00m1,    [01;31m-[00m1,    42,    43,    44
_msmarts_Parser.cc:685:/* YYSTOS[STATE[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m The (internal number of the) accessing
_msmarts_Parser.cc:686:   symbol of state STATE[01;31m-[00mNUM.  */
_msmarts_Parser.cc:702:#define YYEMPTY		([01;31m-[00m2)
_msmarts_Parser.cc:720:     [01;31m-[00mWunused[01;31m-[00mmacros.  Normally we don't worry about that warning, but
_msmarts_Parser.cc:749:/* YYLLOC_DEFAULT [01;31m-[00m[01;31m-[00m Set CURRENT to span from RHS[1] to RHS[N].
_msmarts_Parser.cc:775:/* YY_LOCATION_PRINT [01;31m-[00m[01;31m-[00m Print the location on the stream.
_msmarts_Parser.cc:782:     fprintf (File, "%d.%d[01;31m-[00m%d.%d",			\
_msmarts_Parser.cc:791:/* YYLEX [01;31m-[00m[01;31m-[00m calling `yylex' with the right arguments.  */
_msmarts_Parser.cc:825:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:827:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:862:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:864:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:891:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:892:| yy_stack_print [01;31m-[00m[01;31m-[00m Print the state stack from its BOTTOM up to its |
_msmarts_Parser.cc:894:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:923:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:925:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:944:	     yyrule [01;31m-[00m 1, yylno);
_msmarts_Parser.cc:950:		       &(yyvsp[(yyi + 1) [01;31m-[00m (yynrhs)])
_msmarts_Parser.cc:951:		       , &(yylsp[(yyi + 1) [01;31m-[00m (yynrhs)])		       , data);
_msmarts_Parser.cc:973:/* YYINITDEPTH [01;31m-[00m[01;31m-[00m initial size of the parser's stacks.  */
_msmarts_Parser.cc:978:/* YYMAXDEPTH [01;31m-[00m[01;31m-[00m maximum size the stacks can grow to (effective only
_msmarts_Parser.cc:979:   if the built[01;31m-[00min stack extension method is used).
_msmarts_Parser.cc:983:   evaluated with infinite[01;31m-[00mprecision integer arithmetic.  */
_msmarts_Parser.cc:1039:  return yyd [01;31m-[00m 1;
_msmarts_Parser.cc:1047:   heuristic is that double[01;31m-[00mquoting is unnecessary unless the string
_msmarts_Parser.cc:1049:   backslash[01;31m-[00mbackslash).  YYSTR is taken from yytname.  If YYRES is
_msmarts_Parser.cc:1088:  return yystpcpy (yyres, yystr) [01;31m-[00m yyres;
_msmarts_Parser.cc:1132:		    + sizeof yyexpecting [01;31m-[00m 1
_msmarts_Parser.cc:1133:		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM [01;31m-[00m 2)
_msmarts_Parser.cc:1134:		       * (sizeof yyor [01;31m-[00m 1))];
_msmarts_Parser.cc:1137:      /* Start YYX at [01;31m-[00mYYN if negative to avoid negative indexes in
_msmarts_Parser.cc:1139:      int yyxbegin = yyn < 0 ? [01;31m-[00myyn : 0;
_msmarts_Parser.cc:1142:      int yychecklim = YYLAST [01;31m-[00m yyn + 1;
_msmarts_Parser.cc:1156:		yyformat[sizeof yyunexpected [01;31m-[00m 1] = '\0';
_msmarts_Parser.cc:1202:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:1204:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:1235:	{ if ((yyvaluep[01;31m-[00m>smartsRoot)!=NULL) delete ((yyvaluep[01;31m-[00m>smartsRoot));};
_msmarts_Parser.cc:1244:	{ if ((yyvaluep[01;31m-[00m>bondListMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>bondListMatchNode)); };
_msmarts_Parser.cc:1253:	{ if ((yyvaluep[01;31m-[00m>bondTest)!=NULL) delete ((yyvaluep[01;31m-[00m>bondTest)); };
_msmarts_Parser.cc:1262:	{ if ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)); };
_msmarts_Parser.cc:1271:	{ if ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)); };
_msmarts_Parser.cc:1280:	{ if ((yyvaluep[01;31m-[00m>bondListMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>bondListMatchNode)); };
_msmarts_Parser.cc:1289:	{ if ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)); };
_msmarts_Parser.cc:1298:	{ if ((yyvaluep[01;31m-[00m>logical)!=NULL) delete ((yyvaluep[01;31m-[00m>logical)); };
_msmarts_Parser.cc:1307:	{ if ((yyvaluep[01;31m-[00m>root)!=NULL) delete ((yyvaluep[01;31m-[00m>root)); };
_msmarts_Parser.cc:1318:/* Prevent warnings from [01;31m-[00mWmissing[01;31m-[00mprototypes.  */
_msmarts_Parser.cc:1337:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:1339:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:1423:#define YYPOPSTACK(N)   (yyvsp [01;31m-[00m= (N), yyssp [01;31m-[00m= (N), yylsp [01;31m-[00m= (N))
_msmarts_Parser.cc:1458:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:1459:| yynewstate [01;31m-[00m[01;31m-[00m Push a new state, which is found in yystate.  |
_msmarts_Parser.cc:1460:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:1469:  if (yyss + yystacksize [01;31m-[00m 1 <= yyssp)
_msmarts_Parser.cc:1472:      YYSIZE_T yysize = yyssp [01;31m-[00m yyss + 1;
_msmarts_Parser.cc:1524:      yyssp = yyss + yysize [01;31m-[00m 1;
_msmarts_Parser.cc:1525:      yyvsp = yyvs + yysize [01;31m-[00m 1;
_msmarts_Parser.cc:1526:      yylsp = yyls + yysize [01;31m-[00m 1;
_msmarts_Parser.cc:1531:      if (yyss + yystacksize [01;31m-[00m 1 <= yyssp)
_msmarts_Parser.cc:1542:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:1544:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:1585:      yyn = [01;31m-[00myyn;
_msmarts_Parser.cc:1592:    yyerrstatus[01;31m-[00m[01;31m-[00m;
_msmarts_Parser.cc:1606:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:1607:| yydefault [01;31m-[00m[01;31m-[00m do the default action for the current state.  |
_msmarts_Parser.cc:1608:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:1616:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:1617:| yyreduce [01;31m-[00m[01;31m-[00m Do a reduction.  |
_msmarts_Parser.cc:1618:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:1631:  yyval = yyvsp[1[01;31m-[00myylen];
_msmarts_Parser.cc:1634:  YYLLOC_DEFAULT (yyloc, (yylsp [01;31m-[00m yylen), yylen);
_msmarts_Parser.cc:1642:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"input: chemInfo");
_msmarts_Parser.cc:1643:	    data[01;31m-[00m>expression = (yyvsp[(1) [01;31m-[00m (1)].smartsRoot)[01;31m-[00m>_obj; 
_msmarts_Parser.cc:1651:    { (yyval.smartsRoot) = new Hold<chemInfo::O_SmartsRoot>(MP()[01;31m-[00m>lisp); ;}
_msmarts_Parser.cc:1658:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"chemInfo: atomTest");
_msmarts_Parser.cc:1659:		    (yyval.smartsRoot) = new Hold<chemInfo::O_SmartsRoot>(chemInfo::O_SmartsRoot::create((yyvsp[(1) [01;31m-[00m (1)].atomOrBondMatchNode)[01;31m-[00m>_obj,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1667:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"chemInfo:atomTest chain");
_msmarts_Parser.cc:1668:		    (yyval.smartsRoot) = new Hold<chemInfo::O_SmartsRoot>(chemInfo::O_SmartsRoot::create((yyvsp[(1) [01;31m-[00m (2)].atomOrBondMatchNode)[01;31m-[00m>_obj,(yyvsp[(2) [01;31m-[00m (2)].bondListMatchNode)[01;31m-[00m>_obj,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1676:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"chain:bondAtomTest chain");
_msmarts_Parser.cc:1677:	(yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Chain::create( (yyvsp[(1) [01;31m-[00m (2)].bondTest)[01;31m-[00m>_obj, (yyvsp[(2) [01;31m-[00m (2)].bondListMatchNode)[01;31m-[00m>_obj,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1685:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"chain: branch chain");
_msmarts_Parser.cc:1686:	(yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Branch::create( (yyvsp[(1) [01;31m-[00m (2)].bondListMatchNode)[01;31m-[00m>_obj, (yyvsp[(2) [01;31m-[00m (2)].bondListMatchNode)[01;31m-[00m>_obj,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1694:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"chain: bondAtomTest");
_msmarts_Parser.cc:1695:	(yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Chain::create( (yyvsp[(1) [01;31m-[00m (1)].bondTest)[01;31m-[00m>_obj,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1703:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"chain: branch");
_msmarts_Parser.cc:1704:	(yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Branch::create( (yyvsp[(1) [01;31m-[00m (1)].bondListMatchNode)[01;31m-[00m>_obj,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1712:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"bondAtomTest:APBond atomTest");
_msmarts_Parser.cc:1713:			    (yyval.bondTest) = new Hold<chemInfo::O_BondTest>(chemInfo::O_BondTest::create( (yyvsp[(1) [01;31m-[00m (2)].benum), (yyvsp[(2) [01;31m-[00m (2)].atomOrBondMatchNode)[01;31m-[00m>_obj,MP()[01;31m-[00m>lisp )); 
_msmarts_Parser.cc:1721:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"bondAtomTest: atomTest");
_msmarts_Parser.cc:1722:			    (yyval.bondTest) = new Hold<chemInfo::O_BondTest>(chemInfo::O_BondTest::create( chemInfo::SABSingleOrAromaticBond, (yyvsp[(1) [01;31m-[00m (1)].atomOrBondMatchNode)[01;31m-[00m>_obj,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1730:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"acyclicAtomTest: APOpenBracket logOp APCloseBracket");
_msmarts_Parser.cc:1731:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((yyvsp[(2) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj);
_msmarts_Parser.cc:1739:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"acyclicAtomTest: APOrganicElement");
_msmarts_Parser.cc:1740:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((chemInfo::O_AtomTest::create(chemInfo::SAPElement, 0, 0, (yyvsp[(1) [01;31m-[00m (1)].eval) ,MP()[01;31m-[00m>lisp))); 
_msmarts_Parser.cc:1748:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"acyclicAtomTest: recursiveChemInfo");
_msmarts_Parser.cc:1749:	    		    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((yyvsp[(1) [01;31m-[00m (1)].root)[01;31m-[00m>_obj); 
_msmarts_Parser.cc:1757:    { _lisp_BLOCK_TRACEF(MP()[01;31m-[00m>lisp,BF("atomTest: acyclicAtomTest APNumber   // atomTag==(%s)  ") % ((yyvsp[(2) [01;31m-[00m (2)].cval)));
_msmarts_Parser.cc:1758:	(yyval.atomOrBondMatchNode)=new Hold<chemInfo::O_AtomOrBondMatchNode>(chemInfo::O_TagSet::create(chemInfo::SABAnyBond,(yyvsp[(1) [01;31m-[00m (2)].atomOrBondMatchNode)[01;31m-[00m>_obj,(yyvsp[(2) [01;31m-[00m (2)].cval),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1766:    { _lisp_BLOCK_TRACE(MP()[01;31m-[00m>lisp,"atomTest: acyclicAtomTest");
_msmarts_Parser.cc:1767:	(yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((yyvsp[(1) [01;31m-[00m (1)].atomOrBondMatchNode)[01;31m-[00m>_obj); 
_msmarts_Parser.cc:1775:    { (yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>((yyvsp[(2) [01;31m-[00m (3)].bondListMatchNode)[01;31m-[00m>_obj); ;}
_msmarts_Parser.cc:1784:				chemInfo::O_AtomTest::create(chemInfo::SAPWildCard,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1794:				chemInfo::O_AtomTest::create( chemInfo::SAPDegree, 1,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1804:			chemInfo::O_AtomTest::create( chemInfo::SAPDegree,(yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1814:				chemInfo::O_AtomTest::create( chemInfo::SAPTotalHCount, 1,MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1824:				chemInfo::O_AtomTest::create( chemInfo::SAPTotalHCount, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1834:			chemInfo::O_AtomTest::create( chemInfo::SAPImplicitHCount, 1,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1845:						chemInfo::SAPImplicitHCount, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1855:					chemInfo::O_AtomTest::create(chemInfo::SAPRingTest,(yyvsp[(2) [01;31m-[00m (2)].cval),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1865:					chemInfo::O_AtomTest::create(chemInfo::SAPResidueTest,(yyvsp[(2) [01;31m-[00m (2)].cval),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1874:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPRingMembershipCount, 1,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1883:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPRingMembershipCount, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1892:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPRingSize, 1,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1901:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPRingSize, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1910:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPValence, 1,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1919:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPValence, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1928:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPConnectivity, 1,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1937:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPConnectivity, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1946:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPGroupNumber, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1955:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPElectronegativeElement,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1964:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPHeavyAtomTotalBond, 1,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1973:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPHeavyAtomTotalBond, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:1982:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPNegativeCharge, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:1991:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPNegativeCharge, [01;31m-[00m1,MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2000:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPNegativeCharge, [01;31m-[00m2,MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2009:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPNegativeCharge, [01;31m-[00m3,MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2018:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPPositiveCharge, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2027:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPPositiveCharge, 1,MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2036:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPPositiveCharge, 2,MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2045:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPPositiveCharge, 3,MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2054:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPTransitionMetal, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2063:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPAromaticPiElectron , (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2072:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPPiBondOrbital,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2081:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPAtomicNumber, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2090:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPChiralityAntiClockwise,MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2099:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPChiralityClockwise,MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2108:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPAtomicMass, (yyvsp[(1) [01;31m-[00m (1)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2117:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPElement, (yyvsp[(1) [01;31m-[00m (1)].eval) ,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2126:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPElement, (yyvsp[(1) [01;31m-[00m (1)].eval) ,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2135:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPLonePair, 1,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2144:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPLonePair, (yyvsp[(2) [01;31m-[00m (2)].ival),MP()[01;31m-[00m>lisp));
_msmarts_Parser.cc:2153:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((yyvsp[(1) [01;31m-[00m (1)].root)[01;31m-[00m>_obj); 
_msmarts_Parser.cc:2163:	    		chemInfo::O_Logical::create( chemInfo::logIdentity, (yyvsp[(1) [01;31m-[00m (1)].atomOrBondMatchNode)[01;31m-[00m>_obj ,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2173:	    		chemInfo::O_Logical::create( chemInfo::logNot, (yyvsp[(2) [01;31m-[00m (2)].logical)[01;31m-[00m>_obj ,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2183:	    		chemInfo::O_Logical::create( chemInfo::logHighPrecedenceAnd, (yyvsp[(1) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj ,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2193:	    		chemInfo::O_Logical::create( chemInfo::logOr, (yyvsp[(1) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj ,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2203:	    		chemInfo::O_Logical::create( chemInfo::logLowPrecedenceAnd, (yyvsp[(1) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj ,MP()[01;31m-[00m>lisp)); 
_msmarts_Parser.cc:2211:    { (yyval.root) = new Hold<chemInfo::O_Root>((yyvsp[(3) [01;31m-[00m (4)].smartsRoot)[01;31m-[00m>_obj); ;}
_msmarts_Parser.cc:2218:    { (yyval.ival) = atoi((yyvsp[(1) [01;31m-[00m (1)].cval)); ;}
_msmarts_Parser.cc:2227:  YY_SYMBOL_PRINT ("[01;31m-[00m> $$ =", yyr1[yyn], &yyval, &yyloc);
_msmarts_Parser.cc:2242:  yystate = yypgoto[yyn [01;31m-[00m YYNTOKENS] + *yyssp;
_msmarts_Parser.cc:2246:    yystate = yydefgoto[yyn [01;31m-[00m YYNTOKENS];
_msmarts_Parser.cc:2251:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:2252:| yyerrlab [01;31m-[00m[01;31m-[00m here on detecting error |
_msmarts_Parser.cc:2253:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:2322:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:2323:| yyerrorlab [01;31m-[00m[01;31m-[00m error raised explicitly by YYERROR.  |
_msmarts_Parser.cc:2324:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:2333:  yyerror_range[1] = yylsp[1[01;31m-[00myylen];
_msmarts_Parser.cc:2343:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:2344:| yyerrlab1 [01;31m-[00m[01;31m-[00m common code for both syntax error and YYERROR.  |
_msmarts_Parser.cc:2345:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:2390:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:2391:| yyacceptlab [01;31m-[00m[01;31m-[00m YYACCEPT comes here.  |
_msmarts_Parser.cc:2392:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:2397:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:2398:| yyabortlab [01;31m-[00m[01;31m-[00m YYABORT comes here.  |
_msmarts_Parser.cc:2399:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:2405:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
_msmarts_Parser.cc:2406:| yyexhaustedlab [01;31m-[00m[01;31m-[00m memory exhaustion comes here.  |
_msmarts_Parser.cc:2407:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
_msmarts_Parser.cc:2527:	ichar = data[01;31m-[00m>lexStream[01;31m-[00m>get();	 // Read one character
_msmarts_Parser.cc:2530:    } while (!data[01;31m-[00m>lexStream[01;31m-[00m>eof() && ichar < ' ' );
_msmarts_Parser.cc:2531:    if ( data[01;31m-[00m>lexStream[01;31m-[00m>eof() ) return 0;
_msmarts_Parser.cc:2536:	    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("next char: &amp;"));
_msmarts_Parser.cc:2539:	    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("next char: &lt;"));
_msmarts_Parser.cc:2542:	    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("next char: &gt;"));
_msmarts_Parser.cc:2545:            LEXDPRINT(MP()[01;31m-[00m>lisp,BF("next char: |%c|") % ichar);
_msmarts_Parser.cc:2554:    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Checking 1 and 2 chars inorganic elements"));
_msmarts_Parser.cc:2561:		if ( elementTable[i][1] == data[01;31m-[00m>lexStream[01;31m-[00m>peek() ) 
_msmarts_Parser.cc:2563:		    data[01;31m-[00m>lexStream[01;31m-[00m>get();
_msmarts_Parser.cc:2564://			strcpy( yylval[01;31m-[00m>eval ,  elementTable[i] );
_msmarts_Parser.cc:2565:		    yylval[01;31m-[00m>eval = elementTable[i];
_msmarts_Parser.cc:2566:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Matched the 2 char inorganic element: |%s|")%elementTable[i]);	
_msmarts_Parser.cc:2573:		yylval[01;31m-[00m>eval = elementTable[i];
_msmarts_Parser.cc:2574://		    strcpy( yylval[01;31m-[00m>eval , elementTable[i]);
_msmarts_Parser.cc:2575:		LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Matched the 1 char inorganic element: |%s|")%elementTable[i]);	
_msmarts_Parser.cc:2584:    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Checking 1 and 2 chars organic elements"));	
_msmarts_Parser.cc:2589:	    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Matched the 1st char in organicElementTable[]"));
_msmarts_Parser.cc:2592:		if ( organicElementTable[i][1] == data[01;31m-[00m>lexStream[01;31m-[00m>peek() )
_msmarts_Parser.cc:2594:		    cout<<"Peek char: "<<data[01;31m-[00m>lexStream[01;31m-[00m>peek()<<endl;
_msmarts_Parser.cc:2595:		    data[01;31m-[00m>lexStream[01;31m-[00m>get();
_msmarts_Parser.cc:2596://			 strcpy(yylval[01;31m-[00m>eval , organicElementTable[i] );
_msmarts_Parser.cc:2597:		    yylval[01;31m-[00m>eval = organicElementTable[i];
_msmarts_Parser.cc:2598:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Matched the 2 char organic element: |%s|")%elementTable[i]);
_msmarts_Parser.cc:2604:		yylval[01;31m-[00m>eval = organicElementTable[i];
_msmarts_Parser.cc:2605://		     strcpy( yylval[01;31m-[00m>eval, organicElementTable[i];
_msmarts_Parser.cc:2606:		LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Matched the 1 char organic element: |%s|\n")%organicElementTable[i]);
_msmarts_Parser.cc:2621:    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Checking special characters"));	
_msmarts_Parser.cc:2625:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APWildCard");
_msmarts_Parser.cc:2629:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APDollarSign");
_msmarts_Parser.cc:2633:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APOpenParenthesis");
_msmarts_Parser.cc:2637:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APCloseParenthesis");
_msmarts_Parser.cc:2641:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APOpenBracket");
_msmarts_Parser.cc:2645:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APCloseBracket");
_msmarts_Parser.cc:2649:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APOperatorAndLow");
_msmarts_Parser.cc:2653:	    	    LEXPRINT(MP()[01;31m-[00m>lisp,"APRingTest");
_msmarts_Parser.cc:2659:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APResidueTest");
_msmarts_Parser.cc:2660:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APResidueTest"));
_msmarts_Parser.cc:2664:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APOperatorOr");
_msmarts_Parser.cc:2668:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APOperatorNot");
_msmarts_Parser.cc:2672:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APOpeartorAndHigh");
_msmarts_Parser.cc:2676:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APAnyBond");   
_msmarts_Parser.cc:2677:                    yylval[01;31m-[00m>benum = chemInfo::SABAnyBond;
_msmarts_Parser.cc:2682:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APAromaticBond");
_msmarts_Parser.cc:2683:                    yylval[01;31m-[00m>benum = chemInfo::SABAromaticBond;
_msmarts_Parser.cc:2689:		    if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() >= '0' && data[01;31m-[00m>lexStream[01;31m-[00m>peek() <= '9' ) 
_msmarts_Parser.cc:2691:			    LEXPRINT(MP()[01;31m-[00m>lisp,"APAtomicNumber");
_msmarts_Parser.cc:2694:		    } else if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() == 'G')
_msmarts_Parser.cc:2696:			    data[01;31m-[00m>lexStream[01;31m-[00m>get();
_msmarts_Parser.cc:2697:			    if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() >= '0' && data[01;31m-[00m>lexStream[01;31m-[00m>peek() <= '9')
_msmarts_Parser.cc:2699:			        LEXPRINT(MP()[01;31m-[00m>lisp,"APGroupNumber");
_msmarts_Parser.cc:2704:		    } else if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() == 'T')
_msmarts_Parser.cc:2706:			    data[01;31m-[00m>lexStream[01;31m-[00m>get();
_msmarts_Parser.cc:2707:			    if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() >= '0' && data[01;31m-[00m>lexStream[01;31m-[00m>peek() <= '9')
_msmarts_Parser.cc:2709:				    LEXPRINT(MP()[01;31m-[00m>lisp,"APTransitionMetal");
_msmarts_Parser.cc:2714:		    } else if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() == 'N')
_msmarts_Parser.cc:2716:			    data[01;31m-[00m>lexStream[01;31m-[00m>get();
_msmarts_Parser.cc:2717:			    if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() >= '0' && data[01;31m-[00m>lexStream[01;31m-[00m>peek() <= '9')
_msmarts_Parser.cc:2719:				    LEXPRINT(MP()[01;31m-[00m>lisp,"APElectronegativeElement");
_msmarts_Parser.cc:2725:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APTripleBond");
_msmarts_Parser.cc:2726:                    yylval[01;31m-[00m>benum = chemInfo::SABTripleBond;
_msmarts_Parser.cc:2730:		    if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() == '?') 
_msmarts_Parser.cc:2732:			data[01;31m-[00m>lexStream[01;31m-[00m>get();
_msmarts_Parser.cc:2733:			LEXPRINT(MP()[01;31m-[00m>lisp,"APSingleUpOrUnspecified");
_msmarts_Parser.cc:2734:			yylval[01;31m-[00m>benum = chemInfo::SABDirectionalSingleUpOrUnspecified;
_msmarts_Parser.cc:2738:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APDirectionalSingleUp");
_msmarts_Parser.cc:2739:		    yylval[01;31m-[00m>benum = chemInfo::SABDirectionalSingleUp;
_msmarts_Parser.cc:2742:	    case '[01;31m-[00m':
_msmarts_Parser.cc:2743:		    if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() >= '0' && data[01;31m-[00m>lexStream[01;31m-[00m>peek() <= '9'  ) 
_msmarts_Parser.cc:2745:			    LEXPRINT(MP()[01;31m-[00m>lisp,"APNegativeCharge");
_msmarts_Parser.cc:2749:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APSingleBond");
_msmarts_Parser.cc:2750:		    yylval[01;31m-[00m>benum = chemInfo::SABSingleBond;
_msmarts_Parser.cc:2754:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APDoubleBond");
_msmarts_Parser.cc:2755:                    yylval[01;31m-[00m>benum = chemInfo::SABDoubleBond;
_msmarts_Parser.cc:2759:		    if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() == '?') 
_msmarts_Parser.cc:2761:			data[01;31m-[00m>lexStream[01;31m-[00m>get();
_msmarts_Parser.cc:2762:			LEXPRINT(MP()[01;31m-[00m>lisp,"APSingleDownOrUnspecified");
_msmarts_Parser.cc:2763:			yylval[01;31m-[00m>benum = chemInfo::SABDirectionalSingleDownOrUnspecified;
_msmarts_Parser.cc:2767:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APDirectionalSingleDown");
_msmarts_Parser.cc:2768:		    yylval[01;31m-[00m>benum = chemInfo::SABDirectionalSingleDown;
_msmarts_Parser.cc:2772:		    if ( data[01;31m-[00m>lexStream[01;31m-[00m>peek() == '@' ) {
_msmarts_Parser.cc:2773:			data[01;31m-[00m>lexStream[01;31m-[00m>get(); // pull the second @ out of the stream
_msmarts_Parser.cc:2774:			LEXPRINT(MP()[01;31m-[00m>lisp,"APChiralityClockwise");
_msmarts_Parser.cc:2775:			LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APChiralityClockwise"));	
_msmarts_Parser.cc:2779:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APChiralityAntiClockwiseOrAnyRingBond");
_msmarts_Parser.cc:2780:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APChiralityAntiClockwise"));
_msmarts_Parser.cc:2784:		    if ( data[01;31m-[00m>lexStream[01;31m-[00m>peek() >= '0' && data[01;31m-[00m>lexStream[01;31m-[00m>peek() <= '9') {
_msmarts_Parser.cc:2785:		        LEXPRINT(MP()[01;31m-[00m>lisp,"APDegree");
_msmarts_Parser.cc:2786:		        LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APDegree"));
_msmarts_Parser.cc:2793:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APTotalHCount");
_msmarts_Parser.cc:2794:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APTotalHCount"));
_msmarts_Parser.cc:2798:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APImplicitHCount");
_msmarts_Parser.cc:2799:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identifed as APImplicitHCount"));
_msmarts_Parser.cc:2803:		    if (data[01;31m-[00m>lexStream[01;31m-[00m>peek() >= '0' && data[01;31m-[00m>lexStream[01;31m-[00m>peek() <= '9')
_msmarts_Parser.cc:2805:			LEXPRINT(MP()[01;31m-[00m>lisp,"APAromaticPiElectron");
_msmarts_Parser.cc:2806:			LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APAromaticPiElectron"));
_msmarts_Parser.cc:2810:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APPiBondOrbital");
_msmarts_Parser.cc:2811:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APPiBondOrbital"));
_msmarts_Parser.cc:2815:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APHeavyAtomTotalBond");
_msmarts_Parser.cc:2816:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APHeavyAtomTotalBond"));
_msmarts_Parser.cc:2820:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APRingMembershipCount");
_msmarts_Parser.cc:2821:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APRingMembership"));
_msmarts_Parser.cc:2825:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APRingSize");
_msmarts_Parser.cc:2826:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APRingSize"));
_msmarts_Parser.cc:2830:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APValence");
_msmarts_Parser.cc:2831:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APValence"));	
_msmarts_Parser.cc:2835:		    LEXPRINT(MP()[01;31m-[00m>lisp,"APConnectivity");  
_msmarts_Parser.cc:2836:		    LEXDPRINT(MP()[01;31m-[00m>lisp,BF("Identified as APConnectivity"));	
_msmarts_Parser.cc:2844:    if (ichar == 'L' && data[01;31m-[00m>lexStream[01;31m-[00m>peek() == 'p')
_msmarts_Parser.cc:2846:        data[01;31m-[00m>lexStream[01;31m-[00m>get();	
_msmarts_Parser.cc:2847:        LEXPRINT(MP()[01;31m-[00m>lisp,"APLonePair");
_msmarts_Parser.cc:2856:	    yylval[01;31m-[00m>cval[digitCount] = ichar;
_msmarts_Parser.cc:2858:	    while ( data[01;31m-[00m>lexStream[01;31m-[00m>peek()>='0' && data[01;31m-[00m>lexStream[01;31m-[00m>peek()<='9' ) 
_msmarts_Parser.cc:2860:		    ichar = data[01;31m-[00m>lexStream[01;31m-[00m>get();
_msmarts_Parser.cc:2863:		        lisp_THROW(MP()[01;31m-[00m>lisp,O_LispError(MP()[01;31m-[00m>lisp,BF("Exceeded max number of digits in Number")));
_msmarts_Parser.cc:2865:		    yylval[01;31m-[00m>cval[digitCount] = ichar;
_msmarts_Parser.cc:2868:	    yylval[01;31m-[00m>cval[digitCount] = '\0';
_msmarts_Parser.cc:2869:	    lisp_LOG(MP()[01;31m-[00m>lisp,BF("APNumber = (%s)") % (yylval[01;31m-[00m>cval) );
_msmarts_Parser.cc:2874:    LEXPRINT(MP()[01;31m-[00m>lisp,"APError");
_msmarts_Parser.cc:2886:    data[01;31m-[00m>lexStream = &cin;
_msmarts_Parser.cc:2901:    p.expression = lisp[01;31m-[00m>nil<O_SmartsRoot>();
_msmarts_Parser.cc:2907:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("%s") % (p.msmartsErrorStream[01;31m-[00m>str())));
_msmarts_Parser.cc:2915:    *(data[01;31m-[00m>msmartsErrorStream) << "Error: " << message << endl;
_oldImproperRestraintTerm.cc:2:	tx77 = [01;31m-[00mx2; 		/* rule 1 */
_oldImproperRestraintTerm.cc:6:	tx78 = [01;31m-[00my2; 		/* rule 5 */
_oldImproperRestraintTerm.cc:8:	tx50 = [01;31m-[00my3; 		/* rule 7 */
_oldImproperRestraintTerm.cc:12:	tx49 = [01;31m-[00mx3; 		/* rule 11 */
_oldImproperRestraintTerm.cc:16:	tx79 = [01;31m-[00mz2; 		/* rule 15 */
_oldImproperRestraintTerm.cc:22:	tx51 = [01;31m-[00mz3; 		/* rule 21 */
_oldImproperRestraintTerm.cc:85:	CosPhi=MAX([01;31m-[00m1.0,MIN(1.0,CosPhi));
_oldImproperRestraintTerm.cc:88:	tzz123 = [01;31m-[00mCosPhi; 		/* rule 87 */
_oldImproperRestraintTerm.cc:123:	tzz120 = [01;31m-[00mtzz114; 		/* rule 118 */
_oldImproperRestraintTerm.cc:146:	tzz122 = [01;31m-[00mtzz112; 		/* rule 141 */
_oldImproperRestraintTerm.cc:164:	tzz121 = [01;31m-[00mtzz113; 		/* rule 159 */
_oldImproperRestraintTerm.cc:167:	tx104 = [01;31m-[00mtx95; 		/* rule 162 */
_oldImproperRestraintTerm.cc:172:	tx107 = [01;31m-[00mtx98; 		/* rule 167 */
_oldImproperRestraintTerm.cc:175:	tx108 = [01;31m-[00mtx101; 		/* rule 170 */
_oldImproperRestraintTerm.cc:186:	fx1 = [01;31m-[00mdx1; 		/* rule 181 */
_oldImproperRestraintTerm.cc:187:	fy1 = [01;31m-[00mdy1; 		/* rule 182 */
_oldImproperRestraintTerm.cc:188:	fz1 = [01;31m-[00mdz1; 		/* rule 183 */
_oldImproperRestraintTerm.cc:189:	fx2 = [01;31m-[00mdx2; 		/* rule 184 */
_oldImproperRestraintTerm.cc:190:	fy2 = [01;31m-[00mdy2; 		/* rule 185 */
_oldImproperRestraintTerm.cc:191:	fz2 = [01;31m-[00mdz2; 		/* rule 186 */
_oldImproperRestraintTerm.cc:192:	fx3 = [01;31m-[00mdx3; 		/* rule 187 */
_oldImproperRestraintTerm.cc:193:	fy3 = [01;31m-[00mdy3; 		/* rule 188 */
_oldImproperRestraintTerm.cc:194:	fz3 = [01;31m-[00mdz3; 		/* rule 189 */
_oldImproperRestraintTerm.cc:195:	fx4 = [01;31m-[00mdx4; 		/* rule 190 */
_oldImproperRestraintTerm.cc:196:	fy4 = [01;31m-[00mdy4; 		/* rule 191 */
_oldImproperRestraintTerm.cc:197:	fz4 = [01;31m-[00mdz4; 		/* rule 192 */
aggregate.cc:36:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
aggregate.cc:41:    return this[01;31m-[00m>Base::__repr__();
aggregate.cc:61:	archive[01;31m-[00m>parse(fileName);
aggregate.cc:62:	agg = downcast<O_Aggregate>(archive[01;31m-[00m>get("aggregate"));
aggregate.cc:64:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( boost::format("Cannot read aggregate from unknown fileType: %s") % fileName ));
aggregate.cc:75:{_F(this[01;31m-[00m>lisp());
aggregate.cc:76:    this[01;31m-[00m>Base::archiveBase(node);
aggregate.cc:77:    node[01;31m-[00m>archiveContainerIfNotEmpty("Restraints",this[01;31m-[00m>_Restraints);
aggregate.cc:94:    this[01;31m-[00m>Base::initialize();
aggregate.cc:95:    this[01;31m-[00m>_Restraints = RP_Create<O_RestraintList>(this[01;31m-[00m>lisp());
aggregate.cc:113://    rPNew[01;31m-[00m>duplicate(this);	// *rPNew = *this;
aggregate.cc:114:    rPNew[01;31m-[00m>eraseContents();
aggregate.cc:115:    for ( a=this[01;31m-[00m>getContents().begin(); a!=this[01;31m-[00m>getContents().end(); a++ ) {
aggregate.cc:117:	rPNew[01;31m-[00m>addMolecule(mol);
aggregate.cc:129://    rPNew[01;31m-[00m>duplicate(this);	// *rPNew = *this;
aggregate.cc:130:    rPNew[01;31m-[00m>eraseContents();
aggregate.cc:131:    for ( a=this[01;31m-[00m>getContents().begin(); a!=this[01;31m-[00m>getContents().end(); a++ ) {
aggregate.cc:133:	rPNew[01;31m-[00m>addMolecule(mol[01;31m-[00m>copy()[01;31m-[00m>as<O_Molecule>());
aggregate.cc:140:{_F(this[01;31m-[00m>lisp());
aggregate.cc:141:    if ( this[01;31m-[00m>eqV(obj) ) return true;
aggregate.cc:142:    if ( !obj[01;31m-[00m>isOfClass<O_Aggregate>() ) return false;
aggregate.cc:143:    RPAggregate other = obj[01;31m-[00m>as<O_Aggregate>();
aggregate.cc:144:    if ( other[01;31m-[00m>getName() != this[01;31m-[00m>getName() ) return false;
aggregate.cc:145:    if ( other[01;31m-[00m>_contents.size() != this[01;31m-[00m>_contents.size() ) return false;
aggregate.cc:147:    for ( tit=this[01;31m-[00m>_contents.begin(), oit=other[01;31m-[00m>_contents.begin();
aggregate.cc:148:	    tit!=this[01;31m-[00m>_contents.end(); tit++, oit++ )
aggregate.cc:150:	if ( ! (*tit)[01;31m-[00m>equal(*oit) ) return false;
aggregate.cc:157:{_F(this[01;31m-[00m>lisp());
aggregate.cc:158:    if ( !obj[01;31m-[00m>isOfClass<O_Aggregate>() ) 
aggregate.cc:160:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You can only transfer coordinates to a Aggregate from another Aggregate"));
aggregate.cc:162:    RPAggregate other = obj[01;31m-[00m>as<O_Aggregate>();
aggregate.cc:163:    if ( other[01;31m-[00m>_contents.size() != this[01;31m-[00m>_contents.size() )
aggregate.cc:165:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You can only transfer coordinates if the two Aggregates have the same number of contents"));
aggregate.cc:168:    for ( tit=this[01;31m-[00m>_contents.begin(), oit=other[01;31m-[00m>_contents.begin();
aggregate.cc:169:	    tit!=this[01;31m-[00m>_contents.end(); tit++, oit++ )
aggregate.cc:171:	(*tit)[01;31m-[00m>transferCoordinates(*oit);
aggregate.cc:181:    me = this[01;31m-[00m>sharedThis<O_Aggregate>();
aggregate.cc:185:	if ( a[01;31m-[00m>getId() == id ) {
aggregate.cc:213:    la.loopTopGoal(this[01;31m-[00m>sharedThis<O_Aggregate>(),ATOMS);
aggregate.cc:216:	va = a[01;31m-[00m>getPosition();
aggregate.cc:217:	vdwa = a[01;31m-[00m>getVdwRadius();
aggregate.cc:219:	    vb = (*oa)[01;31m-[00m>getPosition();
aggregate.cc:220:	    vdwb = (*oa)[01;31m-[00m>getVdwRadius();
aggregate.cc:221:	    vdiff = vb [01;31m-[00m va;
aggregate.cc:238:    atom = this[01;31m-[00m>atomWithChimeraSpecification(spec);
aggregate.cc:239:    return atom[01;31m-[00m>notNil();
aggregate.cc:246:{_F(this[01;31m-[00m>lisp());
aggregate.cc:253:     parseChimeraAtomSpecification(spec,fileSequenceNumber,chain,atomName,this[01;31m-[00m>lisp());
aggregate.cc:254:    for ( mi=this[01;31m-[00m>getContents().begin(); mi!= this[01;31m-[00m>getContents().end(); mi++ )
aggregate.cc:257:	if ( mol[01;31m-[00m>getName() == chain )
aggregate.cc:259:	    for ( ri = mol[01;31m-[00m>getContents().begin(); ri!=mol[01;31m-[00m>getContents().end(); ri++ )
aggregate.cc:262:		if ( res[01;31m-[00m>getFileSequenceNumber() == fileSequenceNumber )
aggregate.cc:264:		    if ( res[01;31m-[00m>hasAtomWithName(atomName) )
aggregate.cc:266:		        atom = res[01;31m-[00m>atomWithName(atomName);
aggregate.cc:273:    atom = O_Atom::nil(this[01;31m-[00m>lisp());
aggregate.cc:286:    for ( it=this[01;31m-[00m>getContents().begin(); it!= this[01;31m-[00m>getContents().end(); it++ ) {
aggregate.cc:289:	    this[01;31m-[00m>eraseContent(it);
aggregate.cc:293:    TOSS(_lisp[01;31m-[00m>create<O_LispError>( boost::format("Aggregate does not contain molecule: %s") % a[01;31m-[00m>getName() ) );
aggregate.cc:300:{_F(this[01;31m-[00m>lisp());
aggregate.cc:308:	lb.loopTopAggregateGoal( this[01;31m-[00m>sharedThis<O_Aggregate>(), ATOMS );
aggregate.cc:313:	this[01;31m-[00m>eraseContents();	// erase the old molecules
aggregate.cc:317:	RPMolecule molecule = O_Molecule::create(this[01;31m-[00m>lisp());
aggregate.cc:318:	RPResidue res = O_Residue::create(this[01;31m-[00m>lisp());
aggregate.cc:319:	molecule[01;31m-[00m>addMatter(res);
aggregate.cc:321:	RPSpanningLoop spanner = O_SpanningLoop::create(this[01;31m-[00m>lisp(),top);
aggregate.cc:322:	while ( spanner[01;31m-[00m>advance() )
aggregate.cc:324:	    RPAtom a = spanner[01;31m-[00m>getAtom();
aggregate.cc:326:	    res[01;31m-[00m>addAtom(a);
aggregate.cc:328:	this[01;31m-[00m>addMolecule(molecule);
aggregate.cc:337:    RPAtom a = this[01;31m-[00m>firstAtomWithName(name);
aggregate.cc:338:    RPResidue res = a[01;31m-[00m>containedByLock()[01;31m-[00m>as<O_Residue>();
aggregate.cc:339:    RPMolecule mol = res[01;31m-[00m>containedByLock()[01;31m-[00m>as<O_Molecule>();
aggregate.cc:353:    agg = this[01;31m-[00m>sharedThis<O_Aggregate>();
aggregate.cc:359:	if ( a[01;31m-[00m>getName() == name ) {
aggregate.cc:365:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Could not find atom with name: %s")% name ));
aggregate.cc:380:    agg = this[01;31m-[00m>sharedThis<O_Aggregate>();
aggregate.cc:387:	xml = O_XmlSaveArchive::create(this[01;31m-[00m>lisp());
aggregate.cc:388:	xml[01;31m-[00m>put("aggregate",this[01;31m-[00m>sharedThis<O_Aggregate>());
aggregate.cc:389:	xml[01;31m-[00m>saveAs(fileName);
aggregate.cc:391:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Cannot write aggregate to unknown fileType: %s")% fileName ));
aggregate.cc:404:    allRestraints = RP_Create<O_RestraintList>(this[01;31m-[00m>lisp());
aggregate.cc:405:    allRestraints[01;31m-[00m>merge(this[01;31m-[00m>_Restraints);
aggregate.cc:406:    for ( ci=this[01;31m-[00m>begin_molecules(); ci!=this[01;31m-[00m>end_molecules(); ci++ ) {
aggregate.cc:407:	molRestraints = (downcast<O_Molecule>(*ci))[01;31m-[00m>getRestraints();
aggregate.cc:408:	allRestraints[01;31m-[00m>merge(molRestraints);
aggregate.cc:417://    mol = downcast<O_Molecule>(this[01;31m-[00m>contentAt(0));
aggregate.cc:418:    mol = downcast<O_Molecule>(this[01;31m-[00m>contentAt(0));
aggregate.cc:423:{_F(this[01;31m-[00m>lisp());
aggregate.cc:427:    ASSERTP(this[01;31m-[00m>_contents.size()>0,"O_Aggregate::firstMoleculeName contains no molecules");
aggregate.cc:428:    c = this[01;31m-[00m>contentAt(0);
aggregate.cc:433:    return mol[01;31m-[00m>getName();
aggregate.cc:445:    lb.loopTopAggregateGoal( this[01;31m-[00m>sharedThis<O_Aggregate>(), MOLECULES );
aggregate.cc:448:	numberOfAtoms += lb.getMolecule()[01;31m-[00m>numberOfAtoms();
aggregate.cc:463:    numberOfAtoms = this[01;31m-[00m>numberOfAtoms();
aggregate.cc:466:    lb.loopTopAggregateGoal( this[01;31m-[00m>sharedThis<O_Aggregate>(), ATOMS );
aggregate.cc:472:	xd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
aggregate.cc:473:	yd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
aggregate.cc:474:	zd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
aggregate.cc:475:	v = a[01;31m-[00m>getPosition();
aggregate.cc:478:	a[01;31m-[00m>setPosition(v);
aggregate.cc:487:	for ( af=atoms.begin();af!=atoms.end()[01;31m-[00m1;af++ ) {
aggregate.cc:489:		vdiff = (*af)[01;31m-[00m>getPosition()[01;31m-[00m(*an)[01;31m-[00m>getPosition();
aggregate.cc:494:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "O_Aggregate::perturbAtomPositions>> Atoms are too close and being randomized!!!" ));
aggregate.cc:495:		    xd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
aggregate.cc:496:		    yd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
aggregate.cc:497:		    zd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
aggregate.cc:498:		    v = (*af)[01;31m-[00m>getPosition();
aggregate.cc:501:		    (*af)[01;31m-[00m>setPosition(v);
aggregate.cc:502:		    xd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
aggregate.cc:503:		    yd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
aggregate.cc:504:		    zd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
aggregate.cc:505:		    v = (*an)[01;31m-[00m>getPosition();
aggregate.cc:508:		    (*an)[01;31m-[00m>setPosition(v);
aggregate.cc:513:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "O_Aggregate::perturbAtomPositions>> Atoms are close and being nudged out!!!" ));
aggregate.cc:515:		    pos = (*af)[01;31m-[00m>getPosition();
aggregate.cc:517:		    (*af)[01;31m-[00m>setPosition(pos);
aggregate.cc:518:		    pos = (*an)[01;31m-[00m>getPosition();
aggregate.cc:519:		    pos = pos [01;31m-[00m vdiff;
aggregate.cc:520:		    (*an)[01;31m-[00m>setPosition(pos);
aggregate.cc:528:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("MADE MORE THAN %d ADJUSTMENT CYCLES WHEN PERTURBING ATOMS") % MAX_ADJUST_CYCLES);
aggregate.cc:535:{_F(this[01;31m-[00m>lisp());
aggregate.cc:537:    rend = O_RenderMatter::create(this[01;31m-[00m>lisp());
aggregate.cc:538:    rend[01;31m-[00m>setFromMatter(this[01;31m-[00m>sharedThis<O_Aggregate>());
aggregate.cc:549:    class_<O_Aggregate>(this[01;31m-[00m>lisp())
alias.cc:17:    this[01;31m-[00m>Base::initialize();
alias.cc:18:    this[01;31m-[00m>_OligomerChangeCounter = 1234;
alias.cc:19:    this[01;31m-[00m>_SequenceChangeCounter = 1234;
alias.cc:24:    node[01;31m-[00m>attribute("MonomerAlias",this[01;31m-[00m>_MonomerAlias);
alias.cc:25:    node[01;31m-[00m>attribute("AtomAlias",this[01;31m-[00m>_AtomAlias);
alias.cc:29:/*! \subpage script[01;31m-[00mfunctions
alias.cc:30: * alias 'monAlias 'atomAlias  [01;31m-[00m  Define an monomer/atom alias combo
alias.cc:34:    if ( args[01;31m-[00m>length()<2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide 2 args"));
alias.cc:35:    string monAlias = args[01;31m-[00m>listref<O_Text>(0)[01;31m-[00m>get();
alias.cc:36:    string atomAlias = args[01;31m-[00m>listref<O_Text>(1)[01;31m-[00m>get();
alias.cc:51:    this[01;31m-[00m>Base::oldLispInitialize(args,lisp);
alias.cc:52:    if ( args[01;31m-[00m>numberOfPositionalArguments()<2 ) 
alias.cc:53:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide 2 args: monomerAlias atomAlias"));
alias.cc:54:    this[01;31m-[00m>_MonomerAlias = args[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
alias.cc:55:    this[01;31m-[00m>_AtomAlias = args[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
alias.cc:61:    ss << "[Alias " << this[01;31m-[00m>_MonomerAlias << "@" << this[01;31m-[00m>_AtomAlias;
alias.cc:62:    ss << " monomerId("<<this[01;31m-[00m>_MonomerId<<") atomId("<<this[01;31m-[00m>_AtomId<<")";
alias.cc:69:{_F(this[01;31m-[00m>lisp());
alias.cc:70:    this[01;31m-[00m>_OligomerChangeCounter = builder[01;31m-[00m>getOligomerChangeCounter();
alias.cc:71:    this[01;31m-[00m>_MonomerId = builder[01;31m-[00m>getMonomerIdForUniqueAlias(this[01;31m-[00m>sharedThis<O_Alias>());
alias.cc:75:{_F(this[01;31m-[00m>lisp());
alias.cc:76:    if (!o[01;31m-[00m>isOfClass<O_Alias>()) return false;
alias.cc:77:    RPAlias a = o[01;31m-[00m>as<O_Alias>();
alias.cc:78:    if ( this[01;31m-[00m>_MonomerAlias != a[01;31m-[00m>_MonomerAlias ) return false;
alias.cc:79:    if ( this[01;31m-[00m>_AtomAlias != a[01;31m-[00m>_AtomAlias ) return false;
alias.cc:85:{_F(this[01;31m-[00m>lisp());
alias.cc:86:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_OligomerChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
alias.cc:87:    this[01;31m-[00m>_SequenceChangeCounter = builder[01;31m-[00m>getSequenceChangeCounter();
alias.cc:88:    this[01;31m-[00m>_AtomId = builder[01;31m-[00m>indexOfInterestingAtomWithAlias(this[01;31m-[00m>_MonomerId,this[01;31m-[00m>sharedThis<O_Alias>());
alias.cc:89:    LOG(BF("[Alias %s@%s] _MonomerId(%d) _AtomId(%d)") % this[01;31m-[00m>_MonomerAlias.c_str() % this[01;31m-[00m>_AtomAlias.c_str() % this[01;31m-[00m>_MonomerId % this[01;31m-[00m>_AtomId  ); // vp0(( "[Alias %s@%s] _MonomerId(%d) _AtomId(%d)", this[01;31m-[00m>_MonomerAlias.c_str(), this[01;31m-[00m>_AtomAlias.c_str(), this[01;31m-[00m>_MonomerId, this[01;31m-[00m>_AtomId ));
alias.cc:96:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_OligomerChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
alias.cc:97:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
alias.cc:99:    return builder[01;31m-[00m>getScoreTransformedInterestingAtomPosition(this[01;31m-[00m>_AtomId);
alias.cc:106:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_OligomerChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
alias.cc:107:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
alias.cc:109:    return builder[01;31m-[00m>getScoreTransformedAtomPosition(this[01;31m-[00m>_AtomId,scorerState);
alias.cc:121:	class_<O_Alias>(this[01;31m-[00m>lisp())
alias.cc:123:	defNoWrapPackage(MbbPackage,"alias",&O_Alias::prim_alias,this[01;31m-[00m>lisp());	// Constructor
aliasReferencer.cc:21:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
aliasReferencer.cc:27:    this[01;31m-[00m>Base::initialize();
aliasReferencer.cc:41:    this[01;31m-[00m>streamDump(ss);
aliasReferencer.cc:50:	class_<O_AliasReferencer>(this[01;31m-[00m>lisp())
anchor.cc:19:{ _F(this[01;31m-[00m>lisp());
anchor.cc:25:{_F(this[01;31m-[00m>lisp());
anchor.cc:26:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
anchor.cc:27:    this[01;31m-[00m>_WeakOriginFrame = args[01;31m-[00m>getAndRemove("originFrame")[01;31m-[00m>as<O_Frame>();
anchor.cc:33:{ _F(this[01;31m-[00m>lisp());
anchor.cc:34:    this[01;31m-[00m>Base::archiveBase(node);
anchor.cc:35:    node[01;31m-[00m>archiveWeakPointer("originFrame",this[01;31m-[00m>_WeakOriginFrame);
anchor.cc:41:    ss << this[01;31m-[00m>className() << "[ ";
anchor.cc:43:    if ( this[01;31m-[00m>_WeakOriginFrame.use_count() == 0 )
anchor.cc:47:    if ( this[01;31m-[00m>_WeakOriginFrame.lock()[01;31m-[00m>isNil() )
anchor.cc:52:	ss << this[01;31m-[00m>_WeakOriginFrame.lock()[01;31m-[00m>description();
anchor.cc:59:{_F(this[01;31m-[00m>lisp());
anchor.cc:60:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakOriginFrame);
anchor.cc:61:    ASSERT(this[01;31m-[00m>_WeakOriginFrame.lock()[01;31m-[00m>notNil());
anchor.cc:62:    return this[01;31m-[00m>_WeakOriginFrame.lock();
anchor.cc:66:{_F(this[01;31m-[00m>lisp());
anchor.cc:67:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakOriginFrame);
anchor.cc:68:    ASSERT(this[01;31m-[00m>_WeakOriginFrame.lock()[01;31m-[00m>notNil());
anchor.cc:69:    return this[01;31m-[00m>_WeakOriginFrame.lock()[01;31m-[00m>getCoordinateSystem(monomer);
anchor.cc:76:{_F(this[01;31m-[00m>lisp());
anchor.cc:77:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakOriginFrame);
anchor.cc:78:    ASSERT(this[01;31m-[00m>_WeakOriginFrame.lock()[01;31m-[00m>notNil());
anchor.cc:79:    return this[01;31m-[00m>_WeakOriginFrame.lock()[01;31m-[00m>getBoundFrame(monomer);
anchor.cc:88:{ _F(this[01;31m-[00m>lisp());
anchor.cc:89:    this[01;31m-[00m>Base::archiveBase(node);
anchor.cc:90:    node[01;31m-[00m>attribute("plug",this[01;31m-[00m>_PlugName);
anchor.cc:100:{_F(this[01;31m-[00m>lisp());
anchor.cc:101:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
anchor.cc:102:    this[01;31m-[00m>_PlugName = args[01;31m-[00m>getStringAndRemove("plugName");
anchor.cc:105:{ _F(this[01;31m-[00m>lisp());
anchor.cc:106:    this[01;31m-[00m>archiveBase(node);
anchor.cc:118:    if ( !myMonomer[01;31m-[00m>hasCouplingWithPlugName(this[01;31m-[00m>_PlugName) )
anchor.cc:121:	ss << "O_AnchorOnOtherSideOfPlug::getOthersExportedFrameName>> in monomer("<<myMonomer[01;31m-[00m>description()<<") ";
anchor.cc:122:	ss << "could not find coupling with plugName("<<this[01;31m-[00m>_PlugName<<")";
anchor.cc:123:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("%s%s") % ss.str() % this[01;31m-[00m>sharedThis<O_AnchorOnOtherSideOfPlug>()[01;31m-[00m>description() ));
anchor.cc:126:    coupling = myMonomer[01;31m-[00m>getCouplingWithPlugName(this[01;31m-[00m>_PlugName);
anchor.cc:128:    neighbor = coupling[01;31m-[00m>getOtherSideMonomer(myMonomer);
anchor.cc:130:    neighborConstitution = neighbor[01;31m-[00m>getConstitution();
anchor.cc:132:    neighborPlugName = O_DirectionalCoupling::otherPlugName(this[01;31m-[00m>_PlugName,_lisp);
anchor.cc:133:    if ( !neighborConstitution[01;31m-[00m>hasPlugNamed(neighborPlugName) )
anchor.cc:136:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("Could not find neighbor plug with name(%s) %s") 
anchor.cc:137:			% neighborPlugName % this[01;31m-[00m>sharedThis<O_AnchorOnOtherSideOfPlug>()[01;31m-[00m>description() ));
anchor.cc:139:    neighborPlug = neighborConstitution[01;31m-[00m>getPlugNamed(neighborPlugName)[01;31m-[00m>as<O_OutPlug>();
anchor.cc:141:        if ( !neighborPlug[01;31m-[00m>hasExportFrame() )
anchor.cc:144:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("There was no export frame for plug with name(%s) %s")
anchor.cc:145:			% neighborPlugName % this[01;31m-[00m>sharedThis<O_AnchorOnOtherSideOfPlug>()[01;31m-[00m>description() ));
anchor.cc:148:    exportFrame = neighborPlug[01;31m-[00m>getExportFrame();
anchor.cc:149:    return exportFrame[01;31m-[00m>getName();
anchor.cc:154:{_F(this[01;31m-[00m>lisp());
anchor.cc:161:    if ( !myMonomer[01;31m-[00m>hasCouplingWithPlugName(this[01;31m-[00m>_PlugName) )
anchor.cc:163:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Could not find coupling "
anchor.cc:164:			"with name("+this[01;31m-[00m>_PlugName+")",
anchor.cc:165:			this[01;31m-[00m>sharedThis<O_AnchorOnOtherSideOfPlug>()[01;31m-[00m>description() ));
anchor.cc:168:    coupling = myMonomer[01;31m-[00m>getCouplingWithPlugName(this[01;31m-[00m>_PlugName);
anchor.cc:170:    neighbor = coupling[01;31m-[00m>getOtherSideMonomer(myMonomer);
anchor.cc:172:    constitution = neighbor[01;31m-[00m>getConstitution();
anchor.cc:174:    if ( !constitution[01;31m-[00m>hasFrameWithName(this[01;31m-[00m>getOthersExportedFrameName(myMonomer)) )
anchor.cc:177:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Could not find frame with name("+this[01;31m-[00m>getOthersExportedFrameName(myMonomer)+")",
anchor.cc:178:			this[01;31m-[00m>sharedThis<O_AnchorOnOtherSideOfPlug>()[01;31m-[00m>description() ));
anchor.cc:181:    frame = constitution[01;31m-[00m>getFrameWithName(this[01;31m-[00m>getOthersExportedFrameName(myMonomer));
anchor.cc:184:    boundFrame = frame[01;31m-[00m>getBoundFrame(neighbor);
anchor.cc:189:{_F(this[01;31m-[00m>lisp());
anchor.cc:193:    boundFrame = downcast<O_AtomBoundFrame>(this[01;31m-[00m>getBoundFrame(mon));
anchor.cc:194:    ss << "AnchorOnOtherSideOfPlug: origin(" << boundFrame[01;31m-[00m>get_oAtom()[01;31m-[00m>getName() << ")" << endl;
anchor.cc:195:    ss << "    origin description: " << boundFrame[01;31m-[00m>get_oAtom()[01;31m-[00m>description() << endl;
anchor.cc:196:    ss << "    origin position: " << boundFrame[01;31m-[00m>get_oAtom()[01;31m-[00m>getPosition().asString() << endl;
anchor.cc:197:    cs = boundFrame[01;31m-[00m>getCoordinateSystem();
anchor.cc:198:    ss << "    bound frame: " << endl << cs[01;31m-[00m>asString() << endl;
anchor.cc:204:{_F(this[01;31m-[00m>lisp());
anchor.cc:206:    boundFrame = this[01;31m-[00m>getBoundFrame(mon);
anchor.cc:207:    return boundFrame[01;31m-[00m>getCoordinateSystem();
anchor.cc:212:{_F(this[01;31m-[00m>lisp());
anchor.cc:214:    return neighborScaffold[01;31m-[00m>hasIncompleteFrameTransformWithName(this[01;31m-[00m>getOthersExportedFrameName(myMonomer));
anchor.cc:226:    class_<O_Anchor>(this[01;31m-[00m>lisp())
anchor.cc:251:    class_<O_AnchorOrigin>(this[01;31m-[00m>lisp())
anchor.cc:278:    class_<O_AnchorOnOtherSideOfPlug>(this[01;31m-[00m>lisp())
archive.cc:20:string	WeakPointerNull = "WP_ERROR[01;31m-[00mNULL";
archive.cc:21:string	WeakPointerBroken = "WP_ERROR[01;31m-[00mBROKEN[01;31m-[00mLINK";
archive.cc:22:string	RedirectedWeakPointerBroken = "WP_ERROR[01;31m-[00mBROKEN[01;31m-[00mREDIRECTED_LINK";
archive.cc:27:    this[01;31m-[00m>handleSetExplicit("",EmptyStringHandle);
archive.cc:28:    this[01;31m-[00m>handleSetExplicit(UniqueIdTag,UniqueIdHandle);
archive.cc:33:    lisp[01;31m-[00m>print(BF("Describe symbol manager memory usage here"));
archive.cc:62:    it = this[01;31m-[00m>_SymbolsToHandles.find(symbol);
archive.cc:63:    if ( it == this[01;31m-[00m>_SymbolsToHandles.end() )
archive.cc:65:	handle = this[01;31m-[00m>_Symbols.size();
archive.cc:69:	    serr << "Exceeded MaxHandle(" << MaxHandle << ") symbols, define handleType as a larger type [01;31m-[00m " << sizeof(handleType) << " bytes isn't enough";
archive.cc:73:	this[01;31m-[00m>_Symbols.push_back(symbol);
archive.cc:74:	this[01;31m-[00m>_SymbolsToHandles[symbol] = handle;
archive.cc:77:	handle = it[01;31m-[00m>second;
archive.cc:84:    handleType hIs = this[01;31m-[00m>handle(name);
archive.cc:122:	serr << "numericSymbolCalled for a non numeric symbol(" << this[01;31m-[00m>textSymbol(handle) << ") handle=" << handle;
archive.cc:135:    HARD_ASSERT(handle<this[01;31m-[00m>_Symbols.size());
archive.cc:136:    return this[01;31m-[00m>_Symbols[handle];
archive.cc:147:    HARD_ASSERT(handle<this[01;31m-[00m>_Symbols.size());
archive.cc:148:    return this[01;31m-[00m>_Symbols[handle];
archive.cc:155:    class_<O_Archive>(env[01;31m-[00m>lisp())
archive.cc:186:    this[01;31m-[00m>_ArchiveMemoryManager.reset();
archive.cc:187:    this[01;31m-[00m>_MultiStringBuffer.reset();
archive.cc:188:    if ( this[01;31m-[00m>_HasError ) {
archive.cc:190:			this[01;31m-[00m>_FileName.c_str() );
archive.cc:191:	printf( "%s\n", this[01;31m-[00m>_ErrorStream.str().c_str() );
archive.cc:198:    this[01;31m-[00m>Base::initialize();
archive.cc:199:    this[01;31m-[00m>_NextUniqueId = 1;
archive.cc:200:    this[01;31m-[00m>_DebugEnabled = false;
archive.cc:201:    this[01;31m-[00m>_HasError = false;
archive.cc:202:    this[01;31m-[00m>_Verbosity = 0;
archive.cc:203:    this[01;31m-[00m>_ErrorStream.str("");
archive.cc:204:    this[01;31m-[00m>_ArchiveMemoryManager = O_ArchiveMemoryManager::create(this[01;31m-[00m>sharedThis<O_Archive>(),this[01;31m-[00m>lisp());
archive.cc:205:    this[01;31m-[00m>_TopNode = NULL;
archive.cc:206:    this[01;31m-[00m>_MultiStringBuffer = O_MultiStringBuffer::create(this[01;31m-[00m>lisp());
archive.cc:211:{_F(this[01;31m-[00m>lisp());
archive.cc:213:    total += this[01;31m-[00m>getTopNode()[01;31m-[00m>describeMemoryUsage();
archive.cc:214:    total += this[01;31m-[00m>_MultiStringBuffer[01;31m-[00m>describeMemoryUsage();
archive.cc:215:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("   Total memory usage of archive = %ld bytes") %  total );
archive.cc:221:{_F(this[01;31m-[00m>lisp());
archive.cc:222:    if ( this[01;31m-[00m>_TopNode == NULL )
archive.cc:224:	this[01;31m-[00m>_TopNode = this[01;31m-[00m>newArchiveNode();
archive.cc:225:	this[01;31m-[00m>_TopNode[01;31m-[00m>setRawNodeName("Archive");
archive.cc:226:	this[01;31m-[00m>_TopNode[01;31m-[00m>addAttribute("version",CURRENT_VERSION);
archive.cc:227:	this[01;31m-[00m>_TopNode[01;31m-[00m>setTextUniqueId("_root_");
archive.cc:229:    return this[01;31m-[00m>_TopNode;
archive.cc:235:    class_<O_LoadArchive>(env[01;31m-[00m>lisp())
archive.cc:261:    this[01;31m-[00m>Base::initialize();
archive.cc:262:    this[01;31m-[00m>_NodesToFinalize.clear();
archive.cc:267:{_F(this[01;31m-[00m>lisp());
archive.cc:268:    this[01;31m-[00m>_NodesToFinalize.push_back(node);
archive.cc:273:{_F(this[01;31m-[00m>lisp());
archive.cc:278:    if ( this[01;31m-[00m>_Verbosity > 0 )
archive.cc:280:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF(" Finalizing archive objects" ));
archive.cc:282:    LOG(BF("There are %d objects to finalize") % this[01;31m-[00m>_NodesToFinalize.size()  ); // vp0(( "There are %d objects to finalize",this[01;31m-[00m>_NodesToFinalize.size() ));
archive.cc:285:    for ( it=this[01;31m-[00m>_NodesToFinalize.begin();
archive.cc:286:	    it!=this[01;31m-[00m>_NodesToFinalize.end(); it++ )
archive.cc:288:        (*it)[01;31m-[00m>setFinalized(false);
archive.cc:292:	for ( it=this[01;31m-[00m>_NodesToFinalize.begin();
archive.cc:293:		    it!=this[01;31m-[00m>_NodesToFinalize.end(); it++ ) {
archive.cc:294:	    if ( (*it)[01;31m-[00m>isFinalized() ) continue;
archive.cc:295:	    obj = (*it)[01;31m-[00m>getObject();
archive.cc:296:	    if ( obj[01;31m-[00m>notNil() )
archive.cc:298:	        oneDone = (obj[01;31m-[00m>loadFinalize(*it));
archive.cc:299:		if ( oneDone ) (*it)[01;31m-[00m>setFinalized(true);
archive.cc:311:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Tried to finalize the loaded object 100 times, there must be a circular reference"));
archive.cc:319:    class_<O_SaveArchive>(env[01;31m-[00m>lisp())
archive.cc:345:    this[01;31m-[00m>Base::initialize();
archive.cc:350:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
archive.cc:361:{_F(this[01;31m-[00m>lisp());
archive.cc:363:    LOG(BF("Saving weak pointer node(%s) attribute(%s)") % node[01;31m-[00m>getNodeName().c_str() % attr.c_str()  ); // vp0(("Saving weak pointer node(%s) attribute(%s)",node[01;31m-[00m>getNodeName().c_str(),attr.c_str() ));
archive.cc:370:	entry._Object = O_Object::nil(this[01;31m-[00m>lisp());
archive.cc:372://	ss << "NULL Attribute(" << attr << ")  of node: " << node[01;31m-[00m>description();
archive.cc:373://	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
archive.cc:374:    } else if ( obj.lock()[01;31m-[00m>isNil() )
archive.cc:377:	entry._Object = O_Object::nil(this[01;31m-[00m>lisp());
archive.cc:382:    this[01;31m-[00m>_WeakObjectReferences.push_back(entry);
archive.cc:387:{_F(this[01;31m-[00m>lisp());
archive.cc:391:    ASSERT(obj[01;31m-[00m>notNil());
archive.cc:393:    if ( this[01;31m-[00m>_ObjectNodes.count(obj.get()) == 0 ) 
archive.cc:395:	child = this[01;31m-[00m>newArchiveNode();
archive.cc:396:	child[01;31m-[00m>setClassNodeName(this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(classId));
archive.cc:397:	child[01;31m-[00m>setObject(obj);
archive.cc:398://	child[01;31m-[00m>setUniqueId("only");
archive.cc:399:	node[01;31m-[00m>addChild(child);
archive.cc:401:	obj[01;31m-[00m>archive(child);
archive.cc:402:	this[01;31m-[00m>_ObjectNodes[obj.get()] = child;
archive.cc:405:        TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>("There is already a node with ClassName: "+
archive.cc:406:		this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(classId)[01;31m-[00m>getPackagedName(),
archive.cc:415:{_TF(this[01;31m-[00m>lisp(),BF("_saveObjectWithinNodeWithUidAndPossiblyKey>> huid(#%d) key(%s) useKey=%d") % huid % key % useKey );
archive.cc:421:    if ( obj[01;31m-[00m>isNil() )
archive.cc:423:	LOG(BF("obj[01;31m-[00m>isNil()==true") ); // vp0(("obj[01;31m-[00m>isNil()==true"));
archive.cc:424:	child = this[01;31m-[00m>newArchiveNode();
archive.cc:425:	child[01;31m-[00m>setClassNodeName(obj[01;31m-[00m>_class());
archive.cc:426:	child[01;31m-[00m>setUniqueIdHandle(huid);
archive.cc:427:	node[01;31m-[00m>addChild(child);
archive.cc:428:	child[01;31m-[00m>addAttribute(ObjectPathTag,NilPath);
archive.cc:429:    } else if ( this[01;31m-[00m>_ObjectNodes.count(obj.get()) == 0 ) {
archive.cc:430:	child = this[01;31m-[00m>newArchiveNode();
archive.cc:431:	child[01;31m-[00m>setClassNodeName(obj[01;31m-[00m>_class());
archive.cc:432:	child[01;31m-[00m>setUniqueIdHandle(huid);
archive.cc:433:	if ( useKey ) child[01;31m-[00m>addAttribute("_key",key);
archive.cc:434:	child[01;31m-[00m>setObject(obj);
archive.cc:435:	node[01;31m-[00m>addChild(child);
archive.cc:436:	obj[01;31m-[00m>archive(child);
archive.cc:437:	this[01;31m-[00m>_ObjectNodes[obj.get()] = child;
archive.cc:442:	RPNode existingObjectNode = this[01;31m-[00m>_ObjectNodes[obj.get()];
archive.cc:443:	child = this[01;31m-[00m>newArchiveNode();
archive.cc:444:	child[01;31m-[00m>setClassNodeName(obj[01;31m-[00m>_class());
archive.cc:445:	child[01;31m-[00m>setUniqueIdHandle(huid);
archive.cc:448:	    child[01;31m-[00m>addAttribute("_key",key);
archive.cc:450:	node[01;31m-[00m>addChild(child);
archive.cc:452:	string pth = existingObjectNode[01;31m-[00m>pathRelativeTo(child);
archive.cc:453:	child[01;31m-[00m>addAttribute(ObjectPathTag,pth);
archive.cc:458:{_TF(this[01;31m-[00m>lisp(),BF("saveObjectWithinNodeWithUid>> huid(#%d)") % huid );
archive.cc:459:    this[01;31m-[00m>_saveObjectWithinNodeWithUidAndPossiblyKey(node,huid,"",false,obj);
archive.cc:463:{_TF(this[01;31m-[00m>lisp(),BF("saveObjectWithinNodeWithUid>> uid(%s)") % uid );
archive.cc:464:    handleType huid = this[01;31m-[00m>symbolManager().handle(uid);
archive.cc:465:    this[01;31m-[00m>_saveObjectWithinNodeWithUidAndPossiblyKey(node,huid,"",false,obj);
archive.cc:469:{_TF(this[01;31m-[00m>lisp(),BF("saveObjectWithinNodeWithUidAndKey>> uid(#%d) key(%s)") % huid % key);
archive.cc:470:    this[01;31m-[00m>_saveObjectWithinNodeWithUidAndPossiblyKey(node,huid,key,true,obj);
archive.cc:474:{_TF(this[01;31m-[00m>lisp(),BF("saveObjectWithinNodeWithUidAndKey>> uid(%s) key(%s)") % uid % key );
archive.cc:475:    handleType huid = this[01;31m-[00m>symbolManager().handle(uid);
archive.cc:476:    this[01;31m-[00m>_saveObjectWithinNodeWithUidAndPossiblyKey(node,huid,key,true,obj);
archive.cc:484:{ _TF(this[01;31m-[00m>lisp(),BF("O_SaveArchive::put adding object with uid(%s)") % uid );
archive.cc:485:    handleType huid = this[01;31m-[00m>symbolManager().handle(uid);
archive.cc:486:    this[01;31m-[00m>_saveObjectWithinNodeWithUidAndPossiblyKey(this[01;31m-[00m>getTopNode(),huid,"",false,obj);
archive.cc:490:{ _F(this[01;31m-[00m>lisp());
archive.cc:492:    handleType huid = this[01;31m-[00m>symbolManager().handle(uid);
archive.cc:493:    this[01;31m-[00m>_saveObjectWithinNodeWithUidAndPossiblyKey(this[01;31m-[00m>getTopNode(),huid,"",false,obj);
archive.cc:502:{ _F(this[01;31m-[00m>lisp());
archive.cc:505:    if ( this[01;31m-[00m>_Verbosity > 0 )
archive.cc:507:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF(" Creating archive contents" ));
archive.cc:509:    LOG(BF( "Topnode uid(%s) node name(%s)")% this[01;31m-[00m>getTopNode()[01;31m-[00m>getUniqueIdCharacters() % this[01;31m-[00m>getTopNode()[01;31m-[00m>getNodeName().c_str() );
archive.cc:510:    for ( ni=this[01;31m-[00m>getTopNode()[01;31m-[00m>begin_Children();
archive.cc:511:    		ni!=this[01;31m-[00m>getTopNode()[01;31m-[00m>end_Children(); ni++ ) {
archive.cc:513:			(*ni)[01;31m-[00m>getUniqueIdCharacters() % (*ni)[01;31m-[00m>getNodeName().c_str());
archive.cc:514:	obj = this[01;31m-[00m>loadObjectDirectly(*ni);
archive.cc:516:    this[01;31m-[00m>finalizeObjects();
archive.cc:517:    if ( this[01;31m-[00m>contains("m:*DATABASE*") )
archive.cc:521:	RPObject obj = this[01;31m-[00m>get("m:*DATABASE*");
archive.cc:522:	if ( obj[01;31m-[00m>isAssignableTo<O_BuilderDatabase>() )
archive.cc:524:	    RPLisp lisp = this[01;31m-[00m>lisp();
archive.cc:526:	    ASSERTP(lisp[01;31m-[00m>notNil(),"Default Environment is nil and it should never be nil");
archive.cc:527:	    lisp[01;31m-[00m>setBuilderDatabase(obj[01;31m-[00m>as<O_BuilderDatabase>());
archive.cc:528:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Loaded archive with m:*DATABASE*[01;31m-[00m> replaced system BuilderDatabase"));
archive.cc:543:    for ( ni=this[01;31m-[00m>getTopNode()[01;31m-[00m>begin_Children();
archive.cc:544:    		ni!=this[01;31m-[00m>getTopNode()[01;31m-[00m>end_Children(); ni++ ) 
archive.cc:546:	obj = this[01;31m-[00m>loadObjectDirectly(*ni);
archive.cc:547:	if ( (*ni)[01;31m-[00m>getUniqueIdCharacters() != "m:*DATABASE*" )
archive.cc:555:{_F(this[01;31m-[00m>lisp());
archive.cc:559:    ov = this[01;31m-[00m>getContents();
archive.cc:560:    render = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
archive.cc:563:        if ( (*it)[01;31m-[00m>canRender() )
archive.cc:565:	    render[01;31m-[00m>append((*it)[01;31m-[00m>rendered(options));
archive.cc:575:{_F(this[01;31m-[00m>lisp());
archive.cc:579:    this[01;31m-[00m>_BrokenWeakPointers = 0;
archive.cc:580:    for ( wpi=this[01;31m-[00m>_WeakObjectReferences.begin();
archive.cc:581:    		wpi!=this[01;31m-[00m>_WeakObjectReferences.end(); wpi++ )
archive.cc:583:        ASSERT_NOT_NULL(wpi[01;31m-[00m>_Object);
archive.cc:584:	if ( wpi[01;31m-[00m>_Object[01;31m-[00m>isNil() )
archive.cc:586:	    LOG(BF("WEAK_FAIL: NULL link for weak pointer for attribute: %s") % wpi[01;31m-[00m>_Attribute.c_str()  ); // vp0(("WEAK_FAIL: NULL link for weak pointer for attribute: %s",wpi[01;31m-[00m>_Attribute.c_str() ));
archive.cc:587:	    if ( !wpi[01;31m-[00m>_SuppressAttributeForNilWeakPointers )
archive.cc:589:		wpi[01;31m-[00m>_Node[01;31m-[00m>addAttribute(wpi[01;31m-[00m>_Attribute,WeakPointerNull);
archive.cc:591:	    if ( wpi[01;31m-[00m>_SuppressNodeForBrokenOrNilWeakPointers )
archive.cc:593:	        wpi[01;31m-[00m>_Node[01;31m-[00m>setSuppressNode(true);
archive.cc:601:	    if ( this[01;31m-[00m>_ObjectNodes.count(wpi[01;31m-[00m>_Object.get()) > 0 )
archive.cc:603:		LOG(BF("WEAK_SUCCESS: Linking weak pointer for attribute: %s") % wpi[01;31m-[00m>_Attribute.c_str()  ); // vp0(("WEAK_SUCCESS: Linking weak pointer for attribute: %s",wpi[01;31m-[00m>_Attribute.c_str() ));
archive.cc:604:		destinationNode = this[01;31m-[00m>_ObjectNodes[wpi[01;31m-[00m>_Object.get()];
archive.cc:605:		wpi[01;31m-[00m>_Node[01;31m-[00m>addAttribute(wpi[01;31m-[00m>_Attribute,
archive.cc:606:			destinationNode[01;31m-[00m>pathRelativeTo(wpi[01;31m-[00m>_Node));
archive.cc:619:		LOG(BF("WEAK_FAIL: NULL link for weak pointer for attribute: %s") % wpi[01;31m-[00m>_Attribute.c_str()  ); // vp0(("WEAK_FAIL: NULL link for weak pointer for attribute: %s",wpi[01;31m-[00m>_Attribute.c_str() ));
archive.cc:620:		if ( wpi[01;31m-[00m>_SuppressNodeForBrokenOrNilWeakPointers )
archive.cc:622:	            wpi[01;31m-[00m>_Node[01;31m-[00m>setSuppressNode(true);
archive.cc:623:		    this[01;31m-[00m>_BrokenWeakPointers++;
archive.cc:626:		    wpi[01;31m-[00m>_Node[01;31m-[00m>addAttribute(wpi[01;31m-[00m>_Attribute,WeakPointerBroken);
archive.cc:639: * 	[01;31m-[00m Loading a weak pointer
archive.cc:640: * 		[01;31m-[00m# Read the weak pointer tag from the Node
archive.cc:641: * 		[01;31m-[00m# If the pointer tag == NULL then return an empty pointer.
archive.cc:642: * 		[01;31m-[00m# Identify the Node that corresponds to the weak pointer tag
archive.cc:643: * 		[01;31m-[00m# If the node says the object has already been created
archive.cc:645: * 		[01;31m-[00m# Otherwise create the object from the node.
archive.cc:646: * 		[01;31m-[00m# Return the address of the object (tag now swizzled).
archive.cc:650:{_TF(this[01;31m-[00m>lisp(),BF("Looking up link attribute(%s)") attr );
archive.cc:653:    attrValue = node[01;31m-[00m>getAttributeStringDefault( attr, "" );
archive.cc:655:    LOG(BF("In node at line number: %d") % node[01;31m-[00m>getLineNumber()  ); // vp0(("In node at line number: %d",node[01;31m-[00m>getLineNumber() ));
archive.cc:659:	obj = O_Object::nil(this[01;31m-[00m>lisp());
archive.cc:665:	    TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>("Attribute("+attr+") is missing", node ));
archive.cc:667:	obj = O_Object::nil(this[01;31m-[00m>lisp());
archive.cc:670:    linkedNode = node[01;31m-[00m>followLinkPath(attrValue,node);
archive.cc:675:		<<this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(expectedClassId)[01;31m-[00m>getPackagedName()<< endl;
archive.cc:677:	TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(serr.str(),node));
archive.cc:680:    if ( linkedNode[01;31m-[00m>objectHasBeenCreated() ) {
archive.cc:682:	if ( !linkedNode[01;31m-[00m>getObject()[01;31m-[00m>isAssignableToByClassId(expectedClassId) )
archive.cc:684:	    LOG(BF("Problem loading weak pointer [01;31m-[00m expectedClassId(%d) [01;31m-[00m linkedNode[01;31m-[00m>getObject()[01;31m-[00m>classId()(%d)") % expectedClassId % linkedNode[01;31m-[00m>getObject()[01;31m-[00m>classId() );
archive.cc:687:		<<this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(expectedClassId)[01;31m-[00m>getPackagedName()<< endl;
archive.cc:689:		    <<linkedNode[01;31m-[00m>getObject()[01;31m-[00m>className() << endl;
archive.cc:691:	    		<< linkedNode[01;31m-[00m>getLineNumber()<<endl;
archive.cc:692:	    TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(serr.str(),node));
archive.cc:695:	obj = linkedNode[01;31m-[00m>getObject();
archive.cc:702:    if ( !this[01;31m-[00m>lisp()[01;31m-[00m>isClassName(linkedNode[01;31m-[00m>getNodeName()) ) {
archive.cc:704:	serr << "Weak pointer for attr("<<attr<<") must point to a "<<this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(expectedClassId)[01;31m-[00m>getPackagedName() << endl;
archive.cc:705:	serr << "Instead it points to non[01;31m-[00mobject node: "
archive.cc:706:				<<linkedNode[01;31m-[00m>description() << endl;
archive.cc:707:        TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(serr.str(),node));
archive.cc:710:	LOG(BF("Ok, the weak pointer points to an object node: %s") % linkedNode[01;31m-[00m>getNodeName().c_str()  ); // vp0(( "Ok, the weak pointer points to an object node: %s", linkedNode[01;31m-[00m>getNodeName().c_str() ));
archive.cc:712:    if ( !this[01;31m-[00m>lisp()[01;31m-[00m>subClassOrder(expectedClassId,this[01;31m-[00m>lisp()[01;31m-[00m>getClassIdForClassName(linkedNode[01;31m-[00m>getNodeName())) ) {
archive.cc:715:		<<this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(expectedClassId)[01;31m-[00m>getPackagedName()<< endl;
archive.cc:717:		<<linkedNode[01;31m-[00m>description() << endl;
archive.cc:718:        TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(serr.str(),node));
archive.cc:723:    linkedNode[01;31m-[00m>createYourObject();
archive.cc:724:    obj = linkedNode[01;31m-[00m>getObject();
archive.cc:731:{ _TF(this[01;31m-[00m>lisp(),BF("loadObjectDirectly>>Loading: %s") % node[01;31m-[00m>description() );
archive.cc:735:    LOG(BF("Looking at: %s") % node[01;31m-[00m>description().c_str()  ); // vp0(( "Looking at: %s", node[01;31m-[00m>description().c_str() ));
archive.cc:736:    tagValue = node[01;31m-[00m>getAttributeStringDefault(ObjectPathTag,"");
archive.cc:739:	return O_Object::nil(this[01;31m-[00m>lisp());
archive.cc:744:        linkedNode = node[01;31m-[00m>followLinkPath(tagValue,node);
archive.cc:750:    LOG(BF("Node describing object: %s") % linkedNode[01;31m-[00m>description().c_str()  ); // vp0(( "Node describing object: %s", linkedNode[01;31m-[00m>description().c_str() ));
archive.cc:751:    if ( linkedNode[01;31m-[00m>objectHasBeenCreated() ) {
archive.cc:753:	obj = linkedNode[01;31m-[00m>getObject();
archive.cc:754:	LOG(BF("Got it, object=%s  .use_count=%d") % obj[01;31m-[00m>description().c_str() % obj.use_count()  ); // vp0(( "Got it, object=%s  .use_count=%d", obj[01;31m-[00m>description().c_str(), obj.use_count() ));
archive.cc:758:	LOG(BF("Object has not been created yet, calling linkedNode[01;31m-[00m>createYourObject") ); // vp0(( "Object has not been created yet, calling linkedNode[01;31m-[00m>createYourObject"));
archive.cc:759:	linkedNode[01;31m-[00m>createYourObject();
archive.cc:760:	obj = linkedNode[01;31m-[00m>getObject();
archive.cc:769: * 	[01;31m-[00m Loading
archive.cc:770: * 		[01;31m-[00m# Find the child with the desired nodeName
archive.cc:771: * 		[01;31m-[00m# Extract the shared pointer tag from the Node
archive.cc:772: * 		[01;31m-[00m# Identify the Node that corresponds to the pointer tag
archive.cc:773: * 		[01;31m-[00m# If the node says the object has already been created
archive.cc:775: * 		[01;31m-[00m# Otherwise create the object from the node.
archive.cc:776: * 		[01;31m-[00m# Return the address of the object (tag now swizzled).
archive.cc:779:{_F(this[01;31m-[00m>lisp());
archive.cc:781:    LOG(BF("Looking at node: %s") % node[01;31m-[00m>description().c_str() ); // vp0(( "Looking at node: %s", node[01;31m-[00m>description().c_str()));
archive.cc:782:    handleType huid = this[01;31m-[00m>symbolManager().handle(uid);
archive.cc:783:    childNode = node[01;31m-[00m>childWithUniqueId(huid);
archive.cc:784:    childNode[01;31m-[00m>setRecognized(true);
archive.cc:785:    obj = this[01;31m-[00m>loadObjectDirectly( childNode );
archive.cc:790:{_F(this[01;31m-[00m>lisp());
archive.cc:792:    LOG(BF("Looking at node: %s") % node[01;31m-[00m>description().c_str() ); // vp0(( "Looking at node: %s", node[01;31m-[00m>description().c_str()));
archive.cc:793:    childNode = node[01;31m-[00m>childWithUniqueNodeName(this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(classId)[01;31m-[00m>getPackagedName());
archive.cc:794:    childNode[01;31m-[00m>setRecognized(true);
archive.cc:795:    obj = this[01;31m-[00m>loadObjectDirectly( childNode );
archive.cc:799:{_F(this[01;31m-[00m>lisp());
archive.cc:800:    return this[01;31m-[00m>getTopNode()[01;31m-[00m>hasChildWithUniqueId(uid);
archive.cc:806:{ _TF(this[01;31m-[00m>lisp(),BF("O_LoadArchive::get object with uid(%s)")%uid );
archive.cc:808:    this[01;31m-[00m>loadObjectWithinNodeWithUid(this[01;31m-[00m>getTopNode(),uid,obj);
archive.cc:814:    this[01;31m-[00m>_HasError = true;
archive.cc:815:    this[01;31m-[00m>_ErrorStream << "ERROR:  "<< errorMessage <<endl;
archive.cc:816:    this[01;31m-[00m>_ErrorStream << " file(" << this[01;31m-[00m>getFileName() << ")";
archive.cc:817:    this[01;31m-[00m>_ErrorStream << " line(" << node[01;31m-[00m>getLineNumber() << ")" ;
archive.cc:818:    this[01;31m-[00m>_ErrorStream << " nodeName(" << node[01;31m-[00m>getNodeName() << ")\n";
archiveMemoryManager.cc:18:    m[01;31m-[00m>setArchive(a);
archiveMemoryManager.cc:34:    uint numNodes = this[01;31m-[00m>_ArchiveNodes[01;31m-[00m>numberOfEntries();
archiveMemoryManager.cc:37:	RPNode node = this[01;31m-[00m>_ArchiveNodes[01;31m-[00m>getEntry<Dumb_Node>(i);
archiveMemoryManager.cc:38:	node[01;31m-[00m>~Dumb_Node();
archiveMemoryManager.cc:41:    uint numHolders = this[01;31m-[00m>_ChildHolders[01;31m-[00m>numberOfEntries();
archiveMemoryManager.cc:45:	ChildHolder* holder = this[01;31m-[00m>_ChildHolders[01;31m-[00m>getEntry<ChildHolder>(i);
archiveMemoryManager.cc:47:	holder[01;31m-[00m>~ChildHolder();
archiveMemoryManager.cc:55:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
archiveMemoryManager.cc:61:    this[01;31m-[00m>Base::initialize();
archiveMemoryManager.cc:62:    this[01;31m-[00m>_WeakArchive = O_Archive::nil(this[01;31m-[00m>lisp());
archiveMemoryManager.cc:63:    this[01;31m-[00m>_ArchiveNodes = O_MicroHeap::nil(this[01;31m-[00m>lisp());
archiveMemoryManager.cc:64:    this[01;31m-[00m>_ChildHolders = O_MicroHeap::nil(this[01;31m-[00m>lisp());
archiveMemoryManager.cc:75:    if ( this[01;31m-[00m>_ArchiveNodes[01;31m-[00m>isNil() )
archiveMemoryManager.cc:77:        this[01;31m-[00m>_ArchiveNodes = O_MicroHeap::create(this[01;31m-[00m>lisp(),1024*16,sizeof(Dumb_Node));
archiveMemoryManager.cc:80:    void* mem = this[01;31m-[00m>_ArchiveNodes[01;31m-[00m>rawNewEntry(idx);
archiveMemoryManager.cc:82:    RPNode node = new(mem) Dumb_Node(this[01;31m-[00m>getArchive().get());
archiveMemoryManager.cc:88:    if ( this[01;31m-[00m>_ChildHolders[01;31m-[00m>isNil() )
archiveMemoryManager.cc:90:        this[01;31m-[00m>_ChildHolders = O_MicroHeap::create(this[01;31m-[00m>lisp(),1024,sizeof(ChildHolder));
archiveMemoryManager.cc:93:    void* mem = this[01;31m-[00m>_ChildHolders[01;31m-[00m>rawNewEntry(idx);
archiveMemoryManager.cc:104:	class_<O_ArchiveMemoryManager>(this[01;31m-[00m>lisp())
archiveNode.cc:22:    return node[01;31m-[00m>archive_const().symbolManager().textSymbol(it[01;31m-[00m>first);
archiveNode.cc:28:    return node[01;31m-[00m>archive_const().symbolManager().textSymbol(it[01;31m-[00m>first);
archiveNode.cc:33:    return node[01;31m-[00m>archive().multiStringBuffer()[01;31m-[00m>getCharacters(it[01;31m-[00m>second);
archiveNode.cc:38:    return node[01;31m-[00m>archive().multiStringBuffer()[01;31m-[00m>getCharacters(it[01;31m-[00m>second);
archiveNode.cc:45:    handleType h = node[01;31m-[00m>archive().symbolManager().handle(name);
archiveNode.cc:46:    for (AttributeMap::iterator ii=this[01;31m-[00m>_Entries.begin(); ii!=this[01;31m-[00m>_Entries.end(); ii++ )
archiveNode.cc:48:	if ( ii[01;31m-[00m>first == h ) 
archiveNode.cc:50:	    return node[01;31m-[00m>archive().multiStringBuffer()[01;31m-[00m>getCharacters(ii[01;31m-[00m>second);
archiveNode.cc:58:    return this[01;31m-[00m>get(node,name)!=NULL;
archiveNode.cc:62:{_F(node[01;31m-[00m>lisp());
archiveNode.cc:63:    handleType h = node[01;31m-[00m>archive().symbolManager().handle(name);
archiveNode.cc:66:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("I was asked to set the UniqueId attribute but we don't do that anymore.  UniqueId attributes are set at the Node directly"));
archiveNode.cc:73:    for (AttributeMap::iterator ii=this[01;31m-[00m>_Entries.begin(); ii!=this[01;31m-[00m>_Entries.end(); ii++ )
archiveNode.cc:75:	if ( ii[01;31m-[00m>first == h ) return;
archiveNode.cc:78:    uint valueIndex = node[01;31m-[00m>archive().multiStringBuffer()[01;31m-[00m>addString(val);
archiveNode.cc:79:    this[01;31m-[00m>_Entries.push_back(pair<handleType,uint>(h,valueIndex));
archiveNode.cc:84:    handleType h = node[01;31m-[00m>archive().symbolManager().handle(name);
archiveNode.cc:87:	node[01;31m-[00m>setTextUniqueId(val);
archiveNode.cc:90:    uint valueIndex = node[01;31m-[00m>archive().multiStringBuffer()[01;31m-[00m>addString(val);
archiveNode.cc:91:    this[01;31m-[00m>_Entries.push_back(pair<handleType,uint>(h,valueIndex));
archiveNode.cc:120:    this[01;31m-[00m>nodeCount = 0;
archiveNode.cc:121:    this[01;31m-[00m>nodeNames=0;
archiveNode.cc:122:    this[01;31m-[00m>characterStructure=0;
archiveNode.cc:123:    this[01;31m-[00m>pointers=0;
archiveNode.cc:124:    this[01;31m-[00m>lineNumbersFlags=0;
archiveNode.cc:125:    this[01;31m-[00m>attributesStructure=0;
archiveNode.cc:126:    this[01;31m-[00m>attributesText=0;
archiveNode.cc:127:    this[01;31m-[00m>attributesKeys=0;
archiveNode.cc:128:    this[01;31m-[00m>uidMap=0;
archiveNode.cc:129:    this[01;31m-[00m>focus=0;
archiveNode.cc:130:    this[01;31m-[00m>countAttributes=0;
archiveNode.cc:131:    this[01;31m-[00m>totalBytes=0;
archiveNode.cc:138:    lisp[01;31m-[00m>print(BF("       nodeNames   = %u") %  nodeNames );
archiveNode.cc:140:    lisp[01;31m-[00m>print(BF("characterStructures= %u") %  characterStructure );
archiveNode.cc:142:    lisp[01;31m-[00m>print(BF("          pointers = %u") %  pointers );
archiveNode.cc:144:    lisp[01;31m-[00m>print(BF("  lineNumbersFlags = %u") %  lineNumbersFlags );
archiveNode.cc:146:    lisp[01;31m-[00m>print(BF("attributesStructure= %u") %  attributesStructure );
archiveNode.cc:148:    lisp[01;31m-[00m>print(BF("     attributesKeys= %u") %  attributesKeys );
archiveNode.cc:150:    lisp[01;31m-[00m>print(BF("     attributesText= %u") %  attributesText );
archiveNode.cc:152:    lisp[01;31m-[00m>print(BF("          uidMap   = %u") %  uidMap );
archiveNode.cc:154:    lisp[01;31m-[00m>print(BF("           focus   = %u") %  focus );
archiveNode.cc:156:    lisp[01;31m-[00m>print(BF("           TOTAL   = %u") %  total );
archiveNode.cc:157:    lisp[01;31m-[00m>print(BF(" countAttributes   = %u") %  countAttributes );
archiveNode.cc:169:    this[01;31m-[00m>nodeCount++;
archiveNode.cc:170:    this[01;31m-[00m>focus = sizeof(node[01;31m-[00m>_Attributes);
archiveNode.cc:171:    this[01;31m-[00m>pointers += sizeof(node[01;31m-[00m>_PArchive)+sizeof(node[01;31m-[00m>_Parent)+sizeof(node[01;31m-[00m>_Object);
archiveNode.cc:172:    this[01;31m-[00m>lineNumbersFlags += sizeof(node[01;31m-[00m>_LineNumber)+sizeof(node[01;31m-[00m>_Flags);
archiveNode.cc:173:    this[01;31m-[00m>pointers += sizeof(node[01;31m-[00m>_PChildren);
archiveNode.cc:174:    this[01;31m-[00m>nodeNames += sizeof(node[01;31m-[00m>_NodeHandle);
archiveNode.cc:175:    this[01;31m-[00m>characterStructure += sizeof(node[01;31m-[00m>_CharactersIndex);
archiveNode.cc:177:    for ( ci=node[01;31m-[00m>begin_Children(); ci!=node[01;31m-[00m>end_Children(); ci++ ) 
archiveNode.cc:179:	this[01;31m-[00m>sumUsageForNode(*ci);
archiveNode.cc:180:	this[01;31m-[00m>pointers += sizeof((*ci));
archiveNode.cc:187:    this[01;31m-[00m>countAttributes += node[01;31m-[00m>_Attributes.size();
archiveNode.cc:188:    this[01;31m-[00m>attributesStructure += sizeof(node[01;31m-[00m>_Attributes);
archiveNode.cc:189:    for ( attr=node[01;31m-[00m>_Attributes.begin(); attr!=node[01;31m-[00m>_Attributes.end(); attr++ )
archiveNode.cc:191:	this[01;31m-[00m>attributesKeys += sizeof(attr[01;31m-[00m>first);
archiveNode.cc:192:	this[01;31m-[00m>attributesText += sizeof(attr[01;31m-[00m>second);
archiveNode.cc:202:    ae[01;31m-[00m>setMessage(fmt.str());
archiveNode.cc:203:    ae[01;31m-[00m>appendNodeInformation(node);
archiveNode.cc:211:    ae[01;31m-[00m>setMessage(fmt);
archiveNode.cc:212:    ae[01;31m-[00m>appendNodeInformation(node);
archiveNode.cc:224:    	<< node[01;31m-[00m>getFileName()
archiveNode.cc:226:	<< node[01;31m-[00m>getLineNumber()
archiveNode.cc:228:	<< node[01;31m-[00m>getNodeName() 
archiveNode.cc:230:	<< node[01;31m-[00m>getUniqueIdCharacters()
archiveNode.cc:232:    this[01;31m-[00m>_Message += ss.str();
archiveNode.cc:238:    this[01;31m-[00m>_Message  = fmt.str();
archiveNode.cc:239:    this[01;31m-[00m>appendNodeInformation(node);
archiveNode.cc:244:    this[01;31m-[00m>_Message  = str;
archiveNode.cc:245:    this[01;31m-[00m>appendNodeInformation(node);
archiveNode.cc:253:    this[01;31m-[00m>_Children.clear();
archiveNode.cc:254:    this[01;31m-[00m>_ChildrenByUid.clear();
archiveNode.cc:262:{_F(parent[01;31m-[00m>lisp());
archiveNode.cc:263:    uint nextIdx = this[01;31m-[00m>_Children.size();
archiveNode.cc:264:    this[01;31m-[00m>_Children.push_back(node);
archiveNode.cc:265:    if ( node[01;31m-[00m>hasUniqueId() )
archiveNode.cc:267:	LOG(BF("Child node has a uid(%s)")% node[01;31m-[00m>getUniqueIdCharacters());
archiveNode.cc:268:	handleType uidHandle = node[01;31m-[00m>getUniqueIdHandle();
archiveNode.cc:269:	this[01;31m-[00m>_ChildrenByUid[uidHandle] = nextIdx;
archiveNode.cc:278:    return ( this[01;31m-[00m>_ChildrenByUid.count(huid) > 0 );
archiveNode.cc:284:    if ( this[01;31m-[00m>_ChildrenByUid.count(huid) == 0 ) return child;
archiveNode.cc:285:    uint idx = this[01;31m-[00m>_ChildrenByUid[huid];
archiveNode.cc:286:    return this[01;31m-[00m>_Children[idx];
archiveNode.cc:291:{_F(parent[01;31m-[00m>lisp());
archiveNode.cc:296:    handleType hname = parent[01;31m-[00m>archive().symbolManager().handle(nodeName);
archiveNode.cc:297:    for ( ci=this[01;31m-[00m>begin_Children(parent); ci!=this[01;31m-[00m>end_Children(parent); ci++ ) 
archiveNode.cc:299:	if ( (*ci)[01;31m-[00m>isNamed(hname) )
archiveNode.cc:307:	    TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(BF("Could not find child with name: %s")%nodeName, parent));
archiveNode.cc:309:	TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(BF("There can be only one child with name: ")%nodeName, parent ));
archiveNode.cc:317:    handleType hname = parent[01;31m-[00m>archive().symbolManager().handle(nodeName);
archiveNode.cc:318:    for ( ci=this[01;31m-[00m>begin_Children(parent); ci!=this[01;31m-[00m>end_Children(parent); ci++ ) 
archiveNode.cc:320:	if ( (*ci)[01;31m-[00m>isNamed(hname) ) return true;
archiveNode.cc:329:{_F(parent[01;31m-[00m>lisp());
archiveNode.cc:332:    handleType hname = parent[01;31m-[00m>archive().symbolManager().handle(nodeName);
archiveNode.cc:333:    for ( ci=this[01;31m-[00m>begin_Children(parent); ci!=this[01;31m-[00m>end_Children(parent); ci++ ) 
archiveNode.cc:335:	if ( (*ci)[01;31m-[00m>isNamed(hname) )
archiveNode.cc:337:	    childKey = (*ci)[01;31m-[00m>getAttributeStringDefault("_key","");
archiveNode.cc:344:    TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(BF("Could not find child with NodeName(%s) and key (%s)") % nodeName % key, parent ));
archiveNode.cc:348:{_F(parent[01;31m-[00m>lisp());
archiveNode.cc:353:    handleType hname = parent[01;31m-[00m>archive().symbolManager().handle(name);
archiveNode.cc:354:    for ( ci=this[01;31m-[00m>begin_Children(parent); ci!=this[01;31m-[00m>end_Children(parent); ci++ ) 
archiveNode.cc:356:	if ( (*ci)[01;31m-[00m>isNamed(hname) )
archiveNode.cc:367:    return this[01;31m-[00m>_Children.size();
archiveNode.cc:381:    this[01;31m-[00m>_PArchive = archive;	// This has to be initialized first!!!!!
archiveNode.cc:382:    this[01;31m-[00m>_Huid = EmptyStringHandle;
archiveNode.cc:383:    this[01;31m-[00m>_Object = O_Object::nil(this[01;31m-[00m>lisp());
archiveNode.cc:384:    this[01;31m-[00m>_Parent = NULL;
archiveNode.cc:385:    this[01;31m-[00m>_Flags = 0;
archiveNode.cc:386:    this[01;31m-[00m>setSuppressNode(false);
archiveNode.cc:387:    this[01;31m-[00m>_PChildren = NULL;
archiveNode.cc:388:    this[01;31m-[00m>_CharactersIndex = UndefinedUnsignedInt;
archiveNode.cc:393:    if ( this[01;31m-[00m>_PChildren != NULL )
archiveNode.cc:396:	this[01;31m-[00m>_PChildren[01;31m-[00m>~ChildHolder();
archiveNode.cc:403:    return this[01;31m-[00m>archive().lisp();
archiveNode.cc:408:    return this[01;31m-[00m>archive().lisp();
archiveNode.cc:413:    if ( this[01;31m-[00m>_PChildren == NULL ) return 0;
archiveNode.cc:414:    return this[01;31m-[00m>_PChildren[01;31m-[00m>numberOfChildren(this);
archiveNode.cc:419:    if ( this[01;31m-[00m>_PChildren == NULL ) return _EmptyChildren.begin();
archiveNode.cc:420:    return this[01;31m-[00m>_PChildren[01;31m-[00m>begin_Children(this);
archiveNode.cc:425:    if ( this[01;31m-[00m>_PChildren == NULL ) return _EmptyChildren.end();
archiveNode.cc:426:    return this[01;31m-[00m>_PChildren[01;31m-[00m>end_Children(this);
archiveNode.cc:431:    ASSERT(this[01;31m-[00m>_PArchive!=NULL);
archiveNode.cc:432:    return this[01;31m-[00m>_PArchive[01;31m-[00m>sharedThis<O_Archive>();
archiveNode.cc:438:    return this[01;31m-[00m>getArchive()[01;31m-[00m>newArchiveNode();
archiveNode.cc:444:    arch = this[01;31m-[00m>getArchive();
archiveNode.cc:445:    arch[01;31m-[00m>loadOnlyObjectOfClassWithinNode(this, classId, obj );
archiveNode.cc:450:    uint h = this[01;31m-[00m>getArchive()[01;31m-[00m>symbolManager().handle(name);
archiveNode.cc:451:    return h == this[01;31m-[00m>_NodeHandle;
archiveNode.cc:456:    this[01;31m-[00m>setRawNodeName(metaClass[01;31m-[00m>className());
archiveNode.cc:457:    if (metaClass[01;31m-[00m>isAssignableTo<O_CandoClass>() )
archiveNode.cc:459:	RPCandoClass cc = metaClass[01;31m-[00m>as<O_CandoClass>();
archiveNode.cc:460:	this[01;31m-[00m>addAttribute(CoreObjectClassAttribute,cc[01;31m-[00m>getCoreObjectClass()[01;31m-[00m>className());
archiveNode.cc:466:    ASSERTP(!this[01;31m-[00m>lisp()[01;31m-[00m>isClassName(nm),
archiveNode.cc:468:    this[01;31m-[00m>setRawNodeName(nm);
archiveNode.cc:473:    if ( this[01;31m-[00m>numberOfChildren() < 1 ) return false;
archiveNode.cc:476:    RPMetaClass baseClass = this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(baseId);
archiveNode.cc:477:    for ( ci=this[01;31m-[00m>begin_Children(); ci!=this[01;31m-[00m>end_Children(); ci++ )
archiveNode.cc:479:	RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern((*ci)[01;31m-[00m>getNodeName());
archiveNode.cc:480:	RPObject obj = this[01;31m-[00m>lisp()[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(sym);
archiveNode.cc:481:	if ( obj[01;31m-[00m>isAssignableTo<O_MetaClass>() )
archiveNode.cc:483:	    RPMetaClass mc = obj[01;31m-[00m>as<O_MetaClass>();
archiveNode.cc:484:	    if ( mc[01;31m-[00m>isSubClassOf(baseClass) )
archiveNode.cc:501:    return hname == this[01;31m-[00m>_NodeHandle;
archiveNode.cc:506:    const string& name = this[01;31m-[00m>getArchive()[01;31m-[00m>symbolManager().textSymbol(this[01;31m-[00m>_NodeHandle);
archiveNode.cc:512:    uint h = this[01;31m-[00m>getArchive()[01;31m-[00m>symbolManager().handle(nm);
archiveNode.cc:513:    this[01;31m-[00m>_NodeHandle = h;
archiveNode.cc:520:    return this[01;31m-[00m>archive().multiStringBuffer()[01;31m-[00m>getCharacters(this[01;31m-[00m>_CharactersIndex);
archiveNode.cc:539:{_F(this[01;31m-[00m>lisp());
archiveNode.cc:541:    uint index = this[01;31m-[00m>archive().multiStringBuffer()[01;31m-[00m>addCharacters(buffer.c_str());
archiveNode.cc:542:    this[01;31m-[00m>_CharactersIndex = index;
archiveNode.cc:544:    const char* wrote = this[01;31m-[00m>archive().multiStringBuffer()[01;31m-[00m>getCharacters(index);
archiveNode.cc:556:    this[01;31m-[00m>getArchive()[01;31m-[00m>saveOnlyObjectOfClassWithinNode(this, classId, obj );
archiveNode.cc:561:    this[01;31m-[00m>getArchive()[01;31m-[00m>loadObjectWithinNodeWithUid(this, uid, obj );
archiveNode.cc:567:    this[01;31m-[00m>getArchive()[01;31m-[00m>saveObjectWithinNodeWithUid(this, uid, obj );
archiveNode.cc:572:    this[01;31m-[00m>getArchive()[01;31m-[00m>saveObjectWithinNodeWithUidAndKey(this,uid,key,obj);
archiveNode.cc:578:    return this[01;31m-[00m>getArchive()[01;31m-[00m>loadObjectDirectly(node);
archiveNode.cc:583:    this[01;31m-[00m>getArchive()[01;31m-[00m>loadWeakPointerInAttribute(node,attribute,obj,expectedClassId,mustBeDefined);
archiveNode.cc:591:    if ( this[01;31m-[00m>numberOfChildren() == 0 ) return 1;
archiveNode.cc:592:    for ( ci=this[01;31m-[00m>begin_Children(); ci!=this[01;31m-[00m>end_Children(); ci++ ) {
archiveNode.cc:593:	cnt += (*ci)[01;31m-[00m>leafCount();
archiveNode.cc:603:    for ( ci=this[01;31m-[00m>begin_Children(); ci!=this[01;31m-[00m>end_Children(); ci++ ) {
archiveNode.cc:604:	cnt += (*ci)[01;31m-[00m>nodeCount();
archiveNode.cc:616:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF(" Estimated memory usage broken down" ));
archiveNode.cc:617:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF(" Number of symbols in SymbolManager: %d") %  this[01;31m-[00m>archive().symbolManager().numberOfSymbols() );
archiveNode.cc:618:    this[01;31m-[00m>archive().symbolManager().printDescription(this[01;31m-[00m>lisp());
archiveNode.cc:619:    LongLongInt totalBytes = track.describeMemoryUsage(this[01;31m-[00m>lisp());
archiveNode.cc:620:#define DP(n) {this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("    %20s = %u bytes") %  #n % sizeof(n) ); }
archiveNode.cc:621:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("   Memory usage of top node broken down by parts" ));
archiveNode.cc:622:    DP(this[01;31m-[00m>_PArchive);
archiveNode.cc:623:    DP(this[01;31m-[00m>_Parent);
archiveNode.cc:624:    DP(this[01;31m-[00m>_Object);
archiveNode.cc:625:    DP(this[01;31m-[00m>_NodeHandle);
archiveNode.cc:626:    DP(this[01;31m-[00m>_LineNumber);
archiveNode.cc:627:    DP(this[01;31m-[00m>_Flags);
archiveNode.cc:628:    DP(this[01;31m-[00m>_PChildren);
archiveNode.cc:629:    DP(this[01;31m-[00m>_Attributes);
archiveNode.cc:640:    this[01;31m-[00m>getArchive()[01;31m-[00m>saveWeakPointerInAttribute(this,attribute,
archiveNode.cc:647:    return this[01;31m-[00m>archive().nextUniqueId();
archiveNode.cc:653:    ss << this[01;31m-[00m>archive().nextUniqueId();
archiveNode.cc:661:{_TF(this[01;31m-[00m>lisp(),BF("Dumb_Node::needsFinalization uid(%s)") % this[01;31m-[00m>getUniqueIdCharacters());
archiveNode.cc:662:    if ( this[01;31m-[00m>loading() ) {
archiveNode.cc:663:        this[01;31m-[00m>getArchive()[01;31m-[00m>addNodeToFinalize(this);
archiveNode.cc:680:    this[01;31m-[00m>addAttribute(at,temp.str());
archiveNode.cc:685:    this[01;31m-[00m>_Attributes.set(this,at,val.str());
archiveNode.cc:692:{_F(this[01;31m-[00m>lisp());
archiveNode.cc:720:    if ( b ) this[01;31m-[00m>_Flags |= NODE_Recognized;
archiveNode.cc:721:    else this[01;31m-[00m>_Flags &= ~(NODE_Recognized);
archiveNode.cc:726:    if ( b ) this[01;31m-[00m>_Flags |= NODE_Finalized;
archiveNode.cc:727:    else this[01;31m-[00m>_Flags &= ~(NODE_Finalized);
archiveNode.cc:732:    if ( b ) this[01;31m-[00m>_Flags |= NODE_Suppressed;
archiveNode.cc:733:    else this[01;31m-[00m>_Flags &= ~(NODE_Suppressed);
archiveNode.cc:740:    this[01;31m-[00m>_Attributes.set(this,at,val);
archiveNode.cc:744:    this[01;31m-[00m>addAttributeDouble(at,val);
archiveNode.cc:748:    this[01;31m-[00m>addAttributeFloat(at,val);
archiveNode.cc:752:    this[01;31m-[00m>addAttributeInt(at,val);
archiveNode.cc:756:    this[01;31m-[00m>addAttributeLongLongInt(at,val);
archiveNode.cc:760:    this[01;31m-[00m>addAttributeUInt(at,val);
archiveNode.cc:764:    this[01;31m-[00m>addAttributeULong(at,val);
archiveNode.cc:768:    this[01;31m-[00m>addAttributeBool(at,val);
archiveNode.cc:773:	    this[01;31m-[00m>addAttribute(at,val);
archiveNode.cc:789:    this[01;31m-[00m>addAttribute(at,temp.str());
archiveNode.cc:794:    this[01;31m-[00m>addAttribute(at,temp.str());
archiveNode.cc:800:    this[01;31m-[00m>addAttribute(at,temp.str());
archiveNode.cc:811:    this[01;31m-[00m>addAttribute(at,temp.str());
archiveNode.cc:818:    this[01;31m-[00m>addAttribute(at,temp.str());
archiveNode.cc:824:    this[01;31m-[00m>addAttribute(at,temp.str());
archiveNode.cc:834:    this[01;31m-[00m>addAttribute(at,temp.str());
archiveNode.cc:839:    return this[01;31m-[00m>getArchive()[01;31m-[00m>getFileName();
archiveNode.cc:845:{ _TF(this[01;31m-[00m>lisp(),BF("Dumb_Node::setUniqueId(%s)") % uid );
archiveNode.cc:847:    handleType huid = this[01;31m-[00m>archive().symbolManager().handle(uid);
archiveNode.cc:848:    if ( this[01;31m-[00m>hasParent() ) 
archiveNode.cc:850:        parent = this[01;31m-[00m>getParent();
archiveNode.cc:851:        if ( parent[01;31m-[00m>hasChildWithUniqueId(huid) ) {
archiveNode.cc:852:	    TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(BF("Parent node already has uid(%s)") % uid, parent ));
archiveNode.cc:855:    this[01;31m-[00m>_Huid = huid;
archiveNode.cc:860:{ _TF(this[01;31m-[00m>lisp(),BF("Dumb_Node::setUniqueId(%d)") % uid );
archiveNode.cc:861:    handleType huid = this[01;31m-[00m>archive().symbolManager().handleFromNumber(uid);
archiveNode.cc:862:    this[01;31m-[00m>_Huid = huid;
archiveNode.cc:866:{ _TF(this[01;31m-[00m>lisp(),BF("Dumb_Node::setUniqueIdHandle(#%d)") % huid );
archiveNode.cc:867:    this[01;31m-[00m>_Huid = huid;
archiveNode.cc:871:{ _F(this[01;31m-[00m>lisp());
archiveNode.cc:872:    int uid = this[01;31m-[00m>archive().nextUniqueId();
archiveNode.cc:873:    this[01;31m-[00m>setNumericUniqueId(uid);
archiveNode.cc:878:{_TF(this[01;31m-[00m>lisp(),BF("Dumb_Node::followLinkPathUpTreeForClassName(%s)") % linkPath );
archiveNode.cc:884:	if ( curNode[01;31m-[00m>isNamed(lookForClassName) )
archiveNode.cc:889:	if ( !curNode[01;31m-[00m>hasParent() ) {
archiveNode.cc:890:	    TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>("Could not find node name("+lookForClassName+")", this));
archiveNode.cc:892:        curNode = curNode[01;31m-[00m>getParent();
archiveNode.cc:899:    return this[01;31m-[00m>archive().symbolManager().numericSymbol(this[01;31m-[00m>_Huid);
archiveNode.cc:904:    handleType huid = this[01;31m-[00m>getUniqueIdHandle();
archiveNode.cc:907:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is an empty UniqueId and there shouldn't be"));
archiveNode.cc:909:    return this[01;31m-[00m>archive().symbolManager().anySymbol(huid);
archiveNode.cc:914:    handleType huid = this[01;31m-[00m>getUniqueIdHandle();
archiveNode.cc:915:    return this[01;31m-[00m>archive().symbolManager().anySymbol(huid);
archiveNode.cc:920:{_TF(this[01;31m-[00m>lisp(),BF("Dumb_Node::followLinkPathUpTreeForUid(%s)") % linkPath );
archiveNode.cc:923:    handleType hLookForUid = this[01;31m-[00m>archive().symbolManager().handle(lookForUid);
archiveNode.cc:929:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Couldn't find uid: "+lookForUid));
archiveNode.cc:931:	if ( hLookForUid == curNode[01;31m-[00m>getUniqueIdHandle() ) 
archiveNode.cc:936:	if ( curNode[01;31m-[00m>getParent() == NULL ) {
archiveNode.cc:939:        curNode = curNode[01;31m-[00m>getParent();
archiveNode.cc:945: * /identifier1/identifier2/identifier3 [01;31m-[00m absolute path
archiveNode.cc:946: * ../		[01;31m-[00m Climb one level up the tree
archiveNode.cc:947: * ^[uid]	[01;31m-[00m Climb up the tree until you find the uid
archiveNode.cc:948: * %[className] [01;31m-[00m climb up the tree looking for the class name
archiveNode.cc:950: * @[className] [01;31m-[00m Unique className at current level
archiveNode.cc:953: * !nil [01;31m-[00m represents a nil object (handled in O_PArchive::loadObjectDirectly before followLinkPath is called).
archiveNode.cc:956:{_TF(this[01;31m-[00m>lisp(),BF("Dumb_Node::followLinkPath(%s)")%linkPath);
archiveNode.cc:967:	curNode = this[01;31m-[00m>getArchive()[01;31m-[00m>getTopNode();
archiveNode.cc:971:	curNode = this[01;31m-[00m>followLinkPathUpTreeForUid(parts[0],curNode);
archiveNode.cc:975:	curNode = this[01;31m-[00m>followLinkPathUpTreeForClass(parts[0],curNode);
archiveNode.cc:983:	    curNode = curNode[01;31m-[00m>getParent();
archiveNode.cc:990:	    curNode = curNode[01;31m-[00m>childWithUniqueNodeName(nodeName);
archiveNode.cc:1004:	        TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(ess.str(), curNode ));
archiveNode.cc:1006:	    curNode = curNode[01;31m-[00m>childWithNodeNameAndKey(mapParts[0],mapParts[1]);
archiveNode.cc:1008:	    curNode = curNode[01;31m-[00m>childWithUniqueId(key);
archiveNode.cc:1022:    while ( cur[01;31m-[00m>hasParent() ) {
archiveNode.cc:1023:	cur = cur[01;31m-[00m>getParent();
archiveNode.cc:1035:    child = this[01;31m-[00m>getArchive()[01;31m-[00m>newArchiveNode();
archiveNode.cc:1036:    this[01;31m-[00m>addChild(child);
archiveNode.cc:1037:    child[01;31m-[00m>setRawNodeName(name);
archiveNode.cc:1044:    ASSERT(this[01;31m-[00m>_PArchive!=NULL);
archiveNode.cc:1045:    return this[01;31m-[00m>_PArchive[01;31m-[00m>isSaveArchive();
archiveNode.cc:1050:{_TF(this[01;31m-[00m>lisp(),BF("hasChildWithUniqueId(%s) of child of node: %s") % uid % this[01;31m-[00m>description() );
archiveNode.cc:1051:    if ( this[01;31m-[00m>_PChildren == NULL ) return false;
archiveNode.cc:1052:    handleType huid = this[01;31m-[00m>archive().symbolManager().handle(uid);
archiveNode.cc:1053:    return this[01;31m-[00m>_PChildren[01;31m-[00m>hasChildWithUniqueId(this,huid);
archiveNode.cc:1057:{_TF(this[01;31m-[00m>lisp(),BF("hasChildWithUniqueId(#%d) of child of node: %s") % hid % this[01;31m-[00m>description() );
archiveNode.cc:1058:    if ( this[01;31m-[00m>_PChildren == NULL ) return false;
archiveNode.cc:1059:    return this[01;31m-[00m>_PChildren[01;31m-[00m>hasChildWithUniqueId(this,huid);
archiveNode.cc:1063:{_TF(this[01;31m-[00m>lisp(),BF( "childWithUniqueIdOrNull uid(#%d) of child of node: %s") % huid % this[01;31m-[00m>description() );
archiveNode.cc:1064:    ASSERT(this[01;31m-[00m>_PChildren!=NULL);
archiveNode.cc:1065:    return this[01;31m-[00m>_PChildren[01;31m-[00m>childWithUniqueIdOrNull(this,huid);
archiveNode.cc:1069:{_TF(this[01;31m-[00m>lisp(),BF("childWithUniqueIdOrNull uid(%s) of child of node: %s") % uid % this[01;31m-[00m>description() );
archiveNode.cc:1070:    ASSERT(this[01;31m-[00m>_PChildren!=NULL);
archiveNode.cc:1071:    handleType huid = this[01;31m-[00m>archive().symbolManager().handle(uid);
archiveNode.cc:1072:    return this[01;31m-[00m>_PChildren[01;31m-[00m>childWithUniqueIdOrNull(this,huid);
archiveNode.cc:1076:{_TF(this[01;31m-[00m>lisp(),BF("childWithUniqueId>> loading uid(%s)") % uid );
archiveNode.cc:1077:    handleType huid = this[01;31m-[00m>archive().symbolManager().handle(uid);
archiveNode.cc:1078:    if (this[01;31m-[00m>_PChildren == NULL)
archiveNode.cc:1080:	TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>("Could not find child with uid("+uid+") This node doesn't have children", this ));
archiveNode.cc:1082:    RPNode child = this[01;31m-[00m>_PChildren[01;31m-[00m>childWithUniqueIdOrNull(this,huid);
archiveNode.cc:1085:	TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>("Could not find child with uid("+uid+") This node has children but none with that uid", this ));
archiveNode.cc:1091:{_TF(this[01;31m-[00m>lisp(),BF("childWithUniqueId>> loading uid(#%d)")% huid );
archiveNode.cc:1092:    if (this[01;31m-[00m>_PChildren == NULL)
archiveNode.cc:1095:	ss << "Could not find child with uid(" << this[01;31m-[00m>archive().symbolManager().anySymbol(huid) << " This node doesn't have children";
archiveNode.cc:1096:	TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(ss.str(),this));
archiveNode.cc:1098:    RPNode child = this[01;31m-[00m>_PChildren[01;31m-[00m>childWithUniqueIdOrNull(this,huid);
archiveNode.cc:1102:	ss << "Could not find child with uid(" << this[01;31m-[00m>archive().symbolManager().anySymbol(huid) << " This node has children but none with that uid";
archiveNode.cc:1103:	TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(ss.str(),this));
archiveNode.cc:1110:    if ( this[01;31m-[00m>_PChildren == NULL )
archiveNode.cc:1112:	this[01;31m-[00m>_PChildren = this[01;31m-[00m>getArchive()[01;31m-[00m>newChildHolder();
archiveNode.cc:1114:    this[01;31m-[00m>_PChildren[01;31m-[00m>addChild(this,node);
archiveNode.cc:1115:    node[01;31m-[00m>setParent(this);
archiveNode.cc:1120:{_F(this[01;31m-[00m>lisp());
archiveNode.cc:1121:    if ( this[01;31m-[00m>_PChildren==NULL ) return false;
archiveNode.cc:1122:    return this[01;31m-[00m>_PChildren[01;31m-[00m>hasChildrenWithName(this,name);
archiveNode.cc:1127:    if ( this[01;31m-[00m>_PChildren == NULL ) return false;
archiveNode.cc:1128:    return this[01;31m-[00m>_PChildren[01;31m-[00m>hasChildWithUniqueNodeName(this,nodeName);
archiveNode.cc:1134:    ASSERT(this[01;31m-[00m>_PChildren!=NULL);
archiveNode.cc:1135:    return this[01;31m-[00m>_PChildren[01;31m-[00m>childWithUniqueNodeName(this,nodeName);
archiveNode.cc:1144:    ASSERT(this[01;31m-[00m>_PChildren!=NULL);
archiveNode.cc:1145:    return this[01;31m-[00m>_PChildren[01;31m-[00m>childWithNodeNameAndKey(this,nodeName,key);
archiveNode.cc:1151:    const string& className = this[01;31m-[00m>getNodeName();
archiveNode.cc:1152:    return this[01;31m-[00m>lisp()[01;31m-[00m>isClassName(className);
archiveNode.cc:1158:{ _TF(this[01;31m-[00m>lisp(),BF("Dumb_Node::createYourObject>> creating object with class(%s)") %  this[01;31m-[00m>getNodeName() );
archiveNode.cc:1160:    string className = this[01;31m-[00m>getNodeName();
archiveNode.cc:1161:    {_BLOCK_TRACEF(BF("Determining if node name(%s) is known") % this[01;31m-[00m>getNodeName() );
archiveNode.cc:1162:	if ( !this[01;31m-[00m>lisp()[01;31m-[00m>isClassName(className) )
archiveNode.cc:1165:	    LOG(BF("Known class names: %s")% this[01;31m-[00m>lisp()[01;31m-[00m>allClassNames()[01;31m-[00m>asString() );
archiveNode.cc:1166:	    RPSymbol newCandoClassSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>intern(className);
archiveNode.cc:1167:	    LOG(BF("I'm going to create a CandoClass for the new class name(%s)")% newCandoClassSymbol[01;31m-[00m>fullName());
archiveNode.cc:1168:	    RPCandoClass newCandoClass = this[01;31m-[00m>lisp()[01;31m-[00m>defineCandoClass(newCandoClassSymbol);
archiveNode.cc:1169:	    string coreClassName = this[01;31m-[00m>getAttributeStringDefault(CoreObjectClassAttribute,"CandoObject");
archiveNode.cc:1170:	    if ( !this[01;31m-[00m>lisp()[01;31m-[00m>isClassName(coreClassName) )
archiveNode.cc:1172:		TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>((BF("Trying to create object with CoreObjectClass(%s) but that class doesn't exist")%coreClassName).str(),
archiveNode.cc:1176:	    RPMetaClass coreObjectClass = this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassName(coreClassName);
archiveNode.cc:1177:	    newCandoClass[01;31m-[00m>setCoreObjectClass(coreObjectClass);
archiveNode.cc:1178:	    RPNode binderNode = this[01;31m-[00m>childWithUniqueIdOrNull("slots");
archiveNode.cc:1179:	    newCandoClass[01;31m-[00m>defineYourSlotsFromBinderArchiveNode(binderNode);
archiveNode.cc:1183:	    newCandoClass[01;31m-[00m>setInstanceBaseClass(coreObjectClass);
archiveNode.cc:1184:    //	TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>("Trying to create an object for an unknown class name("+className+")",this));
archiveNode.cc:1187:	    LOG(BF("The class with name(%s) is known [01;31m-[00m creating object of that class")%className );
archiveNode.cc:1191:	RPSymbol classSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>findSymbol(className);
archiveNode.cc:1192:	LOG(BF("Class symbol = %s") % classSymbol[01;31m-[00m>fullName() );
archiveNode.cc:1193:	RPMetaClass mc = this[01;31m-[00m>lisp()[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(classSymbol)[01;31m-[00m>as<O_MetaClass>();
archiveNode.cc:1194:	LOG(BF("Class name(%s)")%mc[01;31m-[00m>getPackagedName());
archiveNode.cc:1195:	obj = this[01;31m-[00m>lisp()[01;31m-[00m>createObjectOfClass(mc);
archiveNode.cc:1196:	this[01;31m-[00m>_Object = obj;
archiveNode.cc:1197:	LOG(BF("Created object of class(%s)") % obj[01;31m-[00m>className() );
archiveNode.cc:1199:    {_BLOCK_TRACE("Filling in the contents of object by calling obj[01;31m-[00m>archive");
archiveNode.cc:1201:	for ( ci=this[01;31m-[00m>begin_Children(); ci!=this[01;31m-[00m>end_Children(); ci++ )
archiveNode.cc:1203:	    (*ci)[01;31m-[00m>setRecognized(false);
archiveNode.cc:1205:	this[01;31m-[00m>setRecognized(true);
archiveNode.cc:1206:	obj[01;31m-[00m>archive(this);
archiveNode.cc:1210:	for ( ci=this[01;31m-[00m>begin_Children(); ci!=this[01;31m-[00m>end_Children(); ci++ )
archiveNode.cc:1212:	    if ( !(*ci)[01;31m-[00m>isRecognized() ) 
archiveNode.cc:1215:		ss << "Left over [01;31m-[00m unrecognized node uid(" << (*ci)[01;31m-[00m>getUniqueIdCharacters() << ")";
archiveNode.cc:1216:		this[01;31m-[00m>getArchive()[01;31m-[00m>addError( ss.str(), (*ci) );
archiveNode.cc:1219:		RPObject child = (*ci)[01;31m-[00m>getObject();
archiveNode.cc:1221:		child[01;31m-[00m>setOwner(obj);
archiveNode.cc:1242:    string val = this[01;31m-[00m>characters();
archiveNode.cc:1256:    const string& val = this[01;31m-[00m>characters();
archiveNode.cc:1271:{ _F(this[01;31m-[00m>lisp());
archiveNode.cc:1280:    if ( this[01;31m-[00m>isSuppressNode() ) return;
archiveNode.cc:1281:    out << "<" << this[01;31m-[00m>getNodeName();
archiveNode.cc:1283:    if ( this[01;31m-[00m>_Huid != EmptyStringHandle )
archiveNode.cc:1286:	out << this[01;31m-[00m>archive().symbolManager().anySymbol(this[01;31m-[00m>_Huid) << "\"";
archiveNode.cc:1288:    abegin = this[01;31m-[00m>_Attributes.begin();
archiveNode.cc:1289:    aend = this[01;31m-[00m>_Attributes.end();
archiveNode.cc:1292:	out << " " << this[01;31m-[00m>_Attributes.name(this,attr) << "=\"" << this[01;31m-[00m>_Attributes.value(this,attr)  << "\"";
archiveNode.cc:1295:    dataWhiteSpace = this[01;31m-[00m>dataIsAllWhiteSpace();
archiveNode.cc:1299:	dataNewLines = this[01;31m-[00m>dataCountNewLines();
archiveNode.cc:1301:    if ( this[01;31m-[00m>begin_Children() == this[01;31m-[00m>end_Children() && dataWhiteSpace ) 
archiveNode.cc:1313:	if ( this[01;31m-[00m>begin_Children() != this[01;31m-[00m>end_Children() ) 
archiveNode.cc:1319:	for ( it = this[01;31m-[00m>begin_Children(); it!=this[01;31m-[00m>end_Children(); it++ ) 
archiveNode.cc:1323:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("Bad child"));
archiveNode.cc:1325:	    (*it)[01;31m-[00m>writeXml(out);
archiveNode.cc:1335:	    this[01;31m-[00m>xml_fwrite(out,this[01;31m-[00m>characters());
archiveNode.cc:1338:	out << "</" << this[01;31m-[00m>getNodeName() << ">\n";
archiveNode.cc:1346:{ _F(this[01;31m-[00m>lisp());
archiveNode.cc:1355:    if ( this[01;31m-[00m>isSuppressNode() ) return;
archiveNode.cc:1356:    out << "n" << this[01;31m-[00m>getNodeName() << endl;
archiveNode.cc:1357:    if ( this[01;31m-[00m>_Huid != EmptyStringHandle )
archiveNode.cc:1359:	out << "u" << this[01;31m-[00m>archive().symbolManager().anySymbol(this[01;31m-[00m>_Huid);
archiveNode.cc:1362:	    out << " # raw Huid = " << this[01;31m-[00m>_Huid;
archiveNode.cc:1366:    abegin = this[01;31m-[00m>_Attributes.begin();
archiveNode.cc:1367:    aend = this[01;31m-[00m>_Attributes.end();
archiveNode.cc:1370:	out << "a" << this[01;31m-[00m>_Attributes.name(this,attr) << ":" << this[01;31m-[00m>_Attributes.value(this,attr)<< endl;
archiveNode.cc:1372:    dataWhiteSpace = this[01;31m-[00m>dataIsAllWhiteSpace();
archiveNode.cc:1376:	const char* data = this[01;31m-[00m>characters();
archiveNode.cc:1379:	    out << "d" << this[01;31m-[00m>oneLineOfCharacters(&data) << endl;
archiveNode.cc:1382:    for ( it = this[01;31m-[00m>begin_Children(); it!=this[01;31m-[00m>end_Children(); it++ ) 
archiveNode.cc:1386:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Bad child"));
archiveNode.cc:1388:	(*it)[01;31m-[00m>writeCandoFormat(out,debug);
archiveNode.cc:1402:    ss << "[" << this[01;31m-[00m>getNodeName()<<" ";
archiveNode.cc:1403:    ss << " line#"<<this[01;31m-[00m>_LineNumber << " ";
archiveNode.cc:1404:    abegin = this[01;31m-[00m>_Attributes.begin();
archiveNode.cc:1405:    aend = this[01;31m-[00m>_Attributes.end();
archiveNode.cc:1408:	ss << "attr("<< this[01;31m-[00m>_Attributes.name_const(this,attr) ;
archiveNode.cc:1409:	ss << ":" << this[01;31m-[00m>_Attributes.value(this,attr) << ") ";
archiveNode.cc:1420:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "Children names: "));
archiveNode.cc:1421:    for ( ci=this[01;31m-[00m>begin_Children(); ci!=this[01;31m-[00m>end_Children(); ci++ ) {
archiveNode.cc:1422:	this[01;31m-[00m>lisp()[01;31m-[00m>prin1(BF( " %s") % (*ci)[01;31m-[00m>getNodeName().c_str() );
archiveNode.cc:1424:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF(""));
archiveNode.cc:1429:{_F(this[01;31m-[00m>lisp());
archiveNode.cc:1430:    if ( this[01;31m-[00m>saving() ) {
archiveNode.cc:1437:	    newNode = this[01;31m-[00m>getArchive()[01;31m-[00m>newArchiveNode();
archiveNode.cc:1438:	    newNode[01;31m-[00m>setClasslessNodeName("VectorString");
archiveNode.cc:1439:	    newNode[01;31m-[00m>setTextUniqueId(uid);
archiveNode.cc:1440:	    newNode[01;31m-[00m>setCharacters(ss.str());
archiveNode.cc:1441:	    this[01;31m-[00m>addChild(newNode);
archiveNode.cc:1445:    	if ( this[01;31m-[00m>hasChildWithUniqueId(uid) ) {
archiveNode.cc:1446:	    childNode = this[01;31m-[00m>childWithUniqueId(uid);
archiveNode.cc:1447:	    vec = childNode[01;31m-[00m>getDataAsVectorOfStrings();
archiveNode.cc:1448:	    childNode[01;31m-[00m>setRecognized(true);
archiveNode.cc:1457:{_F(this[01;31m-[00m>lisp());
archiveNode.cc:1458:    if ( this[01;31m-[00m>saving() ) {
archiveNode.cc:1465:	    newNode = this[01;31m-[00m>getArchive()[01;31m-[00m>newArchiveNode();
archiveNode.cc:1466:	    newNode[01;31m-[00m>setClasslessNodeName("VectorDouble");
archiveNode.cc:1467:	    newNode[01;31m-[00m>setTextUniqueId(uid);
archiveNode.cc:1468:	    newNode[01;31m-[00m>setCharacters(ss.str());
archiveNode.cc:1469:	    this[01;31m-[00m>addChild(newNode);
archiveNode.cc:1473:    	if ( this[01;31m-[00m>hasChildWithUniqueId(uid) ) {
archiveNode.cc:1474:	    childNode = this[01;31m-[00m>childWithUniqueId(uid);
archiveNode.cc:1475:	    vector<double> dvec = childNode[01;31m-[00m>getDataAsVectorOfDoubles();
archiveNode.cc:1477:	    childNode[01;31m-[00m>setRecognized(true);
archiveNode.cc:1486:{_F(this[01;31m-[00m>lisp());
archiveNode.cc:1487:    if ( this[01;31m-[00m>saving() ) {
archiveNode.cc:1494:	    newNode = this[01;31m-[00m>getArchive()[01;31m-[00m>newArchiveNode();
archiveNode.cc:1495:	    newNode[01;31m-[00m>setClasslessNodeName("VectorInt");
archiveNode.cc:1496:	    newNode[01;31m-[00m>setTextUniqueId(uid);
archiveNode.cc:1497:	    newNode[01;31m-[00m>setCharacters(ss.str());
archiveNode.cc:1498:	    this[01;31m-[00m>addChild(newNode);
archiveNode.cc:1502:    	if ( this[01;31m-[00m>hasChildWithUniqueId(uid) ) {
archiveNode.cc:1503:	    childNode = this[01;31m-[00m>childWithUniqueId(uid);
archiveNode.cc:1504:	    vector<int> dvec = childNode[01;31m-[00m>getDataAsVectorOfInts();
archiveNode.cc:1506:	    childNode[01;31m-[00m>setRecognized(true);
archiveNode.cc:1518:    ss = O_StringSet::create(this[01;31m-[00m>lisp());
archiveNode.cc:1519:    const string& s = this[01;31m-[00m>characters();
archiveNode.cc:1531:	stop = cur[01;31m-[00m1;
archiveNode.cc:1532:	ss[01;31m-[00m>insert(s.substr(start,stop[01;31m-[00mstart+1));
archiveNode.cc:1542:    const string& s = this[01;31m-[00m>characters();
archiveNode.cc:1554:	stop = cur[01;31m-[00m1;
archiveNode.cc:1555:	vs.push_back(s.substr(start,stop[01;31m-[00mstart+1));
archiveNode.cc:1565:    const string& s = this[01;31m-[00m>characters();
archiveNode.cc:1576:	stop = cur[01;31m-[00m1;
archiveNode.cc:1577:	string dbl = s.substr(start,stop[01;31m-[00mstart+1);
archiveNode.cc:1589:    const string& s = this[01;31m-[00m>characters();
archiveNode.cc:1600:	stop = cur[01;31m-[00m1;
archiveNode.cc:1601:	string istr = s.substr(start,stop[01;31m-[00mstart+1);
archiveNode.cc:1608:{_F(this[01;31m-[00m>lisp());
archiveNode.cc:1609:    if ( this[01;31m-[00m>saving() ) {
archiveNode.cc:1611:	newNode = this[01;31m-[00m>getArchive()[01;31m-[00m>newArchiveNode();
archiveNode.cc:1612:	newNode[01;31m-[00m>setClasslessNodeName("podString");
archiveNode.cc:1613:	newNode[01;31m-[00m>setTextUniqueId(uid);
archiveNode.cc:1614:	newNode[01;31m-[00m>setCharacters(vec);
archiveNode.cc:1615:	this[01;31m-[00m>addChild(newNode);
archiveNode.cc:1618:    	if ( this[01;31m-[00m>hasChildWithUniqueId(uid) ) {
archiveNode.cc:1619:	    childNode = this[01;31m-[00m>childWithUniqueId(uid);
archiveNode.cc:1620:	    ASSERT(childNode[01;31m-[00m>isNamed("podString"));
archiveNode.cc:1621:	    vec = childNode[01;31m-[00m>characters();
archiveNode.cc:1622:	    childNode[01;31m-[00m>setRecognized(true);
archiveNode.cc:1630:{_F(this[01;31m-[00m>lisp());
archiveNode.cc:1631:    if ( this[01;31m-[00m>saving() ) {
archiveNode.cc:1635:	    newNode = this[01;31m-[00m>getArchive()[01;31m-[00m>newArchiveNode();
archiveNode.cc:1636:	    newNode[01;31m-[00m>setClasslessNodeName("podString");
archiveNode.cc:1637:	    newNode[01;31m-[00m>setTextUniqueId(uid);
archiveNode.cc:1638:	    newNode[01;31m-[00m>setCharacters(vec);
archiveNode.cc:1639:	    this[01;31m-[00m>addChild(newNode);
archiveNode.cc:1643:    	if ( this[01;31m-[00m>hasChildWithUniqueId(uid) ) {
archiveNode.cc:1644:	    childNode = this[01;31m-[00m>childWithUniqueId(uid);
archiveNode.cc:1645:	    ASSERT(childNode[01;31m-[00m>isNamed("podString"));
archiveNode.cc:1646:	    vec = childNode[01;31m-[00m>characters();
archiveNode.cc:1647:	    childNode[01;31m-[00m>setRecognized(true);
archiveNode.cc:1657:    if ( this[01;31m-[00m>saving() ) {
archiveNode.cc:1659:	newNode = this[01;31m-[00m>getArchive()[01;31m-[00m>newArchiveNode();
archiveNode.cc:1660:	newNode[01;31m-[00m>setClasslessNodeName("podStream");
archiveNode.cc:1661:	newNode[01;31m-[00m>setTextUniqueId(uid);
archiveNode.cc:1662:	newNode[01;31m-[00m>setCharacters(vec.str());
archiveNode.cc:1663:	this[01;31m-[00m>addChild(newNode);
archiveNode.cc:1666:    	if ( this[01;31m-[00m>hasChildWithUniqueId(uid) ) {
archiveNode.cc:1667:	    childNode = this[01;31m-[00m>childWithUniqueId(uid);
archiveNode.cc:1668:	    ASSERT(childNode[01;31m-[00m>isNamed("Stream"));
archiveNode.cc:1669:	    vec.str(childNode[01;31m-[00m>characters());
archiveNode.cc:1670:	    childNode[01;31m-[00m>setRecognized(true);
archiveNode.cc:1680:    if ( this[01;31m-[00m>saving() ) {
archiveNode.cc:1683:	newNode = this[01;31m-[00m>getArchive()[01;31m-[00m>newArchiveNode();
archiveNode.cc:1684:	newNode[01;31m-[00m>setClasslessNodeName("podStream");
archiveNode.cc:1685:	newNode[01;31m-[00m>setTextUniqueId(uid);
archiveNode.cc:1686:	newNode[01;31m-[00m>setCharacters(vec.str());
archiveNode.cc:1687:	this[01;31m-[00m>addChild(newNode);
archiveNode.cc:1690:    	if ( this[01;31m-[00m>hasChildWithUniqueId(uid) ) {
archiveNode.cc:1691:	    childNode = this[01;31m-[00m>childWithUniqueId(uid);
archiveNode.cc:1692:	    ASSERTP(childNode[01;31m-[00m>isNamed("podStream"),"Expected node with name(podStream) but found name("+childNode[01;31m-[00m>getNodeName()+")");
archiveNode.cc:1693:	    vec.str(childNode[01;31m-[00m>characters());
archiveNode.cc:1694:	    childNode[01;31m-[00m>setRecognized(true);
archiveNodeWrite.cc:13:{ _F(this[01;31m-[00m>lisp());
archiveNodeWrite.cc:17:    destinationToRoot = this[01;31m-[00m>pathFromNodeToRoot(this);
archiveNodeWrite.cc:18:    sourceToRoot = this[01;31m-[00m>pathFromNodeToRoot(fromNode);
archiveNodeWrite.cc:25:	    path << i << ":" << destinationToRoot[i][01;31m-[00m>getUniqueId() << " [01;31m-[00m ";
archiveNodeWrite.cc:31:	    path << i << ":" << sourceToRoot[i][01;31m-[00m>getUniqueId() << " [01;31m-[00m ";
archiveNodeWrite.cc:36:    int iD = destinationToRoot.size()[01;31m-[00m1;
archiveNodeWrite.cc:37:    int iS = sourceToRoot.size()[01;31m-[00m1;
archiveNodeWrite.cc:41:        LOG(BF("Found common node: %s  iD(%d) iS(%d)") % destinationToRoot[iD][01;31m-[00m>getUniqueId().c_str() % iD % iS ); // vp0(( "Found common node: %s  iD(%d) iS(%d)", destinationToRoot[iD][01;31m-[00m>getUniqueId().c_str(),iD,iS));
archiveNodeWrite.cc:42:	iD[01;31m-[00m[01;31m-[00m;
archiveNodeWrite.cc:43:	iS[01;31m-[00m[01;31m-[00m;
archiveNodeWrite.cc:53:	    iS[01;31m-[00m[01;31m-[00m;
archiveNodeWrite.cc:69:	        path << destinationToRoot[iD][01;31m-[00m>getUniqueIdCharactersIfMissingThrow();
archiveNodeWrite.cc:72:	        TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(e.message()+"\nError while creating a path from node",fromNode));
archiveNodeWrite.cc:74:	    iD[01;31m-[00m[01;31m-[00m;
archiveNodeWrite.cc:83:    LOG(BF("First difference in path destinationToRoot(%s)") % destinationToRoot[iD][01;31m-[00m>getUniqueId().c_str()  ); // vp0(( "First difference in path destinationToRoot(%s)", destinationToRoot[iD][01;31m-[00m>getUniqueId().c_str() ));
archiveNodeWrite.cc:84:    LOG(BF("First difference in path sourceToRoot(%s)") % sourceToRoot[iS][01;31m-[00m>getUniqueId().c_str() ); // vp0(( "First difference in path sourceToRoot(%s)", sourceToRoot[iS][01;31m-[00m>getUniqueId().c_str()));
archiveNodeWrite.cc:92:	if ( this[01;31m-[00m>getArchive()[01;31m-[00m>debugEnabled() ) {
archiveNodeWrite.cc:95:	    // path << " " << sourceToRoot[0][01;31m-[00m>getUniqueId();
archiveNodeWrite.cc:98:	        path << " " << sourceToRoot[0][01;31m-[00m>getUniqueIdCharactersIfMissingThrow();
archiveNodeWrite.cc:107:	if ( this[01;31m-[00m>getArchive()[01;31m-[00m>debugEnabled() ) {
archiveNodeWrite.cc:112:	        path << " " << sourceToRoot[1][01;31m-[00m>getUniqueIdCharactersIfMissingThrow();
archiveNodeWrite.cc:123:	if ( this[01;31m-[00m>getArchive()[01;31m-[00m>debugEnabled() ) {
archiveNodeWrite.cc:126:	    // path << " " << sourceToRoot[i+1][01;31m-[00m>getUniqueId();
archiveNodeWrite.cc:129:	        path << " " << sourceToRoot[i+1][01;31m-[00m>getUniqueIdCharactersIfMissingThrow();
archiveNodeWrite.cc:132:	        TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(e.message()+"\nError while creating a path from node",fromNode));
archiveNodeWrite.cc:140:    for ( i=iD[01;31m-[00m1; i>=0; i[01;31m-[00m[01;31m-[00m ) {
archiveNodeWrite.cc:143:	path << "/" << oneNode[01;31m-[00m>getUniqueIdCharacters();
archiveNodeWrite.cc:144:	if ( this[01;31m-[00m>getArchive()[01;31m-[00m>debugEnabled() ) {
archiveNodeWrite.cc:146:	    // path << " " << destinationToRoot[i][01;31m-[00m>getUniqueId();
archiveNodeWrite.cc:149:	        path << " " << destinationToRoot[i][01;31m-[00m>getUniqueIdCharactersIfMissingThrow();
archiveNodeWrite.cc:152:	        TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(e.message()+"\nError while creating a path from node",fromNode));
argumentHandler.cc:23:    class_<O_ArgumentHandler>(e[01;31m-[00m>lisp())
argumentHandler.cc:43:    RPCons sscons = reader[01;31m-[00m>read()[01;31m-[00m>as<O_Cons>();
argumentHandler.cc:44:    reader[01;31m-[00m>close();
argumentHandler.cc:45:    RPArgumentHandler ah = lisp[01;31m-[00m>create<O_ArgumentHandler>();
argumentHandler.cc:46:    ah[01;31m-[00m>setupArgumentHandling(sscons);
argumentHandler.cc:47:    ah[01;31m-[00m>setArgumentString(argumentsInString);
argumentHandler.cc:54:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
argumentHandler.cc:60:    this[01;31m-[00m>Base::initialize();
argumentHandler.cc:61:    this[01;31m-[00m>_Rest = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Symbol>();
argumentHandler.cc:62:    this[01;31m-[00m>_KeyedArgumentsWithDefaults = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Binder>();
argumentHandler.cc:63:    this[01;31m-[00m>_AddArgumentMode = required;
argumentHandler.cc:69:    this[01;31m-[00m>Base::archiveBase(node);
argumentHandler.cc:77:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:78:    RPEnvironment newEnviron = O_Environment::create(environ,this[01;31m-[00m>lisp());
argumentHandler.cc:79:    this[01;31m-[00m>populateLocalEnvironment(args,newEnviron);
argumentHandler.cc:86:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:87:    ASSERTP(!symbol[01;31m-[00m>isKeywordSymbol(), "Do not use keyword symbols when specifying arguments");
argumentHandler.cc:88:    LOG(BF("It is a symbol: %s %X") % symbol[01;31m-[00m>__repr__() % symbol.get() );
argumentHandler.cc:89:    if ( symbol[01;31m-[00m>isAmpSymbol() )
argumentHandler.cc:92:	switch (this[01;31m-[00m>_AddArgumentMode)
argumentHandler.cc:96:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpOptionalSymbol() )
argumentHandler.cc:99:		    this[01;31m-[00m>_AddArgumentMode = optional;
argumentHandler.cc:101:		} else if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpRestSymbol() )
argumentHandler.cc:103:		    LOG(BF("Argument handling this[01;31m-[00m>_AddArgumentMode switched to (rest)"));
argumentHandler.cc:104:		    this[01;31m-[00m>_AddArgumentMode = rest;
argumentHandler.cc:106:		} else if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpKeySymbol() )
argumentHandler.cc:108:		    LOG(BF("Argument handling this[01;31m-[00m>_AddArgumentMode switched to (keyword)"));
argumentHandler.cc:109:		    this[01;31m-[00m>_AddArgumentMode = keyword;
argumentHandler.cc:112:		LOG(BF("Did not recognize symbol(%s)")%symbol[01;31m-[00m>fullName());
argumentHandler.cc:113:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Did not recognize symbol(%s)")%symbol[01;31m-[00m>fullName()));
argumentHandler.cc:117:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpOptionalSymbol() )
argumentHandler.cc:119:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Duplicate optional argument"));
argumentHandler.cc:121:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpRestSymbol() )
argumentHandler.cc:123:		    LOG(BF("Argument handling this[01;31m-[00m>_AddArgumentMode switched to (rest)"));
argumentHandler.cc:124:		    this[01;31m-[00m>_AddArgumentMode = rest;
argumentHandler.cc:127:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpKeySymbol() )
argumentHandler.cc:129:		    LOG(BF("Argument handling this[01;31m-[00m>_AddArgumentMode switched to (keyword)"));
argumentHandler.cc:130:		    this[01;31m-[00m>_AddArgumentMode = keyword;
argumentHandler.cc:133:		LOG(BF("Did not recognize symbol(%s)")%symbol[01;31m-[00m>fullName());
argumentHandler.cc:134:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Did not recognize symbol(%s)")%symbol[01;31m-[00m>fullName()));
argumentHandler.cc:138:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpOptionalSymbol() )
argumentHandler.cc:140:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("&optional argument specified after &rest is illegal"));
argumentHandler.cc:142:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpRestSymbol() )
argumentHandler.cc:144:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Duplicate &rest argument"));
argumentHandler.cc:146:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpKeySymbol() )
argumentHandler.cc:148:		    LOG(BF("Argument handling this[01;31m-[00m>_AddArgumentMode switched to (keyword)"));
argumentHandler.cc:149:		    this[01;31m-[00m>_AddArgumentMode = keyword;
argumentHandler.cc:152:		LOG(BF("Did not recognize symbol(%s)")%symbol[01;31m-[00m>fullName());
argumentHandler.cc:153:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Did not recognize symbol(%s)")%symbol[01;31m-[00m>fullName()));
argumentHandler.cc:157:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpOptionalSymbol() )
argumentHandler.cc:159:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("&optional argument specified after &key is illegal"));
argumentHandler.cc:161:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpRestSymbol() )
argumentHandler.cc:163:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("&rest argument after &key is illegal"));
argumentHandler.cc:165:		if ( symbol == this[01;31m-[00m>lisp()[01;31m-[00m>getAmpKeySymbol() )
argumentHandler.cc:167:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Duplicate &key argument"));
argumentHandler.cc:169:		LOG(BF("Did not recognize symbol(%s)")%symbol[01;31m-[00m>fullName());
argumentHandler.cc:170:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Did not recognize symbol(%s)")%symbol[01;31m-[00m>fullName()));
argumentHandler.cc:173:	    	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Argument handling was attempted when the ArgumentHandler setup was complete"));
argumentHandler.cc:186:    switch (this[01;31m-[00m>_AddArgumentMode)
argumentHandler.cc:199:    return "[01;31m-[00munknownAddArgumentMode[01;31m-[00m";
argumentHandler.cc:207:    for ( List<O_Symbol>::iterator ri=this[01;31m-[00m>_RequiredArguments.begin(); ri!=this[01;31m-[00m>_RequiredArguments.end(); ri++ )
argumentHandler.cc:209:	ss << (*ri)[01;31m-[00m>__repr__() << " ";
argumentHandler.cc:211:    if ( this[01;31m-[00m>_OptionalArguments.size() > 0 )
argumentHandler.cc:214:	for ( List<O_Cons>::iterator oi=this[01;31m-[00m>_OptionalArguments.begin(); oi!=this[01;31m-[00m>_OptionalArguments.end(); oi++ )
argumentHandler.cc:216:	    RPSymbol symbol = (*oi)[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:217:	    RPObject defaultValue = (*oi)[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Object>();
argumentHandler.cc:218:	    RPSymbol supplied = (*oi)[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:220:	    ss << symbol[01;31m-[00m>__repr__() << " ";
argumentHandler.cc:221:	    ss << defaultValue[01;31m-[00m>__repr__() << " ";
argumentHandler.cc:222:	    if ( supplied[01;31m-[00m>notNil() ) ss << supplied[01;31m-[00m>__repr__() << " ";
argumentHandler.cc:226:    if ( this[01;31m-[00m>_Rest[01;31m-[00m>notNil() )
argumentHandler.cc:228:	ss << "&rest " << this[01;31m-[00m>_Rest[01;31m-[00m>__repr__() << " ";
argumentHandler.cc:230:    if ( this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>size() != 0 )
argumentHandler.cc:233:	for ( O_Binder::iterator ki=this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>begin();
argumentHandler.cc:234:			ki!=this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>end(); ki++ )
argumentHandler.cc:237:	    RPCons parts = ki[01;31m-[00m>second[01;31m-[00m>as<O_Cons>();
argumentHandler.cc:238:	    ss << parts[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>()[01;31m-[00m>__repr__() << " ";
argumentHandler.cc:239:	    ss << parts[01;31m-[00m>ocadr()[01;31m-[00m>__repr__() << " ";
argumentHandler.cc:240:	    if ( parts[01;31m-[00m>ocaddr()[01;31m-[00m>notNil() )
argumentHandler.cc:242:		ss << parts[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Symbol>()[01;31m-[00m>__repr__() << " ";
argumentHandler.cc:254:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:255:    if ( this[01;31m-[00m>_AddArgumentMode != required )
argumentHandler.cc:257:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You tried to add the required argument(%s) when the ArgumentHandler was in mode(%s)")%sym[01;31m-[00m>fullName()%this[01;31m-[00m>addArgumentModeAsString() ));
argumentHandler.cc:259:    this[01;31m-[00m>_RequiredArguments.push_back(sym);
argumentHandler.cc:265:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:266:    if ( this[01;31m-[00m>_AddArgumentMode != optional )
argumentHandler.cc:268:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You tried to add optional argument(%s) when the ArgumentHandler was in mode(%s)")%sym[01;31m-[00m>fullName()%this[01;31m-[00m>addArgumentModeAsString() ));
argumentHandler.cc:270:    RPCons entry = O_Cons::createList(sym,defaultValue,sensorName,this[01;31m-[00m>lisp());
argumentHandler.cc:271:    this[01;31m-[00m>_OptionalArguments.push_back(entry);
argumentHandler.cc:277:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:278:    ASSERTP(this[01;31m-[00m>_Rest[01;31m-[00m>isNil(),"The &rest argument has already been defined");
argumentHandler.cc:279:    this[01;31m-[00m>_Rest = sym;
argumentHandler.cc:285:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:286:    RPCons entry = O_Cons::createList(local,defaultValue,sensor,this[01;31m-[00m>lisp());
argumentHandler.cc:287:    this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>extend(key,entry);
argumentHandler.cc:296:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:297:    LOG(BF("Argument handling mode starts in (required) [01;31m-[00m interpreting: %s") % arguments[01;31m-[00m>__repr__() );
argumentHandler.cc:298:    this[01;31m-[00m>_AddArgumentMode = required;
argumentHandler.cc:299:    RPLisp lisp = this[01;31m-[00m>lisp();
argumentHandler.cc:300:    this[01;31m-[00m>_Rest = lisp[01;31m-[00m>nil<O_Symbol>();
argumentHandler.cc:301:    this[01;31m-[00m>_KeyedArgumentsWithDefaults = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Binder>();
argumentHandler.cc:302:    for ( RPCons cur = arguments; cur[01;31m-[00m>notNil(); cur=cur[01;31m-[00m>cdr() )
argumentHandler.cc:304:	LOG(BF("Handing argument: %s")%cur[01;31m-[00m>ocar()[01;31m-[00m>__repr__() );
argumentHandler.cc:305:	RPObject oarg = cur[01;31m-[00m>ocar();
argumentHandler.cc:306:	if ( oarg[01;31m-[00m>isAssignableTo<O_Symbol>() )
argumentHandler.cc:308:	    RPSymbol sym = oarg[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:309:	    if ( this[01;31m-[00m>switchAddArgumentMode(sym) ) continue;
argumentHandler.cc:314:	switch ( this[01;31m-[00m>_AddArgumentMode )
argumentHandler.cc:318:	    	RPSymbol sarg = oarg[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:319:		this[01;31m-[00m>addRequired(sarg);
argumentHandler.cc:324:		RPSymbol sarg = O_Symbol::nil(this[01;31m-[00m>lisp());
argumentHandler.cc:325:		RPObject defaultValue = O_Object::nil(this[01;31m-[00m>lisp());
argumentHandler.cc:326:		RPSymbol supplied = O_Symbol::nil(this[01;31m-[00m>lisp());
argumentHandler.cc:327:		if ( oarg[01;31m-[00m>isAssignableTo<O_Symbol>() )
argumentHandler.cc:329:		    sarg = oarg[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:330:		} else if ( oarg[01;31m-[00m>isAssignableTo<O_Cons>() )
argumentHandler.cc:332:		    RPCons carg = oarg[01;31m-[00m>as<O_Cons>();
argumentHandler.cc:333:		    sarg = carg[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:334:		    if ( carg[01;31m-[00m>cdr()[01;31m-[00m>notNil() )
argumentHandler.cc:336:			defaultValue = carg[01;31m-[00m>ocadr();
argumentHandler.cc:337:			if ( carg[01;31m-[00m>cddr()[01;31m-[00m>notNil() )
argumentHandler.cc:339:			    supplied = carg[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:343:		LOG(BF("Saving _OptionalArgument(%s) default(%s) supplied(%s)")% sarg[01;31m-[00m>__repr__() % defaultValue[01;31m-[00m>__repr__() % supplied[01;31m-[00m>__repr__() );
argumentHandler.cc:344:		this[01;31m-[00m>addOptional(sarg,defaultValue,supplied);
argumentHandler.cc:349:	    	RPSymbol sarg = oarg[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:350:		LOG(BF("Saving _Rest argument: %s")% sarg[01;31m-[00m>__repr__() );
argumentHandler.cc:351:		if ( this[01;31m-[00m>_Rest[01;31m-[00m>notNil() )
argumentHandler.cc:353:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Only one name is allowed after &rest"));
argumentHandler.cc:355:		this[01;31m-[00m>addRest(sarg);
argumentHandler.cc:360:		RPSymbol keySymbol = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Symbol>();
argumentHandler.cc:361:		RPSymbol localSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Symbol>();
argumentHandler.cc:362:		RPObject defaultValue = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Object>();
argumentHandler.cc:363:		RPSymbol sensorSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Symbol>();
argumentHandler.cc:364:	    	if ( oarg[01;31m-[00m>isAssignableTo<O_Symbol>() )
argumentHandler.cc:366:		    localSymbol = oarg[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:367:		    keySymbol = localSymbol[01;31m-[00m>asKeywordSymbol();
argumentHandler.cc:368:		} else if ( oarg[01;31m-[00m>isAssignableTo<O_Cons>() )
argumentHandler.cc:370:		    RPCons carg = oarg[01;31m-[00m>as<O_Cons>();
argumentHandler.cc:371:		    RPObject head = carg[01;31m-[00m>ocar();
argumentHandler.cc:372:		    if ( head[01;31m-[00m>isAssignableTo<O_Symbol>() )
argumentHandler.cc:374:			localSymbol = head[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:375:		        ASSERTP(!localSymbol[01;31m-[00m>isKeywordSymbol(), "Do not use keyword symbols when specifying arguments");
argumentHandler.cc:376:			keySymbol = localSymbol[01;31m-[00m>asKeywordSymbol();
argumentHandler.cc:377:		    } else if ( head[01;31m-[00m>isAssignableTo<O_Cons>() )
argumentHandler.cc:379:			RPCons namePart = head[01;31m-[00m>as<O_Cons>();
argumentHandler.cc:380:			keySymbol = namePart[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();			// This is the keyword name
argumentHandler.cc:381:			ASSERTP(keySymbol[01;31m-[00m>isKeywordSymbol(),"with key arguments of the form ((:x y) ...) the first argument must be a symbol");
argumentHandler.cc:382:			localSymbol = namePart[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Symbol>();		 // this is the symbol to rename it to
argumentHandler.cc:383:		        ASSERTP(!localSymbol[01;31m-[00m>isKeywordSymbol(), "Do not use keyword symbols when specifying local argument names");
argumentHandler.cc:388:		    if (carg[01;31m-[00m>cdr()[01;31m-[00m>notNil() )
argumentHandler.cc:390:			defaultValue = carg[01;31m-[00m>ocadr();
argumentHandler.cc:391:			if ( carg[01;31m-[00m>cddr()[01;31m-[00m>notNil() )
argumentHandler.cc:393:			    sensorSymbol = carg[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:394:			    ASSERTP(!sensorSymbol[01;31m-[00m>isKeywordSymbol(), "Do not use keyword symbols when specifying local argument names");
argumentHandler.cc:399:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("key arguments must be symbol or cons"));
argumentHandler.cc:401:		LOG(BF("Saving keyword(%s) local(%s) default(%s) sensor(%s)")% keySymbol[01;31m-[00m>__repr__()% localSymbol[01;31m-[00m>__repr__()% defaultValue[01;31m-[00m>__repr__()% sensorSymbol[01;31m-[00m>__repr__() );
argumentHandler.cc:402:		this[01;31m-[00m>addKey(keySymbol,localSymbol,defaultValue,sensorSymbol);
argumentHandler.cc:406:	    	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You are adding arguments when argument processing is complete"));
argumentHandler.cc:416:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(name);
argumentHandler.cc:417:    ASSERT(!sym[01;31m-[00m>isKeywordSymbol());
argumentHandler.cc:418:    return this[01;31m-[00m>addRequired(sym);
argumentHandler.cc:423:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(name);
argumentHandler.cc:424:    ASSERT(!sym[01;31m-[00m>isKeywordSymbol());
argumentHandler.cc:425:    return this[01;31m-[00m>addOptional(sym,this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Object>(),this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Symbol>());
argumentHandler.cc:431:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(name);
argumentHandler.cc:432:    ASSERT(!sym[01;31m-[00m>isKeywordSymbol());
argumentHandler.cc:433:    RPSymbol sensor = this[01;31m-[00m>lisp()[01;31m-[00m>intern(sensorName);
argumentHandler.cc:434:    ASSERT(!sensor[01;31m-[00m>isKeywordSymbol());
argumentHandler.cc:435:    return this[01;31m-[00m>addOptional(sym,this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Object>(),sensor);
argumentHandler.cc:441:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(name);
argumentHandler.cc:442:    ASSERT(!sym[01;31m-[00m>isKeywordSymbol());
argumentHandler.cc:443:    return this[01;31m-[00m>addRest(sym);
argumentHandler.cc:448:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:449:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(name);
argumentHandler.cc:450:    ASSERT(!sym[01;31m-[00m>isKeywordSymbol());
argumentHandler.cc:451:    RPSymbol key = sym[01;31m-[00m>asKeywordSymbol();
argumentHandler.cc:452:    return this[01;31m-[00m>addKey(key,sym,this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Object>(),this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Symbol>());
argumentHandler.cc:457:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:458:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(name);
argumentHandler.cc:459:    ASSERT(!sym[01;31m-[00m>isKeywordSymbol());
argumentHandler.cc:460:    RPSymbol sensor = this[01;31m-[00m>lisp()[01;31m-[00m>intern(sensorName);
argumentHandler.cc:461:    ASSERT(!sensor[01;31m-[00m>isKeywordSymbol());
argumentHandler.cc:462:    RPSymbol key = sym[01;31m-[00m>asKeywordSymbol();
argumentHandler.cc:463:    return this[01;31m-[00m>addKey(key,sym,this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Object>(),sensor);
argumentHandler.cc:469:{_F(this[01;31m-[00m>lisp());
argumentHandler.cc:472:        LOG(BF("There are %d positional arguments") % this[01;31m-[00m>_RequiredArguments.size() );
argumentHandler.cc:473:	for ( List<O_Symbol>::iterator pi = this[01;31m-[00m>_RequiredArguments.begin();
argumentHandler.cc:474:	    pi!=this[01;31m-[00m>_RequiredArguments.end(); pi++ )
argumentHandler.cc:476:	    LOG(BF("Checking if cur[01;31m-[00m>isNil() = %d") % cur[01;31m-[00m>isNil() );
argumentHandler.cc:477:	    if ( cur[01;31m-[00m>isNil() )
argumentHandler.cc:480:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Missing positional argument (%s) [01;31m-[00m expected in argument list: %s") % (*pi)[01;31m-[00m>currentName() % this[01;31m-[00m>asArgumentString() ));
argumentHandler.cc:482:	    RPObject value = cur[01;31m-[00m>ocar();
argumentHandler.cc:483:	    LOG(BF("Updating Binder symbol=%s") % (*pi)[01;31m-[00m>__repr__());
argumentHandler.cc:484:	    LOG(BF("Value it will be assigned: %s") % value[01;31m-[00m>__repr__() );
argumentHandler.cc:486:	    ASSERTP(environment[01;31m-[00m>notNil(),"The Environmentis nil! [01;31m-[00m this should never happen");
argumentHandler.cc:487:	    LOG(BF("The environment currently contains: %s") % environment[01;31m-[00m>summaryOfContents() );
argumentHandler.cc:488:	    environment[01;31m-[00m>extend(*pi,value);
argumentHandler.cc:489:	    LOG(BF("Assigned required argument(%s) value(%s)") % (*pi)[01;31m-[00m>__repr__() % cur[01;31m-[00m>ocar()[01;31m-[00m>__repr__() );
argumentHandler.cc:490:	    cur = cur[01;31m-[00m>cdr();
argumentHandler.cc:494:        LOG(BF("There are %d optional arguments") % this[01;31m-[00m>_OptionalArguments.size() );
argumentHandler.cc:495:	for ( List<O_Cons>::iterator oi = this[01;31m-[00m>_OptionalArguments.begin();
argumentHandler.cc:496:	    oi!=this[01;31m-[00m>_OptionalArguments.end(); oi++ )
argumentHandler.cc:499:	    RPSymbol symbolName = optCons[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>(); // will it be in the correct package?
argumentHandler.cc:500:	    RPObject defaultValue = eval::evaluate(optCons[01;31m-[00m>ocadr(),environment,this[01;31m-[00m>lisp());
argumentHandler.cc:501:	    RPSymbol providedName = optCons[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:502:	    if ( cur[01;31m-[00m>notNil() )
argumentHandler.cc:504:		environment[01;31m-[00m>extend(optCons[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>(),cur[01;31m-[00m>ocar());
argumentHandler.cc:505:		LOG(BF("Assigning required argument(%s) value(%s)") % (optCons[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>())[01;31m-[00m>__repr__() % cur[01;31m-[00m>ocar()[01;31m-[00m>__repr__() );
argumentHandler.cc:506:		if ( providedName[01;31m-[00m>notNil() )
argumentHandler.cc:508:		    environment[01;31m-[00m>extend(providedName,this[01;31m-[00m>lisp()[01;31m-[00m>_true());
argumentHandler.cc:512:		environment[01;31m-[00m>extend(optCons[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>(),defaultValue);
argumentHandler.cc:513:		LOG(BF("Assigning required argument(%s) default value(%s)") % (optCons[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>())[01;31m-[00m>__repr__() % defaultValue[01;31m-[00m>__repr__() );
argumentHandler.cc:514:		if ( providedName[01;31m-[00m>notNil() )
argumentHandler.cc:516:		    environment[01;31m-[00m>extend(providedName,this[01;31m-[00m>lisp()[01;31m-[00m>_false());
argumentHandler.cc:519:	    if ( cur[01;31m-[00m>notNil() ) cur = cur[01;31m-[00m>cdr();
argumentHandler.cc:522:    if ( this[01;31m-[00m>_Rest[01;31m-[00m>notNil() )
argumentHandler.cc:524:	environment[01;31m-[00m>extend(this[01;31m-[00m>_Rest,cur);
argumentHandler.cc:526:    if ( this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>size() > 0 )
argumentHandler.cc:531:	for ( O_Binder::iterator bi=this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>begin(); 
argumentHandler.cc:532:		bi!=this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>end(); bi++ )
argumentHandler.cc:534:	    RPSymbol kw = bi[01;31m-[00m>second[01;31m-[00m>as<O_Cons>()[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:535:	    RPObject value = eval::evaluate(bi[01;31m-[00m>second[01;31m-[00m>as<O_Cons>()[01;31m-[00m>ocadr(),environment,this[01;31m-[00m>lisp());
argumentHandler.cc:536:	    RPSymbol supplied = bi[01;31m-[00m>second[01;31m-[00m>as<O_Cons>()[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:537:	    environment[01;31m-[00m>extend(kw,value);
argumentHandler.cc:538:	    LOG(BF("defining default value for variable(%s) as value(%s)")%kw[01;31m-[00m>__repr__() % value[01;31m-[00m>__repr__() );
argumentHandler.cc:539:	    if ( supplied[01;31m-[00m>notNil() )
argumentHandler.cc:541:		environment[01;31m-[00m>extend(supplied,this[01;31m-[00m>lisp()[01;31m-[00m>_false());
argumentHandler.cc:542:		LOG(BF("defining supplied variable(%s) as false") % supplied[01;31m-[00m>__repr__() );
argumentHandler.cc:546:	    while (cur[01;31m-[00m>notNil())
argumentHandler.cc:548:		if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
argumentHandler.cc:550:		    RPSymbol keyword = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:551:		    if ( cur[01;31m-[00m>cdr()[01;31m-[00m>isNil() )
argumentHandler.cc:553:			TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Keyword parameter(%s) is missing its value")%keyword[01;31m-[00m>__repr__()));
argumentHandler.cc:555:		    if ( !keyword[01;31m-[00m>isKeywordSymbol() )
argumentHandler.cc:557:			TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("illegal symbol(%s) must be a keyword symbol")%keyword[01;31m-[00m>currentName()));
argumentHandler.cc:559:		    cur = cur[01;31m-[00m>cdr();
argumentHandler.cc:560:		    RPObject value = cur[01;31m-[00m>ocar();
argumentHandler.cc:561:		    cur = cur[01;31m-[00m>cdr();
argumentHandler.cc:562:		    O_Binder::iterator fi = this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>find(keyword);
argumentHandler.cc:563:		    if ( fi == this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>end() )
argumentHandler.cc:565:			TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("unexpected keyed argument(%s)")%keyword[01;31m-[00m>currentName()));
argumentHandler.cc:566:			TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("unexpected keyed argument(%s)")%keyword[01;31m-[00m>currentName()));
argumentHandler.cc:568:		    RPCons entry = fi[01;31m-[00m>second[01;31m-[00m>as<O_Cons>();
argumentHandler.cc:569:		    RPSymbol localName = entry[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:570:		    RPSymbol suppliedName = entry[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Symbol>();
argumentHandler.cc:571:		    environment[01;31m-[00m>extend(localName,value);
argumentHandler.cc:572:		    if ( suppliedName[01;31m-[00m>notNil() )
argumentHandler.cc:574:			environment[01;31m-[00m>extend(suppliedName,this[01;31m-[00m>lisp()[01;31m-[00m>_true());
argumentHandler.cc:578:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Expecting a keyed argument from the list(%s) got(%s)") % this[01;31m-[00m>_KeyedArgumentsWithDefaults[01;31m-[00m>allKeysAsString() % cur[01;31m-[00m>__repr__() ));
argumentHandler.cc:586:    if ( cur[01;31m-[00m>notNil() && this[01;31m-[00m>_Rest[01;31m-[00m>isNil() )
argumentHandler.cc:588:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("There are too many arguments [01;31m-[00m expected(%s) was passed(%s)") % this[01;31m-[00m>asArgumentString() % args[01;31m-[00m>__repr__() ));
arrayedMatter.cc:28:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
arrayedMatter.cc:34:    this[01;31m-[00m>Base::initialize();
arrayedMatter.cc:35:    this[01;31m-[00m>_AtomLabel = "";
arrayedMatter.cc:36:    this[01;31m-[00m>_Atom.reset();
arrayedMatter.cc:41:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_AtomLabel);
arrayedMatter.cc:42:    node[01;31m-[00m>archiveWeakPointer("atom",this[01;31m-[00m>_Atom);
arrayedMatter.cc:47:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:48:    this[01;31m-[00m>_AtomLabel = a[01;31m-[00m>getName();
arrayedMatter.cc:49:    this[01;31m-[00m>_Atom = a;
arrayedMatter.cc:54:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:56:    for ( string::iterator it=this[01;31m-[00m>_AtomLabel.begin();
arrayedMatter.cc:57:    	it !=this[01;31m-[00m>_AtomLabel.end(); it++ )
arrayedMatter.cc:68:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:69:    ASSERT(this[01;31m-[00m>_Atom.use_count()!=0);
arrayedMatter.cc:70:    this[01;31m-[00m>_Atom.lock()[01;31m-[00m>setPosition(h[01;31m-[00m>getElement(idx));
arrayedMatter.cc:74:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:75:    ASSERT(this[01;31m-[00m>_Atom.use_count()!=0);
arrayedMatter.cc:76:    h[01;31m-[00m>setElement(idx,this[01;31m-[00m>_Atom.lock()[01;31m-[00m>getPosition());
arrayedMatter.cc:87:	class_<O_ArrayedAtom>(this[01;31m-[00m>lisp())
arrayedMatter.cc:115:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
arrayedMatter.cc:121:    this[01;31m-[00m>Base::initialize();
arrayedMatter.cc:122:    this[01;31m-[00m>_ResidueLabel = "";
arrayedMatter.cc:123:    this[01;31m-[00m>_Residue.reset();
arrayedMatter.cc:124:    this[01;31m-[00m>_SortedAtoms.clear();
arrayedMatter.cc:129:    node[01;31m-[00m>attribute("label",this[01;31m-[00m>_ResidueLabel);
arrayedMatter.cc:130:    node[01;31m-[00m>archiveWeakPointer("residue",this[01;31m-[00m>_Residue);
arrayedMatter.cc:131:    node[01;31m-[00m>archiveList("sortedAtoms",this[01;31m-[00m>_SortedAtoms);
arrayedMatter.cc:140:	return x[01;31m-[00m>_AtomLabel <= y[01;31m-[00m>_AtomLabel;
arrayedMatter.cc:144:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:145:    if ( res[01;31m-[00m>getUniqueLabel() == "" )
arrayedMatter.cc:147:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Every ArrayedResidue must have a label"));
arrayedMatter.cc:149:    this[01;31m-[00m>_ResidueLabel = res[01;31m-[00m>getUniqueLabel();
arrayedMatter.cc:150:    this[01;31m-[00m>_Residue = res;
arrayedMatter.cc:152:    this[01;31m-[00m>_SortedAtoms.clear();
arrayedMatter.cc:153:    for ( it=res[01;31m-[00m>begin_atoms(); it!=res[01;31m-[00m>end_atoms(); it++ )
arrayedMatter.cc:155:	RPArrayedAtom atomRef = O_ArrayedAtom::create(this[01;31m-[00m>lisp());
arrayedMatter.cc:156:	RPAtom a = (*it)[01;31m-[00m>as<O_Atom>();
arrayedMatter.cc:157:	atomRef[01;31m-[00m>setAtom(a);
arrayedMatter.cc:158:	this[01;31m-[00m>_SortedAtoms.push_back(atomRef);
arrayedMatter.cc:161:    sort::quickSort(this[01;31m-[00m>_SortedAtoms.begin(),
arrayedMatter.cc:162:		    this[01;31m-[00m>_SortedAtoms.end(),orderer, this[01;31m-[00m>lisp());
arrayedMatter.cc:166:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:167:    return this[01;31m-[00m>_SortedAtoms.size();
arrayedMatter.cc:172:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:174:    for ( List<O_ArrayedAtom>::iterator it=this[01;31m-[00m>_SortedAtoms.begin();
arrayedMatter.cc:175:    	it !=this[01;31m-[00m>_SortedAtoms.end(); it++ )
arrayedMatter.cc:177:	hash += (*it)[01;31m-[00m>calculateHash();
arrayedMatter.cc:185:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:186:    for ( List<O_ArrayedAtom>::iterator it=this[01;31m-[00m>_SortedAtoms.begin();
arrayedMatter.cc:187:    	it !=this[01;31m-[00m>_SortedAtoms.end(); it++ )
arrayedMatter.cc:189:	(*it)[01;31m-[00m>extractFromCoordinateArray(hash,start);
arrayedMatter.cc:192:    return this[01;31m-[00m>_SortedAtoms.size();
arrayedMatter.cc:196:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:197:    for ( List<O_ArrayedAtom>::iterator it=this[01;31m-[00m>_SortedAtoms.begin();
arrayedMatter.cc:198:    	it !=this[01;31m-[00m>_SortedAtoms.end(); it++ )
arrayedMatter.cc:200:	(*it)[01;31m-[00m>writeToCoordinateArray(hash,start);
arrayedMatter.cc:203:    return this[01;31m-[00m>_SortedAtoms.size();
arrayedMatter.cc:214:	class_<O_ArrayedResidue>(this[01;31m-[00m>lisp())
arrayedMatter.cc:238:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
arrayedMatter.cc:244:    this[01;31m-[00m>Base::initialize();
arrayedMatter.cc:245:    this[01;31m-[00m>_SortedResidues.clear();
arrayedMatter.cc:250:    node[01;31m-[00m>archiveList("sortedResidues",this[01;31m-[00m>_SortedResidues);
arrayedMatter.cc:251:    node[01;31m-[00m>attribute("hash",this[01;31m-[00m>_Hash);
arrayedMatter.cc:252:    node[01;31m-[00m>attribute("numberOfAtoms",this[01;31m-[00m>_NumberOfAtoms);
arrayedMatter.cc:260:	return x[01;31m-[00m>_ResidueLabel <= y[01;31m-[00m>_ResidueLabel;
arrayedMatter.cc:265:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:266:    this[01;31m-[00m>_Molecule = mol;
arrayedMatter.cc:268:    this[01;31m-[00m>_SortedResidues.clear();
arrayedMatter.cc:269:    for ( it=mol[01;31m-[00m>begin_residues(); it!=mol[01;31m-[00m>end_residues(); it++ )
arrayedMatter.cc:271:	RPArrayedResidue linearResidue = O_ArrayedResidue::create(this[01;31m-[00m>lisp());
arrayedMatter.cc:272:	RPResidue res = (*it)[01;31m-[00m>as<O_Residue>();
arrayedMatter.cc:273:	linearResidue[01;31m-[00m>setResidue(res);
arrayedMatter.cc:274:	this[01;31m-[00m>_SortedResidues.push_back(linearResidue);
arrayedMatter.cc:277:    sort::quickSort(this[01;31m-[00m>_SortedResidues.begin(),
arrayedMatter.cc:278:		    this[01;31m-[00m>_SortedResidues.end(),orderer,this[01;31m-[00m>lisp());
arrayedMatter.cc:279:    this[01;31m-[00m>_Hash = this[01;31m-[00m>calculateHash();
arrayedMatter.cc:280:    this[01;31m-[00m>_NumberOfAtoms = this[01;31m-[00m>getNumberOfAtoms();
arrayedMatter.cc:285:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:287:    for ( List<O_ArrayedResidue>::iterator it=this[01;31m-[00m>_SortedResidues.begin();
arrayedMatter.cc:288:    		it!=this[01;31m-[00m>_SortedResidues.end(); it++ )
arrayedMatter.cc:290:	num += (*it)[01;31m-[00m>getNumberOfAtoms();
arrayedMatter.cc:296:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:298:    for ( List<O_ArrayedResidue>::iterator it=this[01;31m-[00m>_SortedResidues.begin();
arrayedMatter.cc:299:    		it!=this[01;31m-[00m>_SortedResidues.end(); it++ )
arrayedMatter.cc:301:	hash += (*it)[01;31m-[00m>calculateHash();
arrayedMatter.cc:310:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:311:    uint numberOfAtoms = this[01;31m-[00m>getNumberOfAtoms();
arrayedMatter.cc:313:    ca = O_CoordinateArrayWithHash::create(this[01;31m-[00m>lisp(),numberOfAtoms);
arrayedMatter.cc:314:    ca[01;31m-[00m>setHash(this[01;31m-[00m>_Hash);
arrayedMatter.cc:320:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:321:    if ( h[01;31m-[00m>getHash() != this[01;31m-[00m>_Hash )
arrayedMatter.cc:323:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The hashes don't match"));
arrayedMatter.cc:325:    if ( h[01;31m-[00m>size() != this[01;31m-[00m>getNumberOfAtoms() )
arrayedMatter.cc:327:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The number of atoms don't match"));
arrayedMatter.cc:330:    for ( List<O_ArrayedResidue>::iterator it=this[01;31m-[00m>_SortedResidues.begin();
arrayedMatter.cc:331:    		it!=this[01;31m-[00m>_SortedResidues.end(); it++ )
arrayedMatter.cc:333:	start += (*it)[01;31m-[00m>extractFromCoordinateArray(h,start);
arrayedMatter.cc:338:{_F(this[01;31m-[00m>lisp());
arrayedMatter.cc:339:    if ( h[01;31m-[00m>getHash() != this[01;31m-[00m>_Hash )
arrayedMatter.cc:341:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The hashes don't match"));
arrayedMatter.cc:343:    if ( h[01;31m-[00m>size() != this[01;31m-[00m>getNumberOfAtoms() )
arrayedMatter.cc:345:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The number of atoms don't match"));
arrayedMatter.cc:348:    for ( List<O_ArrayedResidue>::iterator it=this[01;31m-[00m>_SortedResidues.begin();
arrayedMatter.cc:349:    		it!=this[01;31m-[00m>_SortedResidues.end(); it++ )
arrayedMatter.cc:351:	start += (*it)[01;31m-[00m>writeToCoordinateArray(h,start);
arrayedMatter.cc:361:	class_<O_ArrayedMolecule>(this[01;31m-[00m>lisp())
atom.cc:33: * :colorByElement true/false [01;31m-[00m if true overrides color; 
atom.cc:37: * :color type(GrColor)		[01;31m-[00m defines color  (default byelement)
atom.cc:38: * :renderStyle			[01;31m-[00m one of :none, :line, :ballAndStick or :cpk (default :none if it has bonds and :ball if it doesn't)
atom.cc:39: * :showLabel			[01;31m-[00m true or false (default false)
atom.cc:40: * :label			[01;31m-[00m Label to show (default "")
atom.cc:67:  { "", [01;31m-[00m1 }
atom.cc:74:  { "", [01;31m-[00m1 }
atom.cc:89:    node[01;31m-[00m>archivePlainObject<Vector3>("anchorPos","AnchorPos",this[01;31m-[00m>_AnchorPos);
atom.cc:94: *  return [01;31m-[00m1 if priority(a)<priority(b)
atom.cc:101:    if ( a[01;31m-[00m>isNil() && b[01;31m-[00m>isNil() ) return 0;
atom.cc:102:    if ( b[01;31m-[00m>isNil() ) return 1;
atom.cc:103:    if ( a[01;31m-[00m>isNil() ) return [01;31m-[00m1;
atom.cc:104:    if ( a[01;31m-[00m>getRelativePriority()>b[01;31m-[00m>getRelativePriority() ) return 1;
atom.cc:105:    if ( a[01;31m-[00m>getRelativePriority()<b[01;31m-[00m>getRelativePriority() ) return [01;31m-[00m1;
atom.cc:106:    if ( a[01;31m-[00m>getName() > b[01;31m-[00m>getName() ) return 1;
atom.cc:107:    if ( a[01;31m-[00m>getName() < b[01;31m-[00m>getName() ) return [01;31m-[00m1;
atom.cc:114:{_F(this[01;31m-[00m>lisp());
atom.cc:115:    if ( this[01;31m-[00m>numberOfBonds() != 4 ) return undefinedConfiguration;
atom.cc:116:    RPCons neighborsByPriority = this[01;31m-[00m>getNeighborsByRelativePriority();
atom.cc:117:    RPAtom a4 = neighborsByPriority[01;31m-[00m>ocar()[01;31m-[00m>as<O_Atom>();
atom.cc:118:    RPAtom a3 = neighborsByPriority[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Atom>();
atom.cc:119:    RPAtom a2 = neighborsByPriority[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Atom>();
atom.cc:120:    RPAtom a1 = neighborsByPriority[01;31m-[00m>ocadddr()[01;31m-[00m>as<O_Atom>();
atom.cc:121:    Vector3 vme = this[01;31m-[00m>getPosition();
atom.cc:122:    Vector3 v4 = a4[01;31m-[00m>getPosition().sub(vme);
atom.cc:123:    Vector3 v3 = a3[01;31m-[00m>getPosition().sub(vme);
atom.cc:124:    Vector3 v2 = a2[01;31m-[00m>getPosition().sub(vme);
atom.cc:125:    Vector3 v1 = a1[01;31m-[00m>getPosition().sub(vme);
atom.cc:149:{_F(this[01;31m-[00m>lisp());
atom.cc:151:    ConfigurationEnum config = this[01;31m-[00m>calculateStereochemicalConfiguration();
atom.cc:180:    out << "Atom: " << this[01;31m-[00m>getName();
atom.cc:182:    out << " id=" << this[01;31m-[00m>getId();
atom.cc:183:    out << " typeStr=" << this[01;31m-[00m>getTypeString();
atom.cc:184:    bonds = this[01;31m-[00m>getBonds();
atom.cc:187:	wtoa = (*b)[01;31m-[00m>getTo();
atom.cc:189:	if (wtoa.lock()[01;31m-[00m>isNil()) {
atom.cc:193:	    name = wtoa.lock()[01;31m-[00m>getName();
atom.cc:194:	    out << name << ":" << wtoa.lock()[01;31m-[00m>getId()
atom.cc:199:    if ( !(this[01;31m-[00m>getStereochemistryType() == undefinedCenter 
atom.cc:200:		&& this[01;31m-[00m>getConfiguration() == undefinedConfiguration ) )
atom.cc:202:	switch ( this[01;31m-[00m>getStereochemistryType() )
atom.cc:205:	    	out << "undefinedStereochemistryType[01;31m-[00m";
atom.cc:208:		out << "proChiral[01;31m-[00m";
atom.cc:211:		out << "chiral[01;31m-[00m";
atom.cc:214:	switch (this[01;31m-[00m>getConfiguration())
atom.cc:236:{_F(this[01;31m-[00m>lisp());
atom.cc:237:    this[01;31m-[00m>Base::initialize();
atom.cc:238:    this[01;31m-[00m>copyAtom = O_Atom::nil(this[01;31m-[00m>lisp());
atom.cc:239:    this[01;31m-[00m>flags = ATOM_NEEDS_MINIMIZER;
atom.cc:240:    this[01;31m-[00m>_Mask = 0;
atom.cc:241:    this[01;31m-[00m>tempInt = 0;
atom.cc:242:    this[01;31m-[00m>_HintLP = false;
atom.cc:243:    this[01;31m-[00m>_Element = element_Undefined;
atom.cc:244:    this[01;31m-[00m>_Hybridization = hybridization_undefined;
atom.cc:245:    this[01;31m-[00m>seenId = 0;
atom.cc:246:    this[01;31m-[00m>_Alias = "";
atom.cc:247:    this[01;31m-[00m>_Ionization = 0; // neutral
atom.cc:248:    this[01;31m-[00m>_Force.set(0.0,0.0,0.0);
atom.cc:249:    this[01;31m-[00m>_AnchorRestraint.setIsDefined(false);
atom.cc:250:    this[01;31m-[00m>_AnchorRestraint._AnchorPos.set(0.0,0.0,0.0);
atom.cc:251:    this[01;31m-[00m>charge= 0;
atom.cc:252:    this[01;31m-[00m>_RingMembershipCount = 0;
atom.cc:253:    this[01;31m-[00m>type= 0;
atom.cc:254:    this[01;31m-[00m>typeString= "";
atom.cc:255:    this[01;31m-[00m>invalidateBackSpan();
atom.cc:256:    this[01;31m-[00m>invalidateNextSpan();
atom.cc:257:    this[01;31m-[00m>_MembershipAr1 = 0;
atom.cc:258:    this[01;31m-[00m>_MembershipAr2 = 0;
atom.cc:259:    this[01;31m-[00m>_MembershipAr3 = 0;
atom.cc:260:    this[01;31m-[00m>_MembershipAr4 = 0;
atom.cc:261:    this[01;31m-[00m>_MembershipAr5 = 0;
atom.cc:262:    this[01;31m-[00m>_RelativePriority = 0;
atom.cc:263:    this[01;31m-[00m>_Configuration = undefinedConfiguration;
atom.cc:264:    this[01;31m-[00m>_StereochemistryType = undefinedCenter;
atom.cc:266:    this[01;31m-[00m>_WeakOligomerBuilder = O_OligomerBuilder::nil(this[01;31m-[00m>lisp());
atom.cc:267:    this[01;31m-[00m>_AtomHolderIndex = UndefinedUnsignedInt;
atom.cc:268:    this[01;31m-[00m>_BuildCounter = 0;
atom.cc:274:{_F(this[01;31m-[00m>lisp());
atom.cc:275:    if ( this[01;31m-[00m>eqV(obj) ) goto T;
atom.cc:276:    if ( obj[01;31m-[00m>isOfClass<O_Atom>() )
atom.cc:278:	RPAtom other = obj[01;31m-[00m>as<O_Atom>();
atom.cc:279:	if ( other[01;31m-[00m>getName() != this[01;31m-[00m>getName() )
atom.cc:281:	    LOG(BF("Atom names[ this[01;31m-[00m>getName()=%s  other[01;31m-[00m>getName()=%s ]  don't match!") % this[01;31m-[00m>getName() % other[01;31m-[00m>getName() );
atom.cc:284:	if ( other[01;31m-[00m>numberOfBonds() != this[01;31m-[00m>numberOfBonds() )
atom.cc:286:	    LOG(BF("Numbers of bonds don't match this[01;31m-[00m>numberOfBonds()=%d  other[01;31m-[00m>numberOfBonds()=%d!") % this[01;31m-[00m>numberOfBonds() % other[01;31m-[00m>numberOfBonds() );
atom.cc:293:    LOG(BF("atoms this(%s) =equal= other(%s)  equal==false") % this[01;31m-[00m>description() % obj[01;31m-[00m>description() );
atom.cc:296:    LOG(BF("atoms this(%s) =equal= other(%s)  equal==true") % this[01;31m-[00m>description() % obj[01;31m-[00m>description() );
atom.cc:302:    if ( !this[01;31m-[00m>equal(obj) )
atom.cc:304:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("This atom(%s) is not equal to %s so you cannot transfer coordinates")%this[01;31m-[00m>description() % obj[01;31m-[00m>description() ));
atom.cc:306:    RPAtom other = obj[01;31m-[00m>as<O_Atom>();
atom.cc:307:    this[01;31m-[00m>setPosition(other[01;31m-[00m>getPosition());
atom.cc:313:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
atom.cc:323:    this[01;31m-[00m>_Element = ss._Element;
atom.cc:324:    this[01;31m-[00m>_Alias = ss._Alias;
atom.cc:325:    this[01;31m-[00m>type = ss.type;
atom.cc:326:    this[01;31m-[00m>typeString= ss.typeString;
atom.cc:327:    this[01;31m-[00m>_Hybridization = ss._Hybridization;
atom.cc:328:    this[01;31m-[00m>_HintLP = ss._HintLP;
atom.cc:329:    this[01;31m-[00m>_selected = ss._selected;
atom.cc:330:    this[01;31m-[00m>flags = ss.flags;
atom.cc:331:    this[01;31m-[00m>_Mask = ss._Mask;
atom.cc:332:    this[01;31m-[00m>position = ss.position;
atom.cc:333:    this[01;31m-[00m>_Force = ss._Force;
atom.cc:334:    this[01;31m-[00m>_AnchorRestraint = ss._AnchorRestraint;
atom.cc:335:    this[01;31m-[00m>touched = ss.touched;
atom.cc:336:    this[01;31m-[00m>charge = ss.charge;
atom.cc:337:    this[01;31m-[00m>_RingMembershipCount = ss._RingMembershipCount;
atom.cc:338:    this[01;31m-[00m>occupancy = ss.occupancy;
atom.cc:339:    this[01;31m-[00m>tempFactor = ss.tempFactor;
atom.cc:340:    this[01;31m-[00m>vdwRadius = ss.vdwRadius;
atom.cc:341:    this[01;31m-[00m>covalentRadius = ss.covalentRadius;
atom.cc:342:    this[01;31m-[00m>copyAtom = WPAtom();
atom.cc:343:    this[01;31m-[00m>tempInt = ss.tempInt;
atom.cc:344:    this[01;31m-[00m>moeIndex = ss.moeIndex;
atom.cc:345:    this[01;31m-[00m>moeType = ss.moeType;
atom.cc:346:    this[01;31m-[00m>_Ionization = ss._Ionization;
atom.cc:347:    this[01;31m-[00m>_MembershipAr1 = ss._MembershipAr1;
atom.cc:348:    this[01;31m-[00m>_MembershipAr2 = ss._MembershipAr2;
atom.cc:349:    this[01;31m-[00m>_MembershipAr3 = ss._MembershipAr3;
atom.cc:350:    this[01;31m-[00m>_MembershipAr4 = ss._MembershipAr4;
atom.cc:351:    this[01;31m-[00m>_MembershipAr5 = ss._MembershipAr5;
atom.cc:352:    this[01;31m-[00m>_RelativePriority = ss._RelativePriority;
atom.cc:353:    this[01;31m-[00m>_Configuration = ss._Configuration;
atom.cc:354:    this[01;31m-[00m>_StereochemistryType = ss._StereochemistryType;
atom.cc:355:    this[01;31m-[00m>_BackSpan = ss.lisp()[01;31m-[00m>nil<O_Atom>();		// Is this a bad idea to access env in copy?
atom.cc:356:    this[01;31m-[00m>_NextSpan = ss.lisp()[01;31m-[00m>nil<O_Atom>();		// Is this a bad idea to access env in copy?
atom.cc:357:    this[01;31m-[00m>_WeakOligomerBuilder = ss._WeakOligomerBuilder;
atom.cc:358:    this[01;31m-[00m>_AtomHolderIndex = ss._AtomHolderIndex;
atom.cc:359:    this[01;31m-[00m>_BuildCounter = ss._BuildCounter;
atom.cc:375:{_F(this[01;31m-[00m>lisp());
atom.cc:376:    Element element = elementFromName(this[01;31m-[00m>getName(),this[01;31m-[00m>lisp());
atom.cc:378:    this[01;31m-[00m>setElement(element);
atom.cc:382:{_F(this[01;31m-[00m>lisp());
atom.cc:383:    Element element = elementFromNameCaseInsensitive(str,this[01;31m-[00m>lisp());
atom.cc:385:    this[01;31m-[00m>setElement(element);
atom.cc:390:{_F(this[01;31m-[00m>lisp());
atom.cc:391:    this[01;31m-[00m>_Hybridization = hybridizationForString(h,this[01;31m-[00m>lisp());
atom.cc:395:{_F(this[01;31m-[00m>lisp());
atom.cc:396:    RPAtom h = O_Atom::create(this[01;31m-[00m>lisp());
atom.cc:397:    h[01;31m-[00m>setName(name);
atom.cc:398:    h[01;31m-[00m>setElement(element_H);
atom.cc:399:    RPResidue res = this[01;31m-[00m>getResidueContainedBy();
atom.cc:400:    res[01;31m-[00m>addAtom(h);
atom.cc:401:    this[01;31m-[00m>bondTo(h,singleBond);
atom.cc:406:    return this[01;31m-[00m>bonds[i][01;31m-[00m>getToLocked();
atom.cc:411:    return this[01;31m-[00m>bonds[i][01;31m-[00m>getOrder();
atom.cc:416:    return this[01;31m-[00m>bonds.size();
atom.cc:421:    return this[01;31m-[00m>bonds.size();
atom.cc:437:    first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
atom.cc:439:    if ( this[01;31m-[00m>getElement() != element_C ) return O_Cons::nil(this[01;31m-[00m>lisp());
atom.cc:440:    uint totalBondOrder = this[01;31m-[00m>totalBondOrder();
atom.cc:441:    if ( totalBondOrder == 4 ) return O_Cons::nil(this[01;31m-[00m>lisp());
atom.cc:442:    uint addHydrogens = 4 [01;31m-[00m totalBondOrder;
atom.cc:443:    string nameSuffix = this[01;31m-[00m>getName().substr(1,9999);
atom.cc:446:	RPCons one = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>("H"+nameSuffix),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
atom.cc:447:	cons[01;31m-[00m>setCdr(one);
atom.cc:449:	return first[01;31m-[00m>cdr();
atom.cc:455:	RPCons one = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String,string>(ss.str()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
atom.cc:456:	cons[01;31m-[00m>setCdr(one);
atom.cc:459:    return first[01;31m-[00m>cdr();
atom.cc:466:{_F(this[01;31m-[00m>lisp());
atom.cc:467:    RPCons names = this[01;31m-[00m>createImplicitHydrogenNamesOnCarbon();
atom.cc:468:    if ( names[01;31m-[00m>isNil() ) return;
atom.cc:469:    for ( RPCons cur = names; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
atom.cc:471:	this[01;31m-[00m>_addHydrogenWithName(cur[01;31m-[00m>car<O_String>()[01;31m-[00m>get());
atom.cc:483:{_F(this[01;31m-[00m>lisp());
atom.cc:490:    this[01;31m-[00m>setPosition(v);
atom.cc:503:{_F(this[01;31m-[00m>lisp());
atom.cc:506:    xd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
atom.cc:507:    yd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
atom.cc:508:    zd = (randomNumber01(_lisp)*2.0[01;31m-[00m1.0)*dist;
atom.cc:509:    v = this[01;31m-[00m>getPosition();
atom.cc:512:    this[01;31m-[00m>setPosition(v);
atom.cc:518:{_F(this[01;31m-[00m>lisp());
atom.cc:519:    RPAtom bestAtom = O_Atom::nil(this[01;31m-[00m>lisp());
atom.cc:522:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:523:	atom = (*b)[01;31m-[00m>getToLocked();
atom.cc:524:	if ( avoid[01;31m-[00m>notNil() && atom == avoid ) continue;
atom.cc:535:{_F(this[01;31m-[00m>lisp());
atom.cc:536:    RPAtom bestAtom = O_Atom::nil(this[01;31m-[00m>lisp());
atom.cc:539:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:540:	atom = (*b)[01;31m-[00m>getToLocked();
atom.cc:541:	if ( avoid[01;31m-[00m>notNil() && atom == avoid ) continue;
atom.cc:542:	if ( bestAtom[01;31m-[00m>isNil() )
atom.cc:558:{_F(this[01;31m-[00m>lisp());
atom.cc:563:    from = this[01;31m-[00m>sharedThis<O_Atom>();
atom.cc:564:    to = a[01;31m-[00m>sharedThis<O_Atom>();
atom.cc:565:    b = O_Bond::create(this[01;31m-[00m>lisp(),from,to,o);
atom.cc:566:    this[01;31m-[00m>bonds.push_back(b);
atom.cc:572:{_F(this[01;31m-[00m>lisp());
atom.cc:575:    b = this[01;31m-[00m>basicBondTo( a, o );
atom.cc:576:    aTemp = this[01;31m-[00m>sharedThis<O_Atom>();
atom.cc:577:    a[01;31m-[00m>basicBondTo( aTemp, o );
atom.cc:583:{_F(this[01;31m-[00m>lisp());
atom.cc:586:    b = this[01;31m-[00m>basicBondTo( a, singleBond );
atom.cc:587:    aTemp = this[01;31m-[00m>sharedThis<O_Atom>();
atom.cc:588:    a[01;31m-[00m>basicBondTo( aTemp, singleBond );
atom.cc:600:    s = this[01;31m-[00m>getName()+":";
atom.cc:601:    sprintf( caIndex, "%d", this[01;31m-[00m>moeIndex );
atom.cc:612:	    if ( x[01;31m-[00m>getRelativePriority()<y[01;31m-[00m>getRelativePriority() ) return true;
atom.cc:613:	    if ( x[01;31m-[00m>getRelativePriority()>y[01;31m-[00m>getRelativePriority() ) return false;
atom.cc:614:	    if ( x[01;31m-[00m>getName()<y[01;31m-[00m>getName() ) return true;
atom.cc:620:{_F(this[01;31m-[00m>lisp());
atom.cc:621:    LOG(BF("Ordering neighbors around(%s) by priority and name") % this[01;31m-[00m>getName().c_str()  ); // vp0(("Ordering neighbors around(%s) by priority and name", this[01;31m-[00m>getName().c_str() ));
atom.cc:624:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:625:	reversedNeighbors.push_back((*b)[01;31m-[00m>getToLocked());
atom.cc:628:    RPCons ncons = O_Cons::nil(this[01;31m-[00m>lisp());
atom.cc:638:	LOG(BF("    neighbor priority(%u) name(%s)") % (*ni)[01;31m-[00m>getRelativePriority() % (*ni)[01;31m-[00m>getName().c_str()  ); // vp0(( "    neighbor priority(%u) name(%s)", (*ni)[01;31m-[00m>getRelativePriority(), (*ni)[01;31m-[00m>getName().c_str() ));
atom.cc:639:	ncons = O_Cons::create(*ni,ncons,this[01;31m-[00m>lisp());
atom.cc:650:	this[01;31m-[00m>flags |= fl;
atom.cc:652:	this[01;31m-[00m>flags &= fl;
atom.cc:654:	this[01;31m-[00m>flags |= fl;
atom.cc:656:	this[01;31m-[00m>flags &= (~fl);
atom.cc:667:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:668:	if ( (*b)[01;31m-[00m>getTo().lock()[01;31m-[00m>getName() == name ) {
atom.cc:679:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:680:	if ( (*b)[01;31m-[00m>getTo().lock()[01;31m-[00m>getName() == name ) {
atom.cc:681:	    return (*b)[01;31m-[00m>getTo().lock();
atom.cc:684:    RPAtom a = O_Atom::nil(this[01;31m-[00m>lisp());
atom.cc:693:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) 
atom.cc:695:	if ( (*b)[01;31m-[00m>getTo().lock()[01;31m-[00m>getElement() == el ) 
atom.cc:697:	    if ( (*b)[01;31m-[00m>getOrder() == o ) return true;
atom.cc:708:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) 
atom.cc:710:	if ( (*b)[01;31m-[00m>getTo().lock()[01;31m-[00m>getElement() == el ) 
atom.cc:712:	    if ( (*b)[01;31m-[00m>getTo().lock()[01;31m-[00m>getHybridization() == hy ) return true;
atom.cc:727:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) 
atom.cc:729:	a1 = RPAtom((*b)[01;31m-[00m>getTo());
atom.cc:730:	if ( a1[01;31m-[00m>getElement() == el1 ) 
atom.cc:732:	    if ( a1[01;31m-[00m>getHybridization() == hy1 ) 
atom.cc:734:	        for ( b2=a1[01;31m-[00m>bonds.begin();b2!=a1[01;31m-[00m>bonds.end();b2++) 
atom.cc:736:		    a2 = RPAtom((*b2)[01;31m-[00m>getTo());
atom.cc:737:		    if ( a2 == this[01;31m-[00m>sharedThis<O_Atom>() ) continue;
atom.cc:738:		    if ( a2[01;31m-[00m>getElement() == el2 ) 
atom.cc:740:			if ( (*b2)[01;31m-[00m>getTo().lock()[01;31m-[00m>getHybridization() == hy2 ) return true;
atom.cc:750:{_F(this[01;31m-[00m>lisp());
atom.cc:751:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("This should never be called for an RPAtom"));
atom.cc:761:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:762:	if ( (*b)[01;31m-[00m>getTo().lock() == a ) {
atom.cc:763:	    this[01;31m-[00m>bonds.erase(b);
atom.cc:768:    ss << "Trying to remove bond from atom(" << this[01;31m-[00m>description()
atom.cc:769:	<< ") but I can't find the to atom(" << a[01;31m-[00m>description() << ")";
atom.cc:770:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
atom.cc:777:    this[01;31m-[00m>basicRemoveBondTo(a);
atom.cc:778:    atemp = this[01;31m-[00m>sharedThis<O_Atom>();
atom.cc:779:    a[01;31m-[00m>basicRemoveBondTo(atemp);
atom.cc:783:{_F(this[01;31m-[00m>lisp());
atom.cc:788:    LOG(BF("O_Bond::removeAllBonds for %s") % this[01;31m-[00m>description().c_str()  ); // vp0(( "O_Bond::removeAllBonds for %s", this[01;31m-[00m>description().c_str() ));
atom.cc:789:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:790:	atemp = this[01;31m-[00m>sharedThis<O_Atom>();
atom.cc:791:	WPAtom wato = (*b)[01;31m-[00m>getTo();
atom.cc:794:	ato[01;31m-[00m>basicRemoveBondTo(atemp);
atom.cc:796:    this[01;31m-[00m>bonds.erase(this[01;31m-[00m>bonds.begin(),this[01;31m-[00m>bonds.end());
atom.cc:806:    this[01;31m-[00m>position = (m)*this[01;31m-[00m>position;
atom.cc:819:	out << prefix << "atom " << this[01;31m-[00m>getId() << " '";
atom.cc:820:	out << this[01;31m-[00m>getName() << "' '";
atom.cc:821:	out << this[01;31m-[00m>getElement() << "' '";
atom.cc:822:	out << this[01;31m-[00m>getHybridization() << "' '";
atom.cc:823:	out << this[01;31m-[00m>getTypeString() << "' ";
atom.cc:824:	out << this[01;31m-[00m>getCharge() << " " << 0.0 << " ;" << endl;
atom.cc:829:{_F(this[01;31m-[00m>lisp());
atom.cc:830:    return hybridizationSymbolFromHybridization(this[01;31m-[00m>getHybridization(),this[01;31m-[00m>lisp());
atom.cc:834:{_F(this[01;31m-[00m>lisp());
atom.cc:835:    return atomicSymbolFromElement(this[01;31m-[00m>getElement(),this[01;31m-[00m>lisp());
atom.cc:839:{_F(this[01;31m-[00m>lisp());
atom.cc:840:    this[01;31m-[00m>Base::archiveBase(node);
atom.cc:841:    node[01;31m-[00m>attributeIfNotDefault<ATOM_FLAGS>( "flags", this[01;31m-[00m>flags, (unsigned long)0 );
atom.cc:842:    node[01;31m-[00m>attributeSymbolEnum( "element", this[01;31m-[00m>_Element, this[01;31m-[00m>lisp()[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(this[01;31m-[00m>lisp()[01;31m-[00m>symbol(_sym_MbbPackage_elementToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>() );
atom.cc:843:    node[01;31m-[00m>attributeSymbolEnumIfNotDefault( "hybrid", this[01;31m-[00m>_Hybridization, this[01;31m-[00m>lisp()[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(this[01;31m-[00m>lisp()[01;31m-[00m>symbol(_sym_MbbPackage_hybridizationToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>(),hybridization_sp3 );
atom.cc:844:    node[01;31m-[00m>attributeIfNotDefault<string>( "alias", this[01;31m-[00m>_Alias, "" );
atom.cc:845:    node[01;31m-[00m>attributeIfNotDefault<uint>( "priority", this[01;31m-[00m>_RelativePriority, 0 );
atom.cc:846:    node[01;31m-[00m>attributeIfNotDefault<bool>( "hintLP", this[01;31m-[00m>_HintLP,false );
atom.cc:847:    node[01;31m-[00m>attributeIfNotDefault<double>( "chg", this[01;31m-[00m>charge, 0.0 );
atom.cc:848:    node[01;31m-[00m>attributeEnumIfNotDefault<ConfigurationEnum>( "configuration", this[01;31m-[00m>_Configuration, configurationEnum, undefinedConfiguration  );
atom.cc:849:    node[01;31m-[00m>attributeEnumIfNotDefault<StereochemistryType>( "stereochemistryType", this[01;31m-[00m>_StereochemistryType, stereochemistryTypes, undefinedCenter );
atom.cc:850:    node[01;31m-[00m>attributeIfNotDefault<int>( "ion", this[01;31m-[00m>_Ionization, 0 );
atom.cc:851:    node[01;31m-[00m>attributeIfNotDefault<int>( "rings", this[01;31m-[00m>_RingMembershipCount, 0 );
atom.cc:852:    node[01;31m-[00m>attributeIfNotDefault<int>( "tempInt", this[01;31m-[00m>tempInt, 0 );
atom.cc:853:    node[01;31m-[00m>attributeIfNotDefault<string>( "type", this[01;31m-[00m>typeString, "" );
atom.cc:854:    node[01;31m-[00m>attributeIfNotDefault<int>( "ar1", this[01;31m-[00m>_MembershipAr1, 0 );
atom.cc:855:    node[01;31m-[00m>attributeIfNotDefault<int>( "ar2", this[01;31m-[00m>_MembershipAr2, 0 );
atom.cc:856:    node[01;31m-[00m>attributeIfNotDefault<int>( "ar3", this[01;31m-[00m>_MembershipAr3, 0 );
atom.cc:857:    node[01;31m-[00m>attributeIfNotDefault<int>( "ar4", this[01;31m-[00m>_MembershipAr4, 0 );
atom.cc:858:    node[01;31m-[00m>attributeIfNotDefault<int>( "ar5", this[01;31m-[00m>_MembershipAr5, 0 );
atom.cc:859:    node[01;31m-[00m>attributeIfNotDefault<uint>( "mask", this[01;31m-[00m>_Mask, (unsigned int)(0) );
atom.cc:860:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "pos","Vector3",
atom.cc:861:    					this[01;31m-[00m>position.isDefined(), this[01;31m-[00m>position );
atom.cc:862:    LOG(BF("After pos archived Atom position@%p = %s") % &(this[01;31m-[00m>position) % this[01;31m-[00m>position.asString().c_str()  ); // vp0(( "After pos archived Atom position@%p = %s", &(this[01;31m-[00m>position), this[01;31m-[00m>position.asString().c_str() ));
atom.cc:863:    node[01;31m-[00m>archivePlainObjectIfDefined<AnchorRestraint>("anchor","AnchorRestraint",
atom.cc:864:		this[01;31m-[00m>_AnchorRestraint.isDefined(), this[01;31m-[00m>_AnchorRestraint );
atom.cc:865:    LOG(BF("Atom position = %s") % this[01;31m-[00m>position.asString().c_str()  ); // vp0(( "Atom position = %s", this[01;31m-[00m>position.asString().c_str() ));
atom.cc:871:{_F(this[01;31m-[00m>lisp());
atom.cc:873:    this[01;31m-[00m>tempInt = i;
atom.cc:877:{_F(this[01;31m-[00m>lisp());
atom.cc:878:    return this[01;31m-[00m>tempInt;
atom.cc:884:    if ( this[01;31m-[00m>_Configuration == undefinedConfiguration )
atom.cc:887:    } else if ( this[01;31m-[00m>_Configuration == S_Configuration )
atom.cc:890:    } else if ( this[01;31m-[00m>_Configuration == R_Configuration )
atom.cc:897:    if ( this[01;31m-[00m>_StereochemistryType == undefinedCenter )
atom.cc:900:    } else if ( this[01;31m-[00m>_StereochemistryType == chiralCenter )
atom.cc:903:    } else if ( this[01;31m-[00m>_StereochemistryType == prochiralCenter )
atom.cc:927:    bonds = this[01;31m-[00m>getBonds();
atom.cc:929:	if ( (*b)[01;31m-[00m>getFrom().lock()[01;31m-[00m>atLowerAddressThan((*b)[01;31m-[00m>getTo().lock()) )
atom.cc:932:	    switch ( (*b)[01;31m-[00m>getOrder() ) {
atom.cc:946:		    out << "[01;31m-[00m[01;31m-[00munknown[01;31m-[00m[01;31m-[00m";
atom.cc:948:	    out << " " << (*b)[01;31m-[00m>getFrom().lock()[01;31m-[00m>getId() << " ";
atom.cc:949:	    out << (*b)[01;31m-[00m>getTo().lock()[01;31m-[00m>getId() << " ;" << endl;
atom.cc:959:    if ( this[01;31m-[00m>isNil() ) return "nil";
atom.cc:961:    if ( this[01;31m-[00m>containedByValid() )
atom.cc:963:	RPResidue res = O_Residue::nil(this[01;31m-[00m>lisp());
atom.cc:964:	RPMolecule mol = O_Molecule::nil(this[01;31m-[00m>lisp());
atom.cc:965:	if ( this[01;31m-[00m>containedByValid() )
atom.cc:967:	    res = this[01;31m-[00m>containedBy().lock()[01;31m-[00m>as<O_Residue>();
atom.cc:968:	    if ( res[01;31m-[00m>containedByValid() )
atom.cc:970:		mol = res[01;31m-[00m>containedBy().lock()[01;31m-[00m>as<O_Molecule>();
atom.cc:973:	string molName = (mol[01;31m-[00m>isNil())?"":mol[01;31m-[00m>getName();
atom.cc:974:	string resName = (res[01;31m-[00m>isNil())?"":res[01;31m-[00m>getName();
atom.cc:975:	ss << this[01;31m-[00m>className() << ":" << molName << ":" << resName << "@" << this[01;31m-[00m>name;
atom.cc:978:	ss << "@" << this[01;31m-[00m>name;
atom.cc:986:    if ( this[01;31m-[00m>isNil() )
atom.cc:990:    ss << this[01;31m-[00m>className() << "("<<this[01;31m-[00m>getName();
atom.cc:991:    if ( this[01;31m-[00m>containerContainedBy.use_count() != 0 ) 
atom.cc:993:	if ( this[01;31m-[00m>containedBy().lock()[01;31m-[00m>isNil() )
atom.cc:995:	    ss<<"[residue[01;31m-[00mUNDEFINED[01;31m-[00m]";
atom.cc:997:	    ss <<"["<<this[01;31m-[00m>getResidueContainedBy_const()[01;31m-[00m>description()<<"]";
atom.cc:1001:	ss << "[residue[01;31m-[00mNULL[01;31m-[00m]";
atom.cc:1003:    ss <<")@"<<std::hex<<this<<std::dec<<"|USE("<<this[01;31m-[00m>weakThis_const().use_count()<<")";
atom.cc:1012:{_F(this[01;31m-[00m>lisp());
atom.cc:1017:    bonds = this[01;31m-[00m>getBonds();
atom.cc:1019:        ASSERT_NOT_NULL((*b)[01;31m-[00m>getFrom());
atom.cc:1020:        ASSERT_NOT_NULL((*b)[01;31m-[00m>getTo());
atom.cc:1021:	if ( (*b)[01;31m-[00m>getFrom().lock()[01;31m-[00m>atLowerAddressThan( (*b)[01;31m-[00m>getTo().lock() ) ) 
atom.cc:1023:	    if ( !(*b)[01;31m-[00m>isInterResidueBond() ) {
atom.cc:1024:		LOG(BF("Original bond: %s") % (*b)[01;31m-[00m>description().c_str()  ); // vp0(("Original bond: %s",(*b)[01;31m-[00m>description().c_str() ));
atom.cc:1026:		LOG(BF("Copy bond: %s") % bondCopy[01;31m-[00m>description().c_str()  ); // vp0(("Copy bond: %s",bondCopy[01;31m-[00m>description().c_str() ));
atom.cc:1027:		list[01;31m-[00m>addBond(bondCopy);
atom.cc:1037:{_F(this[01;31m-[00m>lisp());
atom.cc:1042:    bonds = this[01;31m-[00m>getBonds();
atom.cc:1044:	if ( (*b)[01;31m-[00m>getFrom().lock()[01;31m-[00m>atLowerAddressThan( (*b)[01;31m-[00m>getTo().lock() ) ) 
atom.cc:1046:	    if ( (*b)[01;31m-[00m>isInterResidueBond() ) {
atom.cc:1048:		list[01;31m-[00m>addBond(bondCopy);
atom.cc:1055:{_F(this[01;31m-[00m>lisp());
atom.cc:1058:    bonds = this[01;31m-[00m>getBonds();
atom.cc:1060:	if ( (*b)[01;31m-[00m>isInterResidueBond() ) {
atom.cc:1076:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:1077:	a2 = (*b)[01;31m-[00m>getTo().lock();
atom.cc:1079:	if ( (*b)[01;31m-[00m>getFrom().lock().get() != this ) {
atom.cc:1080:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "O_Atom::isBondedTo failed internal consistancy" ));
atom.cc:1081:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "                      a bond getFrom() did not match (this)" ));
atom.cc:1085:	    if ( o == (*b)[01;31m-[00m>getOrder() ) {
atom.cc:1099:{_F(this[01;31m-[00m>lisp());
atom.cc:1102:    LOG(BF("Looking at atom(%s) for bonded atom(%s)") % this[01;31m-[00m>getName().c_str() % aTarget[01;31m-[00m>getName().c_str()  ); // vp0(( "Looking at atom(%s) for bonded atom(%s)", this[01;31m-[00m>getName().c_str(), aTarget[01;31m-[00m>getName().c_str() ));
atom.cc:1103:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:1104:	a2 = (*b)[01;31m-[00m>getTo().lock();
atom.cc:1105:	LOG(BF("  looking at atom(%s)") % a2[01;31m-[00m>getName().c_str()  ); // vp0(("  looking at atom(%s)", a2[01;31m-[00m>getName().c_str() ));
atom.cc:1106:	if ( (*b)[01;31m-[00m>getFrom().lock().get() != this ) {
atom.cc:1107:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "O_Atom::isBondedTo failed internal consistancy" ));
atom.cc:1108:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "                      a bond getFrom() did not match (this)" ));
atom.cc:1128:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:1129:	a2 = (*b)[01;31m-[00m>getTo().lock();
atom.cc:1131:	    return (*b)[01;31m-[00m>getOrder();
atom.cc:1146:    LOG(BF("bonds array start = 0x%08x") % ((void*)&(this[01;31m-[00m>bonds[0]))  ); // vp0(( "bonds array start = 0x%08x", (void*)&(this[01;31m-[00m>bonds[0]) ));
atom.cc:1147:    for ( b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end() ; b++ ) {
atom.cc:1148:        LOG(BF("Testing consistancy of atom: 0x%08x should be bonded to: 0x%08x") % (this) % ((*b)[01;31m-[00m>getTo().lock().get() ) ); // vp0(("Testing consistancy of atom: 0x%08x should be bonded to: 0x%08x", this, (*b)[01;31m-[00m>getTo().lock().get()  );
atom.cc:1149:	a2 = (*b)[01;31m-[00m>getTo().lock();
atom.cc:1150:	atemp = this[01;31m-[00m>sharedThis<O_Atom>();
atom.cc:1151:	if ( !(a2[01;31m-[00m>isBondedToWithBondOrder(atemp,(*b)[01;31m-[00m>getOrder())) ) {
atom.cc:1152:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "O_Atom::testConsistancy failed" ));
atom.cc:1171:{_F(this[01;31m-[00m>lisp());
atom.cc:1177:    aNew[01;31m-[00m>bonds.erase(aNew[01;31m-[00m>bonds.begin(),aNew[01;31m-[00m>bonds.end());
atom.cc:1180:	aNew[01;31m-[00m>bonds.push_back(bNew);
atom.cc:1182:    this[01;31m-[00m>copyAtom = WPAtom(aNew);
atom.cc:1183:    LOG(BF("    copy atom== %s") % aNew[01;31m-[00m>description().c_str() ); // vp0(( "    copy atom== %s",aNew[01;31m-[00m>description().c_str()));
atom.cc:1196:{ _F(this[01;31m-[00m>lisp());
atom.cc:1202:    aNew[01;31m-[00m>bonds.erase(aNew[01;31m-[00m>bonds.begin(),aNew[01;31m-[00m>bonds.end());
atom.cc:1205:	_BLOCK_TRACEF(BF( "Examining %s") % (*b)[01;31m-[00m>description().c_str());
atom.cc:1206:	if ((*b)[01;31m-[00m>isInterResidueBond()) {
atom.cc:1211:	    aNew[01;31m-[00m>bonds.push_back(bNew);
atom.cc:1214:    this[01;31m-[00m>copyAtom = WPAtom(aNew);
atom.cc:1225:{_F(this[01;31m-[00m>lisp());
atom.cc:1227:    LOG(BF("Redirecting bonds for %s") % this[01;31m-[00m>description().c_str() ); // vp0(( "Redirecting bonds for %s", this[01;31m-[00m>description().c_str()));
atom.cc:1229:	(*b)[01;31m-[00m>redirectToAtomCopies();
atom.cc:1241:    for (b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end(); b++ ) {
atom.cc:1242:	vAtoms.push_back((*b)[01;31m-[00m>getTo().lock());
atom.cc:1249:    RPCons list = O_Cons::nil(this[01;31m-[00m>lisp());
atom.cc:1251:    for (b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end(); b++ ) {
atom.cc:1252:	list = O_Cons::create((*b)[01;31m-[00m>getToLocked(),list,this[01;31m-[00m>lisp());
atom.cc:1273:    bl = RP_Create<O_BondList>(this[01;31m-[00m>lisp());
atom.cc:1274:    for (b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end(); b++ ) {
atom.cc:1275:	bl[01;31m-[00m>addBond(*b);
atom.cc:1282:    return ::mbb::maxTotalBondOrderForElement(this[01;31m-[00m>getElement());
atom.cc:1291:    for (b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end(); b++ ) 
atom.cc:1293:	if ( (*b)[01;31m-[00m>getOrder() == singleBond ) twice += 2;
atom.cc:1294:	else if ((*b)[01;31m-[00m>getOrder() == doubleBond ) twice += 4;
atom.cc:1295:	else if ((*b)[01;31m-[00m>getOrder() == aromaticBond ) twice += 3;
atom.cc:1296:	else if ((*b)[01;31m-[00m>getOrder() == tripleBond ) twice += 6;
atom.cc:1297:	else if ((*b)[01;31m-[00m>getOrder() == dashedSingleBond ) twice += 2;
atom.cc:1298:	else if ((*b)[01;31m-[00m>getOrder() == dashedDoubleBond ) twice += 4;
atom.cc:1303:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The total bond order for "+this[01;31m-[00m>description()+" will not be a whole number"));
atom.cc:1313:    list = O_Cons::nil(this[01;31m-[00m>lisp());
atom.cc:1314:    for (b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end(); b++ ) {
atom.cc:1315:        list = O_Cons::create(*b,list,this[01;31m-[00m>lisp());
atom.cc:1321:{_F(this[01;31m-[00m>lisp());
atom.cc:1322:    return ((this[01;31m-[00m>_Element!=element_H) && (this[01;31m-[00m>_Element!=element_D) && (this[01;31m-[00m>_Element!=element_T));
atom.cc:1330:    bl = RP_Create<O_BondList>(this[01;31m-[00m>lisp());
atom.cc:1331:    for (b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end(); b++ ) {
atom.cc:1332:	if ( (*b)[01;31m-[00m>getTo().lock()[01;31m-[00m>getElement() != element_H ) {
atom.cc:1333:	    bl[01;31m-[00m>addBond(*b);
atom.cc:1344:    return atomicNumberForElement(this[01;31m-[00m>getElement());
atom.cc:1350:    return atomicWeightForElement(this[01;31m-[00m>getElement());
atom.cc:1360:    for (b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end(); b++ ) {
atom.cc:1361:	weakAtomTo = (*b)[01;31m-[00m>getTo();
atom.cc:1362:	if ( weakAtomTo.lock()[01;31m-[00m>isNil() )
atom.cc:1364:	    LOG(BF("The To atom connected to %s was undefined") % this[01;31m-[00m>description().c_str()  ); // vp0(( "The To atom connected to %s was undefined", this[01;31m-[00m>description().c_str() ));
atom.cc:1365:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Bad to[01;31m-[00matom from(%s)") % this[01;31m-[00m>description()));
atom.cc:1367:	if ( weakAtomTo.lock()[01;31m-[00m>getElement() == element_H ) hs++;
atom.cc:1377:            return this[01;31m-[00m>testAnyFlags(in3MemberRing);
atom.cc:1379:            return this[01;31m-[00m>testAnyFlags(in4MemberRing);
atom.cc:1381:            return this[01;31m-[00m>testAnyFlags(in5MemberRing);
atom.cc:1383:            return this[01;31m-[00m>testAnyFlags(in6MemberRing);
atom.cc:1385:            return this[01;31m-[00m>testAnyFlags(in7MemberRing);
atom.cc:1387:            return this[01;31m-[00m>testAnyFlags(in8MemberRing);
atom.cc:1395:{_F(this[01;31m-[00m>lisp());
atom.cc:1396:    this[01;31m-[00m>turnOffFlags(InRing);
atom.cc:1404:            this[01;31m-[00m>turnOnFlags(in3MemberRing);
atom.cc:1407:            this[01;31m-[00m>turnOnFlags(in4MemberRing);
atom.cc:1410:            this[01;31m-[00m>turnOnFlags(in5MemberRing);
atom.cc:1413:            this[01;31m-[00m>turnOnFlags(in6MemberRing);
atom.cc:1416:            this[01;31m-[00m>turnOnFlags(in7MemberRing);
atom.cc:1419:            this[01;31m-[00m>turnOnFlags(in8MemberRing);
atom.cc:1435:    for (b=this[01;31m-[00m>bonds.begin();b!=this[01;31m-[00m>bonds.end(); b++ ) {
atom.cc:1436:        bo = (*b)[01;31m-[00m>getOrder();
atom.cc:1458:{_F(this[01;31m-[00m>lisp());
atom.cc:1459:    if ( this[01;31m-[00m>_BackSpan.use_count() == 0 )
atom.cc:1461:	this[01;31m-[00m>_BackSpan = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Atom>();
atom.cc:1463:    return this[01;31m-[00m>_BackSpan.lock();
atom.cc:1468:{_F(this[01;31m-[00m>lisp());
atom.cc:1469:    if ( this[01;31m-[00m>_NextSpan.use_count() == 0 )
atom.cc:1471:	this[01;31m-[00m>_NextSpan = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Atom>();
atom.cc:1473:    return this[01;31m-[00m>_NextSpan.lock();
atom.cc:1479:    RPCons localTree = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>(incomingBond);
atom.cc:1482:    for ( VectorRPBond::iterator bi=this[01;31m-[00m>bonds.begin(); bi!=this[01;31m-[00m>bonds.end(); bi++ )
atom.cc:1484:	RPAtom neighborAtom = (*bi)[01;31m-[00m>getToLocked();
atom.cc:1486:	RPCons one = neighborAtom[01;31m-[00m>_expandLocalSpanningTree(this[01;31m-[00m>sharedThis<O_Atom>(),*bi,depth[01;31m-[00m1);
atom.cc:1487:	tail[01;31m-[00m>setCdr(one);
atom.cc:1494:{_F(this[01;31m-[00m>lisp());
atom.cc:1495:    RPCons localTree = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>(this[01;31m-[00m>sharedThisObject());
atom.cc:1498:    for ( VectorRPBond::iterator bi=this[01;31m-[00m>bonds.begin(); bi!=this[01;31m-[00m>bonds.end(); bi++ )
atom.cc:1500:	RPAtom neighborAtom = (*bi)[01;31m-[00m>getToLocked();
atom.cc:1501:	RPCons one = neighborAtom[01;31m-[00m>_expandLocalSpanningTree(this[01;31m-[00m>sharedThis<O_Atom>(),*bi,depth[01;31m-[00m1);
atom.cc:1502:	tail[01;31m-[00m>setCdr(one);
atom.cc:1511:    return this[01;31m-[00m>_StereochemistryType != undefinedCenter;
atom.cc:1516:{_F(this[01;31m-[00m>lisp());
atom.cc:1517:    Vector3& pos=this[01;31m-[00m>position;
atom.cc:1518:    this[01;31m-[00m>position.set(pos.getX(),pos.getY(),pos.getZ()*[01;31m-[00m1.0);
atom.cc:1519:    Vector3& anchor = this[01;31m-[00m>_AnchorRestraint._AnchorPos;
atom.cc:1520:    anchor.set(anchor.getX(),anchor.getY(),anchor.getZ()*[01;31m-[00m1.0);
atom.cc:1521:    ConfigurationEnum config = this[01;31m-[00m>_Configuration;
atom.cc:1524:	this[01;31m-[00m>_Configuration = R_Configuration;
atom.cc:1527:	this[01;31m-[00m>_Configuration = S_Configuration;
atom.cc:1537:    return this[01;31m-[00m>_Configuration;
atom.cc:1541:    ASSERTP(this[01;31m-[00m>isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1542:    this[01;31m-[00m>_ConfigurationInfo._HighestPriority = highest;
atom.cc:1543:    this[01;31m-[00m>_ConfigurationInfo._HighPriority = high;
atom.cc:1544:    this[01;31m-[00m>_ConfigurationInfo._LowPriority = low;
atom.cc:1545:    this[01;31m-[00m>_ConfigurationInfo._LowestPriority = lowest;
atom.cc:1550:    ASSERTP(this[01;31m-[00m>isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1551:    return this[01;31m-[00m>_ConfigurationInfo._HighestPriority;
atom.cc:1556:    ASSERTP(this[01;31m-[00m>isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1557:    return this[01;31m-[00m>_ConfigurationInfo._HighPriority;
atom.cc:1562:    ASSERTP(this[01;31m-[00m>isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1563:    return this[01;31m-[00m>_ConfigurationInfo._LowPriority;
atom.cc:1568:    ASSERTP(this[01;31m-[00m>isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1569:    return this[01;31m-[00m>_ConfigurationInfo._LowestPriority;
atom.cc:1578:    ASSERT_NOT_NULL(this[01;31m-[00m>containedBy());
atom.cc:1579:    containedBy = this[01;31m-[00m>containedBy();
atom.cc:1580:    if ( containedBy.lock()[01;31m-[00m>isNil() )
atom.cc:1582:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("This atom isnt contained by anything"));
atom.cc:1594:    return this[01;31m-[00m>containedByLock()[01;31m-[00m>as<O_Residue>();
atom.cc:1599:    return this[01;31m-[00m>containedByLock_const()[01;31m-[00m>as<O_Residue>();
atom.cc:1606:    this[01;31m-[00m>_WeakOligomerBuilder = b;
atom.cc:1611:    return this[01;31m-[00m>_WeakOligomerBuilder;
atom.cc:1616:    this[01;31m-[00m>_AtomHolderIndex = i;
atom.cc:1621:    return this[01;31m-[00m>_AtomHolderIndex;
atom.cc:1635:    x = randomNumber01(_lisp)*dist*2.0[01;31m-[00mdist+this[01;31m-[00m>position.getX();
atom.cc:1636:    y = randomNumber01(_lisp)*dist*2.0[01;31m-[00mdist+this[01;31m-[00m>position.getY();
atom.cc:1637:    z = randomNumber01(_lisp)*dist*2.0[01;31m-[00mdist+this[01;31m-[00m>position.getZ();
atom.cc:1638:    this[01;31m-[00m>position.set(x,y,z);
atom.cc:1644:    if ( this[01;31m-[00m>invalid() ) {
atom.cc:1645:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("INVALID %s")% this[01;31m-[00m>description()));
atom.cc:1655:    bonded = this[01;31m-[00m>getBondedAtoms();
atom.cc:1668:    enum_<AtomFlagEnum>(MbbPackage, "AtomFlags",_sym_MbbPackage_atomFlagSymbolConverter,lisp[01;31m-[00m>lisp())
atom.cc:1688:    class_<O_Atom>(this[01;31m-[00m>lisp())
atom.cc:1802:    this[01;31m-[00m>lisp()[01;31m-[00m>installGlobalInitializationCallback(&O_Atom::setupGlobals);
atomGrid.cc:43:    this[01;31m-[00m>Base::initialize();
atomGrid.cc:44:    this[01;31m-[00m>xSize = 0;
atomGrid.cc:45:    this[01;31m-[00m>ySize = 0;
atomGrid.cc:46:    this[01;31m-[00m>zSize = 0;
atomGrid.cc:59:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_AtomGrid>(args,environ);
atomGrid.cc:60:    RPMatter matter = from_object<RPMatter>::convert(bargs[01;31m-[00m>lookup("matter"));
atomGrid.cc:61:    double stepSize = from_object<RPReal>::convert(bargs[01;31m-[00m>lookup("gridResolution"))[01;31m-[00m>get();
atomGrid.cc:62:    double addRadius = from_object<RPReal>::convert(bargs[01;31m-[00m>lookup("addRadius"))[01;31m-[00m>get();
atomGrid.cc:63:    RPBoundingBox bbox = from_object<RPBoundingBox>::convert(bargs[01;31m-[00m>lookup("boundingBox"));
atomGrid.cc:64:    if ( bbox[01;31m-[00m>notNil() )
atomGrid.cc:66:        this[01;31m-[00m>buildGridWithinBoundingBox(matter,addRadius,stepSize,bbox);
atomGrid.cc:69:        this[01;31m-[00m>buildGrid(matter,addRadius,stepSize);
atomGrid.cc:71:    return lisp[01;31m-[00m>onil();
atomGrid.cc:75:{_F(this[01;31m-[00m>lisp());
atomGrid.cc:76:    this[01;31m-[00m>Base::archiveBase(node);
atomGrid.cc:77:    node[01;31m-[00m>attribute("xSize",this[01;31m-[00m>xSize);
atomGrid.cc:78:    node[01;31m-[00m>attribute("ySize",this[01;31m-[00m>ySize);
atomGrid.cc:79:    node[01;31m-[00m>attribute("zSize",this[01;31m-[00m>zSize);
atomGrid.cc:80:    node[01;31m-[00m>attribute("ballRadius",this[01;31m-[00m>ballRadius);
atomGrid.cc:81:    node[01;31m-[00m>attribute("stepSize",this[01;31m-[00m>stepSize);
atomGrid.cc:82:    node[01;31m-[00m>attribute("xMin",this[01;31m-[00m>xMin);
atomGrid.cc:83:    node[01;31m-[00m>attribute("yMin",this[01;31m-[00m>yMin);
atomGrid.cc:84:    node[01;31m-[00m>attribute("zMin",this[01;31m-[00m>zMin);
atomGrid.cc:85:    node[01;31m-[00m>attribute("xMax",this[01;31m-[00m>xMax);
atomGrid.cc:86:    node[01;31m-[00m>attribute("yMax",this[01;31m-[00m>yMax);
atomGrid.cc:87:    node[01;31m-[00m>attribute("zMax",this[01;31m-[00m>zMax);
atomGrid.cc:88:    if ( node[01;31m-[00m>saving() )
atomGrid.cc:98:	it = this[01;31m-[00m>grid.begin();
atomGrid.cc:105:		while (it!=this[01;31m-[00m>grid.end() && *it )
atomGrid.cc:115:		if ( it == this[01;31m-[00m>grid.end() ) done = true;
atomGrid.cc:119:	    while (it!=this[01;31m-[00m>grid.end() && !*it )
atomGrid.cc:126:	    if ( it == this[01;31m-[00m>grid.end() ) done = true;
atomGrid.cc:131:	node[01;31m-[00m>setCharacters(sout.str());
atomGrid.cc:136:	sin.str(node[01;31m-[00m>characters());
atomGrid.cc:137:	this[01;31m-[00m>grid.resize(this[01;31m-[00m>xSize*this[01;31m-[00m>ySize*this[01;31m-[00m>zSize,0);
atomGrid.cc:139:	it = this[01;31m-[00m>grid.begin();
atomGrid.cc:155:	    size_t zzt = (it [01;31m-[00m this[01;31m-[00m>grid.begin())+num;
atomGrid.cc:156:	    ASSERT_lt(zzt,this[01;31m-[00m>grid.size()+1);
atomGrid.cc:169:    this[01;31m-[00m>archiveBase(node);
atomGrid.cc:191:    xh = [01;31m-[00m9e99;
atomGrid.cc:192:    yh = [01;31m-[00m9e99;
atomGrid.cc:193:    zh = [01;31m-[00m9e99;
atomGrid.cc:198:	    diff = a[01;31m-[00m>getPosition() [01;31m-[00m sphereCenter;
atomGrid.cc:201:	xl = MIN( xl, a[01;31m-[00m>getPosition().getX() );
atomGrid.cc:202:	yl = MIN( yl, a[01;31m-[00m>getPosition().getY() );
atomGrid.cc:203:	zl = MIN( zl, a[01;31m-[00m>getPosition().getZ() );
atomGrid.cc:204:	xh = MAX( xh, a[01;31m-[00m>getPosition().getX() );
atomGrid.cc:205:	yh = MAX( yh, a[01;31m-[00m>getPosition().getY() );
atomGrid.cc:206:	zh = MAX( zh, a[01;31m-[00m>getPosition().getZ() );
atomGrid.cc:208:    this[01;31m-[00m>stepSize = step;
atomGrid.cc:209:    this[01;31m-[00m>xMin = xl[01;31m-[00mGRID_PAD;
atomGrid.cc:210:    this[01;31m-[00m>yMin = yl[01;31m-[00mGRID_PAD;
atomGrid.cc:211:    this[01;31m-[00m>zMin = zl[01;31m-[00mGRID_PAD;
atomGrid.cc:212:    this[01;31m-[00m>xMax = xh+GRID_PAD;
atomGrid.cc:213:    this[01;31m-[00m>yMax = yh+GRID_PAD;
atomGrid.cc:214:    this[01;31m-[00m>zMax = zh+GRID_PAD;
atomGrid.cc:215:    this[01;31m-[00m>xSize = (int)floor((this[01;31m-[00m>xMax[01;31m-[00mthis[01;31m-[00m>xMin)/step)+1;
atomGrid.cc:216:    this[01;31m-[00m>ySize = (int)floor((this[01;31m-[00m>yMax[01;31m-[00mthis[01;31m-[00m>yMin)/step)+1;
atomGrid.cc:217:    this[01;31m-[00m>zSize = (int)floor((this[01;31m-[00m>zMax[01;31m-[00mthis[01;31m-[00m>zMin)/step)+1;
atomGrid.cc:218:    this[01;31m-[00m>grid.resize( this[01;31m-[00m>xSize*this[01;31m-[00m>ySize*this[01;31m-[00m>zSize, false );
atomGrid.cc:223:#define	xIndex(ag,xPos) ((int)(floor(((xPos)[01;31m-[00mag[01;31m-[00m>xMin)/ag[01;31m-[00m>stepSize)))
atomGrid.cc:224:#define	yIndex(ag,yPos) ((int)(floor(((yPos)[01;31m-[00mag[01;31m-[00m>yMin)/ag[01;31m-[00m>stepSize)))
atomGrid.cc:225:#define	zIndex(ag,zPos) ((int)(floor(((zPos)[01;31m-[00mag[01;31m-[00m>zMin)/ag[01;31m-[00m>stepSize)))
atomGrid.cc:226:#define	xIndexBounded(ag,xPos) (MIN(MAX(0,xIndex(ag,xPos)),ag[01;31m-[00m>xSize[01;31m-[00m1))
atomGrid.cc:227:#define	yIndexBounded(ag,yPos) (MIN(MAX(0,yIndex(ag,yPos)),ag[01;31m-[00m>ySize[01;31m-[00m1))
atomGrid.cc:228:#define	zIndexBounded(ag,zPos) (MIN(MAX(0,zIndex(ag,zPos)),ag[01;31m-[00m>zSize[01;31m-[00m1))
atomGrid.cc:231:#define	gridIndex(gd,xi,yi,zi) (gd[01;31m-[00m>xSize*(gd[01;31m-[00m>ySize*(zi)+(yi))+(xi))
atomGrid.cc:234:#define	xPos(gd,xi) (gd[01;31m-[00m>xMin+((xi)*gd[01;31m-[00m>stepSize))
atomGrid.cc:235:#define	yPos(gd,yi) (gd[01;31m-[00m>yMin+((yi)*gd[01;31m-[00m>stepSize))
atomGrid.cc:236:#define	zPos(gd,zi) (gd[01;31m-[00m>zMin+((zi)*gd[01;31m-[00m>stepSize))
atomGrid.cc:253:    xBegin = xIndexBounded(this,pos.getX()[01;31m-[00mradius[01;31m-[00m1);
atomGrid.cc:254:    yBegin = yIndexBounded(this,pos.getY()[01;31m-[00mradius[01;31m-[00m1);
atomGrid.cc:255:    zBegin = zIndexBounded(this,pos.getZ()[01;31m-[00mradius[01;31m-[00m1);
atomGrid.cc:266:	    ip = this[01;31m-[00m>grid.begin()+ gridIndex(this,xBegin,yi,zi);
atomGrid.cc:271:		xp = xp [01;31m-[00m pos.getX();
atomGrid.cc:272:		yp = yp [01;31m-[00m pos.getY();
atomGrid.cc:273:		zp = zp [01;31m-[00m pos.getZ();
atomGrid.cc:312:    this[01;31m-[00m>grid.resize( this[01;31m-[00m>xSize*this[01;31m-[00m>ySize*this[01;31m-[00m>zSize, false );
atomGrid.cc:314:    this[01;31m-[00m>paint(container,addRadius);
atomGrid.cc:329:    this[01;31m-[00m>ballRadius = addRadius;
atomGrid.cc:330:    this[01;31m-[00m>defineMinMaxBox( container,
atomGrid.cc:335:    this[01;31m-[00m>privateBuildGrid( container, addRadius, stepSize);
atomGrid.cc:347:    this[01;31m-[00m>ballRadius = addRadius;
atomGrid.cc:348:    this[01;31m-[00m>defineMinMaxBox( container,
atomGrid.cc:353:    this[01;31m-[00m>privateBuildGrid( container, addRadius, stepSize );
atomGrid.cc:362:    ASSERT(bbox[01;31m-[00m>isDefined());
atomGrid.cc:363:    this[01;31m-[00m>stepSize = stepSize;
atomGrid.cc:364:    this[01;31m-[00m>xMin = bbox[01;31m-[00m>minCorner().getX();
atomGrid.cc:365:    this[01;31m-[00m>yMin = bbox[01;31m-[00m>minCorner().getY();
atomGrid.cc:366:    this[01;31m-[00m>zMin = bbox[01;31m-[00m>minCorner().getZ();
atomGrid.cc:367:    this[01;31m-[00m>xMax = bbox[01;31m-[00m>maxCorner().getX();
atomGrid.cc:368:    this[01;31m-[00m>yMax = bbox[01;31m-[00m>maxCorner().getY();
atomGrid.cc:369:    this[01;31m-[00m>zMax = bbox[01;31m-[00m>maxCorner().getZ();
atomGrid.cc:370:    this[01;31m-[00m>xSize = (int)floor((this[01;31m-[00m>xMax[01;31m-[00mthis[01;31m-[00m>xMin)/stepSize)+1;
atomGrid.cc:371:    this[01;31m-[00m>ySize = (int)floor((this[01;31m-[00m>yMax[01;31m-[00mthis[01;31m-[00m>yMin)/stepSize)+1;
atomGrid.cc:372:    this[01;31m-[00m>zSize = (int)floor((this[01;31m-[00m>zMax[01;31m-[00mthis[01;31m-[00m>zMin)/stepSize)+1;
atomGrid.cc:373:    this[01;31m-[00m>privateBuildGrid( container, addRadius, stepSize );
atomGrid.cc:378:{_F(this[01;31m-[00m>lisp());
atomGrid.cc:379:    if ( matter[01;31m-[00m>notNil() )
atomGrid.cc:381:	if ( matter[01;31m-[00m>isOfClass<O_Atom>() )
atomGrid.cc:383:	    RPAtom a = matter[01;31m-[00m>as<O_Atom>();
atomGrid.cc:384:	    a[01;31m-[00m>modifyFlags( ATOMFLAG_OFF, ON_GRID|ATOM_FIXED );
atomGrid.cc:385:	    double vdw = vdwRadiusForElement(a[01;31m-[00m>getElement());
atomGrid.cc:386:	    bool onGrid = this[01;31m-[00m>paintAtom( a[01;31m-[00m>getPosition(), vdw+pad);
atomGrid.cc:389:		a[01;31m-[00m>modifyFlags( ATOMFLAG_ON, ON_GRID|ATOM_FIXED );
atomGrid.cc:397:		a[01;31m-[00m>modifyFlags( ATOMFLAG_OFF, ON_GRID|ATOM_FIXED );
atomGrid.cc:398:		double vdw = vdwRadiusForElement(a[01;31m-[00m>getElement());
atomGrid.cc:399:		bool onGrid = this[01;31m-[00m>paintAtom( a[01;31m-[00m>getPosition(), vdw+pad);
atomGrid.cc:402:		    a[01;31m-[00m>modifyFlags( ATOMFLAG_ON, ON_GRID|ATOM_FIXED );
atomGrid.cc:417:this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "AtomGrid dump" ));
atomGrid.cc:418:this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("  size= ( %d, %d, %d )") % this[01;31m-[00m>xSize % this[01;31m-[00m>ySize % this[01;31m-[00m>zSize );
atomGrid.cc:419:this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "  min=(%lf, %lf, %lf)") % this[01;31m-[00m>xMin % this[01;31m-[00m>yMin % this[01;31m-[00m>zMin );
atomGrid.cc:420:this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "  max=(%lf, %lf, %lf)") % this[01;31m-[00m>xMax % this[01;31m-[00m>yMax % this[01;31m-[00m>zMax );
atomGrid.cc:421:this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "  ballRadius=%lf") % this[01;31m-[00m>ballRadius );
atomGrid.cc:422:this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "  stepSize=%lf") % this[01;31m-[00m>stepSize );
atomGrid.cc:423:this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "  grid Elements=%d") % (int)(this[01;31m-[00m>grid.size()) );
atomGrid.cc:426:    for ( uint i=0; i<this[01;31m-[00m>grid.size(); i++ ) {
atomGrid.cc:427:	if ( this[01;31m-[00m>grid[i] ) iOn++;
atomGrid.cc:430:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("  The grid has %d elements on and %d elements off") %	iOn % iOff );
atomGrid.cc:439:{_F(this[01;31m-[00m>lisp());
atomGrid.cc:446:    RPGrPolygon polygon = O_GrPolygon::create(this[01;31m-[00m>lisp());
atomGrid.cc:447:    polygon[01;31m-[00m>setSurfaceNormal(vn);
atomGrid.cc:448:    polygon[01;31m-[00m>addVertex(v1);
atomGrid.cc:449:    polygon[01;31m-[00m>addVertex(v2);
atomGrid.cc:450:    polygon[01;31m-[00m>addVertex(v3);
atomGrid.cc:451:    polygon[01;31m-[00m>addVertex(v4);
atomGrid.cc:452:    dl[01;31m-[00m>add(polygon);
atomGrid.cc:454:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,1));
atomGrid.cc:455:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>creaet<O_GrLine>(v2,v3,1));
atomGrid.cc:456:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v3,v4,1));
atomGrid.cc:457:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v4,v1,1));
atomGrid.cc:468:{_F(this[01;31m-[00m>lisp());
atomGrid.cc:482:    RPRenderDisplayList	result = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
atomGrid.cc:486:    gsize = this[01;31m-[00m>grid.size();
atomGrid.cc:492:    v1.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMin, this[01;31m-[00m>zMin );
atomGrid.cc:493:    v2.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMin, this[01;31m-[00m>zMin );
atomGrid.cc:494:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("red"));
atomGrid.cc:495:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:496:    v1.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMin, this[01;31m-[00m>zMin );
atomGrid.cc:497:    v2.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMax, this[01;31m-[00m>zMin );
atomGrid.cc:498:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:499:    v1.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMin, this[01;31m-[00m>zMin );
atomGrid.cc:500:    v2.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMin, this[01;31m-[00m>zMax );
atomGrid.cc:501:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:503:    v1.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMax, this[01;31m-[00m>zMax );
atomGrid.cc:504:    v2.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMax, this[01;31m-[00m>zMin );
atomGrid.cc:505:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:506:    v1.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMax, this[01;31m-[00m>zMax );
atomGrid.cc:507:    v2.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMax, this[01;31m-[00m>zMax );
atomGrid.cc:508:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:509:    v1.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMax, this[01;31m-[00m>zMax );
atomGrid.cc:510:    v2.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMin, this[01;31m-[00m>zMax );
atomGrid.cc:511:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:513:    v1.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMin, this[01;31m-[00m>zMin );
atomGrid.cc:514:    v2.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMax, this[01;31m-[00m>zMin );
atomGrid.cc:515:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:516:    v1.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMin, this[01;31m-[00m>zMin );
atomGrid.cc:517:    v2.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMin, this[01;31m-[00m>zMax );
atomGrid.cc:518:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:520:    v1.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMax, this[01;31m-[00m>zMin );
atomGrid.cc:521:    v2.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMax, this[01;31m-[00m>zMin );
atomGrid.cc:522:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:523:    v1.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMax, this[01;31m-[00m>zMin );
atomGrid.cc:524:    v2.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMax, this[01;31m-[00m>zMax );
atomGrid.cc:525:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:527:    v1.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMin, this[01;31m-[00m>zMax );
atomGrid.cc:528:    v2.set(this[01;31m-[00m>xMax, this[01;31m-[00m>yMin, this[01;31m-[00m>zMax );
atomGrid.cc:529:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:530:    v1.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMin, this[01;31m-[00m>zMax );
atomGrid.cc:531:    v2.set(this[01;31m-[00m>xMin, this[01;31m-[00m>yMax, this[01;31m-[00m>zMax );
atomGrid.cc:532:    result[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(v1,v2,2));
atomGrid.cc:534:    RPGrColor color = O_GrColor::create(this[01;31m-[00m>lisp());
atomGrid.cc:535:    color[01;31m-[00m>setRGB(0.4,1.0,0.4);
atomGrid.cc:536:    result[01;31m-[00m>add(color);
atomGrid.cc:537:    halfStep = this[01;31m-[00m>stepSize/2.0;
atomGrid.cc:538:    for ( zi=0; zi!=this[01;31m-[00m>zSize; zi++ ) {
atomGrid.cc:539:	LOG(BF("Rendering a Z[01;31m-[00mslice: %d") % (zi ) ); // vp0(( "Rendering a Z[01;31m-[00mslice: %d", zi ));
atomGrid.cc:540:	for ( yi=0; yi!=this[01;31m-[00m>ySize; yi++ ) {
atomGrid.cc:541:	    for ( xi=0; xi!=this[01;31m-[00m>xSize; xi++ ) {
atomGrid.cc:544:		if ( this[01;31m-[00m>grid[gi] ) {
atomGrid.cc:546:		    gixm = gridIndex(this,xi[01;31m-[00m1,yi,zi);
atomGrid.cc:548:		    giym = gridIndex(this,xi,yi[01;31m-[00m1,zi);
atomGrid.cc:550:		    gizm = gridIndex(this,xi,yi,zi[01;31m-[00m1);
atomGrid.cc:552:		    xmin = xPos(this,xi)[01;31m-[00mhalfStep;
atomGrid.cc:553:		    ymin = yPos(this,yi)[01;31m-[00mhalfStep;
atomGrid.cc:554:		    zmin = zPos(this,zi)[01;31m-[00mhalfStep;
atomGrid.cc:558:		    edge = (gixm>0 )?(!this[01;31m-[00m>grid[gixm]):true;
atomGrid.cc:560:			this[01;31m-[00m>renderSquare( result,
atomGrid.cc:561:						[01;31m-[00m1.0, 0.0, 0.0,
atomGrid.cc:567:		    edge = (gixp<gsize)?(!this[01;31m-[00m>grid[gixp]):true;
atomGrid.cc:569:			this[01;31m-[00m>renderSquare( result,
atomGrid.cc:576:		    edge = (giym>0)?(!this[01;31m-[00m>grid[giym]):true;
atomGrid.cc:578:			this[01;31m-[00m>renderSquare( result,
atomGrid.cc:579:						0.0, [01;31m-[00m1.0, 0.0,
atomGrid.cc:585:		    edge = (giyp<gsize)?(!this[01;31m-[00m>grid[giyp]):true;
atomGrid.cc:587:			this[01;31m-[00m>renderSquare( result,
atomGrid.cc:594:		    edge = (gizm>0)?(!this[01;31m-[00m>grid[gizm]):true;
atomGrid.cc:596:			this[01;31m-[00m>renderSquare( result,
atomGrid.cc:597:						0.0, 0.0, [01;31m-[00m1.0,
atomGrid.cc:603:		    edge = (gizp<gsize)?(!this[01;31m-[00m>grid[gizp]):true;
atomGrid.cc:605:			this[01;31m-[00m>renderSquare( result,
atomGrid.cc:622:{_F(this[01;31m-[00m>lisp());
atomGrid.cc:623:    for ( uint i=0; i<this[01;31m-[00m>grid.size(); i++ ) {
atomGrid.cc:624:	this[01;31m-[00m>grid[i] = !this[01;31m-[00m>grid[i];
atomGrid.cc:642:    LOG(BF( "collision test at: %d, %d, %d [01;31m-[00m[01;31m-[00m>") % xi % yi % zi );
atomGrid.cc:643:    if ( xi<0 || xi>=this[01;31m-[00m>xSize ) goto NOCOLLISION;
atomGrid.cc:644:    if ( yi<0 || yi>=this[01;31m-[00m>ySize ) goto NOCOLLISION;
atomGrid.cc:645:    if ( zi<0 || zi>=this[01;31m-[00m>zSize ) goto NOCOLLISION;
atomGrid.cc:649:    if ( this[01;31m-[00m>grid[ii] ) goto COLLISION;
atomGrid.cc:663:    class_<O_AtomGrid>(this[01;31m-[00m>lisp())
atomGridCollisionRejector.cc:22:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
atomGridCollisionRejector.cc:24:    this[01;31m-[00m>_AtomAliases.fillFromCons(kargs[01;31m-[00m>getAndRemove("aliases")[01;31m-[00m>as<O_Cons>());
atomGridCollisionRejector.cc:25:    this[01;31m-[00m>_AtomGrid = kargs[01;31m-[00m>getAndRemove("atomGrid")[01;31m-[00m>as<O_AtomGrid>();
atomGridCollisionRejector.cc:30:    this[01;31m-[00m>Base::initialize();
atomGridCollisionRejector.cc:31:    this[01;31m-[00m>_AtomAliases.clear();
atomGridCollisionRejector.cc:32:    this[01;31m-[00m>_AtomGrid = O_AtomGrid::nil(this[01;31m-[00m>lisp());
atomGridCollisionRejector.cc:37:    this[01;31m-[00m>Base::archiveBase(node);
atomGridCollisionRejector.cc:38:    node[01;31m-[00m>archiveList("atomAliases",this[01;31m-[00m>_AtomAliases);
atomGridCollisionRejector.cc:39:    node[01;31m-[00m>archiveObject("atomGrid",this[01;31m-[00m>_AtomGrid);
atomGridCollisionRejector.cc:44:{_F(this[01;31m-[00m>lisp());
atomGridCollisionRejector.cc:45:    this[01;31m-[00m>_OligomerChangeCounter = builder[01;31m-[00m>getOligomerChangeCounter();
atomGridCollisionRejector.cc:46:    for ( List<O_Alias>::iterator it=this[01;31m-[00m>_AtomAliases.begin();
atomGridCollisionRejector.cc:47:    		it!=this[01;31m-[00m>_AtomAliases.end(); it++ )
atomGridCollisionRejector.cc:49:	(*it)[01;31m-[00m>oligomerChanged(builder);
atomGridCollisionRejector.cc:54:{_F(this[01;31m-[00m>lisp());
atomGridCollisionRejector.cc:55:    this[01;31m-[00m>_SequenceChangeCounter = builder[01;31m-[00m>getSequenceChangeCounter();
atomGridCollisionRejector.cc:56:    for ( List<O_Alias>::iterator it=this[01;31m-[00m>_AtomAliases.begin();
atomGridCollisionRejector.cc:57:    		it!=this[01;31m-[00m>_AtomAliases.end(); it++ )
atomGridCollisionRejector.cc:59:	(*it)[01;31m-[00m>sequenceChanged(builder);
atomGridCollisionRejector.cc:65:{_F(this[01;31m-[00m>lisp());
atomGridCollisionRejector.cc:66:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_OligomerChangeCounter,
atomGridCollisionRejector.cc:67:    					this[01;31m-[00m>sharedThis<O_AtomGridCollisionRejector>());
atomGridCollisionRejector.cc:68:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
atomGridCollisionRejector.cc:69:    					this[01;31m-[00m>sharedThis<O_AtomGridCollisionRejector>());
atomGridCollisionRejector.cc:71:    for ( List<O_Alias>::iterator it=this[01;31m-[00m>_AtomAliases.begin();
atomGridCollisionRejector.cc:72:    		it!=this[01;31m-[00m>_AtomAliases.end(); it++ )
atomGridCollisionRejector.cc:74:	Vector3 pos = (*it)[01;31m-[00m>getScoreTransformedAtomPosition(builder,state);
atomGridCollisionRejector.cc:75:	if ( this[01;31m-[00m>_AtomGrid[01;31m-[00m>collisionAt(pos) )
atomGridCollisionRejector.cc:84:{_F(this[01;31m-[00m>lisp());
atomGridCollisionRejector.cc:85:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_OligomerChangeCounter,
atomGridCollisionRejector.cc:86:    					this[01;31m-[00m>sharedThis<O_AtomGridCollisionRejector>());
atomGridCollisionRejector.cc:87:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
atomGridCollisionRejector.cc:88:    					this[01;31m-[00m>sharedThis<O_AtomGridCollisionRejector>());
atomGridCollisionRejector.cc:89:    for ( List<O_Alias>::iterator it=this[01;31m-[00m>_AtomAliases.begin();
atomGridCollisionRejector.cc:90:    		it!=this[01;31m-[00m>_AtomAliases.end(); it++ )
atomGridCollisionRejector.cc:92:	Vector3 pos = (*it)[01;31m-[00m>getScoreTransformedAtomPosition(builder,state);
atomGridCollisionRejector.cc:93:	if ( this[01;31m-[00m>_AtomGrid[01;31m-[00m>collisionAt(pos) )
atomGridCollisionRejector.cc:103:{_F(this[01;31m-[00m>lisp());
atomGridCollisionRejector.cc:104:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
atomGridCollisionRejector.cc:105:    dl[01;31m-[00m>setName("gridAvoiders");
atomGridCollisionRejector.cc:107:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_OligomerChangeCounter,
atomGridCollisionRejector.cc:108:    					this[01;31m-[00m>sharedThis<O_AtomGridCollisionRejector>());
atomGridCollisionRejector.cc:109:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
atomGridCollisionRejector.cc:110:    					this[01;31m-[00m>sharedThis<O_AtomGridCollisionRejector>());
atomGridCollisionRejector.cc:114://    RPRender atomGrid = this[01;31m-[00m>_AtomGrid[01;31m-[00m>rendered(O_KeyedArguments::nil(this[01;31m-[00m>lisp()));
atomGridCollisionRejector.cc:115://    dl[01;31m-[00m>add(atomGrid);
atomGridCollisionRejector.cc:116:    RPRenderDisplayList points = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
atomGridCollisionRejector.cc:117:    for ( List<O_Alias>::iterator it=this[01;31m-[00m>_AtomAliases.begin();
atomGridCollisionRejector.cc:118:    		it!=this[01;31m-[00m>_AtomAliases.end(); it++ )
atomGridCollisionRejector.cc:120:	Vector3 pos = (*it)[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
atomGridCollisionRejector.cc:121:	if ( this[01;31m-[00m>_AtomGrid[01;31m-[00m>collisionAt(pos) )
atomGridCollisionRejector.cc:123:	    RPGrColor c = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("red");
atomGridCollisionRejector.cc:124:	    points[01;31m-[00m>add(c);
atomGridCollisionRejector.cc:127:	    RPGrColor c = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("green");
atomGridCollisionRejector.cc:128:	    points[01;31m-[00m>add(c);
atomGridCollisionRejector.cc:130:	RPGrSphere sp = O_GrSphere::create(pos,0.2,this[01;31m-[00m>lisp());
atomGridCollisionRejector.cc:131:	points[01;31m-[00m>add(sp);
atomGridCollisionRejector.cc:133:    dl[01;31m-[00m>add(points);
atomGridCollisionRejector.cc:144:	class_<O_AtomGridCollisionRejector>(this[01;31m-[00m>lisp())
atomIndexer.cc:24:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:25://    node[01;31m-[00m>attribute("indexAll",this[01;31m-[00m>_IndexAll);
atomIndexer.cc:26:    node[01;31m-[00m>archiveVectorStrings("AtomNames",this[01;31m-[00m>_Names);
atomIndexer.cc:31:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:32://    this[01;31m-[00m>_IndexAll = false;
atomIndexer.cc:33:    if ( !this[01;31m-[00m>containsAtomName(name) )
atomIndexer.cc:35:        int id = this[01;31m-[00m>_Names.size();
atomIndexer.cc:36:        this[01;31m-[00m>_Names.push_back(name);
atomIndexer.cc:40:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("The atom name("+name+") is already in the AtomIndexer"));
atomIndexer.cc:44:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:49:    this[01;31m-[00m>_Names.clear();
atomIndexer.cc:54:	    this[01;31m-[00m>_Names.push_back(*it);
atomIndexer.cc:61:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:63:    LOG(BF("Setting from atom names: %s") % sl[01;31m-[00m>asString().c_str()  ); // vp0(("Setting from atom names: %s",sl[01;31m-[00m>asString().c_str() ));
atomIndexer.cc:64:    for ( it = sl[01;31m-[00m>begin(); it!=sl[01;31m-[00m>end(); it++ )
atomIndexer.cc:68:	    this[01;31m-[00m>_Names.push_back(*it);
atomIndexer.cc:74:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:75:    LOG(BF("Appending atom names: %s") % sl[01;31m-[00m>__repr__().c_str()  ); // vp0(("Appending atom names: %s",sl[01;31m-[00m>__repr__().c_str() ));
atomIndexer.cc:76:    for ( RPCons cur=sl; cur[01;31m-[00m>notNil(); cur=cur[01;31m-[00m>cdr() )
atomIndexer.cc:78:        this[01;31m-[00m>_Names.push_back(cur[01;31m-[00m>car<O_Text>()[01;31m-[00m>get());
atomIndexer.cc:87:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:89://    if ( this[01;31m-[00m>_IndexAll ) return true;
atomIndexer.cc:90:    for ( mi=this[01;31m-[00m>_Names.begin(); mi!=this[01;31m-[00m>_Names.end(); mi++ )
atomIndexer.cc:103:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:107:    for ( mi=this[01;31m-[00m>_Names.begin(); mi!=this[01;31m-[00m>_Names.end(); mi++ )
atomIndexer.cc:115:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find name("+name+") in AtomIndexer"));
atomIndexer.cc:120:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:124:    if ( this[01;31m-[00m>_Names.size() > 0 )
atomIndexer.cc:126:        ss << *(this[01;31m-[00m>_Names.begin());
atomIndexer.cc:127:	for ( mi=this[01;31m-[00m>_Names.begin()+1; mi!=this[01;31m-[00m>_Names.end(); mi++ )
atomIndexer.cc:137:    return "AtomIndexer["+this[01;31m-[00m>asString()+"]";
atomIndexer.cc:143:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:144:    this[01;31m-[00m>_IndexAll = b;
atomIndexer.cc:145:    if ( this[01;31m-[00m>_IndexAll )
atomIndexer.cc:147:        this[01;31m-[00m>_Names.clear();
atomIndexer.cc:163:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:164:    node[01;31m-[00m>archiveMapOfObjectsSubClassOf<O_AtomIndexer>(this[01;31m-[00m>_AtomIndexers);
atomIndexer.cc:168:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:169:    this[01;31m-[00m>_AtomIndexers.set(nm,ai);
atomIndexer.cc:173:{_F(this[01;31m-[00m>lisp());
atomIndexer.cc:174:    this[01;31m-[00m>_AtomIndexers.erase(nm);
atomReference.cc:22:	class_<O_AtomReferenceBase>(lisp[01;31m-[00m>lisp())
atomReference.cc:28:	this[01;31m-[00m>Base::initialize();
atomReference.cc:33:	this[01;31m-[00m>Base::archiveBase(node);
atomReference.cc:40:	class_<O_AtomReference>(lisp[01;31m-[00m>lisp())
atomReference.cc:46:	this[01;31m-[00m>Base::initialize();
atomReference.cc:51:	this[01;31m-[00m>Base::archiveBase(node);
atomReference.cc:52:	node[01;31m-[00m>attribute("atom",this[01;31m-[00m>_AtomAlias);
atomReference.cc:57:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_AtomReference>(args,environ);
atomReference.cc:58:    this[01;31m-[00m>_AtomAlias = from_object<string>::convert(bargs[01;31m-[00m>lookup("alias"));
atomReference.cc:59:    return lisp[01;31m-[00m>onil();
atomReference.cc:67:	if ( this[01;31m-[00m>eqV(o) ) return true;
atomReference.cc:68:	if ( this[01;31m-[00m>_AtomAlias == o[01;31m-[00m>as<O_AtomReference>()[01;31m-[00m>_AtomAlias ) return true;
bitVector.cc:23://	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Extracted element: %d = %s") % i % x.c_str() );
bitVector.cc:24:	this[01;31m-[00m>setBit(x,1);
bitVector.cc:33:    for ( i=0; i!=this[01;31m-[00m>length; i++ ) {
bitVector.cc:34:	if ( this[01;31m-[00m>testBit(i) ) {
bitVector.cc:62:    this[01;31m-[00m>setLength(bv.length);
bitVector.cc:63:    for (i=0; i<this[01;31m-[00m>bits.size(); i++ ) {
bitVector.cc:64:	this[01;31m-[00m>bits[i] = bv.bits[i];
bitVector.cc:75:{_F(this[01;31m-[00m>lisp());
bitVector.cc:94:	this[01;31m-[00m>_figureOutBitBlockBitLength();
bitVector.cc:97:    blocks = (l + BitBlockBitLength [01;31m-[00m 1)/BitBlockBitLength;
bitVector.cc:98:    this[01;31m-[00m>bits.resize(blocks,0);
bitVector.cc:100:    this[01;31m-[00m>length = l;
bitVector.cc:106:{_F(this[01;31m-[00m>lisp());
bitVector.cc:110:    for ( i=0; i!=this[01;31m-[00m>length; i++ ) {
bitVector.cc:111:	if ( this[01;31m-[00m>testBit(i) ) {
bitVector.cc:123:    if ( this[01;31m-[00m>length != bv[01;31m-[00m>length ) return false;
bitVector.cc:124:    for ( i=0; i<this[01;31m-[00m>bits.size(); i++ ) {
bitVector.cc:125:	if ( this[01;31m-[00m>bits[i] != bv[01;31m-[00m>bits[i] ) {
bitVector.cc:139:    for ( vi=this[01;31m-[00m>bits.begin(); vi!=this[01;31m-[00m>bits.end(); vi++ ) {
bitVector.cc:152:    if ( i>=this[01;31m-[00m>length ) {
bitVector.cc:153:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("BitVector index overflow"));
bitVector.cc:160:    this[01;31m-[00m>bits[block] = (this[01;31m-[00m>bits[block] & mask )|packedVal;
bitVector.cc:164:{_F(this[01;31m-[00m>lisp());
bitVector.cc:174:    LOG(BF("bits[%04d] = |%lx|") % block % this[01;31m-[00m>bits[block]  ); // vp0(( "bits[%04d] = |%lx|", block, this[01;31m-[00m>bits[block] ));
bitVector.cc:175:    BitBlockType result = (this[01;31m-[00m>bits[block]&mask);
bitVector.cc:184:    if (this[01;31m-[00m>length != bv[01;31m-[00m>length) {
bitVector.cc:185:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("BitVectors aren't the same length for operation"));
bitVector.cc:187:    for ( i = 0; i!= this[01;31m-[00m>bits.size(); i++ ) {
bitVector.cc:188:	this[01;31m-[00m>bits[i] |= bv[01;31m-[00m>bits[i];
bitVector.cc:196:    if (this[01;31m-[00m>length != bv[01;31m-[00m>length) {
bitVector.cc:197:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("BitVectors aren't the same length for operation"));
bitVector.cc:199:    for ( i = 0; i!= this[01;31m-[00m>bits.size(); i++ ) {
bitVector.cc:200:	this[01;31m-[00m>bits[i] &= bv[01;31m-[00m>bits[i];
bitVector.cc:207:    if (this[01;31m-[00m>length != bv[01;31m-[00m>length) {
bitVector.cc:208:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("BitVectors aren't the same length for operation"));
bitVector.cc:210:    for ( i = 0; i!= this[01;31m-[00m>bits.size(); i++ ) {
bitVector.cc:211:	this[01;31m-[00m>bits[i] ^= bv[01;31m-[00m>bits[i];
bitVector.cc:219:    res = this[01;31m-[00m>copy();
bitVector.cc:220:    res[01;31m-[00m>inPlaceOr(bv);
bitVector.cc:228:    res = this[01;31m-[00m>copy();
bitVector.cc:229:    res[01;31m-[00m>inPlaceAnd(bv);
bitVector.cc:236:    res = this[01;31m-[00m>copy();
bitVector.cc:237:    res[01;31m-[00m>inPlaceXor(bv);
bitVector.cc:249:    for ( i=0; i<this[01;31m-[00m>length; i++ ) {
bitVector.cc:250:	if( this[01;31m-[00m>testBit(i) ) c++;
bitVector.cc:262:    for ( i=0; i<this[01;31m-[00m>length; i++ ) {
bitVector.cc:263:	s << this[01;31m-[00m>testBit(i);
bitVector.cc:270:{_F(this[01;31m-[00m>lisp());
bitVector.cc:273:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakThis);
bitVector.cc:288:    for ( i=0; i<this[01;31m-[00m>length; i++ ) {
bitVector.cc:289:	out << this[01;31m-[00m>testBit(i);
bitVector.cc:303:    this[01;31m-[00m>dumpToStream(cout);
bitVector.cc:315:    for ( i=0; i<this[01;31m-[00m>length; i++ ) {
bitVector.cc:316:	if ( this[01;31m-[00m>testBit(i) ) {
bitVector.cc:327:    for ( i=0; i<this[01;31m-[00m>length; i++ ) {
bitVector.cc:328:	if ( this[01;31m-[00m>testBit(i) ) {
bitVector.cc:340:    class_<O_BitVector>(this[01;31m-[00m>lisp())
bond.cc:28:    bond[01;31m-[00m>setFrom(from);
bond.cc:29:    bond[01;31m-[00m>setTo(to);
bond.cc:30:    bond[01;31m-[00m>setOrder(o);
bond.cc:31:    LOG(BF("created bond from=%s to=%s") % bond[01;31m-[00m>getFrom().lock()[01;31m-[00m>description().c_str() % bond[01;31m-[00m>getTo().lock()[01;31m-[00m>description().c_str()  ); // vp0(("created bond from=%s to=%s",bond[01;31m-[00m>getFrom().lock()[01;31m-[00m>description().c_str(),bond[01;31m-[00m>getTo().lock()[01;31m-[00m>description().c_str() ));
bond.cc:38:    this[01;31m-[00m>Base::initialize();
bond.cc:39:    this[01;31m-[00m>order = singleBond;
bond.cc:41:    this[01;31m-[00m>fromAtom = O_Atom::nil(this[01;31m-[00m>lisp());
bond.cc:42:    this[01;31m-[00m>toAtom = O_Atom::nil(this[01;31m-[00m>lisp());
bond.cc:46:{_F(this[01;31m-[00m>lisp());
bond.cc:49:    this[01;31m-[00m>order = bb.order;
bond.cc:50:    this[01;31m-[00m>fromAtom = bb.fromAtom;
bond.cc:51:    this[01;31m-[00m>toAtom = bb.toAtom;
bond.cc:52:    LOG(BF("copy fromAtom=%s toAtom=%s") % this[01;31m-[00m>fromAtom.lock()[01;31m-[00m>description().c_str() % this[01;31m-[00m>toAtom.lock()[01;31m-[00m>description().c_str()  ); // vp0(("copy fromAtom=%s toAtom=%s",this[01;31m-[00m>fromAtom.lock()[01;31m-[00m>description().c_str(),this[01;31m-[00m>toAtom.lock()[01;31m-[00m>description().c_str() ));
bond.cc:62://	Return true if this is an inter[01;31m-[00mresidue bond
bond.cc:65:{_F(this[01;31m-[00m>lisp());
bond.cc:69:    from = this[01;31m-[00m>getFrom();
bond.cc:71:    LOG(BF("from atom = %s") % from.lock()[01;31m-[00m>description().c_str() ); // vp0(( "from atom = %s", from.lock()[01;31m-[00m>description().c_str()));
bond.cc:72:    wfromCont = from.lock()[01;31m-[00m>getResidueContainedBy();
bond.cc:74:    if ( wfromCont.lock()[01;31m-[00m>isNil() )
bond.cc:76:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("From atom isnt in a residue"));
bond.cc:78:    to = this[01;31m-[00m>getTo();
bond.cc:80:    wtoCont = to.lock()[01;31m-[00m>getResidueContainedBy();
bond.cc:82:    if ( wtoCont.lock()[01;31m-[00m>isNil() )
bond.cc:84:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("To atom isnt in a residue"));
bond.cc:104:{ "", [01;31m-[00m1 }
bond.cc:117:{_F(this[01;31m-[00m>lisp());
bond.cc:118:    LOG(BF("archive direction = %s") % (node[01;31m-[00m>loading()?"loading":"saving") ); // vp0(("archive direction = %s",(node[01;31m-[00m>loading()?"loading":"saving")));
bond.cc:119:    node[01;31m-[00m>attributeEnum("order",this[01;31m-[00m>order, bondOrderKeys );
bond.cc:121:    if ( !node[01;31m-[00m>loading() )
bond.cc:123:        LOG(BF("before save this[01;31m-[00m>fromAtom = %s") % this[01;31m-[00m>fromAtom.lock()[01;31m-[00m>description().c_str()  ); // vp0(("before save this[01;31m-[00m>fromAtom = %s",this[01;31m-[00m>fromAtom.lock()[01;31m-[00m>description().c_str() ));
bond.cc:124:        LOG(BF("before save this[01;31m-[00m>toAtom = %s") % this[01;31m-[00m>toAtom.lock()[01;31m-[00m>description().c_str()  ); // vp0(("before save this[01;31m-[00m>toAtom = %s",this[01;31m-[00m>toAtom.lock()[01;31m-[00m>description().c_str() ));
bond.cc:127:    node[01;31m-[00m>archiveWeakPointer<O_Atom>( "from", this[01;31m-[00m>fromAtom  );
bond.cc:128:    node[01;31m-[00m>archiveWeakPointer<O_Atom>( "to", this[01;31m-[00m>toAtom );
bond.cc:130:    if ( node[01;31m-[00m>loading() )
bond.cc:132:        LOG(BF("after load this[01;31m-[00m>fromAtom = %s") % this[01;31m-[00m>fromAtom.lock()[01;31m-[00m>description().c_str()  ); // vp0(("after load this[01;31m-[00m>fromAtom = %s",this[01;31m-[00m>fromAtom.lock()[01;31m-[00m>description().c_str() ));
bond.cc:133:        LOG(BF("after load this[01;31m-[00m>toAtom = %s") % this[01;31m-[00m>toAtom.lock()[01;31m-[00m>description().c_str()  ); // vp0(("after load this[01;31m-[00m>toAtom = %s",this[01;31m-[00m>toAtom.lock()[01;31m-[00m>description().c_str() ));
bond.cc:141:{_F(this[01;31m-[00m>lisp());
bond.cc:142:    WPAtom watom = this[01;31m-[00m>getFrom();
bond.cc:144:    if ( watom.lock()[01;31m-[00m>isNil() )
bond.cc:146:	WPAtom other = this[01;31m-[00m>getTo();
bond.cc:148:	if ( other.lock()[01;31m-[00m>isNil() )
bond.cc:150:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("WOW, both atoms of a bond are undefined"));
bond.cc:152:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("From atom undefined (to atom is: %s)") % other.lock()[01;31m-[00m>description() ));
bond.cc:159:{_F(this[01;31m-[00m>lisp());
bond.cc:160:    WPAtom watom = this[01;31m-[00m>getTo();
bond.cc:163:    if ( watom.lock()[01;31m-[00m>isNil() )
bond.cc:165:	WPAtom other = this[01;31m-[00m>getFrom();
bond.cc:167:	if ( other.lock()[01;31m-[00m>isNil() )
bond.cc:169:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("WOW, both atoms of a bond are undefined"));
bond.cc:172:	LOG(BF("getToLocked failed, from atom is(%s) it has %d bonds") % atom[01;31m-[00m>description().c_str() % atom[01;31m-[00m>numberOfBonds()  ); // vp0(( "getToLocked failed, from atom is(%s) it has %d bonds", atom[01;31m-[00m>description().c_str(), atom[01;31m-[00m>numberOfBonds() ));
bond.cc:173:	for ( vector<RPBond>::iterator bi=atom[01;31m-[00m>bonds_begin();
bond.cc:174:				bi!=atom[01;31m-[00m>bonds_end(); bi++ ) {
bond.cc:175:	    LOG(BF("bond %d description(%s)") % (bi[01;31m-[00matom[01;31m-[00m>bonds_begin()) % (*bi)[01;31m-[00m>description().c_str()  ); // vp0(( "bond %d description(%s)", bi[01;31m-[00matom[01;31m-[00m>bonds_begin(), (*bi)[01;31m-[00m>description().c_str() ));
bond.cc:177:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("To atom undefined (from atom is: %s)") % other.lock()[01;31m-[00m>description() ));
bond.cc:180:    LOG(BF("Returning atom: %s") % atom[01;31m-[00m>description().c_str()  ); // vp0(("Returning atom: %s",atom[01;31m-[00m>description().c_str() ));
bond.cc:190:    wfrom = this[01;31m-[00m>getFrom_const();
bond.cc:192:    ss << wfrom.lock()[01;31m-[00m>description();
bond.cc:193:    ss << bondOrderToChar(this[01;31m-[00m>order);
bond.cc:194:    wto = this[01;31m-[00m>getTo_const();
bond.cc:196:    ss << wto.lock()[01;31m-[00m>description();
bond.cc:206:    ASSERT_NOT_NULL(this[01;31m-[00m>getFrom());
bond.cc:207:    ASSERT_NOT_NULL(this[01;31m-[00m>getTo());
bond.cc:208:    if ( this[01;31m-[00m>getFrom().lock()[01;31m-[00m>isNil() ) return true;
bond.cc:209:    if ( this[01;31m-[00m>getTo().lock()[01;31m-[00m>isNil() ) return true;
bond.cc:210:    if ( a!=this[01;31m-[00m>getFrom().lock() ) return true;
bond.cc:215:{_F(this[01;31m-[00m>lisp());
bond.cc:216:    if ( this[01;31m-[00m>invalid(a) ) {
bond.cc:217:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("INVALID %s")%this[01;31m-[00m>description()));
bond.cc:224:{_F(this[01;31m-[00m>lisp());
bond.cc:228:    fa = this[01;31m-[00m>fromAtom.lock();
bond.cc:229:    ta = this[01;31m-[00m>toAtom.lock();
bond.cc:233:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("redirectToAtomCopies fromAtom is NULL"));
bond.cc:238:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("redirectToAtomCopies toAtom is NULL"));
bond.cc:242:    fc = fa[01;31m-[00m>getCopyAtom();
bond.cc:243:    LOG(BF("    new from %s") % fc.lock()[01;31m-[00m>description().c_str()  ); // vp0(( "    new from %s",fc.lock()[01;31m-[00m>description().c_str() ));
bond.cc:244:    tc = ta[01;31m-[00m>getCopyAtom();
bond.cc:245:    LOG(BF("    new   to %s") % tc.lock()[01;31m-[00m>description().c_str() ); // vp0(( "    new   to %s", tc.lock()[01;31m-[00m>description().c_str()));
bond.cc:246:    this[01;31m-[00m>fromAtom = fc;
bond.cc:247:    this[01;31m-[00m>toAtom = tc;
bond.cc:252:{_F(this[01;31m-[00m>lisp());
bond.cc:254:    aFrom = this[01;31m-[00m>getFromLocked();
bond.cc:255:    aTo = this[01;31m-[00m>getToLocked();
bond.cc:256:    LOG(BF("aFrom = %s  aTo = %s") % aFrom[01;31m-[00m>description().c_str() % aTo[01;31m-[00m>description().c_str()  ); // vp0(("aFrom = %s  aTo = %s",aFrom[01;31m-[00m>description().c_str(),aTo[01;31m-[00m>description().c_str() ));
bond.cc:257:    aFrom[01;31m-[00m>bondTo(aTo,this[01;31m-[00m>getOrder());
bond.cc:262:{_F(this[01;31m-[00m>lisp());
bond.cc:263:    this[01;31m-[00m>fromAtom = a[01;31m-[00m>sharedThis<O_Atom>();
bond.cc:264:    LOG(BF("After setFrom fromAtom=%s") % this[01;31m-[00m>fromAtom.lock()[01;31m-[00m>description().c_str()  ); // vp0(("After setFrom fromAtom=%s",this[01;31m-[00m>fromAtom.lock()[01;31m-[00m>description().c_str() ));
bond.cc:268:{_F(this[01;31m-[00m>lisp());
bond.cc:269:    this[01;31m-[00m>toAtom = a[01;31m-[00m>sharedThis<O_Atom>();
bond.cc:270:    LOG(BF("After setTo toAtom=%s") % this[01;31m-[00m>toAtom.lock()[01;31m-[00m>description().c_str()  ); // vp0(("After setTo toAtom=%s",this[01;31m-[00m>toAtom.lock()[01;31m-[00m>description().c_str() ));
bond.cc:274:{_F(this[01;31m-[00m>lisp());
bond.cc:275:    return bondOrderToString(this[01;31m-[00m>order);
bond.cc:279:{_F(this[01;31m-[00m>lisp());
bond.cc:280:    ASSERT_NOT_NULLP(this[01;31m-[00m>fromAtom,"O_Bond::joinYourAtoms from atom is undefined!");
bond.cc:281:    ASSERT_NOT_NULLP(this[01;31m-[00m>toAtom,"O_Bond::joinYourAtoms to atom is undefined!");
bond.cc:282:    this[01;31m-[00m>fromAtom.lock()[01;31m-[00m>bondTo(this[01;31m-[00m>toAtom.lock(),this[01;31m-[00m>order);
bond.cc:317:	    return "[01;31m-[00munknown[01;31m-[00m";
bond.cc:344:	    return '[01;31m-[00m';
bond.cc:371:    this[01;31m-[00m>Base::initialize();
bond.cc:372:    this[01;31m-[00m>_Bonds.clear();
bond.cc:379:{ _F(this[01;31m-[00m>lisp());
bond.cc:381:    for ( bi=this[01;31m-[00m>_Bonds.begin(); bi!=this[01;31m-[00m>_Bonds.end(); bi++ ) {
bond.cc:382:	(*bi)[01;31m-[00m>imposeYourself();
bond.cc:389:{ _F(this[01;31m-[00m>lisp());
bond.cc:391:    for ( bi=this[01;31m-[00m>_Bonds.begin(); bi!=this[01;31m-[00m>_Bonds.end(); bi++ ) {
bond.cc:393:	    this[01;31m-[00m>_Bonds.erase(bi);
bond.cc:403:    for ( bi=this[01;31m-[00m>_Bonds.begin(); bi!=this[01;31m-[00m>_Bonds.end(); bi++ ) {
bond.cc:404:	if ( (*bi)[01;31m-[00m>getTo().lock() == a ) {
bond.cc:405:	    this[01;31m-[00m>_Bonds.erase(bi);
bond.cc:414:{_F(this[01;31m-[00m>lisp());
bond.cc:415:    this[01;31m-[00m>_Bonds.push_back(b);
bond.cc:421:    for ( bi=this[01;31m-[00m>_Bonds.begin(); bi!=this[01;31m-[00m>_Bonds.end(); bi++ ) {
bond.cc:422:	this[01;31m-[00m>addBond(*bi);
bond.cc:431:    bl = RP_Create<O_BondList>(this[01;31m-[00m>lisp());
bond.cc:432:    for ( bi=this[01;31m-[00m>_Bonds.begin(); bi!=this[01;31m-[00m>_Bonds.end(); bi++ ) {
bond.cc:433:	bl[01;31m-[00m>addBond(*bi);
bond.cc:444:    for ( bi=this[01;31m-[00m>_Bonds.begin(); bi!=this[01;31m-[00m>_Bonds.end(); bi++ ) {
bond.cc:445:	ss << (*bi)[01;31m-[00m>description() << "," << endl;
bond.cc:456:{_F(this[01;31m-[00m>lisp());
bond.cc:458:    if ( node[01;31m-[00m>saving() ) {
bond.cc:459:	LOG(BF("About to save BondList with %d members") % this[01;31m-[00m>size()  ); // vp0(( "About to save BondList with %d members", this[01;31m-[00m>size() ));
bond.cc:460:	for ( ib=this[01;31m-[00m>_Bonds.begin(); ib!=this[01;31m-[00m>_Bonds.end(); ib++ ) {
bond.cc:463:	    node[01;31m-[00m>archiveSaveObjectAsChildAssignAutoUniqueId<O_Bond>(*ib);
bond.cc:469:	this[01;31m-[00m>_Bonds.clear();
bond.cc:472:	for ( ic=node[01;31m-[00m>begin_Children(); ic!=node[01;31m-[00m>end_Children(); ic++ ) {
bond.cc:473:	    (*ic)[01;31m-[00m>archiveLoadObjectDirectly<O_Bond>(b);
bond.cc:475:	    this[01;31m-[00m>_Bonds.push_back(b);
bond.cc:500:    class_<O_Bond>(this[01;31m-[00m>lisp())
bond.cc:509:    this[01;31m-[00m>lisp()[01;31m-[00m>installGlobalInitializationCallback(&O_Bond::initializeGlobals);	
bond.cc:546:    class_<O_BondList>(this[01;31m-[00m>lisp());
boostPythonForceField.cc:32:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not initialize all ForceField classes"));
boostPythonJobs.cc:31:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not initialize all ForceField classes"));
boundFrame.cc:14:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:20:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:21:    this[01;31m-[00m>Base::archiveBase(node);
boundFrame.cc:27:    ss << this[01;31m-[00m>className();
boundFrame.cc:31:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:33:    coord = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
boundFrame.cc:34:    coord[01;31m-[00m>defineCanonical();
boundFrame.cc:39:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:46:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:47:    ASSERT_NOT_NULL(this[01;31m-[00m>_oAtom);
boundFrame.cc:48:    ASSERT(this[01;31m-[00m>_oAtom[01;31m-[00m>notNil());
boundFrame.cc:49:    return this[01;31m-[00m>_oAtom; 
boundFrame.cc:53:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:54:    ASSERT_NOT_NULL(this[01;31m-[00m>_pAtom);
boundFrame.cc:55:    ASSERT(this[01;31m-[00m>_pAtom[01;31m-[00m>notNil());
boundFrame.cc:56:    return this[01;31m-[00m>_pAtom; 
boundFrame.cc:60:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:61:    ASSERT_NOT_NULL(this[01;31m-[00m>_pAtom);
boundFrame.cc:62:    return this[01;31m-[00m>_pAtom; 
boundFrame.cc:67:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:68:    ASSERT_NOT_NULL(this[01;31m-[00m>_pAtom);
boundFrame.cc:69:    return (this[01;31m-[00m>_pAtom[01;31m-[00m>notNil());
boundFrame.cc:74:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:75:    ASSERT_NOT_NULL(this[01;31m-[00m>_qAtom);
boundFrame.cc:76:    ASSERT(this[01;31m-[00m>_qAtom[01;31m-[00m>notNil());
boundFrame.cc:77:    return this[01;31m-[00m>_qAtom; 
boundFrame.cc:81:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:82:    ASSERT_NOT_NULL(this[01;31m-[00m>_qAtom);
boundFrame.cc:83:    return this[01;31m-[00m>_qAtom; 
boundFrame.cc:87:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:88:    ASSERT_NOT_NULL(this[01;31m-[00m>_qAtom);
boundFrame.cc:89:    return (this[01;31m-[00m>_qAtom[01;31m-[00m>notNil());
boundFrame.cc:99:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:101:    this[01;31m-[00m>Base::archiveBase(node);
boundFrame.cc:102:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_name);
boundFrame.cc:103:    node[01;31m-[00m>archiveObject("oAtom",this[01;31m-[00m>_oAtom);
boundFrame.cc:104:    node[01;31m-[00m>archiveObject("pAtom",this[01;31m-[00m>_pAtom);
boundFrame.cc:105:    node[01;31m-[00m>archiveObject("qAtom",this[01;31m-[00m>_qAtom);
boundFrame.cc:110:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:112:    aOrigin = this[01;31m-[00m>get_oAtom();
boundFrame.cc:113:    aX = this[01;31m-[00m>get_pAtomOrNil();
boundFrame.cc:114:    aXY = this[01;31m-[00m>get_qAtomOrNil();
boundFrame.cc:116:    ASSERT(aOrigin[01;31m-[00m>notNil());
boundFrame.cc:117:    Vector3 vOrigin = aOrigin[01;31m-[00m>getPosition();
boundFrame.cc:118:    if ( aX[01;31m-[00m>notNil() && aXY[01;31m-[00m>notNil() )
boundFrame.cc:120:        Vector3 vX = aX[01;31m-[00m>getPosition().sub(vOrigin);
boundFrame.cc:121:        Vector3 vXY = aXY[01;31m-[00m>getPosition().sub(vOrigin);
boundFrame.cc:124:    } else if ( aXY[01;31m-[00m>isNil() )
boundFrame.cc:126:	ASSERT(aX[01;31m-[00m>notNil());
boundFrame.cc:127:        Vector3 vX = aX[01;31m-[00m>getPosition().sub(vOrigin);
boundFrame.cc:129:        res = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
boundFrame.cc:130:        res[01;31m-[00m>defineForTwoAtomVectors(vOrigin,vX);
boundFrame.cc:134:    res = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
boundFrame.cc:135:    res[01;31m-[00m>defineForOneAtomVector(vOrigin);
boundFrame.cc:142:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:144:    aOrigin = this[01;31m-[00m>get_oAtom();
boundFrame.cc:145:    aX = this[01;31m-[00m>get_pAtomOrNil();
boundFrame.cc:146:    aXY = this[01;31m-[00m>get_qAtomOrNil();
boundFrame.cc:148:    ASSERT(aOrigin[01;31m-[00m>notNil());
boundFrame.cc:149:    Vector3 vOrigin = aOrigin[01;31m-[00m>getPosition();
boundFrame.cc:150:    if ( aX[01;31m-[00m>notNil() && aXY[01;31m-[00m>notNil() )
boundFrame.cc:152:        Vector3 vX = aX[01;31m-[00m>getPosition().sub(vOrigin);
boundFrame.cc:153:        Vector3 vXY = aXY[01;31m-[00m>getPosition().sub(vOrigin);
boundFrame.cc:155:        res = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
boundFrame.cc:156:        res[01;31m-[00m>defineForVectorsOriginXDirXYPlane(vOrigin,vX,vXY);
boundFrame.cc:158:    } else if ( aXY[01;31m-[00m>isNil() )
boundFrame.cc:160:	ASSERT(aX[01;31m-[00m>notNil());
boundFrame.cc:161:        Vector3 vX = aX[01;31m-[00m>getPosition().sub(vOrigin);
boundFrame.cc:163:        res = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
boundFrame.cc:164:        res[01;31m-[00m>defineForTwoAtomVectors(vOrigin,vX);
boundFrame.cc:168:    res = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
boundFrame.cc:169:    res[01;31m-[00m>defineForOneAtomVector(vOrigin);
boundFrame.cc:180:    ss << "oAtom=" << this[01;31m-[00m>_oAtom[01;31m-[00m>description() << endl;
boundFrame.cc:181:    ss << "pAtom=" << this[01;31m-[00m>_pAtom[01;31m-[00m>description() << endl;
boundFrame.cc:182:    ss << "qAtom=" << this[01;31m-[00m>_qAtom[01;31m-[00m>description() << endl;
boundFrame.cc:189:    if ( this[01;31m-[00m>_oAtom[01;31m-[00m>getName() == nm ) return true;
boundFrame.cc:190:    if ( this[01;31m-[00m>_pAtom[01;31m-[00m>getName() == nm ) return true;
boundFrame.cc:191:    if ( this[01;31m-[00m>_qAtom[01;31m-[00m>getName() == nm ) return true;
boundFrame.cc:197:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:198:    sl[01;31m-[00m>addSuperposeAtom(this[01;31m-[00m>get_oAtom());
boundFrame.cc:199:    if ( this[01;31m-[00m>has_pAtom() )
boundFrame.cc:201:        sl[01;31m-[00m>addSuperposeAtom(this[01;31m-[00m>get_pAtom());
boundFrame.cc:202:	if ( this[01;31m-[00m>has_qAtom() )
boundFrame.cc:204:    	    sl[01;31m-[00m>addSuperposeAtom(this[01;31m-[00m>get_qAtom());
boundFrame.cc:212:{_F(this[01;31m-[00m>lisp());
boundFrame.cc:213:    LOG(BF("AtomBoundFrame(this)= %s") % this[01;31m-[00m>description().c_str()  ); // vp0(( "AtomBoundFrame(this)= %s", this[01;31m-[00m>description().c_str() ));
boundFrame.cc:214:    RPResidue	focusResidue = monomer[01;31m-[00m>getTemporaryResidue();
boundFrame.cc:215:    if ( this[01;31m-[00m>get_oAtom()[01;31m-[00m>getResidueContainedBy() == focusResidue )
boundFrame.cc:217:        if ( !atoms.contains(this[01;31m-[00m>get_oAtom()) )
boundFrame.cc:219:	    problems << "boundFrame oAtom(" << this[01;31m-[00m>get_oAtom()[01;31m-[00m>description() << ")";
boundFrame.cc:223:		problems << (*it)[01;31m-[00m>description() << " ";
boundFrame.cc:229:    if ( this[01;31m-[00m>has_pAtom() )
boundFrame.cc:231:	if ( this[01;31m-[00m>get_pAtom()[01;31m-[00m>getResidueContainedBy() == focusResidue )
boundFrame.cc:233:	    if ( !atoms.contains(this[01;31m-[00m>get_pAtom()) )
boundFrame.cc:235:		problems << "boundFrame pAtom(" << this[01;31m-[00m>get_pAtom()[01;31m-[00m>description() << ")";
boundFrame.cc:239:		    problems << (*it)[01;31m-[00m>description() << " ";
boundFrame.cc:246:    if ( this[01;31m-[00m>has_qAtom() )
boundFrame.cc:248:	if ( this[01;31m-[00m>get_qAtom()[01;31m-[00m>getResidueContainedBy() == focusResidue )
boundFrame.cc:250:	    if ( !atoms.contains(this[01;31m-[00m>get_qAtom()) )
boundFrame.cc:252:		problems << "boundFrame qAtom(" << this[01;31m-[00m>get_qAtom()[01;31m-[00m>description() << ")";
boundFrame.cc:256:		    problems << (*it)[01;31m-[00m>description() << " ";
boundFrame.cc:272:    class_<O_BoundFrame>(this[01;31m-[00m>lisp())
boundFrame.cc:293:    class_<O_AtomBoundFrame>(this[01;31m-[00m>lisp())
boundFrame.cc:330:    class_<O_OriginBoundFrame>(this[01;31m-[00m>lisp())
boundingBox.cc:24:    this[01;31m-[00m>Base::initialize();
boundingBox.cc:25:    this[01;31m-[00m>_Defined = false;
boundingBox.cc:26:    this[01;31m-[00m>_MinCorner.set(0.0,0.0,0.0);
boundingBox.cc:27:    this[01;31m-[00m>_MaxCorner.set(0.0,0.0,0.0);
boundingBox.cc:32:    node[01;31m-[00m>attributeIfNotDefault("defined",this[01;31m-[00m>_Defined,true);
boundingBox.cc:33:    node[01;31m-[00m>archivePlainObject<Vector3>("minCorner","MinCorner",this[01;31m-[00m>_MinCorner);
boundingBox.cc:34:    node[01;31m-[00m>archivePlainObject<Vector3>("maxCorner","MaxCorner",this[01;31m-[00m>_MaxCorner);
boundingBox.cc:39:{_F(this[01;31m-[00m>lisp());
boundingBox.cc:40:    if ( !this[01;31m-[00m>_Defined )
boundingBox.cc:42:	this[01;31m-[00m>_Defined = true;
boundingBox.cc:43:	this[01;31m-[00m>_MinCorner = p;
boundingBox.cc:44:	this[01;31m-[00m>_MaxCorner = p;
boundingBox.cc:47:    double minX = MIN(p.getX(),this[01;31m-[00m>_MinCorner.getX());
boundingBox.cc:48:    double minY = MIN(p.getY(),this[01;31m-[00m>_MinCorner.getY());
boundingBox.cc:49:    double minZ = MIN(p.getZ(),this[01;31m-[00m>_MinCorner.getZ());
boundingBox.cc:50:    double maxX = MAX(p.getX(),this[01;31m-[00m>_MaxCorner.getX());
boundingBox.cc:51:    double maxY = MAX(p.getY(),this[01;31m-[00m>_MaxCorner.getY());
boundingBox.cc:52:    double maxZ = MAX(p.getZ(),this[01;31m-[00m>_MaxCorner.getZ());
boundingBox.cc:53:    this[01;31m-[00m>_MinCorner.set(minX,minY,minZ);
boundingBox.cc:54:    this[01;31m-[00m>_MaxCorner.set(maxX,maxY,maxZ);
boundingBox.cc:60:    ASSERT(this[01;31m-[00m>_Defined);
boundingBox.cc:61:    if ( !(this[01;31m-[00m>_MinCorner.getX() <= p.getX() && p.getX() <= this[01;31m-[00m>_MaxCorner.getX() ) ) return false;
boundingBox.cc:62:    if ( !(this[01;31m-[00m>_MinCorner.getY() <= p.getY() && p.getY() <= this[01;31m-[00m>_MaxCorner.getY() ) ) return false;
boundingBox.cc:63:    if ( !(this[01;31m-[00m>_MinCorner.getZ() <= p.getZ() && p.getZ() <= this[01;31m-[00m>_MaxCorner.getZ() ) ) return false;
boundingBox.cc:70:    ASSERT(this[01;31m-[00m>_Defined);
boundingBox.cc:73:    this[01;31m-[00m>_MinCorner = this[01;31m-[00m>_MinCorner.sub(vadd);
boundingBox.cc:74:    this[01;31m-[00m>_MaxCorner = this[01;31m-[00m>_MaxCorner.add(vadd);
boundingBox.cc:82:	class_<O_BoundingBox>(this[01;31m-[00m>lisp())
builder.cc:46:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal alias: "+alias));
builder.cc:48:    monomerAlias = alias.substr(1,atomStart[01;31m-[00m1);
builder.cc:60:A Builder object builds three[01;31m-[00mdimensional structures of Oligomers. To achieve this, a Builder needs to be given at least one Oligomer object using ``addOligomer'' and any MonomerPacks that are used by the Oligomer using the ``addMonomerPack'' method.
builder.cc:64:A Builder object lets the user select between the oligomers that it has been given, select between the sequences of the current oligomer and select between the conformationsof the current sequence. It allows the user to build the entire three[01;31m-[00mdimensional structure of the current conformation or just the ``interesting'' atoms.
builder.cc:72:{_F(this[01;31m-[00m>lisp());
builder.cc:73:    this[01;31m-[00m>Base::initialize();
builder.cc:74:    this[01;31m-[00m>_Name = "undef";
builder.cc:75:    this[01;31m-[00m>_CurrentOligomerIndex = 0;
builder.cc:76://    this[01;31m-[00m>_UserMonomerPacks = O_ObjectDictionary::create(this[01;31m-[00m>lisp());
builder.cc:77:    this[01;31m-[00m>_secretRankIdentifier = UndefinedUnsignedInt;
builder.cc:78:    this[01;31m-[00m>_secretOligomerChangeCounter = UndefinedUnsignedInt;
builder.cc:79:    this[01;31m-[00m>_secretSequenceChangeCounter = UndefinedUnsignedInt;
builder.cc:80:    this[01;31m-[00m>_secretConformationChangeCounter = UndefinedUnsignedInt;
builder.cc:81:    this[01;31m-[00m>_BuildAllAtoms = false;
builder.cc:83:    this[01;31m-[00m>_secretRankIdentifier = (uint)(this[01;31m-[00m>lisp()[01;31m-[00m>mpiRank());
builder.cc:84:    LOG(BF("Set the _secretRankIdentifier=%d") % this[01;31m-[00m>_secretRankIdentifier );
builder.cc:88:{_F(this[01;31m-[00m>lisp());
builder.cc:89:    this[01;31m-[00m>_BuildAllAtoms = keyed[01;31m-[00m>getBoolAndRemoveOrDefault("buildAllAtoms",false);
builder.cc:90:    RPCons oligomers = keyed[01;31m-[00m>getAndRemoveOrDefault("oligomers",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
builder.cc:91:    if ( oligomers[01;31m-[00m>length() > 0 )
builder.cc:93:	this[01;31m-[00m>setOligomers(oligomers);
builder.cc:95:    this[01;31m-[00m>firstOligomer();
builder.cc:96:    this[01;31m-[00m>firstSequence();
builder.cc:97:    this[01;31m-[00m>firstConformation();
builder.cc:104:{_F(this[01;31m-[00m>lisp());
builder.cc:105:    this[01;31m-[00m>_secretOligomerChangeCounter = _nextOligomerChangeNumber++;
builder.cc:108:    LOG(BF("advanced OligomerChangeCounter [01;31m-[00m> %u") % this[01;31m-[00m>_secretOligomerChangeCounter  ); // vp0(( "advanced OligomerChangeCounter [01;31m-[00m> %u", this[01;31m-[00m>_secretOligomerChangeCounter ));
builder.cc:109:    LOG(BF("STATE_CHANGE>> current change counters: %s")% this[01;31m-[00m>changeCountersAsString() );
builder.cc:115:{_F(this[01;31m-[00m>lisp());
builder.cc:116:    this[01;31m-[00m>_secretSequenceChangeCounter = _nextSequenceChangeNumber++ ;
builder.cc:119:    LOG(BF("advanced SequenceChangeCounter [01;31m-[00m> %u") % this[01;31m-[00m>_secretSequenceChangeCounter  ); // vp0(( "advanced SequenceChangeCounter [01;31m-[00m> %u", this[01;31m-[00m>_secretSequenceChangeCounter ));
builder.cc:120:    LOG(BF("STATE_CHANGE>> current change counters: %s")% this[01;31m-[00m>changeCountersAsString() );
builder.cc:127:{_F(this[01;31m-[00m>lisp());
builder.cc:128:    this[01;31m-[00m>_secretConformationChangeCounter = _nextConformationChangeNumber++;
builder.cc:131:    LOG(BF("advanced ConformationChangeCounter [01;31m-[00m> %u") % this[01;31m-[00m>_secretConformationChangeCounter  ); // vp0(( "advanced ConformationChangeCounter [01;31m-[00m> %u", this[01;31m-[00m>_secretConformationChangeCounter ));
builder.cc:132:    LOG(BF("STATE_CHANGE>> current change counters: %s")% this[01;31m-[00m>changeCountersAsString() );
builder.cc:136:{_F(this[01;31m-[00m>lisp());
builder.cc:137:    return O_Builder::changeCountersAsString(this[01;31m-[00m>getProcessRank(),this[01;31m-[00m>getOligomerChangeCounter(),this[01;31m-[00m>getSequenceChangeCounter(),this[01;31m-[00m>getConformationChangeCounter() ); // , scorerIdentifier );
builder.cc:142:    return this[01;31m-[00m>changeCountersAsString();
builder.cc:149:{_F(this[01;31m-[00m>lisp());
builder.cc:150:    node[01;31m-[00m>attribute("name", this[01;31m-[00m>_Name );
builder.cc:151:    node[01;31m-[00m>attribute( "buildAllAtoms", this[01;31m-[00m>_BuildAllAtoms);
builder.cc:152://    node[01;31m-[00m>archiveObject("builderDatabase",this[01;31m-[00m>_BuilderDatabase);
builder.cc:153://    node[01;31m-[00m>archiveObject("userMonomerPacks",this[01;31m-[00m>_UserMonomerPacks);
builder.cc:154:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_OligomerList);
builder.cc:155:    node[01;31m-[00m>archiveMap("oligomersByName",this[01;31m-[00m>_OligomersByName);
builder.cc:156:    node[01;31m-[00m>attribute("currentOligomerIndex", this[01;31m-[00m>_CurrentOligomerIndex);
builder.cc:157:    node[01;31m-[00m>attributeIfNotDefault("secretRankId",this[01;31m-[00m>_secretRankIdentifier ,(uint)(0));
builder.cc:158:    node[01;31m-[00m>attributeIfNotDefault("secretOligomerCounter",this[01;31m-[00m>_secretOligomerChangeCounter, UndefinedUnsignedInt );
builder.cc:159:    node[01;31m-[00m>attributeIfNotDefault("secretSequenceCounter",this[01;31m-[00m>_secretSequenceChangeCounter, UndefinedUnsignedInt );
builder.cc:160:    node[01;31m-[00m>attributeIfNotDefault("secretConformationCounter",this[01;31m-[00m>_secretConformationChangeCounter, UndefinedUnsignedInt );
builder.cc:161:    node[01;31m-[00m>needsFinalization();
builder.cc:166:{_F(this[01;31m-[00m>lisp());
builder.cc:168:    RPBuilderDatabase bdb = this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase();
builder.cc:170:    ASSERT_NOT_NULL(this[01;31m-[00m>_UserMonomerPacks);
builder.cc:171:    for ( pi=this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>begin(); pi!=this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>end(); pi++ )
builder.cc:173:	if ( bdb[01;31m-[00m>recognizesMonomerSetName(pi[01;31m-[00m>first) )
builder.cc:175:	    // TOSS(_lisp[01;31m-[00m>create<O_ContentException>("The builder has a MonomerPack with name: "+pi[01;31m-[00m>first+" and that name already exists in the BuilderDatabase"));
builder.cc:180:	RPMonomerPack pack = downcast<O_MonomerPack>(pi[01;31m-[00m>second);
builder.cc:181:	bdb[01;31m-[00m>defineUserMonomerPack(pack);
builder.cc:183://    this[01;31m-[00m>_buildOligomer();
builder.cc:189:{_F(this[01;31m-[00m>lisp());
builder.cc:190:    RPSpecificContextSet allContexts = O_SpecificContextSet::create(this[01;31m-[00m>lisp());
builder.cc:192:    for ( it=this[01;31m-[00m>_OligomerList.begin(); it!=this[01;31m-[00m>_OligomerList.end(); it++)
builder.cc:194:	RPSpecificContextSet oneSet = (*it)[01;31m-[00m>allSpecificMonomerContexts();
builder.cc:195:	allContexts[01;31m-[00m>merge(oneSet);
builder.cc:205:{_F(this[01;31m-[00m>lisp());
builder.cc:206:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:207:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:208:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>writeAllScoreTransformedCoordinatesToAtoms(scorerState);
builder.cc:219:{_F(this[01;31m-[00m>lisp());
builder.cc:220:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>extractCoordinatesFromAtoms();
builder.cc:226:    return this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>getMolecule();
builder.cc:234:{_F(this[01;31m-[00m>lisp());
builder.cc:237:    this[01;31m-[00m>_HasError = false;
builder.cc:238:    this[01;31m-[00m>_ErrorStream.str("");
builder.cc:239:    olig = this[01;31m-[00m>getCurrentOligomer();
builder.cc:240:    if ( olig[01;31m-[00m>getHasError() )
builder.cc:243:	this[01;31m-[00m>_HasError = true;
builder.cc:244:	this[01;31m-[00m>_ErrorStream << "Oligomer has an error so I cant build";
builder.cc:245:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>(this[01;31m-[00m>_ErrorStream.str()));
builder.cc:247://    cdb = this[01;31m-[00m>getBuilderDatabase();
builder.cc:248:    this[01;31m-[00m>_OligomerBuilder = O_OligomerBuilder::create(this[01;31m-[00m>lisp(),olig);
builder.cc:249:    if ( this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>hasError() )
builder.cc:251:        this[01;31m-[00m>_HasError = true;
builder.cc:252:	this[01;31m-[00m>_ErrorStream << this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>errorMessage();
builder.cc:261:{_F(this[01;31m-[00m>lisp());
builder.cc:262:    return this[01;31m-[00m>_OligomersByName.contains(nm);
builder.cc:270:Add a \sa{MonomerPack::pack} to the Builder.  As a side[01;31m-[00meffect, this method also adds the \sa{pack} to the system database.
builder.cc:274:{_F(this[01;31m-[00m>lisp());
builder.cc:275:    string nm = pack[01;31m-[00m>getName();
builder.cc:276:    ASSERT_NOT_NULL(this[01;31m-[00m>_UserMonomerPacks);
builder.cc:277:    if ( this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>contains(nm) )
builder.cc:279:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Builder already contains PartPack with name: %s"+nm,this[01;31m-[00m>sharedThis<O_Builder>()[01;31m-[00m>description() ));
builder.cc:281:    this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>set(nm,pack);
builder.cc:287:{_F(this[01;31m-[00m>lisp());
builder.cc:288:    ASSERT(args[01;31m-[00m>length()==2);
builder.cc:289:    RPMonomerPack pack = args[01;31m-[00m>cadr<O_MonomerPack>();
builder.cc:290:    this[01;31m-[00m>addMonomerPack(pack);
builder.cc:291:    lisp[01;31m-[00m>getBuilderDatabase()[01;31m-[00m>defineUserMonomerPack(pack);
builder.cc:292:    return O_Object::nil(this[01;31m-[00m>lisp());
builder.cc:298:{_F(this[01;31m-[00m>lisp());
builder.cc:299:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:300:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
builder.cc:301:    dl[01;31m-[00m>setName("fragments");
builder.cc:302:    dl[01;31m-[00m>add(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>rendered(koptions));
builder.cc:307:{_F(this[01;31m-[00m>lisp());
builder.cc:308:    string nm = olig[01;31m-[00m>getName();
builder.cc:309:    if ( this[01;31m-[00m>_OligomersByName.contains(nm) )
builder.cc:311:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Builder already contains oligomer with name: %s"+nm,
builder.cc:312:		this[01;31m-[00m>sharedThis<O_Builder>()[01;31m-[00m>description() ));
builder.cc:314:    this[01;31m-[00m>_OligomersByName.set(nm,olig);
builder.cc:315:    this[01;31m-[00m>_OligomerList.append(olig);
builder.cc:316:    olig[01;31m-[00m>connectListener(this[01;31m-[00m>sharedThis<O_Builder>(),Oligomer_monomerContentsChanged);
builder.cc:317:    olig[01;31m-[00m>connectListener(this[01;31m-[00m>sharedThis<O_Builder>(),Oligomer_connectivityChanged);
builder.cc:318:    olig[01;31m-[00m>connectListener(this[01;31m-[00m>sharedThis<O_Builder>(),Oligomer_sequenceChanged);
builder.cc:330:{_F(this[01;31m-[00m>lisp());
builder.cc:332:    for ( ; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
builder.cc:334:	RPOligomer olig = cur[01;31m-[00m>car<O_Oligomer>();
builder.cc:335:	this[01;31m-[00m>addOligomer(olig);
builder.cc:340:    this[01;31m-[00m>allMonomerAliases();
builder.cc:345:{_F(this[01;31m-[00m>lisp());
builder.cc:346:    LOG(BF("_CurrentOligomerIndex = %d") % this[01;31m-[00m>_CurrentOligomerIndex  ); // vp0(("_CurrentOligomerIndex = %d",this[01;31m-[00m>_CurrentOligomerIndex ));
builder.cc:347:    LOG(BF("_OligomerList.size()= %d") % this[01;31m-[00m>_OligomerList.size()  ); // vp0(("_OligomerList.size()= %d",this[01;31m-[00m>_OligomerList.size() ));
builder.cc:348:    ASSERT_lessThan(this[01;31m-[00m>_CurrentOligomerIndex,this[01;31m-[00m>_OligomerList.size());
builder.cc:349:    return this[01;31m-[00m>_OligomerList.get(this[01;31m-[00m>_CurrentOligomerIndex);
builder.cc:353:{_F(this[01;31m-[00m>lisp());
builder.cc:354:    RPOligomer olig = this[01;31m-[00m>getCurrentOligomer();
builder.cc:355:    return olig[01;31m-[00m>sequenceAsString();
builder.cc:359:{_F(this[01;31m-[00m>lisp());
builder.cc:360:    ASSERT_lt(idx,this[01;31m-[00m>_OligomerList.size());
builder.cc:361:    return this[01;31m-[00m>_OligomerList[idx];
builder.cc:366:{_F(this[01;31m-[00m>lisp());
builder.cc:367:    ASSERT(this[01;31m-[00m>_OligomersByName.contains(nm));
builder.cc:368:    return this[01;31m-[00m>_OligomersByName.get(nm);
builder.cc:372:{_F(this[01;31m-[00m>lisp());
builder.cc:373:    return this[01;31m-[00m>_OligomerList.size();
builder.cc:377:{_F(this[01;31m-[00m>lisp());
builder.cc:380:    for ( it=this[01;31m-[00m>_OligomerList.begin(),idx=0;
builder.cc:381:    		it!=this[01;31m-[00m>_OligomerList.end(); it++,idx++ )
builder.cc:385:	    this[01;31m-[00m>gotoOligomerIndexThenBuild(idx);
builder.cc:390:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Oligomer was not in Builder",this[01;31m-[00m>sharedThis<O_Builder>()[01;31m-[00m>description()));
builder.cc:394:{_F(this[01;31m-[00m>lisp());
builder.cc:395:    ASSERT(this[01;31m-[00m>notNil());
builder.cc:396:    ASSERT_lessThan(idx,this[01;31m-[00m>_OligomerList.size());
builder.cc:397:    this[01;31m-[00m>_CurrentOligomerIndex = idx;
builder.cc:398:    this[01;31m-[00m>advanceOligomerChangeCounter();
builder.cc:399:    this[01;31m-[00m>advanceSequenceChangeCounter();
builder.cc:400:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:405:    this[01;31m-[00m>gotoOligomerIndexDontBuild(idx);
builder.cc:406:    this[01;31m-[00m>_buildOligomer();
builder.cc:412:{_F(this[01;31m-[00m>lisp());
builder.cc:413:    ASSERT(this[01;31m-[00m>notNil());
builder.cc:414:    this[01;31m-[00m>_CurrentOligomerIndex = 0;
builder.cc:415:    this[01;31m-[00m>_buildOligomer();
builder.cc:416:    this[01;31m-[00m>advanceOligomerChangeCounter();
builder.cc:417:    this[01;31m-[00m>advanceSequenceChangeCounter();
builder.cc:418:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:422:{_F(this[01;31m-[00m>lisp());
builder.cc:423:    if ( this[01;31m-[00m>_CurrentOligomerIndex >= this[01;31m-[00m>_OligomerList.size() )
builder.cc:427:    this[01;31m-[00m>_CurrentOligomerIndex++;
builder.cc:428:    this[01;31m-[00m>_buildOligomer();
builder.cc:429:    this[01;31m-[00m>advanceOligomerChangeCounter();
builder.cc:430:    this[01;31m-[00m>advanceSequenceChangeCounter();
builder.cc:431:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:437:{_F(this[01;31m-[00m>lisp());
builder.cc:440:    this[01;31m-[00m>_CurrentOligomerIndex = rnd*this[01;31m-[00m>_OligomerList.size();
builder.cc:441:    LOG(BF("Set _CurrentOligomerIndex to %d") % this[01;31m-[00m>_CurrentOligomerIndex  ); // vp0(("Set _CurrentOligomerIndex to %d", this[01;31m-[00m>_CurrentOligomerIndex ));
builder.cc:442:    this[01;31m-[00m>getCurrentOligomer()[01;31m-[00m>perturbMonomerSequence();
builder.cc:443:    this[01;31m-[00m>_buildOligomer();
builder.cc:444:    this[01;31m-[00m>advanceOligomerChangeCounter();
builder.cc:445:    this[01;31m-[00m>advanceSequenceChangeCounter();
builder.cc:446:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:451:{_F(this[01;31m-[00m>lisp());
builder.cc:452:    this[01;31m-[00m>_BuildAllAtoms = b;
builder.cc:456:{_F(this[01;31m-[00m>lisp());
builder.cc:457:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:458:    ASSERTP(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil(),"OligomerBuilder must not be nil");
builder.cc:459:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>buildInterestingUntransformedAtomPositions();
builder.cc:463:{_F(this[01;31m-[00m>lisp());
builder.cc:464:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:465:    ASSERTP(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil(),"OligomerBuilder must not be nil");
builder.cc:466:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>buildAllUntransformedAtomPositions();
builder.cc:477:{_F(this[01;31m-[00m>lisp());
builder.cc:478:    return this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>getSequenceAsString();
builder.cc:485:{_F(this[01;31m-[00m>lisp());
builder.cc:486:    return _OligomerBuilder[01;31m-[00m>numberOfInterestingConformationsInCurrentSequence();
builder.cc:491:{_F(this[01;31m-[00m>lisp());
builder.cc:492:    return _OligomerBuilder[01;31m-[00m>numberOfAllAtomConformationsInCurrentSequence();
builder.cc:498:{_F(this[01;31m-[00m>lisp());
builder.cc:499:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>randomizeInterestingConformations();
builder.cc:500:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:504:{_F(this[01;31m-[00m>lisp());
builder.cc:505:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>perturbInterestingConformations();
builder.cc:506:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:510:{_F(this[01;31m-[00m>lisp());
builder.cc:511:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>randomizeAllAtomConformations();
builder.cc:512:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:516:{_F(this[01;31m-[00m>lisp());
builder.cc:517:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>perturbAllAtomConformations();
builder.cc:518:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:522:{_F(this[01;31m-[00m>lisp());
builder.cc:523:    return this[01;31m-[00m>getCurrentOligomer()[01;31m-[00m>currentSequenceIndex();
builder.cc:527:{_F(this[01;31m-[00m>lisp());
builder.cc:528:    this[01;31m-[00m>getCurrentOligomer()[01;31m-[00m>perturbMonomerSequence();
builder.cc:529:    this[01;31m-[00m>advanceSequenceChangeCounter();
builder.cc:530:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:531:    this[01;31m-[00m>_buildOligomer();
builder.cc:537:    if ( this[01;31m-[00m>getOligomerChangeCounter() == UndefinedUnsignedInt )
builder.cc:541:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
builder.cc:547:    if ( this[01;31m-[00m>getSequenceChangeCounter() == UndefinedUnsignedInt )
builder.cc:551:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
builder.cc:556:    this[01;31m-[00m>throwIfOligomerChangeCounterUndefined(obj);
builder.cc:557:    if ( ctr != this[01;31m-[00m>getOligomerChangeCounter() )
builder.cc:560:	ss << boost::format("The builder got out of sync with the observer object: %s") % obj[01;31m-[00m>description() << endl;
builder.cc:561:	ss << boost::format("The builders OligomerChangeCounter(%d) and the observer objects has counter(%d)") % this[01;31m-[00m>getOligomerChangeCounter() % ctr;
builder.cc:562:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
builder.cc:569:    this[01;31m-[00m>throwIfSequenceChangeCounterUndefined(obj);
builder.cc:570:    if ( ctr != this[01;31m-[00m>getSequenceChangeCounter() )
builder.cc:573:	ss << boost::format("The builder got out of sync with the observer object: %s") % obj[01;31m-[00m>description() << endl;
builder.cc:574:	ss << boost::format("The builders SequenceChangeCounter(%d) and the observer objects has counter(%d)") % this[01;31m-[00m>getSequenceChangeCounter() % ctr;
builder.cc:575:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
builder.cc:582:    if ( ctr != this[01;31m-[00m>getConformationChangeCounter() )
builder.cc:585:	ss << boost::format("The builder got out of sync with the observer object: %s") % obj[01;31m-[00m>description() << endl;
builder.cc:586:	ss << boost::format("The builders ConformationChangeCounter(%d) and the observer objects has counter(%d)") % this[01;31m-[00m>getConformationChangeCounter() % ctr;
builder.cc:587:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
builder.cc:592:{_F(this[01;31m-[00m>lisp());
builder.cc:595:    if ( scorerState[01;31m-[00m>getScorerIdentifier() == UndefinedUnsignedInt ) return;
builder.cc:599:{_F(this[01;31m-[00m>lisp());
builder.cc:601://    this[01;31m-[00m>advanceSequenceChangeCounter();
builder.cc:602://    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:603:    this[01;31m-[00m>_buildOligomer();
builder.cc:609:{_F(this[01;31m-[00m>lisp());
builder.cc:610:    this[01;31m-[00m>getCurrentOligomer()[01;31m-[00m>firstSequence();
builder.cc:611:    this[01;31m-[00m>advanceSequenceChangeCounter();
builder.cc:612:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:613:    this[01;31m-[00m>_buildOligomer();
builder.cc:621:{_F(this[01;31m-[00m>lisp());
builder.cc:622:    this[01;31m-[00m>getCurrentOligomer()[01;31m-[00m>gotoSequence(idx);
builder.cc:623:    this[01;31m-[00m>advanceSequenceChangeCounter();
builder.cc:624:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:625:    this[01;31m-[00m>_buildOligomer();
builder.cc:629:{_F(this[01;31m-[00m>lisp());
builder.cc:630:    bool res = this[01;31m-[00m>getCurrentOligomer()[01;31m-[00m>incrementSequence();
builder.cc:631:    this[01;31m-[00m>advanceSequenceChangeCounter();
builder.cc:632:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:633:    this[01;31m-[00m>_buildOligomer();
builder.cc:638:{_F(this[01;31m-[00m>lisp());
builder.cc:640:    for ( List<O_Oligomer>::iterator oi=this[01;31m-[00m>_OligomerList.begin(); oi!=this[01;31m-[00m>_OligomerList.end(); oi++ )
builder.cc:642:	LongLongInt numCur = (*oi)[01;31m-[00m>numberOfSequences();
builder.cc:649:{_F(this[01;31m-[00m>lisp());
builder.cc:651:    return this[01;31m-[00m>getCurrentOligomer()[01;31m-[00m>numberOfSequences();
builder.cc:655:{_F(this[01;31m-[00m>lisp());
builder.cc:656:    LongLongInt ll = this[01;31m-[00m>numberOfSequencesInCurrentOligomer();
builder.cc:659:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There are too many sequences to fit into an unsigned int"));
builder.cc:665:{_F(this[01;31m-[00m>lisp());
builder.cc:666:    LongLongInt ll = this[01;31m-[00m>numberOfNecessaryConformationsInCurrentSequence();
builder.cc:669:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There are too many conformations to fit into an unsigned int"));
builder.cc:675:{_F(this[01;31m-[00m>lisp());
builder.cc:678:	this[01;31m-[00m>randomizeInterestingConformations();
builder.cc:679:	this[01;31m-[00m>buildInterestingUntransformedAtomPositions();
builder.cc:684:{_F(this[01;31m-[00m>lisp());
builder.cc:686:    RPStringSet aliases = O_StringSet::nil(this[01;31m-[00m>lisp());
builder.cc:687:    for ( it = this[01;31m-[00m>_OligomerList.begin(); it!= this[01;31m-[00m>_OligomerList.end(); it++ )
builder.cc:689:	if ( aliases[01;31m-[00m>isNil() )
builder.cc:691:	    aliases = (*it)[01;31m-[00m>getAllAliases();
builder.cc:694:	    RPStringSet oneAliases = (*it)[01;31m-[00m>getAllAliases();
builder.cc:695:	    if ( !aliases[01;31m-[00m>equal(oneAliases) )
builder.cc:699:		ss << (*it)[01;31m-[00m>getName();
builder.cc:702:		ss <<  oneAliases[01;31m-[00m>asString();
builder.cc:704:		ss << aliases[01;31m-[00m>asString();
builder.cc:707:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
builder.cc:715:{_F(this[01;31m-[00m>lisp());
builder.cc:717:    RPStringSet aliases = O_StringSet::nil(this[01;31m-[00m>lisp());
builder.cc:718:    for ( it = this[01;31m-[00m>_OligomerList.begin(); it!= this[01;31m-[00m>_OligomerList.end(); it++ )
builder.cc:720:	if ( aliases[01;31m-[00m>isNil() )
builder.cc:722:	    aliases = (*it)[01;31m-[00m>allMonomerAliases();
builder.cc:725:	    RPStringSet oneAliases = (*it)[01;31m-[00m>allMonomerAliases();
builder.cc:726:	    if ( !aliases[01;31m-[00m>equal(oneAliases) )
builder.cc:730:		ss << (*it)[01;31m-[00m>getName();
builder.cc:733:		ss <<  oneAliases[01;31m-[00m>asString();
builder.cc:735:		ss << aliases[01;31m-[00m>asString();
builder.cc:738:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
builder.cc:748:    return O_StringSet::nil(this[01;31m-[00m>lisp());
builder.cc:751:    RPStringSet aliases = O_StringSet::nil(this[01;31m-[00m>lisp());
builder.cc:752:    for ( it = this[01;31m-[00m>_OligomerList.begin(); it!= this[01;31m-[00m>_OligomerList.end(); it++ )
builder.cc:754:	if ( aliases[01;31m-[00m>isNil() )
builder.cc:756:	    aliases = (*it)[01;31m-[00m>allAliases();
builder.cc:759:	    RPStringSet oneAliases = (*it)[01;31m-[00m>allAliases();
builder.cc:760:	    if ( !aliases[01;31m-[00m>eq(oneAliases) )
builder.cc:764:		ss << (*it)[01;31m-[00m>getName();
builder.cc:767:		ss <<  oneAliases[01;31m-[00m>asString();
builder.cc:769:		ss << aliases[01;31m-[00m>asString();
builder.cc:772:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
builder.cc:781:{_F(this[01;31m-[00m>lisp());
builder.cc:785:    olig = this[01;31m-[00m>getCurrentOligomer();
builder.cc:786:    ASSERTP(olig[01;31m-[00m>notNil(),"The current oligomer is nil! This should never happen");
builder.cc:787:    LOG(BF("this[01;31m-[00m>getCurrentOligomer = %d") % this[01;31m-[00m>_CurrentOligomerIndex  ); // vp0(("this[01;31m-[00m>getCurrentOligomer = %d", this[01;31m-[00m>_CurrentOligomerIndex ));
builder.cc:789:    LOG(BF("Looking for monomer with alias: %s") % alias[01;31m-[00m>__repr__().c_str()  ); // vp0(("Looking for monomer with alias: %s", alias[01;31m-[00m>__repr__().c_str() ));
builder.cc:790:    for ( mi=olig[01;31m-[00m>begin_Monomers(), monIdx = 0;
builder.cc:791:    		mi!=olig[01;31m-[00m>end_Monomers(); mi++, monIdx++ )
builder.cc:793:	LOG(BF(" Looking at monomer: %s") % (*mi)[01;31m-[00m>description().c_str()  ); // vp0((" Looking at monomer: %s", (*mi)[01;31m-[00m>description().c_str() ));
builder.cc:794:	if ( (*mi)[01;31m-[00m>recognizesAlias(alias) )
builder.cc:807:{_F(this[01;31m-[00m>lisp());
builder.cc:813:    olig = this[01;31m-[00m>getCurrentOligomer();
builder.cc:814:    for ( mi=olig[01;31m-[00m>begin_Monomers(), monIdx = 0;
builder.cc:815:    		mi!=olig[01;31m-[00m>end_Monomers(); mi++, monIdx++ )
builder.cc:817:	if ( (*mi)[01;31m-[00m>recognizesAlias(alias) )
builder.cc:827:{_F(this[01;31m-[00m>lisp());
builder.cc:831:    olig = this[01;31m-[00m>getCurrentOligomer();
builder.cc:832:    LOG(BF("firstMonomerWithAlias looking for alias(%s)") % alias[01;31m-[00m>__repr__().c_str() ); // vp0(("firstMonomerWithAlias looking for alias(%s)",alias[01;31m-[00m>__repr__().c_str()));
builder.cc:833:    for ( mi=olig[01;31m-[00m>begin_Monomers(), monIdx = 0;
builder.cc:834:    		mi!=olig[01;31m-[00m>end_Monomers(); mi++, monIdx++ )
builder.cc:836:        LOG(BF("Comparing to monomer with aliases(%s)") % (*mi)[01;31m-[00m>getAliasesAsString().c_str()  ); // vp0(("Comparing to monomer with aliases(%s)",(*mi)[01;31m-[00m>getAliasesAsString().c_str() ));
builder.cc:837:	if ( (*mi)[01;31m-[00m>recognizesAlias(alias) )
builder.cc:848:{_F(this[01;31m-[00m>lisp());
builder.cc:852:    numMonomers = this[01;31m-[00m>numberOfMonomersWithAlias(alias);
builder.cc:857:	ss << alias[01;31m-[00m>__repr__();
builder.cc:860:	ss << "The available monomer aliases are: " << this[01;31m-[00m>allMonomerAliases()[01;31m-[00m>asString() << endl;
builder.cc:861:	ss << "The available complete aliases are: " << this[01;31m-[00m>getAllAliases()[01;31m-[00m>asString() << endl;
builder.cc:863:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>(ss.str(), this[01;31m-[00m>sharedThis<O_Builder>()[01;31m-[00m>description()));
builder.cc:867:        monIdx = this[01;31m-[00m>firstMonomerWithAlias(alias);
builder.cc:894:{_F(this[01;31m-[00m>lisp());
builder.cc:902:    RPOligomer olig = this[01;31m-[00m>getCurrentOligomer();
builder.cc:904:    ASSERT_lessThan(monomerIndex,this[01;31m-[00m>getCurrentOligomer()[01;31m-[00m>numberOfMonomers());
builder.cc:905:    bdb = this[01;31m-[00m>getBuilderDatabase();
builder.cc:908:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:909:    mon = this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._Monomer;
builder.cc:910:    LOG(BF("Looking for interesting atom in %s") % mon[01;31m-[00m>description().c_str()  ); // vp0(("Looking for interesting atom in %s",mon[01;31m-[00m>description().c_str() ));
builder.cc:911:    monomerSetName = mon[01;31m-[00m>getGroupName();
builder.cc:912:    if ( bdb[01;31m-[00m>recognizesUserMonomerPack(monomerSetName) )
builder.cc:915:        monSet = bdb[01;31m-[00m>getUserMonomerPack(monomerSetName);
builder.cc:916:	if ( monSet[01;31m-[00m>hasInterestingAtomAlias(alias) )
builder.cc:918:	    LOG(BF("MonomerPack has an interesting atom with the alias(%s)") % alias[01;31m-[00m>__repr__().c_str() ); // vp0(("MonomerPack has an interesting atom with the alias(%s)",alias[01;31m-[00m>__repr__().c_str()));
builder.cc:919:	    interestingAtomOffset = monSet[01;31m-[00m>getInterestingAtomAliasIndex(alias);
builder.cc:921:	    beginIndex = this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._BeginInterestingAtomHolderIndex;
builder.cc:922:	    LOG(BF(" this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._BeginInterestingAtomHolderIndex = %d") % this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._BeginInterestingAtomHolderIndex  ); // vp0((" this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._BeginInterestingAtomHolderIndex = %d", this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._BeginInterestingAtomHolderIndex ));
builder.cc:923:	    LOG(BF(" this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._EndInterestingAtomHolderIndex = %d") % this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._EndInterestingAtomHolderIndex  ); // vp0((" this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._EndInterestingAtomHolderIndex = %d", this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_Scaffolds[monomerIndex]._EndInterestingAtomHolderIndex ));
builder.cc:927:	    ASSERT_lessThan(interestingAtomIndex, this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_InterestingAtomHolderIndices.size() );
builder.cc:928:	    LOG(BF("Number of _InterestingAtomHolderIndices = %d") % this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_InterestingAtomHolderIndices.size() ); // vp0(("Number of _InterestingAtomHolderIndices = %d", this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_InterestingAtomHolderIndices.size()));
builder.cc:929:	    atomIndex = this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_InterestingAtomHolderIndices[interestingAtomIndex];
builder.cc:934:	    LOG(BF("MonomerPack does not have an interesting atom with alias(%s)") % alias[01;31m-[00m>__repr__().c_str()  ); // vp0(("MonomerPack does not have an interesting atom with alias(%s)",alias[01;31m-[00m>__repr__().c_str() ));
builder.cc:937:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("MonomrPack recognized but Interesting atom not found"));
builder.cc:946:{_F(this[01;31m-[00m>lisp());
builder.cc:947:    return this[01;31m-[00m>_indexOfInterestingAtomWithAlias(monomerIndex,alias)!=UndefinedUnsignedInt;
builder.cc:952:{_F(this[01;31m-[00m>lisp());
builder.cc:954:    ASSERT_lessThan(i,this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_AllAtomHolders.size());
builder.cc:955:    a = this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_AllAtomHolders[i]._Atom;
builder.cc:964:    ASSERT_lessThan(i,this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_AllAtomHolders.size());
builder.cc:965:    return scorerState[01;31m-[00m>getScoreTransform()*this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_AllAtomHolders[i]._Pos;
builder.cc:971:{_F(this[01;31m-[00m>lisp());
builder.cc:973:    ASSERT_lessThan(i,this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_AllAtomHolders.size());
builder.cc:974:    return this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_AllAtomHolders[i]._Pos;
builder.cc:980:{_F(this[01;31m-[00m>lisp());
builder.cc:982:    idx = this[01;31m-[00m>_indexOfInterestingAtomWithAlias(monomerIndex,alias);
builder.cc:985:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find atom with atomAlias: "+alias[01;31m-[00m>getAtomAlias()));
builder.cc:992:{_F(this[01;31m-[00m>lisp());
builder.cc:993:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:994:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:995:    if ( this[01;31m-[00m>buildsAllAtoms() )
builder.cc:997:	return this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>numberOfAllAtomConformationsInCurrentSequence();
builder.cc:999:    return this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>numberOfInterestingConformationsInCurrentSequence();
builder.cc:1003:{_F(this[01;31m-[00m>lisp());
builder.cc:1004:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1005:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1006:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>firstAllAtomConformations();
builder.cc:1007:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1011:{_F(this[01;31m-[00m>lisp());
builder.cc:1012:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1013:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1015:    if ( this[01;31m-[00m>buildsAllAtoms() )
builder.cc:1017:	res = this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>incrementAllAtomConformations();
builder.cc:1020:	res = this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>incrementInterestingConformations();
builder.cc:1022:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1027:{_F(this[01;31m-[00m>lisp());
builder.cc:1028:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1029:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1030:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>gotoAllAtomConformations(index);
builder.cc:1031:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1035:{_F(this[01;31m-[00m>lisp());
builder.cc:1036:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1037:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1038:    if ( this[01;31m-[00m>buildsAllAtoms() )
builder.cc:1040:	this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>perturbAllAtomConformations();
builder.cc:1043:	this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>perturbInterestingConformations();
builder.cc:1045:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1050:{_F(this[01;31m-[00m>lisp());
builder.cc:1051:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1052:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1053:    if ( this[01;31m-[00m>buildsAllAtoms() )
builder.cc:1055:	this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>randomizeAllAtomConformations();
builder.cc:1058:	this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>randomizeInterestingConformations();
builder.cc:1060:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1068:	this[01;31m-[00m>randomizeConformation();
builder.cc:1071:    return this[01;31m-[00m>incrementConformation();
builder.cc:1077:{_F(this[01;31m-[00m>lisp());
builder.cc:1078:    if ( this[01;31m-[00m>buildsAllAtoms() )
builder.cc:1081:	this[01;31m-[00m>buildAllUntransformedAtomPositions();
builder.cc:1085:    this[01;31m-[00m>buildInterestingUntransformedAtomPositions();
builder.cc:1097:{_F(this[01;31m-[00m>lisp());
builder.cc:1098:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1099:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1100:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>firstAllAtomConformations();
builder.cc:1101:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1105:{_F(this[01;31m-[00m>lisp());
builder.cc:1106:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1107:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1108:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>gotoAllAtomConformations(index);
builder.cc:1109:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1113:{_F(this[01;31m-[00m>lisp());
builder.cc:1114:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1115:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1116:    bool b = this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>incrementAllAtomConformations();
builder.cc:1117:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1122:{_F(this[01;31m-[00m>lisp());
builder.cc:1123:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1124:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1125:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>firstAllAtomConformations();
builder.cc:1126:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1131:{_F(this[01;31m-[00m>lisp());
builder.cc:1132:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1133:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1134:    bool b = this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>incrementInterestingConformations();
builder.cc:1135:    this[01;31m-[00m>advanceConformationChangeCounter();
builder.cc:1141:{_F(this[01;31m-[00m>lisp());
builder.cc:1142:    RPScorerState dummyScorerState = O_ScorerState::create(this[01;31m-[00m>lisp());
builder.cc:1143:    RPCons dropFirst = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
builder.cc:1145:    for ( uint oligomerIndex = 0; oligomerIndex < this[01;31m-[00m>numberOfOligomers();
builder.cc:1148:	this[01;31m-[00m>gotoOligomerIndexThenBuild(oligomerIndex);
builder.cc:1149:	this[01;31m-[00m>firstSequence();
builder.cc:1150:	this[01;31m-[00m>firstAllAtomConformations();
builder.cc:1151:	this[01;31m-[00m>buildAllUntransformedAtomPositions();
builder.cc:1152://	this[01;31m-[00m>calculateAllScoreTransformedAtomPositions();
builder.cc:1153:	this[01;31m-[00m>writeScoreTransformedCoordinatesToBuiltMolecule(dummyScorerState);
builder.cc:1154:	RPMolecule mol = this[01;31m-[00m>getBuiltMolecule()[01;31m-[00m>copy()[01;31m-[00m>as<O_Molecule>();
builder.cc:1155:	RPCons one = O_Cons::create(mol,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
builder.cc:1156:	resultLast[01;31m-[00m>setCdr(one);
builder.cc:1159:    return dropFirst[01;31m-[00m>cdr();
builder.cc:1164:{_F(this[01;31m-[00m>lisp());
builder.cc:1165:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1166:    return this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>allMonomerIds();
builder.cc:1171:{_F(this[01;31m-[00m>lisp());
builder.cc:1172:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1173:    return this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>frameNamesForMonomerId(monomerId);
builder.cc:1177:{_F(this[01;31m-[00m>lisp());
builder.cc:1178:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1179:    return this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>createCoordinateSystemForMonomerIdAndFrameName(monomerId,frameName);
builder.cc:1202:Builders build the three[01;31m-[00mdimensional coordinates of oligomers.
builder.cc:1217:    if ( args[01;31m-[00m>length()<2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a name and a list of oligomers"));
builder.cc:1218:    RPText name = args[01;31m-[00m>listref<O_Text>(0);
builder.cc:1219:    RPCons parts = args[01;31m-[00m>listref<O_Cons>(1);
builder.cc:1221:    for ( RPCons p=parts; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() )
builder.cc:1223:        RPObject o = p[01;31m-[00m>ocar();
builder.cc:1224:	LOG(BF("Got one oligomer as object className=%s") % o[01;31m-[00m>className().c_str()  ); // vp0(("Got one oligomer as object className=%s",o[01;31m-[00m>className().c_str() )));
builder.cc:1225:	RPOligomer olig = p[01;31m-[00m>car<O_Oligomer>();
builder.cc:1226:	LOG(BF("Got oligomer directly className = %s") % olig[01;31m-[00m>className().c_str()  ); // vp0(("Got oligomer directly className = %s",olig[01;31m-[00m>className().c_str() ));
builder.cc:1227:	arch[01;31m-[00m>addOligomer(olig);
builder.cc:1230:    lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(lisp[01;31m-[00m>intern(name[01;31m-[00m>get()),arch);
builder.cc:1235:{_F(this[01;31m-[00m>lisp());
builder.cc:1236:    ASSERT_NOT_NULL(this[01;31m-[00m>_OligomerBuilder);
builder.cc:1237:    ASSERT(this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>notNil());
builder.cc:1238:    return this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>_BuildSerialNumber;
builder.cc:1243:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>logFirstInterestingAtom(comment);
builder.cc:1248:    ss << "Interesting atom dump [01;31m-[00m[01;31m-[00m Build: " << this[01;31m-[00m>changeCountersAsString() << endl;
builder.cc:1249:    this[01;31m-[00m>getOligomerBuilder()[01;31m-[00m>interestingAtomDump(ss);
builder.cc:1254:    ss << "Complete builder dump [01;31m-[00m[01;31m-[00m Build: " << this[01;31m-[00m>changeCountersAsString() << endl;
builder.cc:1255:    ss << boost::format("BuildAllAtoms = %d") % this[01;31m-[00m>buildsAllAtoms() << endl;
builder.cc:1256:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>oligomerBuilderStreamDump(ss);
builder.cc:1263:    this[01;31m-[00m>streamDump(fout);
builder.cc:1270:{_F(this[01;31m-[00m>lisp());
builder.cc:1271:    RPReferencerConformation conf = O_ReferencerConformation::create(this[01;31m-[00m>lisp());
builder.cc:1272:    conf[01;31m-[00m>setChangeCounters(this[01;31m-[00m>getOligomerChangeCounter(),this[01;31m-[00m>getSequenceChangeCounter());
builder.cc:1273:    RPCoordinateArray coords = this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>readAtomScoreTransformedCoordinates(scorerState);
builder.cc:1274:    conf[01;31m-[00m>setCoordinateArray(coords);
builder.cc:1280:{_F(this[01;31m-[00m>lisp());
builder.cc:1281:    this[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(conf[01;31m-[00m>getOligomerChangeCounter(),conf);
builder.cc:1282:    this[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(conf[01;31m-[00m>getSequenceChangeCounter(),conf);
builder.cc:1283:    RPCoordinateArray coords = conf[01;31m-[00m>getCoordinateArray();
builder.cc:1284:    this[01;31m-[00m>_OligomerBuilder[01;31m-[00m>writeAtomCoordinates(coords);
builder.cc:1295:    defNoWrapPackage(MbbPackage,"setBuilder", &O_Builder::prim_setBuilder,this[01;31m-[00m>lisp());
builder.cc:1297:    class_<O_Builder>(this[01;31m-[00m>lisp())
builderDatabase.cc:53:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:94:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:105:	    if ( (*wit).lock()[01;31m-[00m>notNil() )
builderDatabase.cc:124:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:126:    return AllBuilderDatabases.size() [01;31m-[00m 1;	// Remove the "nil" database
builderDatabase.cc:137:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:145:	(*it)[01;31m-[00m>giveYourDependantObjectsTo(bdb);
builderDatabase.cc:156:    return this[01;31m-[00m>_Constitutions.asCons(this[01;31m-[00m>lisp()); 
builderDatabase.cc:161:    return this[01;31m-[00m>_SystemMonomerGroups.asCons(this[01;31m-[00m>lisp());
builderDatabase.cc:166:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:168:    for ( it=this[01;31m-[00m>begin_Constitutions(); it!=this[01;31m-[00m>end_Constitutions(); it++ )
builderDatabase.cc:171:	for ( si=(*it)[01;31m-[00m>begin_Stereoisomers(); si!=(*it)[01;31m-[00m>end_Stereoisomers(); si++ )
builderDatabase.cc:173:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % (*si)[01;31m-[00m>getName().c_str() );
builderDatabase.cc:199:    this[01;31m-[00m>Base::initialize();
builderDatabase.cc:201://    ASSERT_NOT_NULL(this[01;31m-[00m>_Names);
builderDatabase.cc:202://    this[01;31m-[00m>_Names[01;31m-[00m>initialize();
builderDatabase.cc:203:    this[01;31m-[00m>_SystemMonomerGroups.clear();
builderDatabase.cc:204:    this[01;31m-[00m>_UserMonomerPacks = O_ObjectDictionary::create(this[01;31m-[00m>lisp());
builderDatabase.cc:205:    this[01;31m-[00m>_Constitutions.clear();
builderDatabase.cc:206:    this[01;31m-[00m>_Entities.clear();
builderDatabase.cc:207:    this[01;31m-[00m>_WeakEnvironment = O_Lisp::nil(this[01;31m-[00m>lisp());
builderDatabase.cc:208:    LOG(BF("initialized _Entities@%p") % &(this[01;31m-[00m>_Entities)  ); // vp0(("initialized _Entities@%p", &(this[01;31m-[00m>_Entities) ));
builderDatabase.cc:209://    AllBuilderDatabases.append(this[01;31m-[00m>sharedThis<O_BuilderDatabase>());
builderDatabase.cc:212:bool O_BuilderDatabase::recognizesSystemMonomerGroup(const string& name) { return this[01;31m-[00m>_SystemMonomerGroups.contains(name);};
builderDatabase.cc:213:RPStringSet	 O_BuilderDatabase::getSystemMonomerGroupKeys() { return this[01;31m-[00m>_SystemMonomerGroups.getKeysAsStringSet(this[01;31m-[00m>lisp()); };
builderDatabase.cc:214:RPMonomerGroup	 O_BuilderDatabase::getSystemMonomerGroup(const string& name) { return this[01;31m-[00m>_SystemMonomerGroups.get(name);};
builderDatabase.cc:215:bool		 O_BuilderDatabase::recognizesUserMonomerPack(const string& name) { return this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>contains(name);};
builderDatabase.cc:216:RPStringSet	 O_BuilderDatabase::getUserMonomerPackKeys() { return this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>keysAsStringSet(); };
builderDatabase.cc:217:RPMonomerSet	 O_BuilderDatabase::getUserMonomerPack(const string& name) { return downcast<O_MonomerSet>(this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>get(name));};
builderDatabase.cc:228:        return this[01;31m-[00m>monomerConstitutionForName(name);
builderDatabase.cc:232:        return this[01;31m-[00m>getEntity(name);
builderDatabase.cc:236:        return this[01;31m-[00m>getFrameRecognizer(name);
builderDatabase.cc:238:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown BuilderDatabase Resource("+resource+"/"+name+")"));
builderDatabase.cc:244:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:246:    this[01;31m-[00m>_WeakEnvironment = env;
builderDatabase.cc:253:{ _F(this[01;31m-[00m>lisp());
builderDatabase.cc:254:    this[01;31m-[00m>_frameRecognizers.set(rec[01;31m-[00m>getRecognizerName(),rec);
builderDatabase.cc:259:{ _F(this[01;31m-[00m>lisp());
builderDatabase.cc:261:    rec = this[01;31m-[00m>_frameRecognizers.contains(nm);
builderDatabase.cc:275:    names = O_StringSet::create(this[01;31m-[00m>lisp());
builderDatabase.cc:276:    for ( susi=this[01;31m-[00m>_Constitutions.begin();
builderDatabase.cc:277:		susi!=this[01;31m-[00m>_Constitutions.end(); susi++ ) {
builderDatabase.cc:278:	monomers = susi[01;31m-[00m>second[01;31m-[00m>getMonomerNamesAsStringSet();
builderDatabase.cc:279:	if ( monomers[01;31m-[00m>contains(nm) ) return true;
builderDatabase.cc:286:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:287:    if ( ref[01;31m-[00m>getSelector() == "Constitution" )
builderDatabase.cc:289:        return this[01;31m-[00m>_Constitutions.getDefaultNil(ref[01;31m-[00m>getName(),this[01;31m-[00m>lisp());
builderDatabase.cc:291:    if ( ref[01;31m-[00m>getSelector() == "FrameRecognizer" )
builderDatabase.cc:293:        return this[01;31m-[00m>getFrameRecognizer(ref[01;31m-[00m>getName());
builderDatabase.cc:295:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Unknown ObjRef selector: "+ref[01;31m-[00m>getSelector() ));
builderDatabase.cc:302:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:304:    if ( !this[01;31m-[00m>_Entities.contains(nm) )
builderDatabase.cc:310:    obj = this[01;31m-[00m>_Entities.get(nm);
builderDatabase.cc:311:    if ( obj[01;31m-[00m>isAssignableTo<O_MonomerSet>() ) return true;
builderDatabase.cc:317:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:319:    ASSERT( this[01;31m-[00m>_Entities.contains(nm) );
builderDatabase.cc:321:    obj = this[01;31m-[00m>_Entities.get(nm);
builderDatabase.cc:322:    ASSERT( obj[01;31m-[00m>isAssignableTo<O_MonomerSet>() );
builderDatabase.cc:333:    LOG(BF("BuilderDatabase namespace@%p contains %d entries") % &(this[01;31m-[00m>_Entities) % this[01;31m-[00m>_Entities.size()  ); // vp0(("BuilderDatabase namespace@%p contains %d entries", &(this[01;31m-[00m>_Entities),this[01;31m-[00m>_Entities.size() ));
builderDatabase.cc:334:    for ( it=this[01;31m-[00m>_Entities.begin(); it!=this[01;31m-[00m>_Entities.end(); it++ )
builderDatabase.cc:339:    ASSERTP(this[01;31m-[00m>notNil(),"BuilderDatabase is nil!!!!!!");
builderDatabase.cc:340:    ASSERTF(this[01;31m-[00m>_Entities.contains(nm), BF("this[01;31m-[00m>_Entities.contains(%s) failed") % nm );
builderDatabase.cc:341:    return this[01;31m-[00m>_Entities.contains(nm);
builderDatabase.cc:345:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:346:    ASSERT(this[01;31m-[00m>_Entities.contains(nm));
builderDatabase.cc:347:    return this[01;31m-[00m>_Entities.get(nm);
builderDatabase.cc:352:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:355:    if ( this[01;31m-[00m>recognizesMonomerSetName(nm) )
builderDatabase.cc:358:	group = this[01;31m-[00m>getMonomerSet(nm);
builderDatabase.cc:359:	return group[01;31m-[00m>isFinalized();
builderDatabase.cc:367:{ _F(this[01;31m-[00m>lisp());
builderDatabase.cc:371:    if ( this[01;31m-[00m>isNil() )
builderDatabase.cc:373:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must load a BuilderDatabase"));
builderDatabase.cc:378:    ASSERTP(this[01;31m-[00m>notNil(),"The BuilderDatabase is nil");
builderDatabase.cc:379:    if ( !this[01;31m-[00m>_Entities.contains(nm) )
builderDatabase.cc:381:        LOG(BF("The namespace contains %d names: ") % this[01;31m-[00m>_Entities.size()  ); // vp0(( "The namespace contains %d names: ", this[01;31m-[00m>_Entities.size() ));
builderDatabase.cc:382://        for ( Map<O_BuilderDatabaseDependent>::iterator it=this[01;31m-[00m>_Entities.begin();
builderDatabase.cc:383:        for ( Map<O_Entity>::iterator it=this[01;31m-[00m>_Entities.begin();
builderDatabase.cc:384:		it!=this[01;31m-[00m>_Entities.end();
builderDatabase.cc:387:	    LOG(BF("Namespace contains name: %s") % it[01;31m-[00m>first.c_str()  ); // vp0(("Namespace contains name: %s", it[01;31m-[00m>first.c_str() ));
builderDatabase.cc:391://    ASSERTP(this[01;31m-[00m>_Entities.contains(nm),"BuilderDatabase Environment does not contain: "+nm);
builderDatabase.cc:392:    if ( this[01;31m-[00m>_Entities.contains(nm) )
builderDatabase.cc:394:        obj = this[01;31m-[00m>_Entities.get(nm);
builderDatabase.cc:395:        names = obj[01;31m-[00m>expandedNameList();
builderDatabase.cc:398:	names = O_StringSet::nil(this[01;31m-[00m>lisp());
builderDatabase.cc:405:{ _F(this[01;31m-[00m>lisp());
builderDatabase.cc:409:    ASSERT(this[01;31m-[00m>recognizesEntityName(nm));
builderDatabase.cc:410:    obj = this[01;31m-[00m>getEntity(nm);
builderDatabase.cc:411:    ll = obj[01;31m-[00m>expandedRepresentativeList();
builderDatabase.cc:416:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:417://    ASSERT_NOT_NULL(this[01;31m-[00m>_Names);
builderDatabase.cc:418://    ASSERTvalue(this[01;31m-[00m>_Entities.contains(nm), nm); // REMOVE
builderDatabase.cc:419:    if ( !this[01;31m-[00m>_Entities.contains(nm) ) return false;
builderDatabase.cc:421:    obj = this[01;31m-[00m>_Entities.get(nm);
builderDatabase.cc:422:    if ( obj[01;31m-[00m>isTerminalName() ) return true;
builderDatabase.cc:429:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:430:    this[01;31m-[00m>Base::archiveBase(node);
builderDatabase.cc:431:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
builderDatabase.cc:432:    node[01;31m-[00m>attributeIfNotDefault<string>("dateCreated",this[01;31m-[00m>_DateCreated,"");
builderDatabase.cc:433:    node[01;31m-[00m>attributeIfNotDefault<string>("dateUpdated",this[01;31m-[00m>_DateUpdated,"");
builderDatabase.cc:436:    if ( node[01;31m-[00m>saving() ) {
builderDatabase.cc:439:	for ( it=this[01;31m-[00m>_SystemMonomerGroups.begin(); it!=this[01;31m-[00m>_SystemMonomerGroups.end(); it++ )
builderDatabase.cc:441:	    LOG(BF("system group name: %s content use_count=%d") % it[01;31m-[00m>first.c_str() % it[01;31m-[00m>second.use_count()  ); // vp0(("system group name: %s content use_count=%d", it[01;31m-[00m>first.c_str(), it[01;31m-[00m>second.use_count() ));
builderDatabase.cc:444:	for ( ut=this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>begin(); ut!=this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>end(); ut++ )
builderDatabase.cc:446:	    LOG(BF("user group name: %s content use_count=%d") % ut[01;31m-[00m>first.c_str() % ut[01;31m-[00m>second.use_count()  ); // vp0(("user group name: %s content use_count=%d", ut[01;31m-[00m>first.c_str(), ut[01;31m-[00m>second.use_count() ));
builderDatabase.cc:450:    node[01;31m-[00m>archiveMapOfObjectsSubClassOf( this[01;31m-[00m>_SystemMonomerGroups );
builderDatabase.cc:451:    node[01;31m-[00m>archiveObjectIfDefined( "userMonomerPacks", this[01;31m-[00m>_UserMonomerPacks );
builderDatabase.cc:453:    if ( node[01;31m-[00m>loading() ) {
builderDatabase.cc:454:        LOG(BF("Just loaded %d system groups and %d user packs [01;31m-[00m[01;31m-[00m contents:") % this[01;31m-[00m>_SystemMonomerGroups.size() % this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>size()  ); // vp0(("Just loaded %d system groups and %d user packs [01;31m-[00m[01;31m-[00m contents:",this[01;31m-[00m>_SystemMonomerGroups.size(),this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>size() ));
builderDatabase.cc:456:	for ( it=this[01;31m-[00m>_SystemMonomerGroups.begin(); it!=this[01;31m-[00m>_SystemMonomerGroups.end(); it++ )
builderDatabase.cc:458:	    LOG(BF("SystemMonomerGroup: %ss content use_count=%d") % it[01;31m-[00m>second[01;31m-[00m>description().c_str() % it[01;31m-[00m>second.use_count()  ); // vp0(("SystemMonomerGroup: %ss content use_count=%d", it[01;31m-[00m>second[01;31m-[00m>description().c_str(), it[01;31m-[00m>second.use_count() ));
builderDatabase.cc:459:	    LOG(BF("   Representative: %s") % it[01;31m-[00m>second[01;31m-[00m>getRepresentative().c_str()  ); // vp0(("   Representative: %s", it[01;31m-[00m>second[01;31m-[00m>getRepresentative().c_str() ));
builderDatabase.cc:462:	for ( ut=this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>begin(); ut!=this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>end(); ut++ )
builderDatabase.cc:464:	    LOG(BF("UserMonomerPacks: %s content use_count=%d") % ut[01;31m-[00m>second[01;31m-[00m>description().c_str() % ut[01;31m-[00m>second.use_count()  ); // vp0(("UserMonomerPacks: %s content use_count=%d", ut[01;31m-[00m>second[01;31m-[00m>description().c_str(), ut[01;31m-[00m>second.use_count() ));
builderDatabase.cc:469:        node[01;31m-[00m>archiveMapOfObjectsSubClassOf( this[01;31m-[00m>_Constitutions );
builderDatabase.cc:471:    node[01;31m-[00m>archiveMapOfObjectsSubClassOf( this[01;31m-[00m>_frameRecognizers);
builderDatabase.cc:472:    node[01;31m-[00m>archiveMapOfObjectsSubClassOf( this[01;31m-[00m>_MonomerCoordinates );
builderDatabase.cc:473:    node[01;31m-[00m>needsFinalization();
builderDatabase.cc:478:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:480:	for ( O_BuilderDatabase::systemMonomerGroupIterator mgi=this[01;31m-[00m>_SystemMonomerGroups.begin();
builderDatabase.cc:481:		    mgi!=this[01;31m-[00m>_SystemMonomerGroups.end(); mgi++ )
builderDatabase.cc:483:	    LOG(BF("BuilderDatabase_Entities_add(%s) a SystemMonomerGroup") % (*mgi)[01;31m-[00m>getName().c_str()  ); // vp0(("BuilderDatabase_Entities_add(%s) a SystemMonomerGroup",(*mgi)[01;31m-[00m>getName().c_str() ));
builderDatabase.cc:484:	    this[01;31m-[00m>_Entities.addUnique((*mgi)[01;31m-[00m>getName(), (*mgi), _lisp );
builderDatabase.cc:489:	for ( mpi=this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>begin();
builderDatabase.cc:490:		    mpi!=this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>end(); mpi++ )
builderDatabase.cc:492:	    RPMonomerPack pack = downcast<O_MonomerPack>(mpi[01;31m-[00m>second);
builderDatabase.cc:493:	    LOG(BF("BuilderDatabase_Entities_add(%s) a UserMonomerPack") % pack[01;31m-[00m>getName().c_str()  ); // vp0(("BuilderDatabase_Entities_add(%s) a UserMonomerPack",pack[01;31m-[00m>getName().c_str() ));
builderDatabase.cc:494:	    this[01;31m-[00m>_Entities.addUnique(mpi[01;31m-[00m>first, pack, _lisp );
builderDatabase.cc:499:	for ( ci= this[01;31m-[00m>_Constitutions.begin(); ci!=this[01;31m-[00m>_Constitutions.end(); ci++)
builderDatabase.cc:501:	    LOG(BF("BuilderDatabase_Entities_add(%s) a Constitution") % (ci[01;31m-[00m>second)[01;31m-[00m>getName().c_str()  ); // vp0(("BuilderDatabase_Entities_add(%s) a Constitution",(ci[01;31m-[00m>second)[01;31m-[00m>getName().c_str() ));
builderDatabase.cc:502:	    this[01;31m-[00m>_Entities.addUnique((ci[01;31m-[00m>second)[01;31m-[00m>getName(), (ci[01;31m-[00m>second), _lisp);
builderDatabase.cc:504:	    for ( si=(ci[01;31m-[00m>second)[01;31m-[00m>begin_Stereoisomers(); si!=(ci[01;31m-[00m>second)[01;31m-[00m>end_Stereoisomers(); si++ )
builderDatabase.cc:506:		LOG(BF("BuilderDatabase_Entities_add(%s) a MonomerName") % (*si)[01;31m-[00m>getName().c_str()  ); // vp0(("BuilderDatabase_Entities_add(%s) a MonomerName",(*si)[01;31m-[00m>getName().c_str() ));
builderDatabase.cc:507:		this[01;31m-[00m>_Entities.addUnique((*si)[01;31m-[00m>getName(), (*si), _lisp );
builderDatabase.cc:508:	       LOG(BF("BuilderDatabase_Entities_add(%s) a PdbName") % (*si)[01;31m-[00m>getPdb().c_str()  ); // vp0(("BuilderDatabase_Entities_add(%s) a PdbName",(*si)[01;31m-[00m>getPdb().c_str() ));
builderDatabase.cc:509:	       this[01;31m-[00m>_Entities.addUnique((*si)[01;31m-[00m>getPdb(), (*si), _lisp );
builderDatabase.cc:513:    LOG(BF("In loadFinalize BuilderDatabase namespace@%p contains %d entries") % &(this[01;31m-[00m>_Entities) % this[01;31m-[00m>_Entities.size()  ); // vp0(("In loadFinalize BuilderDatabase namespace@%p contains %d entries", &(this[01;31m-[00m>_Entities),this[01;31m-[00m>_Entities.size() ));
builderDatabase.cc:519:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:521:    ASSERTP(this[01;31m-[00m>_Entities.contains(name),"Could not find: "+name+" in Environment");
builderDatabase.cc:522:    obj = this[01;31m-[00m>_Entities.get(name);
builderDatabase.cc:523:    ASSERTP(obj[01;31m-[00m>hasConstitution(), "The name: "+name+" is not part of a Constitution" );
builderDatabase.cc:524:    return obj[01;31m-[00m>constitution();
builderDatabase.cc:528:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:530:    con = this[01;31m-[00m>constitutionForNameOrPdb(name);
builderDatabase.cc:531:    return con[01;31m-[00m>getName();
builderDatabase.cc:535:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:537:    ASSERTP(this[01;31m-[00m>_Entities.contains(name), "Could not find name("+name+") in Environment");
builderDatabase.cc:538:    dep = this[01;31m-[00m>_Entities.get(name);
builderDatabase.cc:539:    ASSERTP(dep[01;31m-[00m>isTerminalName(), "Asked for MonomerName of non[01;31m-[00mterminal name("+name+")");
builderDatabase.cc:540:    return dep[01;31m-[00m>getName();
builderDatabase.cc:544:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:547:    ASSERTP(this[01;31m-[00m>_Entities.contains(name), "Could not find name("+name+") in Environment");
builderDatabase.cc:548:    dep = this[01;31m-[00m>_Entities.get(name);
builderDatabase.cc:549:    ASSERTP(dep[01;31m-[00m>isTerminalName(), "Asked for MonomerName of non[01;31m-[00mterminal name("+name+")");
builderDatabase.cc:551:    return si[01;31m-[00m>getPdb();
builderDatabase.cc:558:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:561:    for ( it=this[01;31m-[00m>_SystemMonomerGroups.begin(); it!=this[01;31m-[00m>_SystemMonomerGroups.end(); it++ )
builderDatabase.cc:563:	LOG(BF("%s group name: %s content use_count=%d") % msg.c_str() % it[01;31m-[00m>first.c_str() % it[01;31m-[00m>second.use_count()  ); // vp0(("%s group name: %s content use_count=%d", msg.c_str(), it[01;31m-[00m>first.c_str(), it[01;31m-[00m>second.use_count() ));
builderDatabase.cc:580:    names = O_StringSet::create(this[01;31m-[00m>lisp());
builderDatabase.cc:581:    for ( susi=this[01;31m-[00m>_Constitutions.begin();
builderDatabase.cc:582:		susi!=this[01;31m-[00m>_Constitutions.end(); susi++ ) {
builderDatabase.cc:583:	monomers = susi[01;31m-[00m>second[01;31m-[00m>getMonomerNamesAsStringSet();
builderDatabase.cc:584:	names[01;31m-[00m>insertStringSet(monomers);
builderDatabase.cc:601:    names = O_StringList::create(this[01;31m-[00m>lisp());
builderDatabase.cc:602:    for ( susi=this[01;31m-[00m>_Constitutions.begin();
builderDatabase.cc:603:		susi!=this[01;31m-[00m>_Constitutions.end(); susi++ ) {
builderDatabase.cc:604:	monomers = susi[01;31m-[00m>second[01;31m-[00m>getMonomerNamesAsStringList();
builderDatabase.cc:605:	names[01;31m-[00m>appendStringList(monomers);
builderDatabase.cc:619:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:620://    sum[01;31m-[00m>setBuilderDatabase(this[01;31m-[00m>sharedThis<O_BuilderDatabase>());
builderDatabase.cc:621://    this[01;31m-[00m>_Names[01;31m-[00m>fillFromConstitution(sum);
builderDatabase.cc:622://    sum[01;31m-[00m>setBuilderDatabase(this[01;31m-[00m>sharedThis<O_BuilderDatabase>());
builderDatabase.cc:623:    LOG(BF("Adding constitution(%s)") % sum[01;31m-[00m>getName() );
builderDatabase.cc:624:    this[01;31m-[00m>_Constitutions.set(sum[01;31m-[00m>getName(),sum);
builderDatabase.cc:625:    LOG(BF("BuilderDatabase_Entities_add(%s) a Constitution") % (sum)[01;31m-[00m>getName().c_str()  ); // vp0(("BuilderDatabase_Entities_add(%s) a Constitution",(sum)[01;31m-[00m>getName().c_str() ));
builderDatabase.cc:626:    this[01;31m-[00m>_Entities.addUnique((sum)[01;31m-[00m>getName(), sum, _lisp);
builderDatabase.cc:628:    for ( si=(sum)[01;31m-[00m>begin_Stereoisomers(); si!=(sum)[01;31m-[00m>end_Stereoisomers(); si++ )
builderDatabase.cc:630:       LOG(BF("BuilderDatabase_Entities_add(%s) a MonomerName") % (*si)[01;31m-[00m>getName().c_str()  ); // vp0(("BuilderDatabase_Entities_add(%s) a MonomerName",(*si)[01;31m-[00m>getName().c_str() ));
builderDatabase.cc:631:       if ( (*si)[01;31m-[00m>getName() == "" )
builderDatabase.cc:633:	   TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("While adding constitution(%s) a stereoisomer had a blank name!!") % sum[01;31m-[00m>getName() ));
builderDatabase.cc:635:       this[01;31m-[00m>_Entities.addUnique((*si)[01;31m-[00m>getName(), (*si), _lisp );
builderDatabase.cc:636:       LOG(BF("BuilderDatabase_Entities_add(%s) a PdbName") % (*si)[01;31m-[00m>getPdb().c_str()  ); // vp0(("BuilderDatabase_Entities_add(%s) a PdbName",(*si)[01;31m-[00m>getPdb().c_str() ));
builderDatabase.cc:637:       if ( (*si)[01;31m-[00m>getPdb() == "" )
builderDatabase.cc:639:	   TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("While adding constitution(%s) a stereoisomer had a blank pdb name!!") % sum[01;31m-[00m>getName() ));
builderDatabase.cc:641:       this[01;31m-[00m>_Entities.addUnique((*si)[01;31m-[00m>getPdb(), (*si), _lisp );
builderDatabase.cc:652:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:653:    LOG(BF("Adding couplingRule with name=%s to BuilderDatabase") % (rule[01;31m-[00m>getName().c_str() ) ); // vp0(( "Adding couplingRule with name=%s to BuilderDatabase", rule[01;31m-[00m>getName().c_str() ));
builderDatabase.cc:654:    this[01;31m-[00m>couplingMap.insert(make_pair(rule[01;31m-[00m>getName(),rule));
builderDatabase.cc:655:    this[01;31m-[00m>couplings.push_back(rule);
builderDatabase.cc:664:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:665:    LOG(BF("Adding fragment with name=%s to BuilderDatabase") % (frag[01;31m-[00m>getName().c_str() ) ); // vp0(( "Adding fragment with name=%s to BuilderDatabase", frag[01;31m-[00m>getName().c_str() ));
builderDatabase.cc:666:    frag[01;31m-[00m>setGlobal(true);
builderDatabase.cc:667:    if ( this[01;31m-[00m>_CoreFragmentMap.count(frag[01;31m-[00m>getName()) != 0 ) {
builderDatabase.cc:668:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The global fragment: ", frag[01;31m-[00m>getName()," has already been defined"));
builderDatabase.cc:670:    this[01;31m-[00m>_CoreFragmentMap[frag[01;31m-[00m>getName()] = frag;
builderDatabase.cc:675:    if ( this[01;31m-[00m>_CoreFragmentMap.count(nm) == 0 ) {
builderDatabase.cc:676:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find global fragment with name: ", nm ));
builderDatabase.cc:678:    return this[01;31m-[00m>_CoreFragmentMap[nm];
builderDatabase.cc:685:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:686:    LOG(BF("Adding fragment with name=%s to BuilderDatabase") % (frag[01;31m-[00m>getName().c_str() ) ); // vp0(( "Adding fragment with name=%s to BuilderDatabase", frag[01;31m-[00m>getName().c_str() ));
builderDatabase.cc:687:    frag[01;31m-[00m>setGlobal(true);
builderDatabase.cc:688:    if ( this[01;31m-[00m>_FinishFragmentMap.count(frag[01;31m-[00m>getName()) != 0 ) {
builderDatabase.cc:689:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The global fragment: ", frag[01;31m-[00m>getName()," has already been defined"));
builderDatabase.cc:691:    this[01;31m-[00m>_FinishFragmentMap[frag[01;31m-[00m>getName()] = frag;
builderDatabase.cc:696:    if ( this[01;31m-[00m>_FinishFragmentMap.count(nm) == 0 ) {
builderDatabase.cc:697:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find global fragment with name: ", nm ));
builderDatabase.cc:699:    return this[01;31m-[00m>_FinishFragmentMap[nm];
builderDatabase.cc:705:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:706:    if ( this[01;31m-[00m>recognizesMonomerSetName(group[01;31m-[00m>getName()) ) {
builderDatabase.cc:707:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("You tried to create a group with a name that is already used: %s") % group[01;31m-[00m>getName() ));
builderDatabase.cc:709:    this[01;31m-[00m>_SystemMonomerGroups.set(group[01;31m-[00m>getName(),group);
builderDatabase.cc:713:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:714:    this[01;31m-[00m>_Entities.set(group[01;31m-[00m>getName(),group);
builderDatabase.cc:715:    this[01;31m-[00m>_UserMonomerPacks[01;31m-[00m>set(group[01;31m-[00m>getName(),group);
builderDatabase.cc:716:    this[01;31m-[00m>_WeakLastUserMonomerPackToChange = group;
builderDatabase.cc:722:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:728:    names = O_StringSet::create(this[01;31m-[00m>lisp());
builderDatabase.cc:729:    names[01;31m-[00m>clear();
builderDatabase.cc:730:    for ( mi=this[01;31m-[00m>begin_Constitutions();
builderDatabase.cc:731:    		mi!=this[01;31m-[00m>end_Constitutions(); mi++ ) {
builderDatabase.cc:733:	for ( pi=cc[01;31m-[00m>begin_Plugs(); pi!=cc[01;31m-[00m>end_Plugs(); pi++ ) {
builderDatabase.cc:734:	    couplingName = O_DirectionalCoupling::couplingName((*pi)[01;31m-[00m>getName(), _lisp);
builderDatabase.cc:736:	    names[01;31m-[00m>insert(couplingName);
builderDatabase.cc:761:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:765://    this[01;31m-[00m>testConsistancyOfMenuLayout(results);
builderDatabase.cc:773:    for ( Map<O_Constitution>::value_iterator mit=this[01;31m-[00m>begin_Constitutions();
builderDatabase.cc:774:			mit!=this[01;31m-[00m>end_Constitutions(); mit++ ) {
builderDatabase.cc:775:	constitutionName = (*mit)[01;31m-[00m>getName();
builderDatabase.cc:793:	if ( ! this[01;31m-[00m>recognizesConstitutionName(constitutionName) ) {
builderDatabase.cc:800://	(*mit)[01;31m-[00m>testConsistency(results);
builderDatabase.cc:806:    for ( vector<RPCouplingRule>::iterator cit=this[01;31m-[00m>couplings.begin();
builderDatabase.cc:807:			cit!=this[01;31m-[00m>couplings.end(); cit++ ) {
builderDatabase.cc:808:	(*cit)[01;31m-[00m>testConsistency(results);
builderDatabase.cc:827:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:840:    if ( !this[01;31m-[00m>recognizesNameOrPdb(res[01;31m-[00m>getName()) ) {
builderDatabase.cc:841:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("I can't learn about this Constitution because I don't recognize the Monomer name or pdb: %s %s %d") % res[01;31m-[00m>getName() % __FILE__ % __LINE__ ));
builderDatabase.cc:843:    constitutionName = this[01;31m-[00m>constitutionNameForNameOrPdb(res[01;31m-[00m>getName());
builderDatabase.cc:844:    if ( this[01;31m-[00m>recognizesConstitutionName((constitutionName) )) {
builderDatabase.cc:845:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("I can't learn about this Constitution because I already have an entry for it. residue name: %s ConstitutionName: %s") % res[01;31m-[00m>getName() % constitutionName ));
builderDatabase.cc:847:    LOG(BF("defineConstitutionAndCouplingRulesBasedOnResidue name=%s  id=%d") % (res[01;31m-[00m>getName().c_str()) % (res[01;31m-[00m>getId() ) ); // vp0(( "defineConstitutionAndCouplingRulesBasedOnResidue name=%s  id=%d", res[01;31m-[00m>getName().c_str(), res[01;31m-[00m>getId() ));
builderDatabase.cc:851:	bonds = a[01;31m-[00m>getBonds();
builderDatabase.cc:853:	    if ( (*b)[01;31m-[00m>isInterResidueBond() ) {
builderDatabase.cc:854:	        otherRes = (*b)[01;31m-[00m>getToLocked()[01;31m-[00m>getResidueContainedBy();
builderDatabase.cc:855:		LOG(BF("  Bonded to another residue name=%s id=%d") % (otherRes[01;31m-[00m>getName().c_str()) % (otherRes[01;31m-[00m>getId() ) ); // vp0(( "  Bonded to another residue name=%s id=%d", otherRes[01;31m-[00m>getName().c_str(), otherRes[01;31m-[00m>getId() ));
builderDatabase.cc:863:    constitution = RP_Create<O_Constitution>(this[01;31m-[00m>lisp());
builderDatabase.cc:864:    constitution[01;31m-[00m>setName(constitutionName);
builderDatabase.cc:865://    constitution[01;31m-[00m>setBuilderDatabase(this[01;31m-[00m>sharedThis<O_BuilderDatabase>());
builderDatabase.cc:866://    constitution[01;31m-[00m>setZType(res[01;31m-[00m>getName());
builderDatabase.cc:867://    constitution[01;31m-[00m>addMonomerName( res[01;31m-[00m>getName(), res[01;31m-[00m>getName() );
builderDatabase.cc:868:    newRes = res[01;31m-[00m>copyDropExternalResidueBonds();
builderDatabase.cc:869:    constitution[01;31m-[00m>setResidue( newRes );
builderDatabase.cc:870:    constitution[01;31m-[00m>setComment("This Constitution was created by defineConstitutionAndCouplingRulesBasedOnResidue");
builderDatabase.cc:871:    this[01;31m-[00m>addConstitution(constitution);
builderDatabase.cc:890:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:902:	nm = rRes[01;31m-[00m>getName();
builderDatabase.cc:904:	if ( !this[01;31m-[00m>recognizesNameOrPdb(rRes[01;31m-[00m>getName()) ) {
builderDatabase.cc:906:	    this[01;31m-[00m>defineConstitutionAndCouplingRulesBasedOnResidue(rRes);
builderDatabase.cc:915:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:920:    res = O_StringList::create(this[01;31m-[00m>lisp());
builderDatabase.cc:921:    for ( ci=this[01;31m-[00m>_Constitutions.begin(); ci!=this[01;31m-[00m>_Constitutions.end(); ci++ )
builderDatabase.cc:924:	for ( si=con[01;31m-[00m>begin_Stereoisomers(); si!=con[01;31m-[00m>end_Stereoisomers(); si++ )
builderDatabase.cc:926:	    res[01;31m-[00m>append((*si)[01;31m-[00m>getName());
builderDatabase.cc:935:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:939:    myDependantObjects = this[01;31m-[00m>listOfListenersForSignal(BuilderDatabase_replaceMe);
builderDatabase.cc:941:    for ( it=myDependantObjects[01;31m-[00m>begin(); it!=myDependantObjects[01;31m-[00m>end(); it++ )
builderDatabase.cc:946://	dep[01;31m-[00m>setBuilderDatabase(bdb);
builderDatabase.cc:952:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
builderDatabase.cc:953:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
builderDatabase.cc:954:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
builderDatabase.cc:965:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:970:    context = mc[01;31m-[00m>getContext();
builderDatabase.cc:971://    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s %u addMonomerCoordinates context:\n%s") % __FILE__% __LINE__ % context[01;31m-[00m>asXmlString().c_str() );
builderDatabase.cc:972:    allContexts = context[01;31m-[00m>getAllSpecificContexts();
builderDatabase.cc:973:    LOG(BF("There are %u specific contexts") % (allContexts[01;31m-[00m>size() ) ); // vp0(("There are %u specific contexts",allContexts[01;31m-[00m>size() ));
builderDatabase.cc:974://    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s %u There are %u specific contexts") % __FILE__% __LINE__ % allContexts[01;31m-[00m>size() );
builderDatabase.cc:976:    for ( si=allContexts[01;31m-[00m>begin(); si!=allContexts[01;31m-[00m>end(); si++ )
builderDatabase.cc:978://        this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("    %s %u Looking at specific contexts: %s") % __FILE__% __LINE__ % si[01;31m-[00m>first.c_str() );
builderDatabase.cc:979:	if ( si[01;31m-[00m>second[01;31m-[00m>allMonomersInDatabase(this[01;31m-[00m>sharedThis<O_BuilderDatabase>()) )
builderDatabase.cc:981://	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("      %s %u  Adding it") % __FILE__ % __LINE__ );
builderDatabase.cc:982:	    LOG(BF("Adding context: %s") % (si[01;31m-[00m>first).c_str()  ); // vp0(("Adding context: %s",(si[01;31m-[00m>first).c_str() ));
builderDatabase.cc:983:	    this[01;31m-[00m>_MonomerCoordinates.set(si[01;31m-[00m>first,mc);
builderDatabase.cc:987://	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("      %s %u  Ignoring it") % __FILE__ % __LINE__ );
builderDatabase.cc:996:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:998:    first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
builderDatabase.cc:1002:    for ( it=this[01;31m-[00m>begin_MonomerCoordinates(); it!=this[01;31m-[00m>end_MonomerCoordinates(); it++ )
builderDatabase.cc:1004:	unique.insert(it[01;31m-[00m>second);
builderDatabase.cc:1008:	RPCons one = O_Cons::create((*ui),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
builderDatabase.cc:1009:	cur[01;31m-[00m>setCdr(one);
builderDatabase.cc:1012:    return first[01;31m-[00m>cdr();
builderDatabase.cc:1016:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1018:    first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
builderDatabase.cc:1021:    for ( it=this[01;31m-[00m>begin_MonomerCoordinates(); it!=this[01;31m-[00m>end_MonomerCoordinates(); it++ )
builderDatabase.cc:1023:	RPCons one = O_Cons::create(O_String::create(it[01;31m-[00m>first,this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
builderDatabase.cc:1024:	cur[01;31m-[00m>setCdr(one);
builderDatabase.cc:1027:    return first[01;31m-[00m>cdr();
builderDatabase.cc:1034:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1035:    return this[01;31m-[00m>_MonomerCoordinates.contains(key);
builderDatabase.cc:1039:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1040:    if ( this[01;31m-[00m>_MonomerCoordinates.contains(key) )
builderDatabase.cc:1042:        return this[01;31m-[00m>_MonomerCoordinates.get(key);
builderDatabase.cc:1044:    return O_MonomerCoordinates::nil(this[01;31m-[00m>lisp());
builderDatabase.cc:1049:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1051:    key = context[01;31m-[00m>getKey();
builderDatabase.cc:1052:    if ( this[01;31m-[00m>_MonomerCoordinates.contains(key) )
builderDatabase.cc:1054:        return this[01;31m-[00m>_MonomerCoordinates.get(key);
builderDatabase.cc:1056:    return O_MonomerCoordinates::nil(this[01;31m-[00m>lisp());
builderDatabase.cc:1060:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1063:    key = context[01;31m-[00m>getKey();
builderDatabase.cc:1065:    foundIt = this[01;31m-[00m>_MonomerCoordinates.contains(key);
builderDatabase.cc:1072:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1074:    xml = O_XmlSaveArchive::create(this[01;31m-[00m>lisp());
builderDatabase.cc:1075:    xml[01;31m-[00m>put("builderDatabase",this[01;31m-[00m>sharedThis<O_BuilderDatabase>());
builderDatabase.cc:1076:    xml[01;31m-[00m>saveAs(fn);
builderDatabase.cc:1081:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1082:    ASSERTP(this[01;31m-[00m>notNil(),"The BuilderDatabase is nil and it cannot be for this operation");
builderDatabase.cc:1083:    RPSpecificContextSet necessary = bs[01;31m-[00m>allSpecificMonomerContexts();
builderDatabase.cc:1084:    RPSpecificContextSet available = this[01;31m-[00m>allSpecificMonomerContexts();
builderDatabase.cc:1085:    LOG(BF("There are %d necessary MonomerContexts") % necessary[01;31m-[00m>size() );
builderDatabase.cc:1086:    LOG(BF("There are %d available MonomerContexts") % available[01;31m-[00m>size() );
builderDatabase.cc:1087:    available[01;31m-[00m>remove(necessary);
builderDatabase.cc:1088:    LOG(BF("After removing necessary there are %d useless MonomerContexts") % available[01;31m-[00m>size() );
builderDatabase.cc:1090:    for ( it=available[01;31m-[00m>begin(); it!=available[01;31m-[00m>end(); it++ )
builderDatabase.cc:1092:	this[01;31m-[00m>_MonomerCoordinates.remove(it[01;31m-[00m>second[01;31m-[00m>asString());
builderDatabase.cc:1100:    available = this[01;31m-[00m>allSpecificMonomerContexts();
builderDatabase.cc:1101:    LOG(BF("Now there are %d available MonomerContexts") % available[01;31m-[00m>size() );
builderDatabase.cc:1102:    necessary[01;31m-[00m>remove(available);
builderDatabase.cc:1103:    LOG(BF("After removing available MonomerContexts from the necessary ones ther are %d missing") % necessary[01;31m-[00m>size() );
builderDatabase.cc:1104:    if ( necessary[01;31m-[00m>size() > 0 )
builderDatabase.cc:1111:	for ( O_SpecificContextSet::iterator mt =necessary[01;31m-[00m>begin(); mt!=necessary[01;31m-[00m>end(); mt++ )
builderDatabase.cc:1113:	    serr << "  missing: " << (mt[01;31m-[00m>second)[01;31m-[00m>asString() << endl;
builderDatabase.cc:1115:	serr << "Total missing MonomerContexts: " << necessary[01;31m-[00m>size() << endl;
builderDatabase.cc:1116:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
builderDatabase.cc:1122:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1123:    RPSpecificContextSet all = O_SpecificContextSet::create(this[01;31m-[00m>lisp());
builderDatabase.cc:1126:    for ( mi=this[01;31m-[00m>_MonomerCoordinates.begin(); mi!=this[01;31m-[00m>_MonomerCoordinates.end(); mi++ )
builderDatabase.cc:1128:	uniqueMonomerCoordinates.insert(mi[01;31m-[00m>second);
builderDatabase.cc:1133:	RPSpecificContextSet one = (*si)[01;31m-[00m>getContext()[01;31m-[00m>getAllSpecificContexts();
builderDatabase.cc:1134:	all[01;31m-[00m>merge(one);
builderDatabase.cc:1140:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1141:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
builderDatabase.cc:1142:    LOG(BF("Looking for frameRecognizers: keys[01;31m-[00m> %s") % (dict[01;31m-[00m>allKeys().c_str() ) ); // vp0(("Looking for frameRecognizers: keys[01;31m-[00m> %s", dict[01;31m-[00m>allKeys().c_str() )); 
builderDatabase.cc:1143:    this[01;31m-[00m>_Name = dict[01;31m-[00m>getStringAndRemoveOrDefault("name","");
builderDatabase.cc:1144:    RPCons frameRecognizers = dict[01;31m-[00m>getAndRemove("frameRecognizers")[01;31m-[00m>as<O_Cons>();
builderDatabase.cc:1145:    this[01;31m-[00m>_frameRecognizers.clear();
builderDatabase.cc:1146:    for ( RPCons cur = frameRecognizers; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
builderDatabase.cc:1148:	RPFrameRecognizer fr = cur[01;31m-[00m>car<O_FrameRecognizer>();
builderDatabase.cc:1149:	string name = fr[01;31m-[00m>getRecognizerName();
builderDatabase.cc:1150:	this[01;31m-[00m>_frameRecognizers.set(name,fr);
builderDatabase.cc:1151:	fr[01;31m-[00m>setOwner(this[01;31m-[00m>sharedThis<O_BuilderDatabase>());
builderDatabase.cc:1155:    LOG(BF("Looking for monomerGroups: keys[01;31m-[00m> %s") % (dict[01;31m-[00m>allKeys().c_str() ) ); // vp0(("Looking for monomerGroups: keys[01;31m-[00m> %s", dict[01;31m-[00m>allKeys().c_str() )); 
builderDatabase.cc:1156:    RPCons monomerPacks =  dict[01;31m-[00m>getAndRemove("monomerGroups")[01;31m-[00m>as<O_Cons>();
builderDatabase.cc:1157:    this[01;31m-[00m>_SystemMonomerGroups.clear();
builderDatabase.cc:1158:    for ( RPCons cur = monomerPacks; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
builderDatabase.cc:1160:	RPMonomerGroup group = cur[01;31m-[00m>car<O_MonomerGroup>();
builderDatabase.cc:1161:	this[01;31m-[00m>_SystemMonomerGroups.set(group[01;31m-[00m>getName(),group);
builderDatabase.cc:1165:    RPCons constitutions =  dict[01;31m-[00m>getAndRemove("constitutions")[01;31m-[00m>as<O_Cons>();
builderDatabase.cc:1166:    this[01;31m-[00m>_Constitutions.clear();
builderDatabase.cc:1167:    for ( RPCons cur = constitutions; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
builderDatabase.cc:1169:	RPConstitution constitution = cur[01;31m-[00m>car<O_Constitution>();
builderDatabase.cc:1170:	this[01;31m-[00m>addConstitution(constitution);
builderDatabase.cc:1181:    class_<O_BuilderDatabase>(this[01;31m-[00m>lisp())
builderDatabase.cc:1302:{_F(this[01;31m-[00m>lisp());
builderDatabase.cc:1306:    names = this[01;31m-[00m>allUniqueCouplingNames();
builderDatabase.cc:1307:    for ( vi=names[01;31m-[00m>begin(); vi!=names[01;31m-[00m>end(); vi++ ) {
builderDatabaseDependent.cc:21:    this[01;31m-[00m>Base::initialize();
builderDatabaseDependent.cc:37:{_F(this[01;31m-[00m>lisp());
builderDatabaseDependent.cc:38:    this[01;31m-[00m>Base::archiveBase(node);
builderDatabaseDependent.cc:39:    node[01;31m-[00m>needsFinalization();
builderDatabaseDependent.cc:46:{_F(this[01;31m-[00m>lisp());
builderDatabaseDependent.cc:48:    if ( !this[01;31m-[00m>Base::loadFinalize(node) ) return false;
builderDatabaseDependent.cc:54:{_F(this[01;31m-[00m>lisp());
builderDatabaseDependent.cc:55:    RPConstitution x = O_Constitution::nil(this[01;31m-[00m>lisp());
builderDatabaseDependent.cc:62:{_F(this[01;31m-[00m>lisp());
builderDatabaseDependent.cc:65:    RPLisp env = db[01;31m-[00m>getEnvironment();
builderDatabaseDependent.cc:66:    this[01;31m-[00m>setEnvironment(env);
builderDatabaseDependent.cc:70:{_F(this[01;31m-[00m>lisp());
builderDatabaseDependent.cc:71:    RPLisp env = this[01;31m-[00m>getEnvironment();
builderDatabaseDependent.cc:72:    return env[01;31m-[00m>hasBuilderDatabase();
builderDatabaseDependent.cc:78:{_F(this[01;31m-[00m>lisp());
builderDatabaseDependent.cc:79:    RPLisp env = this[01;31m-[00m>getEnvironment();
builderDatabaseDependent.cc:80:    ASSERTP(env[01;31m-[00m>notNil(),"My environment is nil");
builderDatabaseDependent.cc:81:    return env[01;31m-[00m>getBuilderDatabase();
builderDatabaseDependent.cc:94:    class_<O_BuilderDatabaseDependent>(this[01;31m-[00m>lisp())
builderDatabaseReference.cc:24:    ref[01;31m-[00m>_Reference = O_ObjRef::create(e,link);
builderDatabaseReference.cc:31:    this[01;31m-[00m>Base::initialize();
builderDatabaseReference.cc:32:    this[01;31m-[00m>_Reference = O_ObjRef::nil(this[01;31m-[00m>lisp());
builderDatabaseReference.cc:37:    this[01;31m-[00m>Base::archiveBase(node);
builderDatabaseReference.cc:38:    if ( node[01;31m-[00m>loading() )
builderDatabaseReference.cc:41:	node[01;31m-[00m>attribute<string>("ref",refStr);
builderDatabaseReference.cc:42:	this[01;31m-[00m>_Reference = O_ObjRef::create(this[01;31m-[00m>lisp(),refStr);
builderDatabaseReference.cc:46:	refStr = this[01;31m-[00m>_Reference[01;31m-[00m>asString();
builderDatabaseReference.cc:47:	node[01;31m-[00m>attribute<string>("ref",refStr);
builderDatabaseReference.cc:53:{_F(this[01;31m-[00m>lisp());
builderDatabaseReference.cc:55:    if ( this[01;31m-[00m>isNil() )
builderDatabaseReference.cc:57:        return O_Object::nil(this[01;31m-[00m>lisp());
builderDatabaseReference.cc:59:    obj = this[01;31m-[00m>getBuilderDatabase();
builderDatabaseReference.cc:61:    RPObject res = this[01;31m-[00m>_Reference[01;31m-[00m>relativeTo(obj);
builderScorer.cc:34:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_BuilderScorer>(args,environ);
builderScorer.cc:35:    this[01;31m-[00m>_Builder = _ARG(RPBuilder,bargs,"builder");
builderScorer.cc:37:    this[01;31m-[00m>setScorerVirtualMachine(scorer);
builderScorer.cc:38:    return this[01;31m-[00m>lisp()[01;31m-[00m>onil();
builderScorer.cc:43:    this[01;31m-[00m>Base::initialize();
builderScorer.cc:44:    this[01;31m-[00m>_Builder = O_Builder::nil(this[01;31m-[00m>lisp());
builderScorer.cc:45:    this[01;31m-[00m>_Scorer = O_ScorerVirtualMachine::nil(this[01;31m-[00m>lisp());
builderScorer.cc:50:    this[01;31m-[00m>Base::archiveBase(node);
builderScorer.cc:51:    node[01;31m-[00m>archiveObject("builder",this[01;31m-[00m>_Builder);
builderScorer.cc:52:    node[01;31m-[00m>archiveObject("scorer",this[01;31m-[00m>_Scorer);
builderScorer.cc:58:    return this[01;31m-[00m>_Builder[01;31m-[00m>changeCountersAsString();
builderScorer.cc:63:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:64:    this[01;31m-[00m>_Scorer = scorer;
builderScorer.cc:65:    if ( scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:66:    uint handle = scorer[01;31m-[00m>setBuilderAndReturnHandle(builder);
builderScorer.cc:67:    builder[01;31m-[00m>setScorer(scorer,handle);
builderScorer.cc:68:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>notNil() && this[01;31m-[00m>_Scorer[01;31m-[00m>needsAllAtomsBuilt(this[01;31m-[00m>_Builder) )
builderScorer.cc:70:	if ( ! this[01;31m-[00m>_Builder[01;31m-[00m>buildsAllAtoms() )
builderScorer.cc:74:	    ss << "and a Scorer that needs all atoms [01;31m-[00m I'm telling the Builder to build all atoms" <<endl;
builderScorer.cc:75:	    this[01;31m-[00m>_Builder[01;31m-[00m>setBuildAllAtoms(true);
builderScorer.cc:78:    this[01;31m-[00m>_Scorer[01;31m-[00m>oligomerChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:84:    return this[01;31m-[00m>_Builder;
builderScorer.cc:89:    return this[01;31m-[00m>_Builder[01;31m-[00m>allSpecificMonomerContexts();
builderScorer.cc:93:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:94:    this[01;31m-[00m>_Builder[01;31m-[00m>perturbSequence();
builderScorer.cc:95:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:96:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:100:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:101:    this[01;31m-[00m>_Builder[01;31m-[00m>perturbConformation();
builderScorer.cc:106:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:107:    RPScorerState ss = _lisp[01;31m-[00m>create<O_ScorerState>();
builderScorer.cc:110:	this[01;31m-[00m>perturbConformation();
builderScorer.cc:111:	this[01;31m-[00m>buildNecessaryUntransformedAtomPositionsAndEvaluateScorer(ss);
builderScorer.cc:117:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:118:    this[01;31m-[00m>_Builder[01;31m-[00m>firstOligomer();
builderScorer.cc:119:    this[01;31m-[00m>_Builder[01;31m-[00m>firstSequence();
builderScorer.cc:120:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:121:    this[01;31m-[00m>_Scorer[01;31m-[00m>oligomerChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:122:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:126:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:127:    this[01;31m-[00m>_Builder[01;31m-[00m>perturbOligomer();
builderScorer.cc:128:    this[01;31m-[00m>_Builder[01;31m-[00m>firstSequence();
builderScorer.cc:129:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:130:    this[01;31m-[00m>_Scorer[01;31m-[00m>oligomerChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:131:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:135:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:136:    bool b = this[01;31m-[00m>_Builder[01;31m-[00m>incrementOligomer();
builderScorer.cc:137:    this[01;31m-[00m>_Builder[01;31m-[00m>firstSequence();
builderScorer.cc:138:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return b;
builderScorer.cc:139:    this[01;31m-[00m>_Scorer[01;31m-[00m>oligomerChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:140:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:145:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:146:    this[01;31m-[00m>_Builder[01;31m-[00m>gotoOligomer(olig);
builderScorer.cc:147:    this[01;31m-[00m>_Builder[01;31m-[00m>firstSequence();
builderScorer.cc:148:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:149:    this[01;31m-[00m>_Scorer[01;31m-[00m>oligomerChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:150:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:154:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:155:    this[01;31m-[00m>_Builder[01;31m-[00m>gotoOligomerIndexDontBuild(idx);
builderScorer.cc:156:    this[01;31m-[00m>_Builder[01;31m-[00m>firstSequence();
builderScorer.cc:157:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:158:    this[01;31m-[00m>_Scorer[01;31m-[00m>oligomerChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:159:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:163:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:164:    this[01;31m-[00m>_Builder[01;31m-[00m>gotoOligomerIndexThenBuild(idx);
builderScorer.cc:165:    this[01;31m-[00m>_Builder[01;31m-[00m>firstSequence();
builderScorer.cc:166:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:167:    this[01;31m-[00m>_Scorer[01;31m-[00m>oligomerChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:168:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:173:    return this[01;31m-[00m>_Builder[01;31m-[00m>getCurrentOligomer();
builderScorer.cc:179:    return this[01;31m-[00m>_Builder[01;31m-[00m>numberOfOligomers();
builderScorer.cc:184:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:185:    return this[01;31m-[00m>_Builder[01;31m-[00m>getSequenceAsString();
builderScorer.cc:189:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:190:    this[01;31m-[00m>_Builder[01;31m-[00m>setupCurrentOligomerAndSequence();
builderScorer.cc:191:    LOG(BF("STATE>> current change counters: %s")% this[01;31m-[00m>_Builder[01;31m-[00m>changeCountersAsString() );
builderScorer.cc:192:    this[01;31m-[00m>_Scorer[01;31m-[00m>oligomerChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:193:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:198:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:199:    this[01;31m-[00m>_Builder[01;31m-[00m>firstSequence();
builderScorer.cc:200:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:201:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:206:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:207:    bool b = this[01;31m-[00m>_Builder[01;31m-[00m>incrementSequence();
builderScorer.cc:208:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return b;
builderScorer.cc:209:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:214:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:215:    this[01;31m-[00m>_Builder[01;31m-[00m>gotoSequence(index);
builderScorer.cc:216:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:217:    this[01;31m-[00m>_Scorer[01;31m-[00m>sequenceChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:223:    return this[01;31m-[00m>_Builder[01;31m-[00m>numberOfSequencesTotal();
builderScorer.cc:227:    return this[01;31m-[00m>_Builder[01;31m-[00m>numberOfSequencesInCurrentOligomer();
builderScorer.cc:232:    return this[01;31m-[00m>_Builder[01;31m-[00m>numberOfSequencesAsUInt();
builderScorer.cc:236:    return this[01;31m-[00m>_Builder[01;31m-[00m>numberOfNecessaryConformationsInCurrentSequenceAsUInt();
builderScorer.cc:240:    return this[01;31m-[00m>_Builder[01;31m-[00m>currentSequenceIndex();
builderScorer.cc:248:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:249:    this[01;31m-[00m>_Builder[01;31m-[00m>firstConformation();
builderScorer.cc:253:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:254:    this[01;31m-[00m>_Builder[01;31m-[00m>gotoConformation(index);
builderScorer.cc:258:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:259:    this[01;31m-[00m>_Builder[01;31m-[00m>gotoConformationUInt(index);
builderScorer.cc:264:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:265:    return this[01;31m-[00m>_Builder[01;31m-[00m>incrementConformation();
builderScorer.cc:269:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:270:    this[01;31m-[00m>_Builder[01;31m-[00m>randomizeConformation();
builderScorer.cc:275:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:276:    return this[01;31m-[00m>_Builder[01;31m-[00m>advanceConformation(useRandomConformations);
builderScorer.cc:281:    return this[01;31m-[00m>_Builder[01;31m-[00m>numberOfNecessaryConformationsInCurrentSequence();
builderScorer.cc:286:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:287:    this[01;31m-[00m>_Builder[01;31m-[00m>buildAllUntransformedAtomPositions();
builderScorer.cc:293://{_F(this[01;31m-[00m>lisp());
builderScorer.cc:294://    this[01;31m-[00m>_Builder[01;31m-[00m>buildAllUntransformedAtomPositions();
builderScorer.cc:295://    this[01;31m-[00m>_Builder[01;31m-[00m>calculateScoreTransformedAtomPositions();
builderScorer.cc:300://{_F(this[01;31m-[00m>lisp());
builderScorer.cc:301://    this[01;31m-[00m>_Builder[01;31m-[00m>buildAllUntransformedAtomPositions();
builderScorer.cc:302://    this[01;31m-[00m>_Builder[01;31m-[00m>calculateScoreTransformedAtomPositions();
builderScorer.cc:308:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:309:    {_BLOCK_TRACEF(BF("About to evaluate scorer for %s") % this[01;31m-[00m>_Builder[01;31m-[00m>changeCountersAsString() );
builderScorer.cc:312:	this[01;31m-[00m>_Builder[01;31m-[00m>streamDump(sout);
builderScorer.cc:315:	this[01;31m-[00m>_Scorer[01;31m-[00m>evaluate(this[01;31m-[00m>_Builder,ss);
builderScorer.cc:317:	this[01;31m-[00m>_Builder[01;31m-[00m>throwIfScorerStateOutOfSync(ss);
builderScorer.cc:319:	LOG(BF("Evaluated score = %lf")% ss[01;31m-[00m>getScore() );
builderScorer.cc:324:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:325:    {_BLOCK_TRACEF(BF("About to evaluate scorer for %s")% this[01;31m-[00m>_Builder[01;31m-[00m>changeCountersAsString() );
builderScorer.cc:328:	this[01;31m-[00m>_Builder[01;31m-[00m>streamDump(sout);
builderScorer.cc:331:	this[01;31m-[00m>_Scorer[01;31m-[00m>evaluateWithoutSuperposing(this[01;31m-[00m>_Builder,ss);
builderScorer.cc:332:	LOG(BF("Evaluated score = %lf")% ss[01;31m-[00m>getScore() );
builderScorer.cc:337:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:338:    this[01;31m-[00m>_Builder[01;31m-[00m>buildNecessaryUntransformedAtomPositions();
builderScorer.cc:339:    this[01;31m-[00m>evaluateScorer(ss);
builderScorer.cc:343:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:344:    ASSERT(this[01;31m-[00m>_Scorer[01;31m-[00m>notNil());
builderScorer.cc:345:    return this[01;31m-[00m>_Scorer[01;31m-[00m>createState();
builderScorer.cc:352:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:353:    ASSERT(this[01;31m-[00m>_Scorer[01;31m-[00m>notNil());
builderScorer.cc:354:    return this[01;31m-[00m>_Scorer[01;31m-[00m>getRenderForScore(this[01;31m-[00m>_Builder, scorerState);
builderScorer.cc:360:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:361:    ASSERT_NOT_NULL(this[01;31m-[00m>_Builder);
builderScorer.cc:362:    ASSERT(this[01;31m-[00m>_Builder[01;31m-[00m>notNil());
builderScorer.cc:363:    bs[01;31m-[00m>defineForBuilder(this[01;31m-[00m>_Builder);
builderScorer.cc:367:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:368:    bs[01;31m-[00m>applyConformationToBuilder(this[01;31m-[00m>_Builder);
builderScorer.cc:372://    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:373://    this[01;31m-[00m>_Scorer[01;31m-[00m>builderChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:378:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:379:    bs[01;31m-[00m>applyToBuilder(this[01;31m-[00m>_Builder);
builderScorer.cc:380:    if ( this[01;31m-[00m>_Scorer[01;31m-[00m>isNil() ) return;
builderScorer.cc:381:    this[01;31m-[00m>_Scorer[01;31m-[00m>builderChanged(this[01;31m-[00m>_Builder);
builderScorer.cc:385:    this[01;31m-[00m>_Builder[01;31m-[00m>streamDump(sstate);
builderScorer.cc:391:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:392:    this[01;31m-[00m>_Builder[01;31m-[00m>writeScoreTransformedCoordinatesToBuiltMolecule(ss);
builderScorer.cc:396:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:397:    this[01;31m-[00m>_Builder[01;31m-[00m>readCoordinatesFromBuiltMolecule();
builderScorer.cc:406:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:407:    return this[01;31m-[00m>_Builder[01;31m-[00m>getBuiltMolecule();
builderScorer.cc:411:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:412:    RPBuilder builder = this[01;31m-[00m>_Builder;
builderScorer.cc:413:    builder[01;31m-[00m>buildAllUntransformedAtomPositions();
builderScorer.cc:414:    builder[01;31m-[00m>writeScoreTransformedCoordinatesToBuiltMolecule(scorerState);
builderScorer.cc:415:    RPMolecule mol = builder[01;31m-[00m>getBuiltMolecule();
builderScorer.cc:420:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:421:    ASSERT_NOT_NULL(this[01;31m-[00m>_Scorer);
builderScorer.cc:422:    ASSERT(this[01;31m-[00m>_Scorer[01;31m-[00m>notNil());
builderScorer.cc:423:    return this[01;31m-[00m>_Scorer;
builderScorer.cc:427:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:428:    ASSERT_NOT_NULL(this[01;31m-[00m>_Scorer);
builderScorer.cc:429:    ASSERT(this[01;31m-[00m>_Scorer[01;31m-[00m>notNil());
builderScorer.cc:430:    return this[01;31m-[00m>_Scorer[01;31m-[00m>getBackgroundRender();
builderScorer.cc:435:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:436:    RPOligomerBuilder ob = this[01;31m-[00m>_Builder[01;31m-[00m>getOligomerBuilder();
builderScorer.cc:443:    this[01;31m-[00m>_Builder[01;31m-[00m>fileDump(fileName);
builderScorer.cc:449:    this[01;31m-[00m>_Builder[01;31m-[00m>streamDump(ss);
builderScorer.cc:456:    this[01;31m-[00m>_Builder[01;31m-[00m>streamDump(o);
builderScorer.cc:461:    this[01;31m-[00m>_Builder[01;31m-[00m>interestingAtomDump(ss);
builderScorer.cc:467:    this[01;31m-[00m>_Builder[01;31m-[00m>throwIfScorerStateOutOfSync(state);
builderScorer.cc:472:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:473:    RPMolecule builtMolecule = this[01;31m-[00m>_Builder[01;31m-[00m>getBuiltMolecule();
builderScorer.cc:474:    this[01;31m-[00m>_Builder[01;31m-[00m>writeScoreTransformedCoordinatesToBuiltMolecule(ss);
builderScorer.cc:475:    RPAggregate agg = O_Aggregate::create(this[01;31m-[00m>lisp());
builderScorer.cc:476:    agg[01;31m-[00m>addMolecule(builtMolecule);
builderScorer.cc:477:    RPEnergyFunction energy = O_EnergyFunction::create(this[01;31m-[00m>lisp());
builderScorer.cc:478:    energy[01;31m-[00m>defineForMatter(agg,forceField);
builderScorer.cc:482:    RPCons restraintList = this[01;31m-[00m>_Scorer[01;31m-[00m>createRestraints(this[01;31m-[00m>_Builder);
builderScorer.cc:483:    energy[01;31m-[00m>addTermsForListOfRestraints(forceField, restraintList);
builderScorer.cc:491:    ASSERT_NOT_NULL(this[01;31m-[00m>_Builder);
builderScorer.cc:492:    ASSERT(this[01;31m-[00m>_Builder[01;31m-[00m>notNil());
builderScorer.cc:493:    return this[01;31m-[00m>_Builder[01;31m-[00m>extractConformation();
builderScorer.cc:498:    ASSERT_NOT_NULL(this[01;31m-[00m>_Builder);
builderScorer.cc:499:    ASSERT(this[01;31m-[00m>_Builder[01;31m-[00m>notNil());
builderScorer.cc:500:    return this[01;31m-[00m>_Builder[01;31m-[00m>applyConformation(conf);
builderScorer.cc:511:{_F(this[01;31m-[00m>lisp());
builderScorer.cc:512:    if ( args[01;31m-[00m>length()!=2) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide an builder and a hitList"));
builderScorer.cc:513:    RPBuilder builder = args[01;31m-[00m>listref<O_Builder>(0);
builderScorer.cc:514:    RPHitList hitList = args[01;31m-[00m>listref<O_HitList>(1);
builderScorer.cc:515:    builder[01;31m-[00m>firstOligomer();
builderScorer.cc:517:    scorer[01;31m-[00m>oligomerChanged(builder);
builderScorer.cc:518:    builder[01;31m-[00m>firstSequence();
builderScorer.cc:519:    scorer[01;31m-[00m>sequenceChanged(builder);
builderScorer.cc:520:    builder[01;31m-[00m>firstAllAtomConformations();
builderScorer.cc:521:    LongLongInt	totalNumberOfSequences = builder[01;31m-[00m>numberOfSequences();
builderScorer.cc:522:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("There are %lld TOTAL sequences to build") % totalNumberOfSequences);
builderScorer.cc:525:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Searching sequence#%6lld to %6lld") % sequenceIndexBegin% sequenceIndexEnd );
builderScorer.cc:530:        this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Searching sequence#%6lld end: %6lld") % sequenceIndex% sequenceIndexEnd );
builderScorer.cc:531:        builder[01;31m-[00m>gotoSequence(sequenceIndex);
builderScorer.cc:532:	scorer[01;31m-[00m>sequenceChanged(builder);
builderScorer.cc:533:	builder[01;31m-[00m>firstAllAtomConformations();
builderScorer.cc:534:	builder[01;31m-[00m>buildInterestingUntransformedAtomPositions();
builderScorer.cc:535:        RPBuilderState builderState = O_BuilderState::create(this[01;31m-[00m>lisp());
builderScorer.cc:536:	builderState[01;31m-[00m>defineForBuilder(builder);
builderScorer.cc:538:	RPHit hit = hitList[01;31m-[00m>createHitWithStates(builderScorer,builderState,O_ScorerState::nil(this[01;31m-[00m>lisp()));
builderScorer.cc:540:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("\nBuilt %lld TOTAL structures\n") % totalNumberOfSequences );
builderScorer.cc:541:    return O_Object::nil(this[01;31m-[00m>lisp());
builderScorer.cc:551:	class_<O_BuilderScorer>(this[01;31m-[00m>lisp())
builderState.cc:26:    node[01;31m-[00m>attribute("monIdx",this[01;31m-[00m>_CurrentMonomerIndex);
builderState.cc:31:    return this[01;31m-[00m>_CurrentMonomerIndex == other._CurrentMonomerIndex;
builderState.cc:38://    node[01;31m-[00m>attribute("scaffoldConf",this[01;31m-[00m>_ScaffoldListIndex);
builderState.cc:39:    node[01;31m-[00m>attributeIfNotDefault("nextSpan",this[01;31m-[00m>_NextSpanIdx,UndefinedUnsignedInt);
builderState.cc:40:    node[01;31m-[00m>attributeIfNotDefault("backSpan",this[01;31m-[00m>_BackSpanIdx,UndefinedUnsignedInt);
builderState.cc:45:    if ( this[01;31m-[00m>_NextSpanIdx != other._NextSpanIdx ) return false;
builderState.cc:46:    if ( this[01;31m-[00m>_BackSpanIdx != other._BackSpanIdx ) return false;
builderState.cc:54:    node[01;31m-[00m>attribute("fragConf",this[01;31m-[00m>_FragmentConformationIndex);
builderState.cc:55:    node[01;31m-[00m>attribute("useScaffConf",this[01;31m-[00m>_UseScaffoldConformation);
builderState.cc:56:    node[01;31m-[00m>attributeIfNotDefault("mask",this[01;31m-[00m>_ManipulateMask,0);
builderState.cc:64:    if ( this[01;31m-[00m>_FragmentConformationIndex != other._FragmentConformationIndex ) return false;
builderState.cc:65:    if ( this[01;31m-[00m>_UseScaffoldConformation != other._UseScaffoldConformation ) return false;
builderState.cc:66:    if ( this[01;31m-[00m>_ManipulateMask != other._ManipulateMask ) return false;
builderState.cc:81://    this[01;31m-[00m>_Builder = orig._Builder;
builderState.cc:82:    this[01;31m-[00m>_Comment = orig._Comment;
builderState.cc:83:    this[01;31m-[00m>_BuildAllAtoms = orig._BuildAllAtoms;
builderState.cc:84:    this[01;31m-[00m>_CurrentOligomerIndex = orig._CurrentOligomerIndex;
builderState.cc:85:    this[01;31m-[00m>_MonomerStates = orig._MonomerStates;
builderState.cc:86:    this[01;31m-[00m>_ScaffoldStates = orig._ScaffoldStates;
builderState.cc:87:    this[01;31m-[00m>_FragmentStates = orig._FragmentStates;
builderState.cc:88:    this[01;31m-[00m>_SavedProcessRank = orig._SavedProcessRank;
builderState.cc:89:    this[01;31m-[00m>_SavedOligomerChangeCounter = orig._SavedOligomerChangeCounter;
builderState.cc:90:    this[01;31m-[00m>_SavedSequenceChangeCounter = orig._SavedSequenceChangeCounter;
builderState.cc:91:    this[01;31m-[00m>_SavedConformationChangeCounter = orig._SavedConformationChangeCounter;
builderState.cc:93:    this[01;31m-[00m>_StateDescription = orig._StateDescription;
builderState.cc:101:    this[01;31m-[00m>Base::initialize();
builderState.cc:102://    this[01;31m-[00m>_Builder = O_Builder::nil(this[01;31m-[00m>lisp());
builderState.cc:103:    this[01;31m-[00m>_BuildAllAtoms = false;
builderState.cc:104:    this[01;31m-[00m>_Comment = "";
builderState.cc:105://    this[01;31m-[00m>_ScorerState = O_ScorerState::nil(this[01;31m-[00m>lisp());
builderState.cc:115:{_F(this[01;31m-[00m>lisp());
builderState.cc:122://    node[01;31m-[00m>archiveObject("builder",this[01;31m-[00m>_Builder);
builderState.cc:123://    node[01;31m-[00m>archiveObject("scorerState",this[01;31m-[00m>_ScorerState);
builderState.cc:124:    node[01;31m-[00m>attribute( "buildAllAtoms", this[01;31m-[00m>_BuildAllAtoms );
builderState.cc:125:    node[01;31m-[00m>attributeIfNotDefault<string>( "comment", this[01;31m-[00m>_Comment, "" );
builderState.cc:126:    node[01;31m-[00m>attributeIfNotDefault<uint>( "SavedProcessRank", this[01;31m-[00m>_SavedProcessRank,0 );
builderState.cc:127:    node[01;31m-[00m>attribute( "SavedOligomerChangeCounter", this[01;31m-[00m>_SavedOligomerChangeCounter );
builderState.cc:128:    node[01;31m-[00m>attribute( "SavedSequenceChangeCounter", this[01;31m-[00m>_SavedSequenceChangeCounter );
builderState.cc:129:    node[01;31m-[00m>attribute( "SavedConformationChangeCounter", this[01;31m-[00m>_SavedConformationChangeCounter );
builderState.cc:130:    node[01;31m-[00m>attribute("currentOligomerIndex",this[01;31m-[00m>_CurrentOligomerIndex);
builderState.cc:131:    node[01;31m-[00m>archiveVectorPlainObjects<MonomerState>("monomerStates",this[01;31m-[00m>_MonomerStates );
builderState.cc:132:    node[01;31m-[00m>archiveVectorPlainObjects("scaffoldStates",this[01;31m-[00m>_ScaffoldStates);
builderState.cc:133:    node[01;31m-[00m>archiveVectorPlainObjects("fragmentStates",this[01;31m-[00m>_FragmentStates);
builderState.cc:135:    node[01;31m-[00m>archiveStringIfNotDefault("stateDescription",this[01;31m-[00m>_StateDescription,"");
builderState.cc:142:    if ( this[01;31m-[00m>_CurrentOligomerIndex != other._CurrentOligomerIndex ) return false;
builderState.cc:143:    if ( this[01;31m-[00m>_BuildAllAtoms != other._BuildAllAtoms ) return false;
builderState.cc:145:	if ( this[01;31m-[00m>_MonomerStates.size() != other._MonomerStates.size() ) return false;
builderState.cc:146:	vector<MonomerState>::const_iterator mmi = this[01;31m-[00m>_MonomerStates.begin();
builderState.cc:148:	for ( ; mmi!=this[01;31m-[00m>_MonomerStates.end(); mmi++, omi++ )
builderState.cc:154:	if ( this[01;31m-[00m>_ScaffoldStates.size() != other._ScaffoldStates.size() ) return false;
builderState.cc:155:	vector<ScaffoldState>::const_iterator mmi = this[01;31m-[00m>_ScaffoldStates.begin();
builderState.cc:157:	for ( ; mmi!=this[01;31m-[00m>_ScaffoldStates.end(); mmi++, omi++ )
builderState.cc:163:	if ( this[01;31m-[00m>_FragmentStates.size() != other._FragmentStates.size() ) return false;
builderState.cc:164:	vector<FragmentState>::const_iterator mmi = this[01;31m-[00m>_FragmentStates.begin();
builderState.cc:166:	for ( ; mmi!=this[01;31m-[00m>_FragmentStates.end(); mmi++, omi++ )
builderState.cc:181:    if ( this[01;31m-[00m>_BuildAllAtoms != other._BuildAllAtoms ) return false;
builderState.cc:183:	if ( this[01;31m-[00m>_MonomerStates.size() != other._MonomerStates.size() ) return false;
builderState.cc:184:	vector<MonomerState>::const_iterator mmi = this[01;31m-[00m>_MonomerStates.begin();
builderState.cc:186:	for ( ; mmi!=this[01;31m-[00m>_MonomerStates.end(); mmi++, omi++ )
builderState.cc:198:    return this[01;31m-[00m>_StateDescription;
builderState.cc:204:{_F(this[01;31m-[00m>lisp());
builderState.cc:210:    LOG(BF("Save BuilderState with %s")% builder[01;31m-[00m>changeCountersAsString() );
builderState.cc:213:    builder[01;31m-[00m>streamDump(sstate);
builderState.cc:214:    this[01;31m-[00m>_StateDescription = sstate.str();
builderState.cc:216:    LOG(BF("Builder conformation=%s") % (builder[01;31m-[00m>describeConformation().c_str()) ); // vp0(("Builder conformation=%s",builder[01;31m-[00m>describeConformation().c_str()));
builderState.cc:217://    this[01;31m-[00m>_Builder = builder;
builderState.cc:218:    this[01;31m-[00m>_BuildAllAtoms = builder[01;31m-[00m>buildsAllAtoms();
builderState.cc:219:    LOG(BF("defineForBuilder@%X _BuildAllAtoms = %d") % this % this[01;31m-[00m>_BuildAllAtoms  ); // vp0(("defineForBuilder@%X _BuildAllAtoms = %d",this, this[01;31m-[00m>_BuildAllAtoms ));
builderState.cc:220:    this[01;31m-[00m>_CurrentOligomerIndex = builder[01;31m-[00m>getCurrentOligomerIndex();
builderState.cc:221:    olig = builder[01;31m-[00m>getCurrentOligomer();
builderState.cc:222:    if ( this[01;31m-[00m>_MonomerStates.size() != olig[01;31m-[00m>numberOfMonomers() )
builderState.cc:224:        this[01;31m-[00m>_MonomerStates.resize(olig[01;31m-[00m>numberOfMonomers(),MonomerState(_lisp));
builderState.cc:227:    for ( ii=0,mi=olig[01;31m-[00m>begin_Monomers(); mi!=olig[01;31m-[00m>end_Monomers(); ii++,mi++ )
builderState.cc:229:	this[01;31m-[00m>_MonomerStates[ii]._CurrentMonomerIndex=(*mi)[01;31m-[00m>getMonomerIndex();
builderState.cc:230:	LOG(BF("Saving monomer#%d state %d") % (mi[01;31m-[00molig[01;31m-[00m>begin_Monomers()) % (this[01;31m-[00m>_MonomerStates[ii]._CurrentMonomerIndex)  );
builderState.cc:234:    oligomerBuilder = builder[01;31m-[00m>_OligomerBuilder;
builderState.cc:235:    if ( this[01;31m-[00m>_ScaffoldStates.size() != oligomerBuilder[01;31m-[00m>_Scaffolds.size() )
builderState.cc:237:        this[01;31m-[00m>_ScaffoldStates.resize(oligomerBuilder[01;31m-[00m>_Scaffolds.size(),ScaffoldState(_lisp) );
builderState.cc:239:    for ( ii=0,si=oligomerBuilder[01;31m-[00m>_Scaffolds.begin();
builderState.cc:240:    		si!=oligomerBuilder[01;31m-[00m>_Scaffolds.end(); ii++,si++ )
builderState.cc:242://	scaffoldState._ScaffoldListIndex = si[01;31m-[00m>_removeScaffoldListIndex;
builderState.cc:243:	this[01;31m-[00m>_ScaffoldStates[ii]._NextSpanIdx = si[01;31m-[00m>_NextSpanIdx;
builderState.cc:244:	this[01;31m-[00m>_ScaffoldStates[ii]._BackSpanIdx = si[01;31m-[00m>_BackSpanIdx;
builderState.cc:246:	LOG(BF("Saving scaffold#%d state _NextSpan: %d") % (si[01;31m-[00moligomerBuilder[01;31m-[00m>_Scaffolds.begin()) % si[01;31m-[00m>_NextSpan  ); // vp0(("Saving scaffold#%d state _NextSpan: %d", si[01;31m-[00moligomerBuilder[01;31m-[00m>_Scaffolds.begin(),si[01;31m-[00m>_NextSpan ));
builderState.cc:247:	LOG(BF("Saving scaffold#%d state _BackSpan: %d") % (si[01;31m-[00moligomerBuilder[01;31m-[00m>_Scaffolds.begin()) % si[01;31m-[00m>_BackSpan  ); // vp0(("Saving scaffold#%d state _BackSpan: %d", si[01;31m-[00moligomerBuilder[01;31m-[00m>_Scaffolds.begin(),si[01;31m-[00m>_BackSpan ));
builderState.cc:252:    if ( this[01;31m-[00m>_FragmentStates.size() != oligomerBuilder[01;31m-[00m>_AllFragmentHolders.size() )
builderState.cc:254:        this[01;31m-[00m>_FragmentStates.resize(oligomerBuilder[01;31m-[00m>_AllFragmentHolders.size(),FragmentState(_lisp));
builderState.cc:256:    for ( ii=0,fi=oligomerBuilder[01;31m-[00m>_AllFragmentHolders.begin();
builderState.cc:257:   		 fi!=oligomerBuilder[01;31m-[00m>_AllFragmentHolders.end(); ii++,fi++ )
builderState.cc:259:	this[01;31m-[00m>_FragmentStates[ii]._FragmentConformationIndex = fi[01;31m-[00m>_localFragmentConformationIndex;
builderState.cc:260:	this[01;31m-[00m>_FragmentStates[ii]._UseScaffoldConformation = fi[01;31m-[00m>_LockToScaffoldConformation;
builderState.cc:261:	this[01;31m-[00m>_FragmentStates[ii]._ManipulateMask = fi[01;31m-[00m>_ManipulateMask;
builderState.cc:262:	LOG(BF("  Saving fragment#%d _FragmentConformationIndex = %d") % (fi[01;31m-[00moligomerBuilder[01;31m-[00m>_AllFragmentHolders.begin()) % this[01;31m-[00m>_FragmentStates[ii]._FragmentConformationIndex );
builderState.cc:263:       	LOG(BF("  Saving fragment#%d _LockToScaffoldConformation= %d") % (fi[01;31m-[00moligomerBuilder[01;31m-[00m>_AllFragmentHolders.begin()) % this[01;31m-[00m>_FragmentStates[ii]._UseScaffoldConformation );
builderState.cc:265:    this[01;31m-[00m>_SavedProcessRank = builder[01;31m-[00m>getProcessRank();
builderState.cc:266:    this[01;31m-[00m>_SavedOligomerChangeCounter = builder[01;31m-[00m>getOligomerChangeCounter();
builderState.cc:267:    this[01;31m-[00m>_SavedSequenceChangeCounter = builder[01;31m-[00m>getSequenceChangeCounter();
builderState.cc:268:    this[01;31m-[00m>_SavedConformationChangeCounter = builder[01;31m-[00m>getConformationChangeCounter();
builderState.cc:272:{_F(this[01;31m-[00m>lisp());
builderState.cc:273:    return O_Builder::changeCountersAsString(this[01;31m-[00m>_SavedProcessRank, this[01;31m-[00m>_SavedOligomerChangeCounter, this[01;31m-[00m>_SavedSequenceChangeCounter, this[01;31m-[00m>_SavedConformationChangeCounter ); // , this[01;31m-[00m>_ScoreTransformScorerIdentifier);
builderState.cc:280:    if ( this[01;31m-[00m>_SavedOligomerChangeCounter != builder[01;31m-[00m>getOligomerChangeCounter() ) return false;
builderState.cc:281:    if ( this[01;31m-[00m>_SavedSequenceChangeCounter != builder[01;31m-[00m>getSequenceChangeCounter() ) return false;
builderState.cc:282:    if ( this[01;31m-[00m>_SavedConformationChangeCounter != builder[01;31m-[00m>getConformationChangeCounter() ) return false;
builderState.cc:292:{_F(this[01;31m-[00m>lisp());
builderState.cc:298:    LOG(BF("STATE_CHANGE>> Restoring BuilderState for conformation only with %s")% this[01;31m-[00m>changeCountersAsString() );
builderState.cc:300:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_SavedOligomerChangeCounter,
builderState.cc:301:    		this[01;31m-[00m>sharedThis<O_BuilderState>());
builderState.cc:302:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SavedSequenceChangeCounter,
builderState.cc:303:    		this[01;31m-[00m>sharedThis<O_BuilderState>());
builderState.cc:305:    oligomerBuilder = builder[01;31m-[00m>_OligomerBuilder;
builderState.cc:307:    ASSERT(oligomerBuilder[01;31m-[00m>_Scaffolds.size()==this[01;31m-[00m>_ScaffoldStates.size());
builderState.cc:308:    for ( si=oligomerBuilder[01;31m-[00m>_Scaffolds.begin(), ssi=this[01;31m-[00m>_ScaffoldStates.begin();
builderState.cc:309:    		si!=oligomerBuilder[01;31m-[00m>_Scaffolds.end(); si++, ssi++ )
builderState.cc:311:	LOG(BF("ssi[01;31m-[00m>_NextSpanIdx = %u  ssi[01;31m-[00m>_BackSpanIdx = %u") % ssi[01;31m-[00m>_NextSpanIdx % ssi[01;31m-[00m>_BackSpanIdx  ); // vp0(("ssi[01;31m-[00m>_NextSpanIdx = %u  ssi[01;31m-[00m>_BackSpanIdx = %u", ssi[01;31m-[00m>_NextSpanIdx, ssi[01;31m-[00m>_BackSpanIdx ));
builderState.cc:312:	ASSERT_eq( si[01;31m-[00m>_NextSpanIdx, ssi[01;31m-[00m>_NextSpanIdx );
builderState.cc:313:	ASSERT_eq( si[01;31m-[00m>_BackSpanIdx, ssi[01;31m-[00m>_BackSpanIdx );
builderState.cc:317:    oligomerBuilder = builder[01;31m-[00m>_OligomerBuilder;
builderState.cc:318:    ASSERT(oligomerBuilder[01;31m-[00m>_AllFragmentHolders.size() == this[01;31m-[00m>_FragmentStates.size());
builderState.cc:319:    for ( fi=oligomerBuilder[01;31m-[00m>_AllFragmentHolders.begin(),
builderState.cc:320:    			fsi=this[01;31m-[00m>_FragmentStates.begin();
builderState.cc:321:    		fi!=oligomerBuilder[01;31m-[00m>_AllFragmentHolders.end(); fi++, fsi++ )
builderState.cc:323:	fi[01;31m-[00m>_localFragmentConformationIndex = fsi[01;31m-[00m>_FragmentConformationIndex;
builderState.cc:324:	fi[01;31m-[00m>_LockToScaffoldConformation = fsi[01;31m-[00m>_UseScaffoldConformation;
builderState.cc:325:	fi[01;31m-[00m>_ManipulateMask = fsi[01;31m-[00m>_ManipulateMask;
builderState.cc:326:	LOG(BF("Restore fragment#%d state _LockToScaffoldConformation: %d") % (fi[01;31m-[00moligomerBuilder[01;31m-[00m>_AllFragmentHolders.begin()) % fi[01;31m-[00m>_LockToScaffoldConformation );
builderState.cc:328:    LOG(BF("applyToBuilder@%X _BuildAllAtoms = %d") % this % this[01;31m-[00m>_BuildAllAtoms  );
builderState.cc:329:    builder[01;31m-[00m>setBuildAllAtoms(this[01;31m-[00m>_BuildAllAtoms);
builderState.cc:330:    builder[01;31m-[00m>setConformationChangeCounter(this[01;31m-[00m>_SavedConformationChangeCounter);
builderState.cc:331:    builder[01;31m-[00m>buildNecessaryUntransformedAtomPositions();
builderState.cc:341:{_F(this[01;31m-[00m>lisp());
builderState.cc:346:    LOG(BF("STATE_CHANGE>> Restoring entire BuilderState with %s")% this[01;31m-[00m>changeCountersAsString() );
builderState.cc:347:    builder[01;31m-[00m>setProcessRank(this[01;31m-[00m>_SavedProcessRank);
builderState.cc:350:        builder[01;31m-[00m>gotoOligomerIndexDontBuild(this[01;31m-[00m>_CurrentOligomerIndex);
builderState.cc:351:        builder[01;31m-[00m>setOligomerChangeCounter(this[01;31m-[00m>_SavedOligomerChangeCounter);
builderState.cc:353:    olig = builder[01;31m-[00m>getCurrentOligomer();
builderState.cc:354:    ASSERT(olig[01;31m-[00m>_Monomers.size() == this[01;31m-[00m>_MonomerStates.size());
builderState.cc:355:    for ( mi=olig[01;31m-[00m>begin_Monomers(), msi=this[01;31m-[00m>_MonomerStates.begin();
builderState.cc:356:   		 mi!=olig[01;31m-[00m>end_Monomers(); mi++, msi++ )
builderState.cc:358:	(*mi)[01;31m-[00m>setMonomerIndex(msi[01;31m-[00m>_CurrentMonomerIndex);
builderState.cc:359:	LOG(BF("Restore monomer#%d state _MonomerIndex: %d") % (mi[01;31m-[00molig[01;31m-[00m>begin_Monomers()) % (*mi)[01;31m-[00m>getMonomerIndex() );
builderState.cc:361:    builder[01;31m-[00m>_buildOligomer();
builderState.cc:362:    builder[01;31m-[00m>setSequenceChangeCounter(this[01;31m-[00m>_SavedSequenceChangeCounter);
builderState.cc:363:    this[01;31m-[00m>applyConformationToBuilder(builder);
builderState.cc:374:    class_<O_BuilderState>(this[01;31m-[00m>lisp())
builtReference.cc:17:    this[01;31m-[00m>Base::initialize();
builtReference.cc:18:    this[01;31m-[00m>_OligomerChangeCounter = 1234;
builtReference.cc:19:    this[01;31m-[00m>_SequenceChangeCounter = 1234;
builtReference.cc:24:    node[01;31m-[00m>attribute("MonomerAlias",this[01;31m-[00m>_MonomerAlias);
builtReference.cc:25:    node[01;31m-[00m>attribute("AtomAlias",this[01;31m-[00m>_AtomAlias);
builtReference.cc:29:/*! \subpage script[01;31m-[00mfunctions
builtReference.cc:30: * alias 'monAlias 'atomAlias  [01;31m-[00m  Define an monomer/atom alias combo
builtReference.cc:34:    if ( args[01;31m-[00m>length()<2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide 2 args"));
builtReference.cc:35:    string monAlias = args[01;31m-[00m>listref<O_Text>(0)[01;31m-[00m>get();
builtReference.cc:36:    string atomAlias = args[01;31m-[00m>listref<O_Text>(1)[01;31m-[00m>get();
builtReference.cc:51:    this[01;31m-[00m>Base::oldLispInitialize(args,lisp);
builtReference.cc:52:    if ( args[01;31m-[00m>numberOfPositionalArguments()<2 ) 
builtReference.cc:53:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide 2 args: monomerAlias atomAlias"));
builtReference.cc:54:    this[01;31m-[00m>_MonomerAlias = args[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
builtReference.cc:55:    this[01;31m-[00m>_AtomAlias = args[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
builtReference.cc:61:    ss << "[Alias " << this[01;31m-[00m>_MonomerAlias << "@" << this[01;31m-[00m>_AtomAlias;
builtReference.cc:62:    ss << " monomerId("<<this[01;31m-[00m>_MonomerId<<") atomId("<<this[01;31m-[00m>_AtomId<<")";
builtReference.cc:69:{_F(this[01;31m-[00m>lisp());
builtReference.cc:70:    this[01;31m-[00m>_OligomerChangeCounter = builder[01;31m-[00m>getOligomerChangeCounter();
builtReference.cc:71:    this[01;31m-[00m>_MonomerId = builder[01;31m-[00m>getMonomerIdForUniqueAlias(this[01;31m-[00m>sharedThis<O_Alias>());
builtReference.cc:75:{_F(this[01;31m-[00m>lisp());
builtReference.cc:76:    if (!o[01;31m-[00m>isOfClass<O_Alias>()) return false;
builtReference.cc:77:    RPAlias a = o[01;31m-[00m>as<O_Alias>();
builtReference.cc:78:    if ( this[01;31m-[00m>_MonomerAlias != a[01;31m-[00m>_MonomerAlias ) return false;
builtReference.cc:79:    if ( this[01;31m-[00m>_AtomAlias != a[01;31m-[00m>_AtomAlias ) return false;
builtReference.cc:85:{_F(this[01;31m-[00m>lisp());
builtReference.cc:86:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_OligomerChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
builtReference.cc:87:    this[01;31m-[00m>_SequenceChangeCounter = builder[01;31m-[00m>getSequenceChangeCounter();
builtReference.cc:88:    this[01;31m-[00m>_AtomId = builder[01;31m-[00m>indexOfInterestingAtomWithAlias(this[01;31m-[00m>_MonomerId,this[01;31m-[00m>sharedThis<O_Alias>());
builtReference.cc:89:    LOG(BF("[Alias %s@%s] _MonomerId(%d) _AtomId(%d)") % this[01;31m-[00m>_MonomerAlias.c_str() % this[01;31m-[00m>_AtomAlias.c_str() % this[01;31m-[00m>_MonomerId % this[01;31m-[00m>_AtomId  ); // vp0(( "[Alias %s@%s] _MonomerId(%d) _AtomId(%d)", this[01;31m-[00m>_MonomerAlias.c_str(), this[01;31m-[00m>_AtomAlias.c_str(), this[01;31m-[00m>_MonomerId, this[01;31m-[00m>_AtomId ));
builtReference.cc:96:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_OligomerChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
builtReference.cc:97:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
builtReference.cc:99:    return builder[01;31m-[00m>getScoreTransformedInterestingAtomPosition(this[01;31m-[00m>_AtomId);
builtReference.cc:106:    builder[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(this[01;31m-[00m>_OligomerChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
builtReference.cc:107:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,this[01;31m-[00m>sharedThis<O_Alias>());
builtReference.cc:109:    return builder[01;31m-[00m>getScoreTransformedAtomPosition(this[01;31m-[00m>_AtomId,scorerState);
builtReference.cc:121:	class_<O_Alias>(this[01;31m-[00m>lisp())
builtReference.cc:123:	defNoWrapPackage(MbbPackage,"alias",&O_Alias::prim_alias,this[01;31m-[00m>lisp());	// Constructor
bundle.cc:17:{_F(this[01;31m-[00m>lisp());
bundle.cc:24:    this[01;31m-[00m>_Initialized = false;
bundle.cc:25:    this[01;31m-[00m>_WeakLisp = lisp;
bundle.cc:30:	if ( this[01;31m-[00m>_WeakLisp.use_count() == 0 )
bundle.cc:34:	return this[01;31m-[00m>_WeakLisp.lock();
bundle.cc:38:{_F(this[01;31m-[00m>lisp());
bundle.cc:41:    bf::path appDir = this[01;31m-[00m>findAppDir(argv0,cwd,envVar);
bundle.cc:57:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find the root directory of the cando application bundle.\n"
bundle.cc:61:    this[01;31m-[00m>_RootDir = curPath;
bundle.cc:62:    this[01;31m-[00m>findSubDirectories(curPath);
bundle.cc:63:    this[01;31m-[00m>_Initialized=true;
bundle.cc:68:// argv0 is wxTheApp[01;31m-[00m>argv[0]
bundle.cc:74:{_F(this[01;31m-[00m>lisp());
bundle.cc:125:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("PATH environment variable must be defined"));
bundle.cc:155:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not determine absolute path to executable: "+argv0+"\n"
bundle.cc:162:{_F(this[01;31m-[00m>lisp());
bundle.cc:169:    LOG(BF("Looking for sub[01;31m-[00mdirectories") ); // vp0(("Looking for sub[01;31m-[00mdirectories"));
bundle.cc:175:	LOG(BF("File name: %s") % dirs[01;31m-[00m>path().file_string().c_str()  ); // vp0(( "File name: %s", dirs[01;31m-[00m>path().file_string().c_str() ));
bundle.cc:176:	if ( is_directory(dirs[01;31m-[00m>path()) )
bundle.cc:179:	    LOG(BF("Looking at directory: %s") % dirs[01;31m-[00m>path().file_string().c_str()  ); // vp0(("Looking at directory: %s", dirs[01;31m-[00m>path().file_string().c_str() ));
bundle.cc:180:	    string leaf = dirs[01;31m-[00m>path().leaf();
bundle.cc:186:		this[01;31m-[00m>_AppDir = dirs[01;31m-[00m>path();
bundle.cc:190:		this[01;31m-[00m>_ResourcesDir = dirs[01;31m-[00m>path();
bundle.cc:194:		this[01;31m-[00m>_DatabasesDir = dirs[01;31m-[00m>path();
bundle.cc:198:	        this[01;31m-[00m>_ScriptsDir = dirs[01;31m-[00m>path();
bundle.cc:202:	        this[01;31m-[00m>_CandoScriptDir = dirs[01;31m-[00m>path();
bundle.cc:208:    LOG(BF("Sub directories =%s") % (this[01;31m-[00m>describe().c_str() ) ); // vp0(("Sub directories =%s", this[01;31m-[00m>describe().c_str() ));
bundle.cc:213:{_F(this[01;31m-[00m>lisp());
bundle.cc:215:    ss << "Root dir:        " << this[01;31m-[00m>_RootDir.file_string() << endl;
bundle.cc:216:    ss << "Application dir: " << this[01;31m-[00m>_AppDir.file_string() << endl;
bundle.cc:217:    ss << "Resources dir:   " << this[01;31m-[00m>_ResourcesDir.file_string() << endl;
bundle.cc:218:    ss << "Databases dir:   " << this[01;31m-[00m>_DatabasesDir.file_string() << endl;
bundle.cc:219:    ss << "Scripts dir:     " << this[01;31m-[00m>_ScriptsDir.file_string() << endl;
bundle.cc:220:    ss << "CandoScript dir: " << this[01;31m-[00m>_CandoScriptDir.file_string() << endl;
bundle.cc:226:    ASSERT(!this[01;31m-[00m>_RootDir.empty());
bundle.cc:227:    return this[01;31m-[00m>_RootDir;
bundle.cc:232:    ASSERT(!this[01;31m-[00m>_AppDir.empty());
bundle.cc:233:    return this[01;31m-[00m>_AppDir;
bundle.cc:238:    ASSERT(!this[01;31m-[00m>_ResourcesDir.empty());
bundle.cc:239:    return this[01;31m-[00m>_ResourcesDir;
bundle.cc:244:    ASSERT(!this[01;31m-[00m>_DatabasesDir.empty());
bundle.cc:245:    return this[01;31m-[00m>_DatabasesDir;
bundle.cc:250:    return this[01;31m-[00m>_ScriptsDir;
bundle.cc:255:    return this[01;31m-[00m>_CandoScriptDir;
calculatePosition.cc:19:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
calculatePosition.cc:26:    this[01;31m-[00m>Base::initialize();
calculatePosition.cc:38:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
calculatePosition.cc:39:    this[01;31m-[00m>_DistanceAtomName = kargs[01;31m-[00m>getStringAndRemoveOrDefault("distanceAtomName","");
calculatePosition.cc:40:    this[01;31m-[00m>_AngleAtomName = kargs[01;31m-[00m>getStringAndRemoveOrDefault("angleAtomName","");
calculatePosition.cc:41:    this[01;31m-[00m>_DihedralAtomName = kargs[01;31m-[00m>getStringAndRemoveOrDefault("dihedralAtomName","");
calculatePosition.cc:42:    this[01;31m-[00m>_Distance = kargs[01;31m-[00m>getDoubleAndRemove("distance");
calculatePosition.cc:43:    this[01;31m-[00m>_AngleDegrees = kargs[01;31m-[00m>getDoubleAndRemove("angleDegrees");
calculatePosition.cc:44:    this[01;31m-[00m>_DihedralDegrees = kargs[01;31m-[00m>getDoubleAndRemove("dihedralDegrees");
calculatePosition.cc:49:    this[01;31m-[00m>Base::initialize();
calculatePosition.cc:50:    this[01;31m-[00m>_DistanceAtomName = "";
calculatePosition.cc:51:    this[01;31m-[00m>_AngleAtomName = "";
calculatePosition.cc:52:    this[01;31m-[00m>_DihedralAtomName = "";
calculatePosition.cc:57:    this[01;31m-[00m>Base::archiveBase(node);
calculatePosition.cc:58:    node[01;31m-[00m>attribute("DistanceAtomName",this[01;31m-[00m>_DistanceAtomName);
calculatePosition.cc:59:    node[01;31m-[00m>attribute("AngleAtomName",this[01;31m-[00m>_AngleAtomName);
calculatePosition.cc:60:    node[01;31m-[00m>attribute("DihedralAtomName",this[01;31m-[00m>_DihedralAtomName);
calculatePosition.cc:61:    node[01;31m-[00m>attribute("Distance",this[01;31m-[00m>_Distance);
calculatePosition.cc:62:    node[01;31m-[00m>attribute("AngleDegrees",this[01;31m-[00m>_AngleDegrees);
calculatePosition.cc:63:    node[01;31m-[00m>attribute("DihedralDegrees",this[01;31m-[00m>_DihedralDegrees);
calculatePosition.cc:67:{_F(this[01;31m-[00m>lisp());
calculatePosition.cc:72:    if ( positionLookup[01;31m-[00m>isOfClass<O_IterateFragmentCoordinateEntries>() )
calculatePosition.cc:74:	RPIterateFragmentCoordinateEntries it = positionLookup[01;31m-[00m>as<O_IterateFragmentCoordinateEntries>();
calculatePosition.cc:75:	posDistanceAtom = it[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_DistanceAtomName);
calculatePosition.cc:76:	posAngleAtom = it[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_AngleAtomName);
calculatePosition.cc:77:	posDihedralAtom = it[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_DihedralAtomName);
calculatePosition.cc:78:    } else if ( positionLookup[01;31m-[00m>isOfClass<O_Residue>() )
calculatePosition.cc:80:	RPResidue res = positionLookup[01;31m-[00m>as<O_Residue>();
calculatePosition.cc:81:	posDistanceAtom = res[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_DistanceAtomName);
calculatePosition.cc:82:	posAngleAtom = res[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_AngleAtomName);
calculatePosition.cc:83:	posDihedralAtom = res[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_DihedralAtomName);
calculatePosition.cc:86:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unacceptable positionLookup class"));
calculatePosition.cc:89:    LOG(BF(" distance(%lf)  distancePoint(%s)") % this[01;31m-[00m>_Distance % posDistanceAtom.asString().c_str()  ); // vp0((" distance(%lf)  distancePoint(%s)", this[01;31m-[00m>_Distance, posDistanceAtom.asString().c_str() ));
calculatePosition.cc:90:    LOG(BF(" angleDegrees(%lf)  anglePoint(%s)") % this[01;31m-[00m>_AngleDegrees % posAngleAtom.asString().c_str()  ); // vp0((" angleDegrees(%lf)  anglePoint(%s)", this[01;31m-[00m>_AngleDegrees, posAngleAtom.asString().c_str() ));
calculatePosition.cc:91:    LOG(BF(" dihedralDegrees(%lf)  dihedralPoint(%s)") % this[01;31m-[00m>_DihedralDegrees % posDihedralAtom.asString().c_str()  ); // vp0((" dihedralDegrees(%lf)  dihedralPoint(%s)", this[01;31m-[00m>_DihedralDegrees, posDihedralAtom.asString().c_str() ));
calculatePosition.cc:92:    pnt = buildUsingBondAngleDihedral(this[01;31m-[00m>_Distance,posDistanceAtom,
calculatePosition.cc:93:			this[01;31m-[00m>_AngleDegrees*0.0174533,posAngleAtom,
calculatePosition.cc:94:				      this[01;31m-[00m>_DihedralDegrees*0.0174533,posDihedralAtom,_lisp);
calculatePosition.cc:103:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
calculatePosition.cc:104:    this[01;31m-[00m>_FromAtomName = kargs[01;31m-[00m>getStringAndRemoveOrDefault("fromAtomName","");
calculatePosition.cc:105:    this[01;31m-[00m>_ToAtomName = kargs[01;31m-[00m>getStringAndRemoveOrDefault("toAtomName","");
calculatePosition.cc:106:    this[01;31m-[00m>_ExtendDistance = kargs[01;31m-[00m>getDoubleAndRemove("extendDistance");
calculatePosition.cc:111:    this[01;31m-[00m>Base::initialize();
calculatePosition.cc:112:    this[01;31m-[00m>_FromAtomName = "";
calculatePosition.cc:113:    this[01;31m-[00m>_ToAtomName = "";
calculatePosition.cc:114:    this[01;31m-[00m>_ExtendDistance = 0.0;
calculatePosition.cc:119:    this[01;31m-[00m>Base::archiveBase(node);
calculatePosition.cc:120:    node[01;31m-[00m>attribute("FromAtomName",this[01;31m-[00m>_FromAtomName);
calculatePosition.cc:121:    node[01;31m-[00m>attribute("ToAtomName",this[01;31m-[00m>_ToAtomName);
calculatePosition.cc:122:    node[01;31m-[00m>attribute("ExtendDistance",this[01;31m-[00m>_ExtendDistance);
calculatePosition.cc:129:{_F(this[01;31m-[00m>lisp());
calculatePosition.cc:134:    if ( positionLookup[01;31m-[00m>isOfClass<O_IterateFragmentCoordinateEntries>() )
calculatePosition.cc:136:	RPIterateFragmentCoordinateEntries it = positionLookup[01;31m-[00m>as<O_IterateFragmentCoordinateEntries>();
calculatePosition.cc:137:	posFromAtom = it[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_FromAtomName);
calculatePosition.cc:138:	posToAtom = it[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_ToAtomName);
calculatePosition.cc:139:	LOG(BF("Got atom positions from IterateFragmentCoordinateEntries with names (%s)[01;31m-[00m(%s)") % this[01;31m-[00m>_FromAtomName.c_str() % this[01;31m-[00m>_ToAtomName.c_str()  ); // vp0(("Got atom positions from IterateFragmentCoordinateEntries with names (%s)[01;31m-[00m(%s)", this[01;31m-[00m>_FromAtomName.c_str(), this[01;31m-[00m>_ToAtomName.c_str() ));
calculatePosition.cc:140:    } else if ( positionLookup[01;31m-[00m>isOfClass<O_Residue>() )
calculatePosition.cc:142:	RPResidue res = positionLookup[01;31m-[00m>as<O_Residue>();
calculatePosition.cc:143:	posFromAtom = res[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_FromAtomName);
calculatePosition.cc:144:	posToAtom = res[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_ToAtomName);
calculatePosition.cc:145:	LOG(BF("Got atom positions from Residue with names (%s)[01;31m-[00m(%s)") % this[01;31m-[00m>_FromAtomName.c_str() % this[01;31m-[00m>_ToAtomName.c_str()  ); // vp0(("Got atom positions from Residue with names (%s)[01;31m-[00m(%s)", this[01;31m-[00m>_FromAtomName.c_str(), this[01;31m-[00m>_ToAtomName.c_str() ));
calculatePosition.cc:148:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unacceptable positionLookup class"));
calculatePosition.cc:151:    LOG(BF(" fromAtom(%s)   [01;31m-[00m  toAtom(%s)") % posFromAtom.asString().c_str() % posToAtom.asString().c_str()  ); // vp0((" fromAtom(%s)   [01;31m-[00m  toAtom(%s)", posFromAtom.asString().c_str(), posToAtom.asString().c_str() ));
calculatePosition.cc:152:    LOG(BF(" extendDistance(%lf) ") % this[01;31m-[00m>_ExtendDistance  ); // vp0((" extendDistance(%lf) ", this[01;31m-[00m>_ExtendDistance ));
calculatePosition.cc:161:    pnt = posToAtom.add(dir.multiplyByScalar(this[01;31m-[00m>_ExtendDistance));
calculatePosition.cc:169:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
calculatePosition.cc:170:    this[01;31m-[00m>_OriginAtomName = kargs[01;31m-[00m>getStringAndRemoveOrDefault("originAtomName","");
calculatePosition.cc:171:    this[01;31m-[00m>_ToAtomName = kargs[01;31m-[00m>getStringAndRemoveOrDefault("toAtomName","");
calculatePosition.cc:172:    this[01;31m-[00m>_ExtendDistance = kargs[01;31m-[00m>getDoubleAndRemove("extendDistance");
calculatePosition.cc:177:    this[01;31m-[00m>Base::initialize();
calculatePosition.cc:178:    this[01;31m-[00m>_OriginAtomName = "";
calculatePosition.cc:179:    this[01;31m-[00m>_ToAtomName = "";
calculatePosition.cc:180:    this[01;31m-[00m>_ExtendDistance = 0.0;
calculatePosition.cc:185:    this[01;31m-[00m>Base::archiveBase(node);
calculatePosition.cc:186:    node[01;31m-[00m>attribute("OriginAtomName",this[01;31m-[00m>_OriginAtomName);
calculatePosition.cc:187:    node[01;31m-[00m>attribute("ToAtomName",this[01;31m-[00m>_ToAtomName);
calculatePosition.cc:188:    node[01;31m-[00m>attribute("ExtendDistance",this[01;31m-[00m>_ExtendDistance);
calculatePosition.cc:200:{_F(this[01;31m-[00m>lisp());
calculatePosition.cc:205:    if ( positionLookup[01;31m-[00m>isOfClass<O_IterateFragmentCoordinateEntries>() )
calculatePosition.cc:207:	RPIterateFragmentCoordinateEntries it = positionLookup[01;31m-[00m>as<O_IterateFragmentCoordinateEntries>();
calculatePosition.cc:209:	posToAtom = it[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_ToAtomName);
calculatePosition.cc:210:	LOG(BF("Got atom positions from IterateFragmentCoordinateEntries with names (%s)[01;31m-[00m(%s)") % this[01;31m-[00m>_OriginAtomName.c_str() % this[01;31m-[00m>_ToAtomName.c_str()  ); // vp0(("Got atom positions from IterateFragmentCoordinateEntries with names (%s)[01;31m-[00m(%s)", this[01;31m-[00m>_OriginAtomName.c_str(), this[01;31m-[00m>_ToAtomName.c_str() ));
calculatePosition.cc:211:    } else if ( positionLookup[01;31m-[00m>isOfClass<O_Residue>() )
calculatePosition.cc:213:	RPResidue res = positionLookup[01;31m-[00m>as<O_Residue>();
calculatePosition.cc:214:	posOriginAtom = res[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_OriginAtomName);
calculatePosition.cc:215:	posToAtom = res[01;31m-[00m>positionOfAtomWithName(this[01;31m-[00m>_ToAtomName);
calculatePosition.cc:216:	LOG(BF("Got atom positions from Residue with names (%s)[01;31m-[00m(%s)") % this[01;31m-[00m>_OriginAtomName.c_str() % this[01;31m-[00m>_ToAtomName.c_str()  ); // vp0(("Got atom positions from Residue with names (%s)[01;31m-[00m(%s)", this[01;31m-[00m>_OriginAtomName.c_str(), this[01;31m-[00m>_ToAtomName.c_str() ));
calculatePosition.cc:219:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unacceptable positionLookup class"));
calculatePosition.cc:222:    LOG(BF(" originAtom(%s)   [01;31m-[00m  toAtom(%s)") % posOriginAtom.asString().c_str() % posToAtom.asString().c_str()  ); // vp0((" originAtom(%s)   [01;31m-[00m  toAtom(%s)", posOriginAtom.asString().c_str(), posToAtom.asString().c_str() ));
calculatePosition.cc:223:    LOG(BF(" extendDistance(%lf) ") % this[01;31m-[00m>_ExtendDistance  ); // vp0((" extendDistance(%lf) ", this[01;31m-[00m>_ExtendDistance ));
calculatePosition.cc:232:    pnt = posToAtom.add(dir.multiplyByScalar(this[01;31m-[00m>_ExtendDistance));
calculatePosition.cc:244:	class_<O_CalculatePosition>(this[01;31m-[00m>lisp())
calculatePosition.cc:265:	class_<O_CalculatePositionUsingInternals>(this[01;31m-[00m>lisp())
calculatePosition.cc:287:	class_<O_CalculatePositionAlongBond>(this[01;31m-[00m>lisp())
calculatePosition.cc:309:	class_<O_CalculatePositionRelativeToOrigin>(this[01;31m-[00m>lisp())
candoFormatSaveArchive.cc:21:    class_<O_CandoFormatSaveArchive>(env[01;31m-[00m>lisp())
candoFormatSaveArchive.cc:41:    this[01;31m-[00m>Base::initialize();
candoFormatSaveArchive.cc:42:    this[01;31m-[00m>setVersion(0);
candoFormatSaveArchive.cc:54:    this[01;31m-[00m>completeWeakObjectReferences();
candoFormatSaveArchive.cc:55:    if ( this[01;31m-[00m>_Verbosity>0 )
candoFormatSaveArchive.cc:57:	this[01;31m-[00m>describeMemoryUsage();
candoFormatSaveArchive.cc:76:    this[01;31m-[00m>_TopNode[01;31m-[00m>writeCandoFormat(out,this[01;31m-[00m>_Verbosity>0);
candoFormatSaveArchive.cc:77:    if ( this[01;31m-[00m>_Verbosity > 0 )
candoFormatSaveArchive.cc:80:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( " Size of archive file is %lu bytes") % fileSize );
candoFormatSaveArchive.cc:100:    this[01;31m-[00m>completeWeakObjectReferences();
candoFormatSaveArchive.cc:102:    this[01;31m-[00m>_TopNode[01;31m-[00m>writeCandoFormat(sout,false);
candoFormatSaveArchive.cc:114:    for ( ch=this[01;31m-[00m>_TopNode[01;31m-[00m>begin_Children(); ch!=this[01;31m-[00m>_TopNode[01;31m-[00m>end_Children(); ch++ )
candoFormatSaveArchive.cc:116:	(*ch)[01;31m-[00m>writeCandoFormat(sout,false);
candoObject.cc:18:    LOG(BF("Creating object of class(%s)") % candoClass[01;31m-[00m>instanceClassName() );
candoObject.cc:20:    obj[01;31m-[00m>initializeSlots(candoClass);
candoObject.cc:22:    obj[01;31m-[00m>InvokeMethod("__init__",selfArgs);
candoObject.cc:28:{_F(this[01;31m-[00m>lisp());
candoObject.cc:29:    LOG(BF("Becoming the class(%s)") % cl[01;31m-[00m>dumpInfo() );
candoObject.cc:30:    this[01;31m-[00m>_Class = cl.get();
candoObject.cc:31:    LOG(BF("Initializing %d slot values to nil") % cl[01;31m-[00m>numberOfSlots() );
candoObject.cc:32:    for ( O_CandoClass::slotIterator si=cl[01;31m-[00m>begin(); si!=cl[01;31m-[00m>end(); si++ )
candoObject.cc:34:	if ( !this[01;31m-[00m>_SlotBinder[01;31m-[00m>contains(*si) )
candoObject.cc:36:	    LOG(BF("Setting slot(%s) to nil")%(*si)[01;31m-[00m>fullName());
candoObject.cc:37:	    this[01;31m-[00m>_SlotBinder[01;31m-[00m>update(*si,this[01;31m-[00m>lisp()[01;31m-[00m>onil());
candoObject.cc:40:	    LOG(BF("Slot(%s) already has value: %s") % (*si)[01;31m-[00m>fullName() % this[01;31m-[00m>_SlotBinder[01;31m-[00m>value(*si)[01;31m-[00m>__repr__());
candoObject.cc:49:{_F(this[01;31m-[00m>lisp());
candoObject.cc:51:    this[01;31m-[00m>Base::initialize();
candoObject.cc:52:    this[01;31m-[00m>_SlotBinder = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Binder>();
candoObject.cc:57:{_F(this[01;31m-[00m>lisp());
candoObject.cc:58:    return env[01;31m-[00m>onil();
candoObject.cc:67:    this[01;31m-[00m>Base::archiveBase(node); 
candoObject.cc:68:    node[01;31m-[00m>archiveObject("slots",this[01;31m-[00m>_SlotBinder);
candoObject.cc:75:    ss << this[01;31m-[00m>className();
candoObject.cc:76:    if ( this[01;31m-[00m>_SlotBinder.use_count() == 0 ) 
candoObject.cc:81:    ss << "{slots" << this[01;31m-[00m>_SlotBinder[01;31m-[00m>allKeysAsString() << "}";
candoObject.cc:88:{_F(this[01;31m-[00m>lisp());
candoObject.cc:89:    RPCandoClass cc = this[01;31m-[00m>_class()[01;31m-[00m>as<O_CandoClass>();
candoObject.cc:90:    ASSERT(cc[01;31m-[00m>notNil());
candoObject.cc:91:    LOG(BF("This object is of class: %s") % cc[01;31m-[00m>__repr__() );
candoObject.cc:92:    O_CandoClass::slotIterator it = cc[01;31m-[00m>find(sym);
candoObject.cc:93:    if ( it == cc[01;31m-[00m>end() )
candoObject.cc:95:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Class(%s) does not have slot named(%s) [01;31m-[00m legal slots: %s")%cc[01;31m-[00m>getPackagedName()%sym[01;31m-[00m>currentName() % cc[01;31m-[00m>slotNamesAsString() ));
candoObject.cc:98:	LOG(BF("Found the slot with name: %s")% (*it)[01;31m-[00m>fullName() );
candoObject.cc:99:	LOG(BF("   the number of slots in this object are: %d")% this[01;31m-[00m>_SlotBinder[01;31m-[00m>size() );
candoObject.cc:100:	this[01;31m-[00m>_SlotBinder[01;31m-[00m>extend(sym,obj);
candoObject.cc:108:{_F(this[01;31m-[00m>lisp());
candoObject.cc:109:    if ( !this[01;31m-[00m>_SlotBinder[01;31m-[00m>contains(name) )
candoObject.cc:111:	LOG(BF("Did not find symbol(%s) [01;31m-[00m throwing exception") % name[01;31m-[00m>fullName() );
candoObject.cc:113:    RPObject result = this[01;31m-[00m>_SlotBinder[01;31m-[00m>lookup(name);
candoObject.cc:114:    LOG(BF("Result = %s") % result[01;31m-[00m>__repr__() );
candoObject.cc:122:    return this[01;31m-[00m>_SlotBinder[01;31m-[00m>contains(sym);
candoObject.cc:127:{_F(this[01;31m-[00m>lisp());
candoObject.cc:128:    LOG(BF("About to initialize slots(%s)") % cc[01;31m-[00m>slotNamesAsString() );
candoObject.cc:129:    for ( O_CandoClass::slotIterator si=cc[01;31m-[00m>begin(); si!=cc[01;31m-[00m>end(); si++ )
candoObject.cc:131:	this[01;31m-[00m>setSlot(*si,this[01;31m-[00m>lisp()[01;31m-[00m>onil());
candoObject.cc:144:	class_<O_CandoObject>(this[01;31m-[00m>lisp())
candoScript.cc:47:{_F(this[01;31m-[00m>lisp());
candoScript.cc:52:{_F(this[01;31m-[00m>lisp());
candoScript.cc:53:    this[01;31m-[00m>Base::archiveBase(node);
candoScript.cc:54:    node[01;31m-[00m>attribute("_MonomerId",this[01;31m-[00m>_MonomerId);
candoScript.cc:55:    node[01;31m-[00m>attribute("_GroupName",this[01;31m-[00m>_GroupName);
candoScript.cc:56:    node[01;31m-[00m>archiveObjectIfDefined("_MonomerAliases",this[01;31m-[00m>_MonomerAliases);
candoScript.cc:57:    node[01;31m-[00m>attributeIfNotDefault<string>("_Comment",this[01;31m-[00m>_Comment,"");
candoScript.cc:61:{_F(this[01;31m-[00m>lisp());
candoScript.cc:62:    RPMultiMonomer mon = O_MultiMonomer::create(this[01;31m-[00m>lisp());
candoScript.cc:63:    mon[01;31m-[00m>setId(this[01;31m-[00m>_MonomerId);
candoScript.cc:64:    mon[01;31m-[00m>setGroupName(this[01;31m-[00m>_GroupName);
candoScript.cc:65:    mon[01;31m-[00m>setAliasesFromCons(this[01;31m-[00m>_MonomerAliases);
candoScript.cc:72:{_F(this[01;31m-[00m>lisp());
candoScript.cc:73:    this[01;31m-[00m>Base::archiveBase(node);
candoScript.cc:74:    node[01;31m-[00m>attribute("_Monomer1Id",this[01;31m-[00m>_Monomer1Id);
candoScript.cc:75:    node[01;31m-[00m>attribute("_Coupling",this[01;31m-[00m>_Coupling);
candoScript.cc:76:    node[01;31m-[00m>archiveObject("_Monomer2",this[01;31m-[00m>_Monomer2);
candoScript.cc:82:{_F(this[01;31m-[00m>lisp());
candoScript.cc:83:    return this[01;31m-[00m>_Monomer2[01;31m-[00m>createMonomer(bdb);
candoScript.cc:106:    RPString fileName = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_String>();
candoScript.cc:107:    uint verbosity = kargs[01;31m-[00m>getIntDefault("verbosity",0);
candoScript.cc:108:    boost::filesystem::path filePath(fileName[01;31m-[00m>get());
candoScript.cc:110:    lisp[01;31m-[00m>loadBuilderDatabase(filePath.file_string(),verbosity);
candoScript.cc:125:    RPString dbName = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_String>();
candoScript.cc:126:    uint verbosity = kargs[01;31m-[00m>getIntDefault("verbosity",0);
candoScript.cc:128:    name << "database_" << dbName[01;31m-[00m>get() << ".cxml";
candoScript.cc:129:    filePath  = lisp[01;31m-[00m>bundle().getDatabasesDir() / name.str();
candoScript.cc:131:    lisp[01;31m-[00m>loadBuilderDatabase(filePath.file_string(),verbosity);
candoScript.cc:146:    RPText pathName = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Text>();
candoScript.cc:147:    filePath  = lisp[01;31m-[00m>bundle().getDatabasesDir() / pathName[01;31m-[00m>get();
candoScript.cc:163:    cdb = args[01;31m-[00m>car<O_BuilderDatabase>();
candoScript.cc:164:    lisp[01;31m-[00m>setBuilderDatabase(cdb);
candoScript.cc:181:    if ( args[01;31m-[00m>length()!=1 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a name to lookup"));
candoScript.cc:182:    RPText name = args[01;31m-[00m>car<O_Text>();
candoScript.cc:183:    RPObject obj = lisp[01;31m-[00m>getBuilderDatabase()[01;31m-[00m>getEntity(name[01;31m-[00m>get());
candoScript.cc:198:    RPBuilderDatabase bdb = lisp[01;31m-[00m>getBuilderDatabase();
candoScript.cc:199:    if ( bdb[01;31m-[00m>isNil() )
candoScript.cc:201:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must define a BuilderDatabse"));
candoScript.cc:203:    part = args[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
candoScript.cc:205:    for ( mit=bdb[01;31m-[00m>begin_MonomerCoordinates_keyValue();
candoScript.cc:206:    		mit != bdb[01;31m-[00m>end_MonomerCoordinates_keyValue(); mit++ )
candoScript.cc:208:	RPMonomerContext context = mit[01;31m-[00m>second[01;31m-[00m>getContext();
candoScript.cc:209:	RPStringSet allKeys = context[01;31m-[00m>getAllSpecificKeys();
candoScript.cc:213:	for ( sit=allKeys[01;31m-[00m>begin(); sit!=allKeys[01;31m-[00m>end(); sit++ )
candoScript.cc:223:	    lisp[01;31m-[00m>print(BF( "%s") % mit[01;31m-[00m>second[01;31m-[00m>getComment().c_str() );
candoScript.cc:224:	    lisp[01;31m-[00m>print(BF("     Found %d times first: %s") %times % firstFind.c_str() );
candoScript.cc:242:    RPPlug p = kargs[01;31m-[00m>getAndRemove("plug")[01;31m-[00m>as<O_Plug>();
candoScript.cc:258:    bdb = lisp[01;31m-[00m>getBuilderDatabase();
candoScript.cc:259:    for ( O_BuilderDatabase::constitutionIterator it=bdb[01;31m-[00m>begin_Constitutions();
candoScript.cc:260:    		it!=bdb[01;31m-[00m>end_Constitutions(); it++ )
candoScript.cc:262:	string stereoisomers = (*it)[01;31m-[00m>getMonomerNamesAsStringList()[01;31m-[00m>asString();
candoScript.cc:263:	lisp[01;31m-[00m>print(BF(" Constitution: %12s [01;31m-[00m[01;31m-[00m %s") % (*it)[01;31m-[00m>getName() % stereoisomers );
candoScript.cc:284:    string virtualAtomName = kargs[01;31m-[00m>getStringAndRemove("name");
candoScript.cc:285:    string constitutionName = kargs[01;31m-[00m>getStringAndRemove("constitutionName");
candoScript.cc:286:    string fragmentName = kargs[01;31m-[00m>getStringAndRemoveOrDefault("fragmentName","");
candoScript.cc:287:    RPCalculatePosition calcPos= kargs[01;31m-[00m>getAndRemove("position")[01;31m-[00m>as<O_CalculatePosition>();
candoScript.cc:288:    RPBuilderDatabase bdb = lisp[01;31m-[00m>getBuilderDatabase();
candoScript.cc:297:	for ( ci=bdb[01;31m-[00m>begin_Constitutions();
candoScript.cc:298:		    ci!=bdb[01;31m-[00m>end_Constitutions(); ci++ )
candoScript.cc:300:	    LOG(BF("Looking at constitution(%s)") % (*ci)[01;31m-[00m>getName().c_str()  ); // vp0(( "Looking at constitution(%s)", (*ci)[01;31m-[00m>getName().c_str() ));
candoScript.cc:301:	    if ( (*ci)[01;31m-[00m>getName() == constitutionName )
candoScript.cc:304:		RPResidue res = (*ci)[01;31m-[00m>getResidue();
candoScript.cc:305:		res[01;31m-[00m>addVirtualAtom(virtualAtomName,calcPos,lisp);
candoScript.cc:315:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find constitution: "+constitutionName));
candoScript.cc:322:	for ( mi=bdb[01;31m-[00m>begin_MonomerCoordinates(); 
candoScript.cc:323:		    mi!=bdb[01;31m-[00m>end_MonomerCoordinates();
candoScript.cc:326:	    uniqueMonomerCoordinates.insert(mi[01;31m-[00m>second);
candoScript.cc:333:	{ _BLOCK_TRACEF(BF("Checking MonomerCoordinates with context: %s") % (*ui)[01;31m-[00m>getContext()[01;31m-[00m>getKey().c_str() );
candoScript.cc:334:	    RPMonomerContext context = (*ui)[01;31m-[00m>getContext();
candoScript.cc:335:	    RPMonomerSetBase focus = context[01;31m-[00m>getFocus();
candoScript.cc:336:	    string focusMonomerName = focus[01;31m-[00m>getOnlyMonomerName();
candoScript.cc:337:	    RPBuilderDatabase bdb = lisp[01;31m-[00m>getBuilderDatabase();
candoScript.cc:338:	    RPConstitution constitution = bdb[01;31m-[00m>constitutionForNameOrPdb(focusMonomerName);
candoScript.cc:339:	    if ( constitution[01;31m-[00m>getName() == constitutionName )
candoScript.cc:342:			focus[01;31m-[00m>getMonomerNamesAsString() % constitutionName );
candoScript.cc:348:	{ _BLOCK_TRACEF(BF("Checking MonomerCoordinates with context: %s") % (*si)[01;31m-[00m>getContext()[01;31m-[00m>getKey().c_str() );
candoScript.cc:357:		fragmentCoords = monCoords[01;31m-[00m>getFragmentCoordinatesThatContainAtomWithName(calcPos[01;31m-[00m>closestAtomName());
candoScript.cc:359:			    virtualAtomName % fragmentCoords[01;31m-[00m>getFragmentName() );
candoScript.cc:361:			    virtualAtomName % calcPos[01;31m-[00m>closestAtomName() );
candoScript.cc:364:		fragmentCoords = monCoords[01;31m-[00m>getFragmentCoordinatesWithName(fragmentName);
candoScript.cc:365:		if ( fragmentCoords[01;31m-[00m>isNil() )
candoScript.cc:367:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("In createVirtualAtom: Unrecognized fragmentCoordinates name("+fragmentName+")"));
candoScript.cc:373:			    fragmentCoords[01;31m-[00m>getFragmentName() );
candoScript.cc:374:	    if ( !fragmentCoords[01;31m-[00m>addVirtualAtom(virtualAtomName,calcPos,lisp) )
candoScript.cc:378:    lisp[01;31m-[00m>print(BF("Added virtual atom(%s) for constitution(%s)") % virtualAtomName % constitutionName );
candoScript.cc:381:        lisp[01;31m-[00m>print(BF(" saw %d collisions") % collisions );
candoScript.cc:383:    lisp[01;31m-[00m>print(BF(""));
candoScript.cc:397:Save the \sa{object} to the \sa{filename} in Cando[01;31m-[00mArchive format.
candoScript.cc:403:    RPObject obj = args[01;31m-[00m>ocar();
candoScript.cc:404:    RPText fileName = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Text>();
candoScript.cc:406:    if ( args[01;31m-[00m>cddr()[01;31m-[00m>notNil() )
candoScript.cc:408:	RPBinder options = O_Binder::createFromKeywordCons(args[01;31m-[00m>cdr(),keywords_saveArchive,lisp);
candoScript.cc:409:	debugLevel = options[01;31m-[00m>intValueOrDefault(lisp[01;31m-[00m>predefinedSymbol(_sym_kw_debug),0);
candoScript.cc:412:    archive[01;31m-[00m>setVerbosity(debugLevel);
candoScript.cc:413:    archive[01;31m-[00m>put("only",obj);
candoScript.cc:414:    archive[01;31m-[00m>saveAs(fileName[01;31m-[00m>get());
candoScript.cc:415://    obj[01;31m-[00m>saveXmlAs(fileName[01;31m-[00m>get(),"only");
candoScript.cc:425:Save the \sa{object} along with the system BuilderDatabase to the \sa{filename} in Cando[01;31m-[00mXML format.
candoScript.cc:431:    if ( kargs[01;31m-[00m>numberOfPositionalArguments()!=2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide the object and file name"));
candoScript.cc:432:    RPObject obj = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Object>();
candoScript.cc:433:    RPText fileName = kargs[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Text>();
candoScript.cc:434:    int debugLevel = kargs[01;31m-[00m>getIntAndRemoveOrDefault("verbosity",0);
candoScript.cc:436:    archive[01;31m-[00m>setVerbosity(debugLevel);
candoScript.cc:437:    archive[01;31m-[00m>putBuilderDatabase(lisp[01;31m-[00m>getBuilderDatabase());
candoScript.cc:438:    archive[01;31m-[00m>put("only",obj);
candoScript.cc:439:    archive[01;31m-[00m>saveAs(fileName[01;31m-[00m>get());
candoScript.cc:440://    obj[01;31m-[00m>saveXmlAs(fileName[01;31m-[00m>get(),"only");
candoScript.cc:448:Save the \sa{object} to the \sa{filename} in Cando[01;31m-[00mOML format.
candoScript.cc:454:    if ( kargs[01;31m-[00m>numberOfPositionalArguments()!=2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide the object and file name"));
candoScript.cc:455:    RPObject obj = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Object>();
candoScript.cc:456:    RPText fileName = kargs[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Text>();
candoScript.cc:457:    int debugLevel = kargs[01;31m-[00m>getIntAndRemoveOrDefault("verbosity",0);
candoScript.cc:459:    archive[01;31m-[00m>setVerbosity(debugLevel);
candoScript.cc:460:    archive[01;31m-[00m>put("only",obj);
candoScript.cc:461:    archive[01;31m-[00m>saveAs(fileName[01;31m-[00m>get());
candoScript.cc:475:    if ( args[01;31m-[00m>length()!=1 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a file name"));
candoScript.cc:476:    RPText fileName = args[01;31m-[00m>listref<O_Text>(0);
candoScript.cc:478:    boost::filesystem::path filePath(fileName[01;31m-[00m>get());
candoScript.cc:495:    if ( args[01;31m-[00m>ocar()[01;31m-[00m>notNil() )
candoScript.cc:497:	prompt = args[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
candoScript.cc:513:	_lisp[01;31m-[00m>print(BF("%s ") % prompt );
candoScript.cc:514:	_lisp[01;31m-[00m>printvFlush();
candoScript.cc:531:    string command = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
candoScript.cc:533:    RPInt iret = lisp[01;31m-[00m>create<O_Int>(ret);
candoScript.cc:547:    if ( args[01;31m-[00m>length()!=2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a matter and file name"));
candoScript.cc:548:    RPMatter matter = args[01;31m-[00m>listref<O_Matter>(0);
candoScript.cc:549:    RPText fileName = args[01;31m-[00m>listref<O_Text>(1);
candoScript.cc:550:    mol2WriteMatterToFileName(matter,fileName[01;31m-[00m>get());
candoScript.cc:562:{_F(matter[01;31m-[00m>lisp());
candoScript.cc:569:    RPText resIdName = residueIdentifier[01;31m-[00m>asOrNil<O_Text>();
candoScript.cc:570:    RPInt resIdSeqNum = residueIdentifier[01;31m-[00m>asOrNil<O_Int>();
candoScript.cc:576:        LOG(BF("Looking at residue with sequence number: %d") % res[01;31m-[00m>getFileSequenceNumber()  ); // vp0(("Looking at residue with sequence number: %d",res[01;31m-[00m>getFileSequenceNumber() ));
candoScript.cc:578:	if ( resIdName[01;31m-[00m>notNil() )
candoScript.cc:580:	    LOG(BF("Checking if residue has name(%s) that matches(%s)") % res[01;31m-[00m>getName().c_str() % resIdName[01;31m-[00m>get().c_str()  ); // vp0(( "Checking if residue has name(%s) that matches(%s)", res[01;31m-[00m>getName().c_str(), resIdName[01;31m-[00m>get().c_str() ));
candoScript.cc:581:	    if ( resIdName[01;31m-[00m>get()==res[01;31m-[00m>getName() )
candoScript.cc:583:	        LOG(BF("Found residue with sequence name: %s") % resIdName[01;31m-[00m>get().c_str() ); // vp0(("Found residue with sequence name: %s", resIdName[01;31m-[00m>get().c_str()));
candoScript.cc:585:	    } else if ( res[01;31m-[00m>recognizesMonomerAlias(resIdName[01;31m-[00m>get()) )
candoScript.cc:587:	        LOG(BF("Found residue with Monomer alias: %s") % resIdName[01;31m-[00m>get().c_str() ); // vp0(("Found residue with Monomer alias: %s", resIdName[01;31m-[00m>get().c_str()));
candoScript.cc:590:	} else if ( resIdSeqNum[01;31m-[00m>notNil() )
candoScript.cc:592:	    LOG(BF("Checking if residue has fileSequenceNumber(%d) that matches(%d)") % res[01;31m-[00m>getFileSequenceNumber() % resIdSeqNum[01;31m-[00m>get()  ); // vp0(( "Checking if residue has fileSequenceNumber(%d) that matches(%d)", res[01;31m-[00m>getFileSequenceNumber(), resIdSeqNum[01;31m-[00m>get() ));
candoScript.cc:593:	    if ( (int)(res[01;31m-[00m>getFileSequenceNumber()) == resIdSeqNum[01;31m-[00m>get() )
candoScript.cc:595:	        LOG(BF("Found residue with sequence number: %s") % resIdSeqNum[01;31m-[00m>get()  ); // vp0(("Found residue with sequence number: %s", resIdSeqNum[01;31m-[00m>get() ));
candoScript.cc:604:    return O_Residue::nil(matter[01;31m-[00m>lisp());
candoScript.cc:621:    if ( args[01;31m-[00m>length()==3 ) 
candoScript.cc:623:        RPAggregate agg = args[01;31m-[00m>listref<O_Aggregate>(0);
candoScript.cc:624:	RPText chain = args[01;31m-[00m>listref<O_Text>(1);
candoScript.cc:625:	residueIdentifier = args[01;31m-[00m>listref<O_Object>(2);
candoScript.cc:626:	molecule = safe_downcast<O_Molecule>(agg[01;31m-[00m>contentWithName(chain[01;31m-[00m>get()));
candoScript.cc:627:    } else if ( args[01;31m-[00m>length()==2 ) 
candoScript.cc:629:        molecule = args[01;31m-[00m>listref<O_Molecule>(0);
candoScript.cc:630:	residueIdentifier = args[01;31m-[00m>listref<O_Object>(1);
candoScript.cc:633:    	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a molecule, residueId" ));
candoScript.cc:636:    if ( res[01;31m-[00m>isNil() )
candoScript.cc:639:	serr << "Molecule does not contain residue with identifier: " << residueIdentifier[01;31m-[00m>__repr__().c_str() ;
candoScript.cc:640:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
candoScript.cc:664:    if ( args[01;31m-[00m>length()==4 ) 
candoScript.cc:666:        RPAggregate agg = args[01;31m-[00m>listref<O_Aggregate>(0);
candoScript.cc:667:	RPText chain = args[01;31m-[00m>listref<O_Text>(1);
candoScript.cc:668:	residueIdentifier = args[01;31m-[00m>listref<O_Object>(2);
candoScript.cc:669:	atomName = args[01;31m-[00m>listref<O_Text>(3);
candoScript.cc:670:	molecule = safe_downcast<O_Molecule>(agg[01;31m-[00m>contentWithName(chain[01;31m-[00m>get()));
candoScript.cc:671:    } else if ( args[01;31m-[00m>length()==3 ) 
candoScript.cc:673:        molecule = args[01;31m-[00m>listref<O_Molecule>(0);
candoScript.cc:674:	residueIdentifier = args[01;31m-[00m>listref<O_Object>(1);
candoScript.cc:675:	atomName = args[01;31m-[00m>listref<O_Text>(2);
candoScript.cc:678:    	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a molecule, residueId and atom name"));
candoScript.cc:681:    if ( foundResidue[01;31m-[00m>notNil() )
candoScript.cc:683:	if ( foundResidue[01;31m-[00m>hasAtomWithName(atomName[01;31m-[00m>get() ) )
candoScript.cc:685:	    LOG(BF("Found atom with name: %s") % atomName[01;31m-[00m>get().c_str()  ); // vp0(("Found atom with name: %s",atomName[01;31m-[00m>get().c_str() ));
candoScript.cc:686:	    Vector3 pos = foundResidue[01;31m-[00m>atomWithName(atomName[01;31m-[00m>get())[01;31m-[00m>getPosition();
candoScript.cc:688:	    v[01;31m-[00m>setAll(pos.getX(),pos.getY(),pos.getZ());
candoScript.cc:691:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Residue does not contain atom named: "+atomName[01;31m-[00m>get()));
candoScript.cc:694:    serr << "Molecule does not contain residue with identifier: " << residueIdentifier[01;31m-[00m>__repr__().c_str() ;
candoScript.cc:695:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
candoScript.cc:712:    if ( kargs[01;31m-[00m>numberOfPositionalArguments()!=1 )
candoScript.cc:714:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide the object to render as the only positional argument, 'options' is a keyedArgument "));
candoScript.cc:716:    RPObject obj = kargs[01;31m-[00m>getPositionalArgument(0);
candoScript.cc:717:    RPCons options = kargs[01;31m-[00m>getAndRemoveOrDefault("options",O_Cons::nil(lisp))[01;31m-[00m>as<O_Cons>();
candoScript.cc:720:    if ( obj[01;31m-[00m>canRender() )
candoScript.cc:722:        render = obj[01;31m-[00m>rendered(koptions);
candoScript.cc:725:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Object doesn't support render"));
candoScript.cc:746:    RPText fileName = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Text>();
candoScript.cc:748:    if ( args[01;31m-[00m>cdr()[01;31m-[00m>notNil() )
candoScript.cc:750:	RPBinder options = O_Binder::createFromKeywordCons(args[01;31m-[00m>cdr(),keywords_loadArchive,lisp);
candoScript.cc:751:	if ( options[01;31m-[00m>contains(lisp[01;31m-[00m>predefinedSymbol(_sym_kw_debug)) )
candoScript.cc:753:	    RPInt debugLevelObj = options[01;31m-[00m>lookup(lisp[01;31m-[00m>predefinedSymbol(_sym_kw_debug))[01;31m-[00m>as<O_Int>();
candoScript.cc:754:	    debugLevel = debugLevelObj[01;31m-[00m>get();
candoScript.cc:758:    archive[01;31m-[00m>setVerbosity(debugLevel);
candoScript.cc:759:    boost::filesystem::path filePath(fileName[01;31m-[00m>get());
candoScript.cc:761:    archive[01;31m-[00m>open(filePath.file_string());
candoScript.cc:762:    contents = archive[01;31m-[00m>getContents();
candoScript.cc:765:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("There must be one and only one object in the file"));
candoScript.cc:773:#define	FuncError(x) TOSS(_lisp[01;31m-[00m>create<O_LispError>(x))
candoScript.cc:783:    if ( args[01;31m-[00m>length()<2 ) FuncError("You must provide at least 2 args");
candoScript.cc:785:    newMon[01;31m-[00m>_MonomerId = args[01;31m-[00m>listref<O_Text>(0)[01;31m-[00m>get();
candoScript.cc:786:    RPObject obj = args[01;31m-[00m>olistref(1);
candoScript.cc:787:    if ( obj[01;31m-[00m>isAssignableTo<O_Text>() )
candoScript.cc:789:	newMon[01;31m-[00m>_GroupName = obj[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
candoScript.cc:790:    } else if ( obj[01;31m-[00m>isAssignableTo<O_GroupPart>() )
candoScript.cc:792:	newMon[01;31m-[00m>_GroupName = obj[01;31m-[00m>as<O_GroupPart>()[01;31m-[00m>getPartName();
candoScript.cc:794:    newMon[01;31m-[00m>_MonomerAliases = O_Cons::nil(lisp);
candoScript.cc:795:    if ( args[01;31m-[00m>length() >2 ) newMon[01;31m-[00m>_MonomerAliases = args[01;31m-[00m>listref<O_Cons>(2);
candoScript.cc:796:    newMon[01;31m-[00m>_Comment = "";
candoScript.cc:797:    if ( args[01;31m-[00m>length() > 3 ) newMon[01;31m-[00m>_Comment = args[01;31m-[00m>listref<O_Text>(3)[01;31m-[00m>get();
candoScript.cc:807:    if ( args[01;31m-[00m>length()<3 ) FuncError("You must provide 3 args");
candoScript.cc:809:    newLink[01;31m-[00m>_Monomer1Id = args[01;31m-[00m>listref<O_Text>(0)[01;31m-[00m>get();
candoScript.cc:810:    newLink[01;31m-[00m>_Coupling = args[01;31m-[00m>listref<O_Text>(1)[01;31m-[00m>get();
candoScript.cc:811:    newLink[01;31m-[00m>_Monomer2 = args[01;31m-[00m>listref<O_OligomerPart_Monomer>(2);
candoScript.cc:828:    string distanceAtom = kargs[01;31m-[00m>getStringAndRemoveOrDefault("distanceAtom","");
candoScript.cc:829:    string angleAtom = kargs[01;31m-[00m>getStringAndRemoveOrDefault("angleAtom","");
candoScript.cc:830:    string dihedralAtom = kargs[01;31m-[00m>getStringAndRemoveOrDefault("dihedralAtom","");
candoScript.cc:831:    double distance = kargs[01;31m-[00m>getDoubleAndRemoveOrDefault("distance",0.0);
candoScript.cc:832:    double angleDegrees = kargs[01;31m-[00m>getDoubleAndRemoveOrDefault("angleDegrees",0.0);
candoScript.cc:833:    double dihedralDegrees = kargs[01;31m-[00m>getDoubleAndRemoveOrDefault("dihedralDegrees",0.0);
candoScript.cc:834:    RPObject positionLookup = kargs[01;31m-[00m>getAndRemove("positionLookup");
candoScript.cc:840:    if ( positionLookup[01;31m-[00m>isOfClass<O_IterateFragmentCoordinateEntries>() )
candoScript.cc:842:	RPIterateFragmentCoordinateEntries it = positionLookup[01;31m-[00m>as<O_IterateFragmentCoordinateEntries>();
candoScript.cc:843:	posDistanceAtom = it[01;31m-[00m>positionOfAtomWithName(distanceAtom);
candoScript.cc:844:	posAngleAtom = it[01;31m-[00m>positionOfAtomWithName(angleAtom);
candoScript.cc:845:	posDihedralAtom = it[01;31m-[00m>positionOfAtomWithName(dihedralAtom);
candoScript.cc:846:    } else if ( positionLookup[01;31m-[00m>isOfClass<O_Residue>() )
candoScript.cc:848:	RPResidue res = positionLookup[01;31m-[00m>as<O_Residue>();
candoScript.cc:849:	posDistanceAtom = res[01;31m-[00m>positionOfAtomWithName(distanceAtom);
candoScript.cc:850:	posAngleAtom = res[01;31m-[00m>positionOfAtomWithName(angleAtom);
candoScript.cc:851:	posDihedralAtom = res[01;31m-[00m>positionOfAtomWithName(dihedralAtom);
candoScript.cc:854:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unacceptable positionLookup class"));
candoScript.cc:872:    if ( args[01;31m-[00m>length()<2 ) FuncError("You must provide 2 args");
candoScript.cc:873:    RPText oligomerName = args[01;31m-[00m>listref<O_Text>(0);
candoScript.cc:874:    RPCons parts = args[01;31m-[00m>listref<O_Cons>(1);
candoScript.cc:876:    olig[01;31m-[00m>setName(oligomerName[01;31m-[00m>get());
candoScript.cc:878:    RPBuilderDatabase bdb = lisp[01;31m-[00m>getBuilderDatabase();
candoScript.cc:879:    for ( RPCons p=parts; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() )
candoScript.cc:881:	RPOligomerPart_Base oligPart = p[01;31m-[00m>car<O_OligomerPart_Base>();
candoScript.cc:882:	RPMultiMonomer mon = oligPart[01;31m-[00m>createMonomer(bdb);
candoScript.cc:883:	olig[01;31m-[00m>addMonomer(mon);
candoScript.cc:884:	monomerMap.set(mon[01;31m-[00m>getId(), mon);
candoScript.cc:885:	if ( oligPart[01;31m-[00m>isOfClass<O_OligomerPart_Link>() )
candoScript.cc:888:	    string	mon1Id = link[01;31m-[00m>_Monomer1Id;
candoScript.cc:889:	    string	mon2Id = link[01;31m-[00m>_Monomer2[01;31m-[00m>_MonomerId;
candoScript.cc:890:	    if ( !monomerMap.contains(mon1Id) ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown monomer id: "+mon1Id));
candoScript.cc:891:	    if ( !monomerMap.contains(mon2Id) ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown monomer id: "+mon2Id));
candoScript.cc:894:	    olig[01;31m-[00m>couple(mon1,link[01;31m-[00m>_Coupling,mon2);
chemInfo.cc:41:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:42:    this[01;31m-[00m>_Matches = false;
chemInfo.cc:43:    this[01;31m-[00m>_TagLookup.clear();
chemInfo.cc:44:    this[01;31m-[00m>_ClosestMatch.clear();
chemInfo.cc:50:    this[01;31m-[00m>Base::archiveBase(node);
chemInfo.cc:51:    node[01;31m-[00m>attribute("matches",this[01;31m-[00m>_Matches);
chemInfo.cc:52:    node[01;31m-[00m>archiveMap("tags",this[01;31m-[00m>_TagLookup);
chemInfo.cc:53:    node[01;31m-[00m>archiveMapIfDefined("bestMatch",this[01;31m-[00m>_ClosestMatch);
chemInfo.cc:58:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:59:    ASSERT(this[01;31m-[00m>notNil());
chemInfo.cc:60:    return this[01;31m-[00m>_Matches;
chemInfo.cc:65:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:66:    ASSERT(this[01;31m-[00m>notNil());
chemInfo.cc:67:    this[01;31m-[00m>_TagLookup.clear();
chemInfo.cc:71:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:72:    ASSERT(this[01;31m-[00m>notNil());
chemInfo.cc:73:    return this[01;31m-[00m>_TagLookup.count(tag);
chemInfo.cc:77:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:78:    ASSERT(this[01;31m-[00m>notNil());
chemInfo.cc:79:    this[01;31m-[00m>_TagLookup.set(tag,a);
chemInfo.cc:80:    if ( this[01;31m-[00m>_TagLookup.size() > this[01;31m-[00m>_ClosestMatch.size() )
chemInfo.cc:82:	this[01;31m-[00m>_ClosestMatch = this[01;31m-[00m>_TagLookup;
chemInfo.cc:87:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:88:    ASSERT(this[01;31m-[00m>notNil());
chemInfo.cc:89:    return this[01;31m-[00m>_TagLookup.count(tag)>0;
chemInfo.cc:94:	if ( !this[01;31m-[00m>hasAtomWithTag(tag) )
chemInfo.cc:96:	    return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Atom>();
chemInfo.cc:98:	return this[01;31m-[00m>getAtomWithTag(tag);
chemInfo.cc:103:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:104:    ASSERT(this[01;31m-[00m>notNil());
chemInfo.cc:105:    if ( this[01;31m-[00m>_TagLookup.count(tag) == 0 )
chemInfo.cc:109:        serr << "Available tags(" << this[01;31m-[00m>_TagLookup.getKeysAsStringSet(this[01;31m-[00m>lisp())[01;31m-[00m>asString() << ")" <<endl;
chemInfo.cc:110:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
chemInfo.cc:112:    return this[01;31m-[00m>_TagLookup.get(tag);
chemInfo.cc:116:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:117:    ASSERT(this[01;31m-[00m>notNil());
chemInfo.cc:118:    this[01;31m-[00m>_TagLookup.erase(tag);
chemInfo.cc:122:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:123:    for ( Map<O_Atom>::iterator it=this[01;31m-[00m>_ClosestMatch.begin(); it != this[01;31m-[00m>_ClosestMatch.end(); it++ )
chemInfo.cc:125:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("  tag(%s) = %s") % it[01;31m-[00m>first.c_str() % it[01;31m-[00m>second[01;31m-[00m>description().c_str() );
chemInfo.cc:131:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:132:    if ( !this[01;31m-[00m>_Matches )
chemInfo.cc:134:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("I cannot create a bound frame because there was no ChemInfo match"));
chemInfo.cc:136:    RPAtomBoundFrame bound = O_AtomBoundFrame::create(this[01;31m-[00m>lisp());
chemInfo.cc:137:    bound[01;31m-[00m>set_oAtom(this[01;31m-[00m>getAtomWithTag("1"));
chemInfo.cc:138:    bound[01;31m-[00m>set_pAtom(this[01;31m-[00m>getAtomWithTag("2"));
chemInfo.cc:139:    bound[01;31m-[00m>set_qAtom(this[01;31m-[00m>getAtomWithTag("3"));
chemInfo.cc:146:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m O_WildElementDict
chemInfo.cc:151:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:152:    this[01;31m-[00m>_AtomWildCards.clear();
chemInfo.cc:158:    maps = O_StringSet::create(this[01;31m-[00m>lisp());
chemInfo.cc:159:    this[01;31m-[00m>_AtomWildCards.set(name,maps);
chemInfo.cc:165:    if ( this[01;31m-[00m>_AtomWildCards.count(wildName) == 0 ) {
chemInfo.cc:166:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Could not find wild card name(%s)") % wildName ));
chemInfo.cc:168:    this[01;31m-[00m>_AtomWildCards.get(wildName)[01;31m-[00m>insert(elementName);
chemInfo.cc:173:    if ( this[01;31m-[00m>_AtomWildCards.count(name) == 0 ) return false;
chemInfo.cc:179:    if ( this[01;31m-[00m>_AtomWildCards.count(name) == 0 ) {
chemInfo.cc:180:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Unrecognized wild card name(%s)")% name));
chemInfo.cc:182:    if ( this[01;31m-[00m>_AtomWildCards.get(name)[01;31m-[00m>contains(element)!= 0 ) return true;
chemInfo.cc:192:    return (this[01;31m-[00m>_AtomWildCards.count(name)!= 0);
chemInfo.cc:199:    return (this[01;31m-[00m>_AtomWildCards.count(name)!= 0);
chemInfo.cc:208:    if ( node[01;31m-[00m>saving() ) {
chemInfo.cc:210:	for ( i=this[01;31m-[00m>_AtomWildCards.begin();
chemInfo.cc:211:		i!=this[01;31m-[00m>_AtomWildCards.end(); i++ ) {
chemInfo.cc:212:	    child = node[01;31m-[00m>createChildNode("Entry");
chemInfo.cc:213:	    child[01;31m-[00m>addAttributeString("name",i[01;31m-[00m>first);
chemInfo.cc:215:	    for ( si = i[01;31m-[00m>second[01;31m-[00m>begin(); si!=i[01;31m-[00m>second[01;31m-[00m>end(); si++ ) {
chemInfo.cc:218:	    child[01;31m-[00m>setCharacters(sdata.str());
chemInfo.cc:222:	for ( ni=node[01;31m-[00m>begin_Children(); ni!=node[01;31m-[00m>end_Children(); ni++ ) {
chemInfo.cc:223:	    string name = (*ni)[01;31m-[00m>getAttributeString("name");
chemInfo.cc:224:	    this[01;31m-[00m>addWildName(name);
chemInfo.cc:225:	    VectorStrings entries = (*ni)[01;31m-[00m>getDataAsVectorOfStrings();
chemInfo.cc:228:		this[01;31m-[00m>addWildNameMap(name,*si);
chemInfo.cc:230:	    (*ni)[01;31m-[00m>setRecognized(true);
chemInfo.cc:252:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:253:    this[01;31m-[00m>_Code = "";
chemInfo.cc:254:    this[01;31m-[00m>_Root = O_Root::nil(this[01;31m-[00m>lisp());
chemInfo.cc:255:    this[01;31m-[00m>_CompilerMessage = "";
chemInfo.cc:260:    return this[01;31m-[00m>_Root[01;31m-[00m>depth();
chemInfo.cc:267:    ASSERT_NOT_NULL(this[01;31m-[00m>_Root);
chemInfo.cc:268:    this[01;31m-[00m>_Root = O_Root::nil(this[01;31m-[00m>lisp());
chemInfo.cc:269:    this[01;31m-[00m>_Code = code;
chemInfo.cc:271:    root = smarts_compile(code,this[01;31m-[00m>lisp(),errors);
chemInfo.cc:272:    this[01;31m-[00m>_Root = root;
chemInfo.cc:273:    ANN(this[01;31m-[00m>_Root);
chemInfo.cc:274:    if ( root[01;31m-[00m>isNil() )
chemInfo.cc:276:	this[01;31m-[00m>_CompilerMessage = errors.str();
chemInfo.cc:279:    this[01;31m-[00m>_CompilerMessage = "Successfully compiled SMARTS";
chemInfo.cc:284:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:287:    this[01;31m-[00m>_Code = code;
chemInfo.cc:289:    root = ::gaff_compile(code,dict,this[01;31m-[00m>lisp(),serr);
chemInfo.cc:290:    this[01;31m-[00m>_Root = root;
chemInfo.cc:291:    if ( root[01;31m-[00m>isNil() )
chemInfo.cc:294:	this[01;31m-[00m>_CompilerMessage = serr.str();
chemInfo.cc:295:        LOG(BF("After unsuccessful compile this[01;31m-[00m>_Root = %s") % this[01;31m-[00m>_Root[01;31m-[00m>description().c_str()  ); // vp0(("After unsuccessful compile this[01;31m-[00m>_Root = %s",this[01;31m-[00m>_Root[01;31m-[00m>description().c_str() ));
chemInfo.cc:298:    root[01;31m-[00m>setElementWildCardDictionary(dict);
chemInfo.cc:300:    this[01;31m-[00m>_CompilerMessage = "Successfully compiled Antechamber";
chemInfo.cc:301:    LOG(BF("After compile this[01;31m-[00m>_Root = %s") % this[01;31m-[00m>_Root[01;31m-[00m>description().c_str()  ); // vp0(("After compile this[01;31m-[00m>_Root = %s",this[01;31m-[00m>_Root[01;31m-[00m>description().c_str() ));
chemInfo.cc:307:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:308:    ASSERT_NOT_NULL(this[01;31m-[00m>_Root);
chemInfo.cc:309:    if ( this[01;31m-[00m>_Root[01;31m-[00m>isNil() )
chemInfo.cc:311:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The ChemInfo root is nil!"));
chemInfo.cc:313:    LOG(BF("Starting matching process with atom: %s") % a[01;31m-[00m>description().c_str() ); // vp0(( "Starting matching process with atom: %s", a[01;31m-[00m>description().c_str()));
chemInfo.cc:314:    this[01;31m-[00m>_Root[01;31m-[00m>createNewMatch(this[01;31m-[00m>lisp());
chemInfo.cc:315:    if ( !this[01;31m-[00m>_Root[01;31m-[00m>matches(this[01;31m-[00m>_Root,a) ) goto FAIL;
chemInfo.cc:318:    this[01;31m-[00m>_Root[01;31m-[00m>getMatch()[01;31m-[00m>setMatches(true);
chemInfo.cc:322:    this[01;31m-[00m>_Root[01;31m-[00m>getMatch()[01;31m-[00m>setMatches(false);
chemInfo.cc:328:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:329:    node[01;31m-[00m>archiveObject("root",this[01;31m-[00m>_Root);
chemInfo.cc:335:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:336:    ASSERT_NOT_NULL(this[01;31m-[00m>_Root);
chemInfo.cc:337:    ASSERT(this[01;31m-[00m>_Root[01;31m-[00m>notNil());
chemInfo.cc:338:    ASSERT(this[01;31m-[00m>_Root[01;31m-[00m>getMatch()[01;31m-[00m>notNil());
chemInfo.cc:339:    return this[01;31m-[00m>_Root[01;31m-[00m>getMatch();
chemInfo.cc:377:    while ( p[01;31m-[00m>type != noType ) {
chemInfo.cc:378:	if ( p[01;31m-[00m>type == type ) return p[01;31m-[00m>name;
chemInfo.cc:391:    while ( p[01;31m-[00m>type != noType ) {
chemInfo.cc:392:	if ( p[01;31m-[00m>name== name) return p[01;31m-[00m>type;
chemInfo.cc:428:    return this[01;31m-[00m>matches(root,bond[01;31m-[00m>getTo().lock());
chemInfo.cc:443:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:444:    this[01;31m-[00m>_Operator = logIdentity;
chemInfo.cc:445:    this[01;31m-[00m>_Left = O_AtomOrBondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:446:    this[01;31m-[00m>_Right = O_AtomOrBondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:452:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:453:    LOG(BF("Logical match for atom: %s") % atom[01;31m-[00m>description().c_str()  ); // vp0(( "Logical match for atom: %s", atom[01;31m-[00m>description().c_str() ));
chemInfo.cc:454:    switch ( this[01;31m-[00m>_Operator ) {
chemInfo.cc:456:	    LOG(BF("Identity no[01;31m-[00mop test") ); // vp0(("Identity no[01;31m-[00mop test"));
chemInfo.cc:457:	    if ( this[01;31m-[00m>_Left[01;31m-[00m>matches(root,atom)) goto SUCCESS;
chemInfo.cc:461:	    if ( !(this[01;31m-[00m>_Left[01;31m-[00m>matches(root,atom)) ) goto SUCCESS;
chemInfo.cc:465:	    if ( this[01;31m-[00m>_Left[01;31m-[00m>matches(root,atom) && this[01;31m-[00m>_Right[01;31m-[00m>matches(root,atom) ) goto SUCCESS;
chemInfo.cc:469:	    if ( this[01;31m-[00m>_Left[01;31m-[00m>matches(root,atom) && this[01;31m-[00m>_Right[01;31m-[00m>matches(root,atom) ) goto SUCCESS;
chemInfo.cc:473:	    if ( this[01;31m-[00m>_Left[01;31m-[00m>matches(root,atom) || this[01;31m-[00m>_Right[01;31m-[00m>matches(root,atom) ) goto SUCCESS;
chemInfo.cc:477:	    err << "Unknown logical operator(" << this[01;31m-[00m>_Operator << ")";
chemInfo.cc:478:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(err.str()));
chemInfo.cc:491:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:492:    LOG(BF("Logical match for bond: %s") % bond[01;31m-[00m>description().c_str()  ); // vp0(( "Logical match for bond: %s", bond[01;31m-[00m>description().c_str() ));
chemInfo.cc:493:    switch ( this[01;31m-[00m>_Operator ) {
chemInfo.cc:495:	    if ( this[01;31m-[00m>_Left[01;31m-[00m>matches(root,bond)) goto SUCCESS;
chemInfo.cc:498:	    if ( !(this[01;31m-[00m>_Left[01;31m-[00m>matches(root,bond)) ) goto SUCCESS;
chemInfo.cc:502:	    if ( this[01;31m-[00m>_Left[01;31m-[00m>matches(root,bond) && this[01;31m-[00m>_Right[01;31m-[00m>matches(root,bond) ) goto SUCCESS;
chemInfo.cc:505:	    if ( this[01;31m-[00m>_Left[01;31m-[00m>matches(root,bond) || this[01;31m-[00m>_Right[01;31m-[00m>matches(root,bond) ) goto SUCCESS;
chemInfo.cc:509:	    err << "Unknown logical operator(" << this[01;31m-[00m>_Operator << ")";
chemInfo.cc:510:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(err.str()));
chemInfo.cc:527:	{ "", [01;31m-[00m1 }
chemInfo.cc:532:    node[01;31m-[00m>attributeEnum( "op", this[01;31m-[00m>_Operator, logicalEnum );
chemInfo.cc:533:    node[01;31m-[00m>archiveObject( "left", this[01;31m-[00m>_Left );
chemInfo.cc:534:    node[01;31m-[00m>archiveObjectIfDefined( "right", this[01;31m-[00m>_Right );
chemInfo.cc:541:// [01;31m-[00m[01;31m-[00m[01;31m-[00m TagSet  set a tag for the atom
chemInfo.cc:557: {"",[01;31m-[00m1}
chemInfo.cc:563:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:564:    this[01;31m-[00m>_Bond = SABAnyBond;
chemInfo.cc:565:    this[01;31m-[00m>_AtomTest = O_AtomOrBondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:566:    this[01;31m-[00m>_RingTag = "";
chemInfo.cc:573:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:576:    LOG(BF("TagSet match for atom: %s") % atom[01;31m-[00m>description().c_str()  ); // vp0(( "TagSet match for atom: %s", atom[01;31m-[00m>description().c_str() ));
chemInfo.cc:577:    if ( root[01;31m-[00m>type() != chemInfo::smartsRoot ) {
chemInfo.cc:578:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Trying to carry out a TagSet with a non Smarts root"));
chemInfo.cc:581:    ASSERT_NOT_NULL(this[01;31m-[00m>_AtomTest);
chemInfo.cc:582:    if ( !this[01;31m-[00m>_AtomTest[01;31m-[00m>matches(root,atom) )
chemInfo.cc:589:    smartsRoot[01;31m-[00m>getMatch()[01;31m-[00m>defineAtomTag( atom, this[01;31m-[00m>_RingTag );
chemInfo.cc:590:    LOG(BF("RingTag (%s) defined atom: %s") % this[01;31m-[00m>_RingTag.c_str() % atom[01;31m-[00m>description().c_str()  ); // vp0(("RingTag (%s) defined atom: %s",this[01;31m-[00m>_RingTag.c_str(), atom[01;31m-[00m>description().c_str() ));
chemInfo.cc:601:    node[01;31m-[00m>attributeEnum( "bond", this[01;31m-[00m>_Bond, bondEnum );
chemInfo.cc:602:    node[01;31m-[00m>attribute("ringTag", this[01;31m-[00m>_RingTag );
chemInfo.cc:603:    node[01;31m-[00m>archiveObject("atomTest", this[01;31m-[00m>_AtomTest);
chemInfo.cc:612:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m RingTest
chemInfo.cc:617:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:618:    this[01;31m-[00m>_Bond = SABAnyBond;
chemInfo.cc:619:    this[01;31m-[00m>_AtomTest = O_AtomOrBondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:620:    this[01;31m-[00m>_RingTag = "";
chemInfo.cc:625:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:628:    LOG(BF("RingTest match for atom: %s") % atom[01;31m-[00m>description().c_str()  ); // vp0(( "RingTest match for atom: %s", atom[01;31m-[00m>description().c_str() ));
chemInfo.cc:629:    if ( root[01;31m-[00m>type() != chemInfo::smartsRoot ) {
chemInfo.cc:630:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Trying to carry out a RingTest with a non Smarts root"));
chemInfo.cc:633:    ASSERT_NOT_NULL(this[01;31m-[00m>_AtomTest);
chemInfo.cc:634:    if ( !this[01;31m-[00m>_AtomTest[01;31m-[00m>matches(root,atom) )
chemInfo.cc:643:    if ( !smartsRoot[01;31m-[00m>getMatch()[01;31m-[00m>recognizesAtomTag(this[01;31m-[00m>_RingTag) )
chemInfo.cc:645:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("We are trying to test the atomTag ("+this[01;31m-[00m>_RingTag+") but it doesn't exist!" ));
chemInfo.cc:648:    ringStartAtom = smartsRoot[01;31m-[00m>getMatch()[01;31m-[00m>getAtomWithTag(this[01;31m-[00m>_RingTag);
chemInfo.cc:649:    LOG(BF("      checking if %s matches ringStart atom: %s") % atom[01;31m-[00m>description().c_str() % ringStartAtom[01;31m-[00m>description().c_str()  ); // vp0(( "      checking if %s matches ringStart atom: %s", atom[01;31m-[00m>description().c_str(), ringStartAtom[01;31m-[00m>description().c_str() ));
chemInfo.cc:666:    node[01;31m-[00m>attributeEnum( "bond", this[01;31m-[00m>_Bond, bondEnum );
chemInfo.cc:667:    node[01;31m-[00m>attribute("ringTag", this[01;31m-[00m>_RingTag );
chemInfo.cc:668:    node[01;31m-[00m>archiveObject("atomTest", this[01;31m-[00m>_AtomTest);
chemInfo.cc:675:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m ResidueTest
chemInfo.cc:680:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:681:    this[01;31m-[00m>_Bond = SABAnyBond;
chemInfo.cc:682:    this[01;31m-[00m>_AtomTest = O_AtomOrBondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:683:    this[01;31m-[00m>_RingTag = "";
chemInfo.cc:688:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:691:    LOG(BF("ResidueTest match for atom: %s") % atom[01;31m-[00m>description().c_str()  ); // vp0(( "ResidueTest match for atom: %s", atom[01;31m-[00m>description().c_str() ));
chemInfo.cc:692:    if ( root[01;31m-[00m>type() != chemInfo::smartsRoot ) {
chemInfo.cc:693:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Trying to carry out a ResidueTest with a non Smarts root"));
chemInfo.cc:696:    ASSERT_NOT_NULL(this[01;31m-[00m>_AtomTest);
chemInfo.cc:697:    if ( !this[01;31m-[00m>_AtomTest[01;31m-[00m>matches(root,atom) )
chemInfo.cc:706:    if ( !smartsRoot[01;31m-[00m>getMatch()[01;31m-[00m>recognizesAtomTag(this[01;31m-[00m>_RingTag) )
chemInfo.cc:708:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("We are trying to test the atomTag ("+this[01;31m-[00m>_RingTag+") but it doesn't exist!" ));
chemInfo.cc:711:    ringAtom = smartsRoot[01;31m-[00m>getMatch()[01;31m-[00m>getAtomWithTag(this[01;31m-[00m>_RingTag);
chemInfo.cc:712:    LOG(BF("      checking if %s matches ringAtom: %s") % atom[01;31m-[00m>description().c_str() % ringAtom[01;31m-[00m>description().c_str()  ); // vp0(( "      checking if %s matches ringAtom: %s", atom[01;31m-[00m>description().c_str(), ringAtom[01;31m-[00m>description().c_str() ));
chemInfo.cc:713:    if ( ! atom[01;31m-[00m>containedByValid() )
chemInfo.cc:715:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(atom[01;31m-[00m>description()+" failed containedByValid()"));
chemInfo.cc:717:    if ( ! ringAtom[01;31m-[00m>containedByValid() )
chemInfo.cc:719:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ringAtom[01;31m-[00m>description()+" failed containedByValid()"));
chemInfo.cc:721:    LOG(BF("   atom[01;31m-[00m>containedBy()[01;31m-[00m>description() = %s") % atom[01;31m-[00m>containedByLock()[01;31m-[00m>description().c_str()  ); // vp0(( "   atom[01;31m-[00m>containedBy()[01;31m-[00m>description() = %s", atom[01;31m-[00m>containedByLock()[01;31m-[00m>description().c_str() ));
chemInfo.cc:722:    LOG(BF("   ringAtom[01;31m-[00m>containedBy()[01;31m-[00m>description() = %s") % ringAtom[01;31m-[00m>containedByLock()[01;31m-[00m>description().c_str()  ); // vp0(( "   ringAtom[01;31m-[00m>containedBy()[01;31m-[00m>description() = %s", ringAtom[01;31m-[00m>containedByLock()[01;31m-[00m>description().c_str() ));
chemInfo.cc:723:    if ( atom[01;31m-[00m>containedByLock().get()  == ringAtom[01;31m-[00m>containedByLock().get() )
chemInfo.cc:739:    node[01;31m-[00m>attributeEnum( "bond", this[01;31m-[00m>_Bond, bondEnum );
chemInfo.cc:740:    node[01;31m-[00m>attribute("ringTag", this[01;31m-[00m>_RingTag );
chemInfo.cc:741:    node[01;31m-[00m>archiveObject("atomTest", this[01;31m-[00m>_AtomTest);
chemInfo.cc:748:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m BondTest
chemInfo.cc:786:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Must implement SingleDirectionalDownOrUnspecified"));
chemInfo.cc:788:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Must implement SingleDirectionalUpOrUnspecified"));
chemInfo.cc:791:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Must implement directional bonds"));
chemInfo.cc:805:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:806:    this[01;31m-[00m>_Bond = SABNoBond;
chemInfo.cc:807:    this[01;31m-[00m>_AtomTest = O_AtomOrBondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:814:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:815:    LOG(BF("Checking bond: %s") % bond[01;31m-[00m>description().c_str()  ); // vp0(("Checking bond: %s",bond[01;31m-[00m>description().c_str() ));
chemInfo.cc:817:    bo = bond[01;31m-[00m>getOrder();
chemInfo.cc:818:    if ( !chemInfo::_matchBondTypes(this[01;31m-[00m>_Bond,bo,this[01;31m-[00m>lisp()) ) goto FAIL;
chemInfo.cc:819:    if ( this[01;31m-[00m>_AtomTest[01;31m-[00m>matches(root,bond[01;31m-[00m>getTo().lock()) ) goto SUCCESS;
chemInfo.cc:831:    node[01;31m-[00m>attributeEnum( "bond", this[01;31m-[00m>_Bond, bondEnum );
chemInfo.cc:832:    node[01;31m-[00m>archiveObject( "atomTest", this[01;31m-[00m>_AtomTest );
chemInfo.cc:839:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m AtomTest
chemInfo.cc:843:    this[01;31m-[00m>_Test = SAPNone;
chemInfo.cc:844:    this[01;31m-[00m>_IntArg = 0;
chemInfo.cc:845:    this[01;31m-[00m>_NumArg = 0;
chemInfo.cc:846:    this[01;31m-[00m>_StringArg = "";
chemInfo.cc:852:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:853:    switch ( this[01;31m-[00m>_Test ) 
chemInfo.cc:856:            if ( chemInfo::_matchBondTypes((chemInfo::BondEnum)this[01;31m-[00m>_IntArg,bond[01;31m-[00m>getOrder(),this[01;31m-[00m>lisp())) goto SUCCESS;
chemInfo.cc:859:            if (!chemInfo::_matchBondTypes((chemInfo::BondEnum)this[01;31m-[00m>_IntArg,bond[01;31m-[00m>getOrder(),this[01;31m-[00m>lisp())) goto SUCCESS;
chemInfo.cc:867:    if ( this[01;31m-[00m>matches(root,bond[01;31m-[00m>getTo().lock()) ) goto SUCCESS;
chemInfo.cc:878:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:882:    LOG(BF("AtomTest match for atom: %s") % atom[01;31m-[00m>description().c_str()  ); // vp0(( "AtomTest match for atom: %s",atom[01;31m-[00m>description().c_str() ));
chemInfo.cc:883:    switch ( this[01;31m-[00m>_Test ) {
chemInfo.cc:888:	    LOG(BF("SAPElement(%s) == expecting(%s)") % atom[01;31m-[00m>getElementAsString().c_str() % this[01;31m-[00m>_StringArg.c_str() ); // vp0(("SAPElement(%s) == expecting(%s)", atom[01;31m-[00m>getElementAsString().c_str(), this[01;31m-[00m>_StringArg.c_str()));
chemInfo.cc:889:	    if ( this[01;31m-[00m>_StringArg == atom[01;31m-[00m>getElementAsString() ) goto SUCCESS;
chemInfo.cc:892:	    LOG(BF("SAPAtomicNumber(%d) == expecting(%d)") % atom[01;31m-[00m>getAtomicNumber() % this[01;31m-[00m>_IntArg ); // vp0(("SAPAtomicNumber(%d) == expecting(%d)", atom[01;31m-[00m>getAtomicNumber(),this[01;31m-[00m>_IntArg));
chemInfo.cc:893:            if ( this[01;31m-[00m>_IntArg == atom[01;31m-[00m>getAtomicNumber() ) goto SUCCESS;
chemInfo.cc:896:            hc = atom[01;31m-[00m>getBondedHydrogenCount();
chemInfo.cc:897:	    LOG(BF("SAPTotalHCount(%d) == expecting(%d)") % hc % this[01;31m-[00m>_IntArg ); // vp0(("SAPTotalHCount(%d) == expecting(%d)", hc, this[01;31m-[00m>_IntArg));
chemInfo.cc:898:            LOG(BF("Checking total hydrogen count looking for(%d) got(%d)") % this[01;31m-[00m>_IntArg % hc ); // vp0(("Checking total hydrogen count looking for(%d) got(%d)",this[01;31m-[00m>_IntArg,hc));
chemInfo.cc:899:            if ( this[01;31m-[00m>_IntArg == hc ) {
chemInfo.cc:906:	    LOG(BF("SAPRingTest looking for tag: %s") % this[01;31m-[00m>_StringArg.c_str() % this[01;31m-[00m>_StringArg.c_str()  ); // vp0(("SAPRingTest looking for tag: %s",this[01;31m-[00m>_StringArg.c_str(),this[01;31m-[00m>_StringArg.c_str() ));
chemInfo.cc:907:	    if ( !root[01;31m-[00m>getMatch()[01;31m-[00m>recognizesAtomTag(this[01;31m-[00m>_StringArg) )
chemInfo.cc:909:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("We are trying to test the atomTag ("+this[01;31m-[00m>_StringArg+") but it doesn't exist!" ));
chemInfo.cc:912:	    ringStartAtom = root[01;31m-[00m>getMatch()[01;31m-[00m>getAtomWithTag(this[01;31m-[00m>_StringArg);
chemInfo.cc:913:	    LOG(BF("      checking if %s matches ringStart atom: %s") % atom[01;31m-[00m>description().c_str() % ringStartAtom[01;31m-[00m>description().c_str()  ); // vp0(( "      checking if %s matches ringStart atom: %s", atom[01;31m-[00m>description().c_str(), ringStartAtom[01;31m-[00m>description().c_str() ));
chemInfo.cc:921:	    LOG(BF("SAPResidueTest looking for tag: %s") % this[01;31m-[00m>_StringArg.c_str() % this[01;31m-[00m>_StringArg.c_str()   ); // vp0(("SAPResidueTest looking for tag: %s",this[01;31m-[00m>_StringArg.c_str(),this[01;31m-[00m>_StringArg.c_str()  ));
chemInfo.cc:922:	    if ( !root[01;31m-[00m>getMatch()[01;31m-[00m>recognizesAtomTag(this[01;31m-[00m>_StringArg) )
chemInfo.cc:924:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("We are trying to test the atomTag ("+this[01;31m-[00m>_StringArg+") but it doesn't exist!" ));
chemInfo.cc:927:	    ringStartAtom = root[01;31m-[00m>getMatch()[01;31m-[00m>getAtomWithTag(this[01;31m-[00m>_StringArg);
chemInfo.cc:928:	    LOG(BF("      checking if residue for %s matches residue for ringStart atom: %s") % atom[01;31m-[00m>description().c_str() % ringStartAtom[01;31m-[00m>description().c_str()  ); // vp0(( "      checking if residue for %s matches residue for ringStart atom: %s", atom[01;31m-[00m>description().c_str(), ringStartAtom[01;31m-[00m>description().c_str() ));
chemInfo.cc:929:	    if ( atom[01;31m-[00m>containedByLock().get() == ringStartAtom[01;31m-[00m>containedByLock().get() )
chemInfo.cc:940:            if ( this[01;31m-[00m>_IntArg == atom[01;31m-[00m>getIonization() ) goto SUCCESS;
chemInfo.cc:944:            if (this[01;31m-[00m>_IntArg == atom[01;31m-[00m>getRingMembershipCount()) goto SUCCESS;
chemInfo.cc:948:            if (atom[01;31m-[00m>inRingSize(this[01;31m-[00m>_IntArg)) goto SUCCESS;
chemInfo.cc:956:            if (this[01;31m-[00m>_IntArg == atom[01;31m-[00m>getValence()) goto SUCCESS;
chemInfo.cc:960:	    LOG(BF("SAPDegree testing if atom[01;31m-[00m>numberOfBonds(){%d} == this[01;31m-[00m>_IntArg{%d}") % atom[01;31m-[00m>numberOfBonds() % this[01;31m-[00m>_IntArg ); // vp0(("SAPDegree testing if atom[01;31m-[00m>numberOfBonds(){%d} == this[01;31m-[00m>_IntArg{%d}", atom[01;31m-[00m>numberOfBonds(), this[01;31m-[00m>_IntArg));
chemInfo.cc:961:            if (this[01;31m-[00m>_IntArg == atom[01;31m-[00m>numberOfBonds()) goto SUCCESS;
chemInfo.cc:966:            for ( int i=0; i<atom[01;31m-[00m>numberOfBonds(); i++ ) {
chemInfo.cc:967:                if ( chemInfo::_matchBondTypes((chemInfo::BondEnum)this[01;31m-[00m>_IntArg,atom[01;31m-[00m>bondedOrder(i),this[01;31m-[00m>lisp())) cnt++;
chemInfo.cc:969:            if ( cnt == this[01;31m-[00m>_NumArg ) goto SUCCESS;
chemInfo.cc:973:            switch ( this[01;31m-[00m>_IntArg ) {
chemInfo.cc:975:                    if ( atom[01;31m-[00m>getMembershipAr1() != 0 ) goto SUCCESS;
chemInfo.cc:978:                    if ( atom[01;31m-[00m>getMembershipAr2() != 0 ) goto SUCCESS;
chemInfo.cc:981:                    if ( atom[01;31m-[00m>getMembershipAr3() != 0 ) goto SUCCESS;
chemInfo.cc:984:                    if ( atom[01;31m-[00m>getMembershipAr4() != 0 ) goto SUCCESS;
chemInfo.cc:987:                    if ( atom[01;31m-[00m>getMembershipAr5() != 0 ) goto SUCCESS;
chemInfo.cc:993:            if ( !atom[01;31m-[00m>isInRing() ) goto SUCCESS;
chemInfo.cc:997:            if ( atom[01;31m-[00m>getElement() == element_O ) goto SUCCESS;
chemInfo.cc:998:            if ( atom[01;31m-[00m>getElement() == element_N ) goto SUCCESS;
chemInfo.cc:999:            if ( atom[01;31m-[00m>getElement() == element_F ) goto SUCCESS;
chemInfo.cc:1000:            if ( atom[01;31m-[00m>getElement() == element_Cl ) goto SUCCESS;
chemInfo.cc:1001:            if ( atom[01;31m-[00m>getElement() == element_Br ) goto SUCCESS;
chemInfo.cc:1005:	    ss << "You must implement a test for: " << this[01;31m-[00m>testName(this[01;31m-[00m>_Test);
chemInfo.cc:1006:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str() ));
chemInfo.cc:1066:	{ "", [01;31m-[00m1 }
chemInfo.cc:1070:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1071:    for ( uint i=0; testEnum[i]._Enum != [01;31m-[00m1; i++ )
chemInfo.cc:1078:    return "[01;31m-[00munknownTest[01;31m-[00m";
chemInfo.cc:1083:    node[01;31m-[00m>attributeEnum( "test", this[01;31m-[00m>_Test, testEnum );
chemInfo.cc:1084:    node[01;31m-[00m>attributeIfNotDefault( "int", this[01;31m-[00m>_IntArg, 0 );
chemInfo.cc:1085:    node[01;31m-[00m>attributeIfNotDefault( "num", this[01;31m-[00m>_NumArg, 0 );
chemInfo.cc:1086:    node[01;31m-[00m>attributeIfNotDefault<string>( "str", this[01;31m-[00m>_StringArg, "" );
chemInfo.cc:1095:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m Chain
chemInfo.cc:1100:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:1101:    this[01;31m-[00m>_Head = O_BondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1102:    this[01;31m-[00m>_Tail = O_BondListMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1107:    if ( this[01;31m-[00m>isNil() ) return 0;
chemInfo.cc:1108:    return MAX(this[01;31m-[00m>_Head[01;31m-[00m>depth(),this[01;31m-[00m>_Tail[01;31m-[00m>depth()+1);
chemInfo.cc:1112:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1115:    LOG(BF("There are %d neighbors bondList: %s") % neighbors[01;31m-[00m>size() % neighbors[01;31m-[00m>description().c_str()  ); // vp0(("There are %d neighbors bondList: %s",neighbors[01;31m-[00m>size(),neighbors[01;31m-[00m>description().c_str() ));
chemInfo.cc:1116:    for ( bi=neighbors[01;31m-[00m>begin(); bi!=neighbors[01;31m-[00m>end(); bi++ )
chemInfo.cc:1117:    { _BLOCK_TRACEF(BF("Checking neighbor for bond: %s") % (*bi)[01;31m-[00m>description().c_str() );
chemInfo.cc:1118:	if ( this[01;31m-[00m>_Head[01;31m-[00m>matches(root,*bi) )
chemInfo.cc:1121://	    nextBonds = (*bi)[01;31m-[00m>getTo().lock()[01;31m-[00m>getHeavyAtomBondList();
chemInfo.cc:1122:	    nextBonds = (*bi)[01;31m-[00m>getTo().lock()[01;31m-[00m>getBondList();
chemInfo.cc:1123:	    nextBonds[01;31m-[00m>removeBondTo((*bi)[01;31m-[00m>getFrom().lock());
chemInfo.cc:1124:	    ASSERT_NOT_NULL(this[01;31m-[00m>_Tail);
chemInfo.cc:1125:	    if ( this[01;31m-[00m>_Tail[01;31m-[00m>notNil() )
chemInfo.cc:1127:		if ( this[01;31m-[00m>_Tail[01;31m-[00m>matches(root,nextBonds) ) goto SUCCESS;
chemInfo.cc:1145:    node[01;31m-[00m>archiveObjectIfDefined("head",this[01;31m-[00m>_Head);
chemInfo.cc:1146:    node[01;31m-[00m>archiveObjectIfDefined("tail",this[01;31m-[00m>_Tail);
chemInfo.cc:1152:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m Branch
chemInfo.cc:1156:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:1157:    this[01;31m-[00m>_Left = O_BondListMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1158:    this[01;31m-[00m>_Right = O_BondListMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1162:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1163:    if ( this[01;31m-[00m>isNil() ) return 0;
chemInfo.cc:1164:    return MAX(this[01;31m-[00m>_Left[01;31m-[00m>depth(),this[01;31m-[00m>_Right[01;31m-[00m>depth());
chemInfo.cc:1168:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1173:    for ( bi=neighbors[01;31m-[00m>begin(); bi!=neighbors[01;31m-[00m>end(); bi++ ) {
chemInfo.cc:1174:	_BLOCK_TRACEF(BF("Checking neighbors focusing on %s") % (*bi)[01;31m-[00m>description().c_str());
chemInfo.cc:1175:	LOG(BF("Neighbors bond list= %s") % neighbors[01;31m-[00m>description().c_str()  ); // vp0(("Neighbors bond list= %s",neighbors[01;31m-[00m>description().c_str() ));
chemInfo.cc:1176:	leftBondList = O_BondList::create(this[01;31m-[00m>lisp());
chemInfo.cc:1177:	leftBondList[01;31m-[00m>addBond(*bi);
chemInfo.cc:1179:	LOG(BF("Left bond list = %s") % leftBondList[01;31m-[00m>description().c_str()  ); // vp0(("Left bond list = %s",leftBondList[01;31m-[00m>description().c_str() ));
chemInfo.cc:1180:	rightBondList = neighbors[01;31m-[00m>copy();
chemInfo.cc:1181:	LOG(BF("Right bond list after copy = %s") % rightBondList[01;31m-[00m>description().c_str()  ); // vp0(("Right bond list after copy = %s",rightBondList[01;31m-[00m>description().c_str() ));
chemInfo.cc:1182:	rightBondList[01;31m-[00m>removeBond(*bi);
chemInfo.cc:1184:	LOG(BF("Right bond list after remove left = %s") % rightBondList[01;31m-[00m>description().c_str()  ); // vp0(("Right bond list after remove left = %s",rightBondList[01;31m-[00m>description().c_str() ));
chemInfo.cc:1186:	if ( this[01;31m-[00m>_Left[01;31m-[00m>matches(root,leftBondList) ) {
chemInfo.cc:1188:	    ANN(this[01;31m-[00m>_Right);
chemInfo.cc:1189:	    if ( this[01;31m-[00m>_Right[01;31m-[00m>notNil() )
chemInfo.cc:1192:		if ( this[01;31m-[00m>_Right[01;31m-[00m>matches(root,rightBondList) ) {
chemInfo.cc:1217:    node[01;31m-[00m>archiveObject("left",this[01;31m-[00m>_Left);
chemInfo.cc:1218:    node[01;31m-[00m>archiveObjectIfDefined("right",this[01;31m-[00m>_Right);
chemInfo.cc:1230:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m AfterMatchBondTest
chemInfo.cc:1234:    this[01;31m-[00m>_AtomTag1 = "";
chemInfo.cc:1235:    this[01;31m-[00m>_AtomTag2 = "";
chemInfo.cc:1236:    this[01;31m-[00m>_Bond = SABNoBond;
chemInfo.cc:1243:    node[01;31m-[00m>attribute( "tag1", this[01;31m-[00m>_AtomTag1 );
chemInfo.cc:1244:    node[01;31m-[00m>attribute( "tag2", this[01;31m-[00m>_AtomTag2 );
chemInfo.cc:1245:    node[01;31m-[00m>attributeEnum( "bond", this[01;31m-[00m>_Bond, bondEnum );
chemInfo.cc:1252:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Must implement"));
chemInfo.cc:1258:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m AntechamberFocusAtomMatch
chemInfo.cc:1262:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:1263:    this[01;31m-[00m>_ResidueNames = O_ResidueList::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1264:    this[01;31m-[00m>_AtomicNumber = 0;
chemInfo.cc:1265:    this[01;31m-[00m>_NumberOfAttachedAtoms = 0;
chemInfo.cc:1266:    this[01;31m-[00m>_NumberOfAttachedHydrogens = 0;
chemInfo.cc:1267:    this[01;31m-[00m>_NumberOfElectronWithdrawingGroups = 0;
chemInfo.cc:1268:    this[01;31m-[00m>_AtomicProperty = O_AtomOrBondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1274:    node[01;31m-[00m>archiveObjectIfDefined("residueNames",this[01;31m-[00m>_ResidueNames);
chemInfo.cc:1275:    node[01;31m-[00m>archiveObjectIfDefined("atomicProperty",this[01;31m-[00m>_AtomicProperty);
chemInfo.cc:1276:    node[01;31m-[00m>attribute("atomicNumber",this[01;31m-[00m>_AtomicNumber);
chemInfo.cc:1277:    node[01;31m-[00m>attribute("attachedAtoms",this[01;31m-[00m>_NumberOfAttachedAtoms);
chemInfo.cc:1278:    node[01;31m-[00m>attribute("attachedHs",this[01;31m-[00m>_NumberOfAttachedHydrogens);
chemInfo.cc:1279:    node[01;31m-[00m>attribute("attachedEWGs",this[01;31m-[00m>_NumberOfElectronWithdrawingGroups);
chemInfo.cc:1288:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1290:    if ( this[01;31m-[00m>_AtomicNumber >=0 ) {
chemInfo.cc:1291:	LOG(BF("Checking if atomic number(%d) == expected(%d)") % atom[01;31m-[00m>getAtomicNumber() % this[01;31m-[00m>_AtomicNumber  ); // vp0(( "Checking if atomic number(%d) == expected(%d)", atom[01;31m-[00m>getAtomicNumber(), this[01;31m-[00m>_AtomicNumber ));
chemInfo.cc:1292:        if ( atom[01;31m-[00m>getAtomicNumber() != this[01;31m-[00m>_AtomicNumber ) goto FAIL;
chemInfo.cc:1294:    if ( this[01;31m-[00m>_NumberOfAttachedAtoms >=0 ) {
chemInfo.cc:1295:	LOG(BF("Checking if number of bonds(%d) == expected(%d)") % atom[01;31m-[00m>numberOfBonds() % this[01;31m-[00m>_NumberOfAttachedAtoms ); // vp0(( "Checking if number of bonds(%d) == expected(%d)", atom[01;31m-[00m>numberOfBonds(), this[01;31m-[00m>_NumberOfAttachedAtoms));
chemInfo.cc:1296:        if ( atom[01;31m-[00m>numberOfBonds() != this[01;31m-[00m>_NumberOfAttachedAtoms ) goto FAIL;
chemInfo.cc:1298:    if ( this[01;31m-[00m>_NumberOfAttachedHydrogens >=0 ){
chemInfo.cc:1299:	LOG(BF("Checking if number of attached hydrogens(%d) == expected(%d)") % atom[01;31m-[00m>getBondedHydrogenCount() % this[01;31m-[00m>_NumberOfAttachedHydrogens  ); // vp0(( "Checking if number of attached hydrogens(%d) == expected(%d)", atom[01;31m-[00m>getBondedHydrogenCount(), this[01;31m-[00m>_NumberOfAttachedHydrogens ));
chemInfo.cc:1300:        if ( atom[01;31m-[00m>getBondedHydrogenCount() != this[01;31m-[00m>_NumberOfAttachedHydrogens ) goto FAIL;
chemInfo.cc:1302:    if ( this[01;31m-[00m>_NumberOfElectronWithdrawingGroups >=0 ) {
chemInfo.cc:1303:        if ( atom[01;31m-[00m>numberOfBonds() != 1 ) {
chemInfo.cc:1304:            TOSS(_lisp[01;31m-[00m>create<O_LispError>("Testing NumberOfElectronWithdrawingGroups must have one bond"));
chemInfo.cc:1306:        neighbor = atom[01;31m-[00m>bondedNeighbor(0);
chemInfo.cc:1308:        for ( int i=0; i<neighbor[01;31m-[00m>numberOfBonds(); i++ ) {
chemInfo.cc:1309:            nn = neighbor[01;31m-[00m>bondedNeighbor(i);
chemInfo.cc:1310:            if ( nn[01;31m-[00m>getElement() == element_N ) cnt++;
chemInfo.cc:1311:            if ( nn[01;31m-[00m>getElement() == element_O ) cnt++;
chemInfo.cc:1312:            if ( nn[01;31m-[00m>getElement() == element_F ) cnt++;
chemInfo.cc:1313:            if ( nn[01;31m-[00m>getElement() == element_Cl ) cnt++;
chemInfo.cc:1314:            if ( nn[01;31m-[00m>getElement() == element_Br ) cnt++;
chemInfo.cc:1316:	LOG(BF("Checking if number of electron withdrawing groups(%d) == expected(%d)") % cnt % this[01;31m-[00m>_NumberOfElectronWithdrawingGroups ); // vp0(( "Checking if number of electron withdrawing groups(%d) == expected(%d)", cnt, this[01;31m-[00m>_NumberOfElectronWithdrawingGroups));
chemInfo.cc:1317:        if ( cnt != this[01;31m-[00m>_NumberOfElectronWithdrawingGroups ) goto FAIL;
chemInfo.cc:1319:    ANN(this[01;31m-[00m>_AtomicProperty);
chemInfo.cc:1320:    if ( this[01;31m-[00m>_AtomicProperty[01;31m-[00m>notNil() ) {
chemInfo.cc:1321:        if ( !this[01;31m-[00m>_AtomicProperty[01;31m-[00m>matches(root,atom) ) goto FAIL;
chemInfo.cc:1335:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m AntechamberBondTest
chemInfo.cc:1338:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1341:    dict = root[01;31m-[00m>getElementWildCardDictionary();
chemInfo.cc:1344:    if ( dict[01;31m-[00m>notNil() )
chemInfo.cc:1346:        if ( dict[01;31m-[00m>recognizesWildName(this[01;31m-[00m>_Element) ) {
chemInfo.cc:1347:	    LOG(BF("Matching wildcard element has(%s) == expecting (%s)") % atom[01;31m-[00m>getElementAsString().c_str() % this[01;31m-[00m>_Element.c_str() ); // vp0(( "Matching wildcard element has(%s) == expecting (%s)",atom[01;31m-[00m>getElementAsString().c_str(),this[01;31m-[00m>_Element.c_str()));
chemInfo.cc:1348:            if ( !dict[01;31m-[00m>recognizesWildNameElement(this[01;31m-[00m>_Element,atom[01;31m-[00m>getElementAsString() ) ) goto FAIL;
chemInfo.cc:1354:        LOG(BF("Trying to match regular element(%s) == expected(%s)") % atom[01;31m-[00m>getElementAsString().c_str() % this[01;31m-[00m>_Element.c_str() ); // vp0(( "Trying to match regular element(%s) == expected(%s)", atom[01;31m-[00m>getElementAsString().c_str(),this[01;31m-[00m>_Element.c_str()));
chemInfo.cc:1355:        if ( atom[01;31m-[00m>getElementAsString() != this[01;31m-[00m>_Element ) goto FAIL;
chemInfo.cc:1357:    LOG(BF("Trying to match number of bonds(%d) == expected(%d)") % atom[01;31m-[00m>numberOfBonds() % this[01;31m-[00m>_Neighbors ); // vp0(( "Trying to match number of bonds(%d) == expected(%d)",atom[01;31m-[00m>numberOfBonds(),this[01;31m-[00m>_Neighbors));
chemInfo.cc:1358:    if ( this[01;31m-[00m>_Neighbors >=0 ) {
chemInfo.cc:1359:        if ( atom[01;31m-[00m>numberOfBonds() != this[01;31m-[00m>_Neighbors ) goto FAIL;
chemInfo.cc:1361:    if ( this[01;31m-[00m>_Tag != "" ) {
chemInfo.cc:1362:        root[01;31m-[00m>getMatch()[01;31m-[00m>defineAtomTag( atom, this[01;31m-[00m>_Tag );
chemInfo.cc:1373:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1375:    if ( root[01;31m-[00m>type() != antechamberRoot ) {
chemInfo.cc:1376:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("AntechamberBondTest::matches requires an AntechamberRoot"));
chemInfo.cc:1379:    if ( !this[01;31m-[00m>matchBasic(acRoot,atom) ) goto FAIL;
chemInfo.cc:1380:    if ( this[01;31m-[00m>_AtomProperties[01;31m-[00m>matches(acRoot,atom) ) goto SUCCESS;
chemInfo.cc:1390:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1392:    if ( root[01;31m-[00m>type() != chemInfo::antechamberRoot ) {
chemInfo.cc:1395:            << "instead we have" << (unsigned long)(root.get()) << " of type: " << root[01;31m-[00m>type();
chemInfo.cc:1396:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
chemInfo.cc:1399:    if ( !this[01;31m-[00m>matchBasic(antechamberRoot,bond[01;31m-[00m>getTo().lock()) ) goto FAIL;
chemInfo.cc:1400:    ANN(this[01;31m-[00m>_AtomProperties);
chemInfo.cc:1401:    if ( this[01;31m-[00m>_AtomProperties[01;31m-[00m>notNil() )
chemInfo.cc:1403:        if ( !this[01;31m-[00m>_AtomProperties[01;31m-[00m>matches(antechamberRoot,bond) ) goto FAIL;
chemInfo.cc:1416:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:1417:    this[01;31m-[00m>_Element = "";
chemInfo.cc:1418:    this[01;31m-[00m>_Neighbors = 0;
chemInfo.cc:1419:    this[01;31m-[00m>_AtomProperties.reset();
chemInfo.cc:1420:    this[01;31m-[00m>_Tag = "";
chemInfo.cc:1421:    this[01;31m-[00m>_AtomProperties = O_AtomOrBondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1428:    node[01;31m-[00m>attribute("element",this[01;31m-[00m>_Element);
chemInfo.cc:1429:    node[01;31m-[00m>attribute("neighbors", this[01;31m-[00m>_Neighbors );
chemInfo.cc:1430:    node[01;31m-[00m>attribute("tag",this[01;31m-[00m>_Tag);
chemInfo.cc:1431:    node[01;31m-[00m>archiveObjectIfDefined("atomProps", this[01;31m-[00m>_AtomProperties);
chemInfo.cc:1440:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m Root
chemInfo.cc:1444:    if ( this[01;31m-[00m>isNil() ) return 0;
chemInfo.cc:1445:    return MAX(this[01;31m-[00m>_FirstTest[01;31m-[00m>depth(),this[01;31m-[00m>_Chain[01;31m-[00m>depth()+1);
chemInfo.cc:1449:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:1450:    this[01;31m-[00m>_FirstTest = O_AtomOrBondMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1451:    this[01;31m-[00m>_Chain = O_BondListMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1452:    this[01;31m-[00m>_Match = O_ChemInfoMatch::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1459:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1460:    node[01;31m-[00m>archiveObjectIfDefined("firstTest",this[01;31m-[00m>_FirstTest);
chemInfo.cc:1461:    node[01;31m-[00m>archiveObjectIfDefined("chain",this[01;31m-[00m>_Chain);
chemInfo.cc:1463:    LOG(BF("After load chain=%s") % this[01;31m-[00m>_Chain[01;31m-[00m>description().c_str()  ); // vp0(("After load chain=%s",this[01;31m-[00m>_Chain[01;31m-[00m>description().c_str() ));
chemInfo.cc:1469:    return this[01;31m-[00m>matches(root,bond[01;31m-[00m>getTo().lock());
chemInfo.cc:1476:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1480:    ANN(this[01;31m-[00m>_FirstTest);
chemInfo.cc:1481:    if ( this[01;31m-[00m>_FirstTest[01;31m-[00m>notNil() )
chemInfo.cc:1483:        if ( !this[01;31m-[00m>_FirstTest[01;31m-[00m>matches(root,atom) ) goto FAIL;
chemInfo.cc:1485:    ANN(this[01;31m-[00m>_Chain);
chemInfo.cc:1486:    if ( this[01;31m-[00m>_Chain[01;31m-[00m>notNil() )
chemInfo.cc:1488://	nextBonds = atom[01;31m-[00m>getHeavyAtomBondList();
chemInfo.cc:1489:	nextBonds = atom[01;31m-[00m>getBondList();
chemInfo.cc:1490:        if ( !this[01;31m-[00m>_Chain[01;31m-[00m>matches(root,nextBonds) ) {
chemInfo.cc:1516:    this[01;31m-[00m>Base::archiveBase(node);
chemInfo.cc:1521:    this[01;31m-[00m>archiveBase(node);
chemInfo.cc:1527:    return this[01;31m-[00m>matches(root,bond[01;31m-[00m>getTo().lock());
chemInfo.cc:1532:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1536:    LOG(BF("Root match for atom: %s") % atom[01;31m-[00m>description().c_str()  ); // vp0(( "Root match for atom: %s", atom[01;31m-[00m>description().c_str() ));
chemInfo.cc:1537:    if ( !this[01;31m-[00m>O_Root::matches(root,atom) ) goto FAIL;
chemInfo.cc:1549:    this[01;31m-[00m>Base::initialize();
chemInfo.cc:1550:    this[01;31m-[00m>_AssignType = "";
chemInfo.cc:1551:    this[01;31m-[00m>_AfterMatchTests = O_RootMatchNode::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1552:    this[01;31m-[00m>_WildElementDictionary = O_WildElementDict::nil(this[01;31m-[00m>lisp());
chemInfo.cc:1557:    this[01;31m-[00m>Base::archiveBase(node);
chemInfo.cc:1558:    node[01;31m-[00m>attribute( "assignType", this[01;31m-[00m>_AssignType );
chemInfo.cc:1559:    node[01;31m-[00m>archiveObjectIfDefined( "afterMatchTests", this[01;31m-[00m>_AfterMatchTests );
chemInfo.cc:1560:    node[01;31m-[00m>archiveObjectIfDefined( "wildDict", this[01;31m-[00m>_WildElementDictionary);
chemInfo.cc:1566:    this[01;31m-[00m>archiveBase(node);
chemInfo.cc:1572:    return this[01;31m-[00m>matches(root,bond[01;31m-[00m>getTo().lock());
chemInfo.cc:1581:{_F(this[01;31m-[00m>lisp());
chemInfo.cc:1585:    if ( !this[01;31m-[00m>Base::matches(root, atom )) {
chemInfo.cc:1588:    ANN(this[01;31m-[00m>_AfterMatchTests);
chemInfo.cc:1589:    if ( this[01;31m-[00m>_AfterMatchTests[01;31m-[00m>notNil() )
chemInfo.cc:1591:        if ( !this[01;31m-[00m>_AfterMatchTests[01;31m-[00m>matches(root) ) {
chemInfo.cc:1595:    atom[01;31m-[00m>setTypeString(this[01;31m-[00m>_AssignType);
chemInfo.cc:1596:    LOG(BF("Matched and assigned type(%s)") % this[01;31m-[00m>_AssignType.c_str() ); // vp0(( "Matched and assigned type(%s)",this[01;31m-[00m>_AssignType.c_str()));
chemInfo.cc:1631:    sstr << e._code[01;31m-[00m>compilerMessage() << endl;
chemInfo.cc:1641:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_ChemInfo>(args,environ);
chemInfo.cc:1643:    this[01;31m-[00m>compileSmarts(smarts);
chemInfo.cc:1644:    if ( !this[01;31m-[00m>compileSucceeded() )
chemInfo.cc:1646:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(this[01;31m-[00m>compilerMessage()));
chemInfo.cc:1648:    return lisp[01;31m-[00m>onil();
chemInfo.cc:1663:    class_<chemInfo::O_ChemInfoMatch>(this[01;31m-[00m>lisp())
chemInfo.cc:1696:    class_<chemInfo::O_WildElementDict>(this[01;31m-[00m>lisp())
chemInfo.cc:1723:    class_<O_ChemInfo>(this[01;31m-[00m>lisp())
chemdraw.cc:35:    this[01;31m-[00m>Base::initialize();
chemdraw.cc:36:    this[01;31m-[00m>_Atom = O_Atom::nil(this[01;31m-[00m>lisp());
chemdraw.cc:42:    if ( node[01;31m-[00m>hasChildrenWithName("t") )
chemdraw.cc:44:	RPQDomNode text = node[01;31m-[00m>childWithName("t");
chemdraw.cc:45:	if ( text[01;31m-[00m>hasChildrenWithName("s") )
chemdraw.cc:47:	    RPQDomNode xmls = text[01;31m-[00m>childWithName("s");
chemdraw.cc:48:	    string name = xmls[01;31m-[00m>getData();
chemdraw.cc:52:    return "C_"+node[01;31m-[00m>getAttributeString("id");
chemdraw.cc:57:    this[01;31m-[00m>_Id = xml[01;31m-[00m>getAttributeInt("id");
chemdraw.cc:58:    this[01;31m-[00m>_Label = this[01;31m-[00m>_parseLabel(xml);
chemdraw.cc:67:    this[01;31m-[00m>_Neighbors.push_back(bd);
chemdraw.cc:72:    this[01;31m-[00m>bondTo(other,o);
chemdraw.cc:73:    other[01;31m-[00m>bondTo(this[01;31m-[00m>sharedThis<O_CDNode>(),o);
chemdraw.cc:79:    this[01;31m-[00m>Base::initialize();
chemdraw.cc:80:    this[01;31m-[00m>_BeginNode = O_CDNode::nil(this[01;31m-[00m>lisp());
chemdraw.cc:81:    this[01;31m-[00m>_EndNode = O_CDNode::nil(this[01;31m-[00m>lisp());
chemdraw.cc:86:    switch ( this[01;31m-[00m>_Order )
chemdraw.cc:103:    switch ( this[01;31m-[00m>_Order )
chemdraw.cc:121:    this[01;31m-[00m>_IdBegin = xml[01;31m-[00m>getAttributeInt("B");
chemdraw.cc:122:    this[01;31m-[00m>_IdEnd = xml[01;31m-[00m>getAttributeInt("E");
chemdraw.cc:123:    string order = xml[01;31m-[00m>getAttributeStringDefault("Order","1");
chemdraw.cc:124:    string display = xml[01;31m-[00m>getAttributeStringDefault("Display","");
chemdraw.cc:129:	    this[01;31m-[00m>_Order = singleDashCDBond;
chemdraw.cc:132:	    this[01;31m-[00m>_Order = hashCDBond;
chemdraw.cc:135:	    this[01;31m-[00m>_Order = singleCDBond;
chemdraw.cc:139:	if ( display == "Dash" ) this[01;31m-[00m>_Order = doubleDashCDBond;
chemdraw.cc:142:	this[01;31m-[00m>_Order = doubleCDBond;
chemdraw.cc:145:	this[01;31m-[00m>_Order = tripleCDBond;
chemdraw.cc:148:	this[01;31m-[00m>_Order = dativeCDBond;
chemdraw.cc:151:	this[01;31m-[00m>_Order = unknownCDBond;
chemdraw.cc:158:    this[01;31m-[00m>Base::initialize();
chemdraw.cc:159:    this[01;31m-[00m>_ConstitutionName = "";
chemdraw.cc:160:    this[01;31m-[00m>_Nodes.clear();
chemdraw.cc:161:    this[01;31m-[00m>_AtomsToNodes.clear();
chemdraw.cc:162:    this[01;31m-[00m>_Bonds.clear();
chemdraw.cc:163:    this[01;31m-[00m>_LargestId = [01;31m-[00m1;
chemdraw.cc:164:    this[01;31m-[00m>_RootNode = O_CDNode::nil(this[01;31m-[00m>lisp());
chemdraw.cc:169:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:170:    RPAtom fromAtom = fromNode[01;31m-[00m>getAtom();
chemdraw.cc:171:    LOG(BF("From %s") % fromAtom[01;31m-[00m>description().c_str()  ); // vp0(("From %s", fromAtom[01;31m-[00m>description().c_str() ));
chemdraw.cc:172:    RPAtom a = O_Atom::create(this[01;31m-[00m>lisp());
chemdraw.cc:173:    a[01;31m-[00m>setContainedBy(O_Residue::nil(this[01;31m-[00m>lisp()));
chemdraw.cc:174:    a[01;31m-[00m>setName(name);
chemdraw.cc:175:    a[01;31m-[00m>setElement(element_H);
chemdraw.cc:177:    fromAtom[01;31m-[00m>bondTo(a,singleBond);
chemdraw.cc:178:    RPCDNode toNode = RP_Create<O_CDNode>(this[01;31m-[00m>lisp());
chemdraw.cc:179:    toNode[01;31m-[00m>setAtom(a);
chemdraw.cc:180:    toNode[01;31m-[00m>setLabel(name);
chemdraw.cc:181:    toNode[01;31m-[00m>setId(this[01;31m-[00m>_LargestId+1);
chemdraw.cc:182:    this[01;31m-[00m>_LargestId++;
chemdraw.cc:183:    this[01;31m-[00m>_Nodes[toNode[01;31m-[00m>getId()] = toNode;
chemdraw.cc:184:    this[01;31m-[00m>_AtomsToNodes[a] = toNode;
chemdraw.cc:185:    RPCDBond bond = RP_Create<O_CDBond>(this[01;31m-[00m>lisp());
chemdraw.cc:186:    bond[01;31m-[00m>setIdBegin(fromNode[01;31m-[00m>getId());
chemdraw.cc:187:    bond[01;31m-[00m>setIdEnd(toNode[01;31m-[00m>getId());
chemdraw.cc:188:    bond[01;31m-[00m>setBeginNode(fromNode);
chemdraw.cc:189:    bond[01;31m-[00m>setEndNode(toNode);
chemdraw.cc:190:    bond[01;31m-[00m>setOrder(singleCDBond);
chemdraw.cc:191:    this[01;31m-[00m>_Bonds.push_back(bond);
chemdraw.cc:197:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:199:    this[01;31m-[00m>_Nodes.clear();
chemdraw.cc:200:    this[01;31m-[00m>_AtomsToNodes.clear();
chemdraw.cc:201:    for ( it=fragment[01;31m-[00m>begin_Children(); it!=fragment[01;31m-[00m>end_Children(); it++ )
chemdraw.cc:204:	if ( child[01;31m-[00m>getLocalName() == "n" )
chemdraw.cc:206:	    RPCDNode node = RP_Create<O_CDNode>(this[01;31m-[00m>lisp());
chemdraw.cc:207:	    node[01;31m-[00m>parseFromXml(child);
chemdraw.cc:208:	    int id = node[01;31m-[00m>getId();
chemdraw.cc:209:	    if ( id > this[01;31m-[00m>_LargestId )
chemdraw.cc:210:		this[01;31m-[00m>_LargestId = id;
chemdraw.cc:211:	    this[01;31m-[00m>_Nodes[id] = node;
chemdraw.cc:212:	    LOG(BF("Processed node label(%s)") % node[01;31m-[00m>getLabel().c_str()  ); // vp0(( "Processed node label(%s)", node[01;31m-[00m>getLabel().c_str() ));
chemdraw.cc:215:    for ( it=fragment[01;31m-[00m>begin_Children(); it!=fragment[01;31m-[00m>end_Children(); it++ )
chemdraw.cc:218:	if ( child[01;31m-[00m>getLocalName() == "b" )
chemdraw.cc:220:	    RPCDBond bond = RP_Create<O_CDBond>(this[01;31m-[00m>lisp());
chemdraw.cc:221:	    bond[01;31m-[00m>parseFromXml(child);
chemdraw.cc:222:	    uint idBegin = bond[01;31m-[00m>getIdBegin();
chemdraw.cc:223:	    uint idEnd = bond[01;31m-[00m>getIdEnd();
chemdraw.cc:224:	    ASSERT(this[01;31m-[00m>_Nodes.count(idBegin)>0);
chemdraw.cc:225:	    ASSERT(this[01;31m-[00m>_Nodes.count(idEnd)>0);
chemdraw.cc:226:	    RPCDNode nodeBegin = this[01;31m-[00m>_Nodes[idBegin];
chemdraw.cc:227:	    RPCDNode nodeEnd = this[01;31m-[00m>_Nodes[idEnd];
chemdraw.cc:228:	    bond[01;31m-[00m>setBeginNode( nodeBegin );
chemdraw.cc:229:	    bond[01;31m-[00m>setEndNode( nodeEnd);
chemdraw.cc:230:	    this[01;31m-[00m>_Bonds.push_back(bond);
chemdraw.cc:231:	    LOG(BF("Processed bond order(%s) from(%s) to (%s)") % bond[01;31m-[00m>getOrderAsString().c_str() % nodeBegin[01;31m-[00m>getLabel().c_str() % nodeEnd[01;31m-[00m>getLabel().c_str()  ); // vp0(( "Processed bond order(%s) from(%s) to (%s)", bond[01;31m-[00m>getOrderAsString().c_str(), nodeBegin[01;31m-[00m>getLabel().c_str(), nodeEnd[01;31m-[00m>getLabel().c_str() ));
chemdraw.cc:238:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:239:    this[01;31m-[00m>_Properties[01;31m-[00m>addAllBindings(d);
chemdraw.cc:249:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:259:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is an error in a ChemDraw file, the string["+label+"] should be a key:value pair"));
chemdraw.cc:263:	    // trim off white[01;31m-[00mspace and put it in the _Properties
chemdraw.cc:266:    keyword = this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(trimKey);
chemdraw.cc:267:    obj = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(trimValue);
chemdraw.cc:275:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:276:    return this[01;31m-[00m>_Variables.count(key)>0;
chemdraw.cc:280:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:281:    ASSERT(this[01;31m-[00m>_Variables.count(key)>0);
chemdraw.cc:282:    return this[01;31m-[00m>_Variables.get(key);
chemdraw.cc:286:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:287:    if ( key.rfind("residue") == key.size()[01;31m-[00mstrlen("residue") )
chemdraw.cc:289:	if ( !obj[01;31m-[00m>isAssignableTo<O_Residue>() )
chemdraw.cc:291:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You are trying to set the (%s) variable to an object that is not a Residue [01;31m-[00m its class is(%s) its value is(%s)")%key%obj[01;31m-[00m>className()%obj[01;31m-[00m>__repr__() ));
chemdraw.cc:294:    if ( this[01;31m-[00m>_Variables.count(key)!= 0 )
chemdraw.cc:296:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You have already set the variable(%s) it has the value(%s) and you are trying to set it with(%s)") % key % this[01;31m-[00m>_Variables.get(key)[01;31m-[00m>__repr__() % obj[01;31m-[00m>__repr__()  ));
chemdraw.cc:298:    LOG(BF("Setting variable(%s) class(%s) to %s") % key % obj[01;31m-[00m>className() % obj[01;31m-[00m>__repr__() );
chemdraw.cc:299:    this[01;31m-[00m>_Variables.set(key,obj);
chemdraw.cc:306:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:308:    for ( Map<O_Object>::iterator mi=this[01;31m-[00m>_Variables.begin(); mi!=this[01;31m-[00m>_Variables.end(); mi++ )
chemdraw.cc:310:	ss << mi[01;31m-[00m>first << " class(" << mi[01;31m-[00m>second[01;31m-[00m>className() << ") value=" << mi[01;31m-[00m>second[01;31m-[00m>__repr__() << endl;
chemdraw.cc:331:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:332:    LOG(BF("Starting a new fragment, number of bonds = %d") % this[01;31m-[00m>_Bonds.size() ); // vp0(("Starting a new fragment, number of bonds = %d", this[01;31m-[00m>_Bonds.size()));
chemdraw.cc:334:    this[01;31m-[00m>_Properties = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Binder>();
chemdraw.cc:335:    for ( bi=this[01;31m-[00m>_Bonds.begin(); bi!=this[01;31m-[00m>_Bonds.end(); bi++ )
chemdraw.cc:336:    { _BLOCK_TRACEF(BF("Processing bond with order: %s") % (*bi)[01;31m-[00m>getOrderAsString().c_str() );
chemdraw.cc:337:	LOG(BF("label Begin = %s") % ((*bi)[01;31m-[00m>getBeginNode()[01;31m-[00m>getLabel().c_str())  ); // vp0(( "label Begin = %s", ((*bi)[01;31m-[00m>getBeginNode()[01;31m-[00m>getLabel().c_str()) ));
chemdraw.cc:338:	LOG(BF("label End   = %s") % ((*bi)[01;31m-[00m>getEndNode()[01;31m-[00m>getLabel().c_str())  ); // vp0(( "label End   = %s", ((*bi)[01;31m-[00m>getEndNode()[01;31m-[00m>getLabel().c_str()) ));
chemdraw.cc:340:		// Dative bonds must have form begin(XXX:)[01;31m-[00m>end(YYY)
chemdraw.cc:343:	if ( (*bi)[01;31m-[00m>getOrder() == dativeCDBond )
chemdraw.cc:345:	    string beginLabel = (*bi)[01;31m-[00m>getBeginNode()[01;31m-[00m>getLabel();
chemdraw.cc:346:	    string endLabel = (*bi)[01;31m-[00m>getEndNode()[01;31m-[00m>getLabel();
chemdraw.cc:349:	    this[01;31m-[00m>_Properties[01;31m-[00m>extend(this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(propertyStr),O_String::create(valueStr,this[01;31m-[00m>lisp()));
chemdraw.cc:351:	} else if ( (*bi)[01;31m-[00m>getOrder() == hashCDBond )
chemdraw.cc:359:	    bool koBegin = this[01;31m-[00m>_asKeyedObject((*bi)[01;31m-[00m>getBeginNode()[01;31m-[00m>getLabel(),kwBegin,objBegin);
chemdraw.cc:360:	    bool koEnd = this[01;31m-[00m>_asKeyedObject((*bi)[01;31m-[00m>getEndNode()[01;31m-[00m>getLabel(),kwEnd,objEnd);
chemdraw.cc:361:	    RPSymbol kwPart = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Symbol>(); 
chemdraw.cc:362:	    RPObject objPart = this[01;31m-[00m>lisp()[01;31m-[00m>onil();
chemdraw.cc:363:	    RPCDNode rootNode = O_CDNode::nil(this[01;31m-[00m>lisp());
chemdraw.cc:371:		rootNode = (*bi)[01;31m-[00m>getEndNode();
chemdraw.cc:375:		if ( kwPart[01;31m-[00m>notNil() )
chemdraw.cc:377:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Invalid hash bond ("
chemdraw.cc:378:		    		+ (*bi)[01;31m-[00m>getBeginNode()[01;31m-[00m>getLabel()
chemdraw.cc:379:				+ " [01;31m-[00m "
chemdraw.cc:380:				+ (*bi)[01;31m-[00m>getEndNode()[01;31m-[00m>getLabel()
chemdraw.cc:385:		rootNode = (*bi)[01;31m-[00m>getBeginNode();
chemdraw.cc:387:	    if ( kwPart[01;31m-[00m>isNil() )
chemdraw.cc:391:		serr << "On one side the label is ["<< (*bi)[01;31m-[00m>getBeginNode()[01;31m-[00m>getLabel() << "]"<<endl;
chemdraw.cc:392:		serr << "On the other side the label is ["<< (*bi)[01;31m-[00m>getEndNode()[01;31m-[00m>getLabel() << "]"<<endl;
chemdraw.cc:393:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
chemdraw.cc:395:	    this[01;31m-[00m>_Properties[01;31m-[00m>extend(kwPart,objPart);
chemdraw.cc:396:	    this[01;31m-[00m>_RootNode = rootNode;
chemdraw.cc:399:	    LOG(BF("Doing nothing with bond type(%s)") % (*bi)[01;31m-[00m>getOrderAsString().c_str()  ); // vp0(( "Doing nothing with bond type(%s)", (*bi)[01;31m-[00m>getOrderAsString().c_str() ));
chemdraw.cc:402:    this[01;31m-[00m>createAtoms();
chemdraw.cc:405:    RPResidue res = this[01;31m-[00m>buildResidue(false);
chemdraw.cc:406:    RPCons carbons = res[01;31m-[00m>allAtomsOfElementAsList(element_C);
chemdraw.cc:407:    for ( RPCons cur = carbons; cur[01;31m-[00m>notNil(); cur=cur[01;31m-[00m>cdr() )
chemdraw.cc:409:	RPAtom c = cur[01;31m-[00m>car<O_Atom>();
chemdraw.cc:410:	ASSERT(this[01;31m-[00m>_AtomsToNodes.count(c)>0);
chemdraw.cc:411:	RPCDNode fromNode = this[01;31m-[00m>_AtomsToNodes[c];
chemdraw.cc:412:	RPCons hydrogens = c[01;31m-[00m>createImplicitHydrogenNamesOnCarbon();
chemdraw.cc:413:	LOG(BF("Creating implicit hydrogens for %s named %s") % c[01;31m-[00m>description().c_str() % hydrogens[01;31m-[00m>__repr__().c_str()  ); // vp0(("Creating implicit hydrogens for %s named %s", c[01;31m-[00m>description().c_str(), hydrogens[01;31m-[00m>__repr__().c_str() ));
chemdraw.cc:414:	for ( RPCons ih=hydrogens; ih[01;31m-[00m>notNil(); ih=ih[01;31m-[00m>cdr() )
chemdraw.cc:416:	    string name = ih[01;31m-[00m>car<O_String>()[01;31m-[00m>get();
chemdraw.cc:417:	    this[01;31m-[00m>createImplicitHydrogen(fromNode,name);
chemdraw.cc:420:    RPResidue everything = this[01;31m-[00m>buildResidue(false);
chemdraw.cc:426:    RPCipPrioritizer cip = O_CipPrioritizer::create(this[01;31m-[00m>lisp());
chemdraw.cc:427:    cip[01;31m-[00m>defineStereochemicalConfigurationsForAllAtoms(everything);
chemdraw.cc:431:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:437:    for ( bi=this[01;31m-[00m>_Bonds.begin(); bi!=this[01;31m-[00m>_Bonds.end(); bi++ )
chemdraw.cc:439:	CDBondOrder o = ( (*bi)[01;31m-[00m>getOrder() );
chemdraw.cc:443:	    RPCDNode n = (*bi)[01;31m-[00m>getBeginNode();
chemdraw.cc:444:	    if ( n[01;31m-[00m>getAtom()[01;31m-[00m>isNil() ) 
chemdraw.cc:446:		RPAtom a = O_Atom::create(this[01;31m-[00m>lisp());
chemdraw.cc:447:		a[01;31m-[00m>setContainedBy(O_Residue::nil(this[01;31m-[00m>lisp()));
chemdraw.cc:448:		n[01;31m-[00m>setAtom(a);
chemdraw.cc:449:		this[01;31m-[00m>_AtomsToNodes[a] = n;
chemdraw.cc:450:		a[01;31m-[00m>setName(n[01;31m-[00m>getLabel());
chemdraw.cc:451:		a[01;31m-[00m>setElementFromName();
chemdraw.cc:452:		ASSERT(elementIsRealElement(a[01;31m-[00m>getElement()));
chemdraw.cc:454:	    n = (*bi)[01;31m-[00m>getEndNode();
chemdraw.cc:455:	    if ( n[01;31m-[00m>getAtom()[01;31m-[00m>isNil() ) 
chemdraw.cc:457:		RPAtom a = O_Atom::create(this[01;31m-[00m>lisp());
chemdraw.cc:458:		a[01;31m-[00m>setContainedBy(O_Residue::nil(this[01;31m-[00m>lisp()));
chemdraw.cc:459:		n[01;31m-[00m>setAtom(a);
chemdraw.cc:460:		this[01;31m-[00m>_AtomsToNodes[a] = n;
chemdraw.cc:461:		a[01;31m-[00m>setName(n[01;31m-[00m>getLabel());
chemdraw.cc:462:		a[01;31m-[00m>setElementFromName();
chemdraw.cc:463:		ASSERT(elementIsRealElement(a[01;31m-[00m>getElement()));
chemdraw.cc:471:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:472:    RPBinder dict = this[01;31m-[00m>getProperties();
chemdraw.cc:473:    if ( !dict[01;31m-[00m>contains(s) )
chemdraw.cc:476:	serr << "Fragment(" << this[01;31m-[00m>getConstitutionName() << ") is missing property: " << s << endl;
chemdraw.cc:478:	serr << dict[01;31m-[00m>summaryOfContents() << endl;
chemdraw.cc:479:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
chemdraw.cc:481:    return dict[01;31m-[00m>lookup(s);
chemdraw.cc:485:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:486:    RPBinder dict = this[01;31m-[00m>getProperties();
chemdraw.cc:487:    if ( dict[01;31m-[00m>contains(s) )
chemdraw.cc:489:	return dict[01;31m-[00m>lookup(s);
chemdraw.cc:496:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:497:    for ( List<O_CDBond>::iterator bi=this[01;31m-[00m>_Bonds.begin();
chemdraw.cc:498:		bi!=this[01;31m-[00m>_Bonds.end(); bi++ )
chemdraw.cc:500:	CDBondOrder o = ( (*bi)[01;31m-[00m>getOrder() );
chemdraw.cc:501:	BondOrder bo = (*bi)[01;31m-[00m>getOrderAsBondOrder();
chemdraw.cc:502:	RPAtom a1 = (*bi)[01;31m-[00m>getBeginNode()[01;31m-[00m>getAtom();
chemdraw.cc:504:	if ( a1[01;31m-[00m>isNil() ) continue;
chemdraw.cc:505:	RPAtom a2 = (*bi)[01;31m-[00m>getEndNode()[01;31m-[00m>getAtom();
chemdraw.cc:507:	if ( a2[01;31m-[00m>isNil() ) continue;
chemdraw.cc:509:	if ( selectedAtomsOnly && (!a1[01;31m-[00m>testAllFlags(SELECTED) || !a2[01;31m-[00m>testAllFlags(SELECTED)) )
chemdraw.cc:515:	    LOG(BF("Creating a bond between %s and %s order: %s") % a1[01;31m-[00m>description().c_str() % a2[01;31m-[00m>description().c_str() % bondOrderToString(bo).c_str()  ); // vp0(("Creating a bond between %s and %s order: %s", a1[01;31m-[00m>description().c_str(), a2[01;31m-[00m>description().c_str(), bondOrderToString(bo).c_str() ));
chemdraw.cc:516:	    a1[01;31m-[00m>bondTo(a2,bo);
chemdraw.cc:522:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:524:    for ( ni = this[01;31m-[00m>_Nodes.begin(); ni!=this[01;31m-[00m>_Nodes.end(); ni++ )
chemdraw.cc:526:	RPAtom a = (*ni).second[01;31m-[00m>getAtom();
chemdraw.cc:527:	if ( a[01;31m-[00m>notNil() )
chemdraw.cc:529:	    LOG(BF("Removing bonds for atom: %s") % a[01;31m-[00m>description().c_str()  ); // vp0(("Removing bonds for atom: %s", a[01;31m-[00m>description().c_str() ));
chemdraw.cc:530:	    a[01;31m-[00m>removeAllBonds();
chemdraw.cc:537:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:539:    for ( ni = this[01;31m-[00m>_Nodes.begin(); ni!=this[01;31m-[00m>_Nodes.end(); ni++ )
chemdraw.cc:541:	RPAtom a = (*ni).second[01;31m-[00m>getAtom();
chemdraw.cc:542:	if ( a[01;31m-[00m>notNil() )
chemdraw.cc:544:	    a[01;31m-[00m>resetFlags();
chemdraw.cc:551:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:552:    RPResidue res = O_Residue::create(this[01;31m-[00m>lisp());
chemdraw.cc:554:    for ( ni = this[01;31m-[00m>_Nodes.begin(); ni!=this[01;31m-[00m>_Nodes.end(); ni++ )
chemdraw.cc:556:	RPAtom a = (*ni).second[01;31m-[00m>getAtom();
chemdraw.cc:557:	if ( a[01;31m-[00m>notNil() )
chemdraw.cc:559:	    if ( a[01;31m-[00m>testAllFlags(SELECTED) ) res[01;31m-[00m>addAtom(a);
chemdraw.cc:571:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:575:    this[01;31m-[00m>clearAtomSelected();
chemdraw.cc:576:    this[01;31m-[00m>removeAllBonds();
chemdraw.cc:577:    this[01;31m-[00m>createBonds(false);
chemdraw.cc:582:	RPResidue res = O_Residue::create(this[01;31m-[00m>lisp());
chemdraw.cc:583:	RPSpanningLoop span = O_SpanningLoop::create(this[01;31m-[00m>lisp());
chemdraw.cc:584:	span[01;31m-[00m>setOnlyFollowRealBonds(constitutionOnly);
chemdraw.cc:585:	ASSERT_NOT_NULL(this[01;31m-[00m>_RootNode);
chemdraw.cc:586:	ASSERTP(this[01;31m-[00m>_RootNode[01;31m-[00m>notNil(),"An atom must be labeled 'root'");
chemdraw.cc:587:	span[01;31m-[00m>setTop(this[01;31m-[00m>_RootNode[01;31m-[00m>getAtom());
chemdraw.cc:588:	while ( span[01;31m-[00m>advance() )
chemdraw.cc:590:	    RPAtom a = span[01;31m-[00m>getAtom();
chemdraw.cc:591:	    a[01;31m-[00m>turnOnFlags(SELECTED);
chemdraw.cc:592:	    LOG(BF("Selected %s") % a[01;31m-[00m>description().c_str()  ); // vp0(( "Selected %s", a[01;31m-[00m>description().c_str() ));
chemdraw.cc:598:    this[01;31m-[00m>removeAllBonds();
chemdraw.cc:602:    this[01;31m-[00m>createBonds(true);
chemdraw.cc:603:    RPResidue res = this[01;31m-[00m>createResidueOfSelectedAtoms();
chemdraw.cc:604:    ASSERTP(res[01;31m-[00m>contentSize()>0,"The residue is empty");
chemdraw.cc:617:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:618:    return this[01;31m-[00m>buildResidue(false);
chemdraw.cc:622:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:623:    return this[01;31m-[00m>buildResidue(true);
chemdraw.cc:631:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:632:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
chemdraw.cc:633:    RPCons props = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Cons>();
chemdraw.cc:635:    this[01;31m-[00m>_Properties = kprops;
chemdraw.cc:636:    this[01;31m-[00m>_Text = "n/a";
chemdraw.cc:641:    this[01;31m-[00m>Base::initialize();
chemdraw.cc:642:    this[01;31m-[00m>_Properties = O_Binder::create(this[01;31m-[00m>lisp());
chemdraw.cc:648:    return this[01;31m-[00m>_Properties[01;31m-[00m>size()>0; 
chemdraw.cc:657:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:658:    RPQDomNode sub = text[01;31m-[00m>childWithName("s");
chemdraw.cc:659:    this[01;31m-[00m>_Text = trimWhiteSpace(sub[01;31m-[00m>getData());
chemdraw.cc:660:    if ( this[01;31m-[00m>_Text[0] != '(' )
chemdraw.cc:665:    RPReader reader = O_Reader::createOnString(this[01;31m-[00m>_Text,lisp);
chemdraw.cc:666:    RPCons block = reader[01;31m-[00m>read()[01;31m-[00m>as<O_Cons>();
chemdraw.cc:667:    reader[01;31m-[00m>close();
chemdraw.cc:668:    LOG(BF("Parsed text block: %s\n") % this[01;31m-[00m>_Text.c_str());
chemdraw.cc:669:    if ( block[01;31m-[00m>isNil() )
chemdraw.cc:671:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Error compiling code:\n"+this[01;31m-[00m>_Text));
chemdraw.cc:673:    LOG(BF("About to evaluate CDText: %s") % block[01;31m-[00m>__repr__() );
chemdraw.cc:674:    RPObject result = eval::evaluate(block,lisp[01;31m-[00m>globalEnvironment(),lisp);
chemdraw.cc:675:    this[01;31m-[00m>_Properties = O_Binder::createFromKeywordCons(result[01;31m-[00m>as<O_Cons>(),validChemdrawKeywords,lisp);
chemdraw.cc:688:    this[01;31m-[00m>Base::initialize();
chemdraw.cc:700:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:701:    LOG(BF("Entered O_ChemDraw::oldLispInitialize with: %s") % keyed[01;31m-[00m>description() );
chemdraw.cc:702:    this[01;31m-[00m>Base::oldLispInitialize(keyed,env);
chemdraw.cc:703:    this[01;31m-[00m>_Environment = env;
chemdraw.cc:704:    string fileName = keyed[01;31m-[00m>getStringAndRemove("fileName");
chemdraw.cc:706:    this[01;31m-[00m>parseFromFileName(fileName);
chemdraw.cc:717:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:718:    RPBinder kargs = O_Binder::createFromKeywordCons(props,validChemdrawKeywords,this[01;31m-[00m>lisp());
chemdraw.cc:719:    if ( !kargs[01;31m-[00m>contains(this[01;31m-[00m>lisp()[01;31m-[00m>predefinedSymbol(_sym_kw_name)) )
chemdraw.cc:722:	ss << "Properties for ChemDraw Fragments must have a (name) property, what was passed has: " << kargs[01;31m-[00m>description();
chemdraw.cc:723:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
chemdraw.cc:725:    string name = kargs[01;31m-[00m>lookup(this[01;31m-[00m>lisp()[01;31m-[00m>predefinedSymbol(_sym_kw_name))[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
chemdraw.cc:726:    if ( !this[01;31m-[00m>_NamedFragments.contains(name) )
chemdraw.cc:730:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
chemdraw.cc:732:    RPCDFragment frag = this[01;31m-[00m>_NamedFragments.get(name);
chemdraw.cc:733:    frag[01;31m-[00m>addProperties(kargs);
chemdraw.cc:738:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:739:    RPQDomNode xml = O_QDomNode::open(fileName,this[01;31m-[00m>lisp());
chemdraw.cc:740:    if ( !xml[01;31m-[00m>hasChildrenWithName("page") )
chemdraw.cc:742:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Not a cdxml file" ));
chemdraw.cc:744:    RPQDomNode page = xml[01;31m-[00m>childWithName("page");
chemdraw.cc:746:    this[01;31m-[00m>_NamedFragments.clear();
chemdraw.cc:747:    for ( it=page[01;31m-[00m>begin_Children(); it!=page[01;31m-[00m>end_Children(); it++ )
chemdraw.cc:750:	if ( child[01;31m-[00m>getLocalName() == "fragment" )
chemdraw.cc:752:	    RPCDFragment fragment = RP_Create<O_CDFragment>(this[01;31m-[00m>lisp());
chemdraw.cc:753:	    fragment[01;31m-[00m>parseFromXml(child);
chemdraw.cc:754:	    fragment[01;31m-[00m>interpret();
chemdraw.cc:755:	    RPBinder properties = fragment[01;31m-[00m>getProperties();
chemdraw.cc:756:	    if ( !properties[01;31m-[00m>contains(this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword("name") ))
chemdraw.cc:758:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("Every fragment must have a property(name:)"));
chemdraw.cc:760:	    RPText ko = properties[01;31m-[00m>lookup(this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword("name"))[01;31m-[00m>as<O_Text>();
chemdraw.cc:761:	    string constitutionName = ko[01;31m-[00m>get();
chemdraw.cc:762:	    fragment[01;31m-[00m>setConstitutionName(constitutionName);
chemdraw.cc:763:	    this[01;31m-[00m>_NamedFragments.set(constitutionName,fragment);
chemdraw.cc:764:	    this[01;31m-[00m>_AllFragments.append(fragment);
chemdraw.cc:767:    for ( it=page[01;31m-[00m>begin_Children(); it!=page[01;31m-[00m>end_Children(); it++ )
chemdraw.cc:770:	if ( child[01;31m-[00m>getLocalName() == "t" )
chemdraw.cc:772:	    RPCDText text = RP_Create<O_CDText>(this[01;31m-[00m>lisp());
chemdraw.cc:773:	    ASSERT_NOT_NULL(this[01;31m-[00m>_Environment);
chemdraw.cc:774:	    ASSERT(this[01;31m-[00m>_Environment.lock()[01;31m-[00m>notNil() );
chemdraw.cc:775:	    RPLisp env = this[01;31m-[00m>_Environment.lock();
chemdraw.cc:776:	    text[01;31m-[00m>parseFromXml(child,env);
chemdraw.cc:777:	    if ( text[01;31m-[00m>hasProperties() )
chemdraw.cc:779:		LOG(BF("Found properties: %s") % text[01;31m-[00m>__repr__() );
chemdraw.cc:780:		RPBinder properties = text[01;31m-[00m>getProperties();
chemdraw.cc:781:		if (!properties[01;31m-[00m>contains(this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword("name")) )
chemdraw.cc:783:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Every properties block must have a property(name:)"));
chemdraw.cc:785:	        string constitutionName = properties[01;31m-[00m>lookup(this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword("name"))[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
chemdraw.cc:786:		if ( !this[01;31m-[00m>_NamedFragments.contains(constitutionName) )
chemdraw.cc:788:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find fragment with name("+constitutionName+")"));
chemdraw.cc:790:		RPCDFragment fragment = this[01;31m-[00m>_NamedFragments.get(constitutionName);
chemdraw.cc:791:		fragment[01;31m-[00m>addProperties(properties);
chemdraw.cc:799:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:800:RPCons	frags = O_Cons::nil(this[01;31m-[00m>lisp());
chemdraw.cc:802:    for ( fi=this[01;31m-[00m>_AllFragments.begin(); fi!=this[01;31m-[00m>_AllFragments.end(); fi++ )
chemdraw.cc:804:	RPCons n = O_Cons::create(*fi,frags,this[01;31m-[00m>lisp());
chemdraw.cc:812:{_F(this[01;31m-[00m>lisp());
chemdraw.cc:813:RPCons	frags = O_Cons::nil(this[01;31m-[00m>lisp());
chemdraw.cc:814:    RPStringSet namesChosen = O_StringSet::create(this[01;31m-[00m>lisp());
chemdraw.cc:816:    for ( fi=this[01;31m-[00m>_NamedFragments.begin(); fi!=this[01;31m-[00m>_NamedFragments.end(); fi++ )
chemdraw.cc:818:	if ( namesOfSubSet[01;31m-[00m>contains(fi[01;31m-[00m>first) )
chemdraw.cc:820:	    namesChosen[01;31m-[00m>insert(fi[01;31m-[00m>first);
chemdraw.cc:821:	    RPCons n = O_Cons::create(fi[01;31m-[00m>second,frags,this[01;31m-[00m>lisp());
chemdraw.cc:825:    if ( namesChosen[01;31m-[00m>size() != namesOfSubSet[01;31m-[00m>size() )
chemdraw.cc:827:	RPStringSet diff = namesOfSubSet[01;31m-[00m>relativeComplement(namesChosen);
chemdraw.cc:830:	ss << diff[01;31m-[00m>asString();
chemdraw.cc:831:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
chemdraw.cc:843:	class_<O_CDFragment>(this[01;31m-[00m>lisp())
chemdraw.cc:876:	class_<O_ChemDraw>(this[01;31m-[00m>lisp())
chimera.cc:20:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal Chimera atom specification"));
chimera.cc:24:	string residueInfo = spec.substr(residueStart,atomNameStart[01;31m-[00mresidueStart[01;31m-[00m1);
cipPrioritizer.cc:28:    return a[01;31m-[00m>getAtomicNumber();
cipPrioritizer.cc:37:    void setCipPrioritizer(RPCipPrioritizer p) { this[01;31m-[00m>prior = p;};
cipPrioritizer.cc:47:	if ( prior[01;31m-[00m>getP(x) <= prior[01;31m-[00m>getP(y) ) return true;
cipPrioritizer.cc:57:{_F(x[01;31m-[00m>lisp());
cipPrioritizer.cc:60:	vector<int>&	xv = prior[01;31m-[00m>getS(x);
cipPrioritizer.cc:61:	vector<int>&	yv = prior[01;31m-[00m>getS(y);
cipPrioritizer.cc:71:		res = [01;31m-[00m1;
cipPrioritizer.cc:91:	    res = [01;31m-[00m1;
cipPrioritizer.cc:101:    {_F(x[01;31m-[00m>lisp());
cipPrioritizer.cc:102:        int order = this[01;31m-[00m>cmpByS(x,y);
cipPrioritizer.cc:113:    this[01;31m-[00m>Base::initialize();
cipPrioritizer.cc:118:    ASSERT_lessThan(a[01;31m-[00m>getRelativePriority(),this[01;31m-[00m>_p.size());
cipPrioritizer.cc:119:    return this[01;31m-[00m>_p[a[01;31m-[00m>getRelativePriority()];
cipPrioritizer.cc:125:    if ( ! ( a[01;31m-[00m>getRelativePriority() < this[01;31m-[00m>_s.size() ) )
cipPrioritizer.cc:129:	LOG(BF("Bad priority for atom: %s") % a[01;31m-[00m>description().c_str()  ); // vp0(( "Bad priority for atom: %s", a[01;31m-[00m>description().c_str() ));
cipPrioritizer.cc:130:	LOG(BF("   priority value = %d") % a[01;31m-[00m>getRelativePriority()  ); // vp0(( "   priority value = %d", a[01;31m-[00m>getRelativePriority() ));
cipPrioritizer.cc:132:    ASSERT_lessThan(a[01;31m-[00m>getRelativePriority(),this[01;31m-[00m>_s.size());
cipPrioritizer.cc:133:    return this[01;31m-[00m>_s[a[01;31m-[00m>getRelativePriority()];
cipPrioritizer.cc:139: * partition the atoms between cBegin and cEnd[01;31m-[00m1 into classes based on orderFn
cipPrioritizer.cc:147:	if ( orderer.cmpByS(atoms[i[01;31m-[00m1],atoms[i])!=0 )
cipPrioritizer.cc:157:{_F(matter[01;31m-[00m>lisp());
cipPrioritizer.cc:159:    prior = O_CipPrioritizer::create(matter[01;31m-[00m>lisp());
cipPrioritizer.cc:160:    prior[01;31m-[00m>assignCahnIngoldPrelogPriorityToAtomsRelativePriority(matter);
cipPrioritizer.cc:167:{_F(this[01;31m-[00m>lisp());
cipPrioritizer.cc:179:    // in an equivalence class is assigned the priority of the [01;31m-[00m1 of the 
cipPrioritizer.cc:195:    { _BLOCK_TRACE("Stage 1 [01;31m-[00m setting initial priorities");
cipPrioritizer.cc:196:	this[01;31m-[00m>_p.clear();
cipPrioritizer.cc:202:	    if ( a[01;31m-[00m>isOfClass<O_VirtualAtom>() ) continue;
cipPrioritizer.cc:203:	    a[01;31m-[00m>setRelativePriority(mAtoms.size());
cipPrioritizer.cc:205:	    this[01;31m-[00m>_p.push_back(atomicNumber(a));
cipPrioritizer.cc:209:	byP.setCipPrioritizer(this[01;31m-[00m>sharedThis<O_CipPrioritizer>());
cipPrioritizer.cc:210:	sort::quickSort(mAtoms.begin(),mAtoms.end(),byP,this[01;31m-[00m>lisp());
cipPrioritizer.cc:213:	int pcur = [01;31m-[00m1;
cipPrioritizer.cc:217:	    uint idx = a[01;31m-[00m>getRelativePriority();
cipPrioritizer.cc:218:	    if (pcur != this[01;31m-[00m>_p[idx])
cipPrioritizer.cc:221:		pcur = this[01;31m-[00m>_p[idx];
cipPrioritizer.cc:231:	    ss << "Atom: " << (*mit)[01;31m-[00m>getName();
cipPrioritizer.cc:232:	    ss << " priority: " << this[01;31m-[00m>getP((*mit));
cipPrioritizer.cc:234:	    if ( cidx < (int)(C.size()) && mit[01;31m-[00mmAtoms.begin() == C[cidx] )
cipPrioritizer.cc:238:	    ss << " C[01;31m-[00mclass: " << cidx[01;31m-[00m1;
cipPrioritizer.cc:258:	    this[01;31m-[00m>_s.clear();
cipPrioritizer.cc:259:	    this[01;31m-[00m>_s.resize(mAtoms.size());
cipPrioritizer.cc:267:		    for ( vector<RPBond>::iterator bi=myatom[01;31m-[00m>bonds_begin();
cipPrioritizer.cc:268:				 bi!=myatom[01;31m-[00m>bonds_end(); bi++ )
cipPrioritizer.cc:271:			if ( (*bi)[01;31m-[00m>getOrder() == singleBond ) bondOrder = 1;
cipPrioritizer.cc:272:			if ( (*bi)[01;31m-[00m>getOrder() == doubleBond ) bondOrder = 2;
cipPrioritizer.cc:273:			if ( (*bi)[01;31m-[00m>getOrder() == tripleBond ) bondOrder = 3;
cipPrioritizer.cc:276:			    mys.push_back(this[01;31m-[00m>_p[(*bi)[01;31m-[00m>getToLocked()[01;31m-[00m>getRelativePriority()]);
cipPrioritizer.cc:280:		    sort::quickSort(mys.begin(),mys.end(),this[01;31m-[00m>lisp());
cipPrioritizer.cc:285:		    this[01;31m-[00m>_s[myatom[01;31m-[00m>getRelativePriority()] = mys;
cipPrioritizer.cc:289:	    { _BLOCK_TRACEF(BF("STAGE2 results [01;31m-[00m there are %d classes")% C.size() );
cipPrioritizer.cc:297:		for ( zit=this[01;31m-[00m>_s[(*ait)[01;31m-[00m>getRelativePriority()].begin();
cipPrioritizer.cc:298:			    zit!=this[01;31m-[00m>_s[(*ait)[01;31m-[00m>getRelativePriority()].end();
cipPrioritizer.cc:303:		LOG(BF("  reverse sorted priorities of neighbors of %s [01;31m-[00m %s") % (*ait)[01;31m-[00m>getName().c_str() % ss.str().c_str()  ); // vp0(("  reverse sorted priorities of neighbors of %s [01;31m-[00m %s", (*ait)[01;31m-[00m>getName().c_str(), ss.str().c_str() ));
cipPrioritizer.cc:324:		    if ( classIndex == C.size()[01;31m-[00m1 )
cipPrioritizer.cc:331:		    LOG(BF("Looking at class (%u)[01;31m-[00m(%u)") % classBegin % classEnd  ); // vp0(( "Looking at class (%u)[01;31m-[00m(%u)", classBegin,classEnd ));
cipPrioritizer.cc:337:			    LOG(BF("Pushing back atom(use_count=%d): %s") % a.use_count() % a[01;31m-[00m>description().c_str()  ); // vp0(("Pushing back atom(use_count=%d): %s", a.use_count(),a[01;31m-[00m>description().c_str() ));
cipPrioritizer.cc:345:			byS.setCipPrioritizer(this[01;31m-[00m>sharedThis<O_CipPrioritizer>());
cipPrioritizer.cc:352:			    LOG(BF("    %s") % (*ssi)[01;31m-[00m>description().c_str() ); // vp0(("    %s", (*ssi)[01;31m-[00m>description().c_str()));
cipPrioritizer.cc:355:			sort::quickSort(S.begin(),S.end(),byS,this[01;31m-[00m>lisp());
cipPrioritizer.cc:365:    sz << "After sort S[" << iiS[01;31m-[00mS.begin() << "].atom("<<(*iiS)[01;31m-[00m>getName();
cipPrioritizer.cc:368:    for ( zit=this[01;31m-[00m>_s[(*iiS)[01;31m-[00m>getRelativePriority()].begin();
cipPrioritizer.cc:369:		zit!=this[01;31m-[00m>_s[(*iiS)[01;31m-[00m>getRelativePriority()].end();
cipPrioritizer.cc:381:		    LOG(BF("Replacing mAtoms from (%u)[01;31m-[00m(%u) with S") % classBegin % classEnd ); // vp0(( "Replacing mAtoms from (%u)[01;31m-[00m(%u) with S", classBegin,classEnd));
cipPrioritizer.cc:417:	    { _BLOCK_TRACEF(BF("Stage 5 [01;31m-[00m there are now %d classes") % newC.size());
cipPrioritizer.cc:431:		    if ( classIndex == C.size()[01;31m-[00m1 )
cipPrioritizer.cc:441:			this[01;31m-[00m>_p[a[01;31m-[00m>getRelativePriority()] = classIndex;
cipPrioritizer.cc:467:	    uint relPriority = this[01;31m-[00m>_p[(*ai)[01;31m-[00m>getRelativePriority()];
cipPrioritizer.cc:468:	    (*ai)[01;31m-[00m>setRelativePriority(relPriority);
cipPrioritizer.cc:469:	    LOG(BF("Assigned to atom: %s priority: %d") % (*ai)[01;31m-[00m>getName().c_str() % relPriority  ); // vp0(("Assigned to atom: %s priority: %d", (*ai)[01;31m-[00m>getName().c_str(), relPriority ));
cipPrioritizer.cc:477:    return p2[01;31m-[00m>getRelativePriority() < p1[01;31m-[00m>getRelativePriority();
cipPrioritizer.cc:482:    return p1[01;31m-[00m>getName() < p2[01;31m-[00m>getName();
cipPrioritizer.cc:488:{_F(this[01;31m-[00m>lisp());
cipPrioritizer.cc:489:    this[01;31m-[00m>assignCahnIngoldPrelogPriorityToAtomsRelativePriority(molOrAgg);
cipPrioritizer.cc:495:	if ( a[01;31m-[00m>isOfClass<O_VirtualAtom>() ) continue;
cipPrioritizer.cc:496:	RPResidue res = a[01;31m-[00m>getResidueContainedBy();
cipPrioritizer.cc:497:	if ( a[01;31m-[00m>numberOfBonds() == 4 )
cipPrioritizer.cc:501:	    for ( vector<RPBond>::iterator bi = a[01;31m-[00m>bonds_begin(); bi!=a[01;31m-[00m>bonds_end(); bi++ )
cipPrioritizer.cc:503:		priority.push_back((*bi)[01;31m-[00m>getToLocked());
cipPrioritizer.cc:505:	    sort::quickSort(priority.begin(), priority.end(), orderByPriority, this[01;31m-[00m>lisp() );
cipPrioritizer.cc:513:		if ( (*pi)[01;31m-[00m>getRelativePriority() != prevPriority )
cipPrioritizer.cc:517:		prevPriority = (*pi)[01;31m-[00m>getRelativePriority();
cipPrioritizer.cc:522:		a[01;31m-[00m>setStereochemistryType(chiralCenter);
cipPrioritizer.cc:523:		a[01;31m-[00m>setConfiguration(undefinedConfiguration);
cipPrioritizer.cc:529:		a[01;31m-[00m>setStereochemistryType(prochiralCenter);
cipPrioritizer.cc:530:		a[01;31m-[00m>setConfiguration(undefinedConfiguration);
cipPrioritizer.cc:534:	    a[01;31m-[00m>setConfiguration(undefinedConfiguration);
cipPrioritizer.cc:535:	    a[01;31m-[00m>setStereochemistryType(undefinedCenter);
cipPrioritizer.cc:546:    class_<O_CipPrioritizer>(this[01;31m-[00m>lisp())
clusterFinder.cc:33:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
clusterFinder.cc:39:    this[01;31m-[00m>Base::initialize();
clusterFinder.cc:44:    this[01;31m-[00m>Base::archiveBase(node);
clusterFinder.cc:50:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:54:    RPCoordinateArray coords = this[01;31m-[00m>_Coordinates;
clusterFinder.cc:57:	LOG(BF("Adding atom name(%s) pos=%s") % (*sit).c_str() % coords[01;31m-[00m>getElement(idx).asString().c_str()  ); // vp0(( "Adding atom name(%s) pos=%s", (*sit).c_str(), coords[01;31m-[00m>getElement(idx).asString().c_str() ));
clusterFinder.cc:58:	atomPositions[*sit] = coords[01;31m-[00m>getElement(idx);
clusterFinder.cc:60:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
clusterFinder.cc:68:	if ( atomPositions.count(a1[01;31m-[00m>getName())>0 && atomPositions.count(a2[01;31m-[00m>getName()) )
clusterFinder.cc:70:	    Vector3 a1Pos = atomPositions[a1[01;31m-[00m>getName()];
clusterFinder.cc:71:	    Vector3 a2Pos = atomPositions[a2[01;31m-[00m>getName()];
clusterFinder.cc:72:	    Element element1 = a1[01;31m-[00m>getElement();
clusterFinder.cc:73:	    Element element2 = a2[01;31m-[00m>getElement();
clusterFinder.cc:76:	    dl[01;31m-[00m>add(O_RenderMatter::elementToColor(element1,this[01;31m-[00m>lisp()));
clusterFinder.cc:77:	    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(a1Pos,center));
clusterFinder.cc:78:	    dl[01;31m-[00m>add(O_RenderMatter::elementToColor(element2,this[01;31m-[00m>lisp()));
clusterFinder.cc:79:	    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(a2Pos,center));
clusterFinder.cc:85:	dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("magenta"));
clusterFinder.cc:89:	    RPGrPoint p = RP_Create<O_GrPoint>(this[01;31m-[00m>lisp());
clusterFinder.cc:90:	    p[01;31m-[00m>setPosition(it[01;31m-[00m>second);
clusterFinder.cc:91:	    dl[01;31m-[00m>add(p);
clusterFinder.cc:104:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
clusterFinder.cc:110:    this[01;31m-[00m>Base::initialize();
clusterFinder.cc:111:    this[01;31m-[00m>_SumOfCoordinates = O_CoordinateArray::nil(this[01;31m-[00m>lisp());
clusterFinder.cc:112:    this[01;31m-[00m>_Center = O_CoordinateArray::nil(this[01;31m-[00m>lisp());
clusterFinder.cc:113:    this[01;31m-[00m>_Collisions = 0;
clusterFinder.cc:118:    this[01;31m-[00m>Base::archiveBase(node);
clusterFinder.cc:124:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:125:    ASSERT_lt(i,this[01;31m-[00m>_Entries.size());
clusterFinder.cc:126:    return this[01;31m-[00m>_Entries.get(i);
clusterFinder.cc:131:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:132:    ASSERTP(this[01;31m-[00m>_Center[01;31m-[00m>notNil(),"The _Center of the cluster must be defined");
clusterFinder.cc:133:    double distance = this[01;31m-[00m>_Center[01;31m-[00m>distanceTo(entry[01;31m-[00m>getCoordinateArray());
clusterFinder.cc:139:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:141:    RPClusterEntry closestEntry = O_ClusterEntry::nil(this[01;31m-[00m>lisp());
clusterFinder.cc:142:    for ( List<O_ClusterEntry>::iterator it=this[01;31m-[00m>_Entries.begin();
clusterFinder.cc:143:    		it!=this[01;31m-[00m>_Entries.end(); it++ ) 
clusterFinder.cc:145:	double dist = this[01;31m-[00m>_Center[01;31m-[00m>distanceTo((*it)[01;31m-[00m>getCoordinateArray());
clusterFinder.cc:157:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:159:    ASSERTP(this[01;31m-[00m>_Center[01;31m-[00m>notNil(),"The _Center of the cluster must be defined");
clusterFinder.cc:160:    for ( List<O_ClusterEntry>::iterator it=this[01;31m-[00m>_Entries.begin();
clusterFinder.cc:161:    		it!=this[01;31m-[00m>_Entries.end(); it++ ) 
clusterFinder.cc:163:	double dist = this[01;31m-[00m>_Center[01;31m-[00m>distanceTo((*it)[01;31m-[00m>getCoordinateArray());
clusterFinder.cc:173:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:174:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
clusterFinder.cc:175:    dl[01;31m-[00m>appendCoordinateAxes();
clusterFinder.cc:176:    for ( List<O_ClusterEntry>::iterator it=this[01;31m-[00m>_Entries.begin();
clusterFinder.cc:177:    		it!=this[01;31m-[00m>_Entries.end(); it++ ) 
clusterFinder.cc:179:	dl[01;31m-[00m>add((*it)[01;31m-[00m>renderWithBonds(res,atomNames));
clusterFinder.cc:187:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:188:    if ( this[01;31m-[00m>_Entries.size() == 0 )
clusterFinder.cc:190:	uint sz = entry[01;31m-[00m>getCoordinateArray()[01;31m-[00m>size();
clusterFinder.cc:191:	this[01;31m-[00m>_SumOfCoordinates = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>(sz);
clusterFinder.cc:192:	this[01;31m-[00m>_SumOfCoordinates[01;31m-[00m>zeroAllCoordinates();
clusterFinder.cc:194:    this[01;31m-[00m>_Entries.push_back(entry);
clusterFinder.cc:195:    this[01;31m-[00m>_SumOfCoordinates[01;31m-[00m>add(entry[01;31m-[00m>getCoordinateArray());
clusterFinder.cc:196:    double scale = 1.0/this[01;31m-[00m>_Entries.size();
clusterFinder.cc:197:    this[01;31m-[00m>_Center = this[01;31m-[00m>_SumOfCoordinates[01;31m-[00m>copy();
clusterFinder.cc:198:    this[01;31m-[00m>_Center[01;31m-[00m>multiplyByScalar(scale);
clusterFinder.cc:204:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:205:    return O_Cons::createFromRange(this[01;31m-[00m>_Entries.begin(),this[01;31m-[00m>_Entries.end(),this[01;31m-[00m>lisp());
clusterFinder.cc:215:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
clusterFinder.cc:216:    RPFragmentCoordinates fragCoords = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_FragmentCoordinates>();
clusterFinder.cc:217:    this[01;31m-[00m>setFragmentCoordinates(fragCoords);
clusterFinder.cc:222:    this[01;31m-[00m>Base::initialize();
clusterFinder.cc:227:    this[01;31m-[00m>Base::archiveBase(node);
clusterFinder.cc:233:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:235:    RPCluster bestCluster = O_Cluster::nil(this[01;31m-[00m>lisp());
clusterFinder.cc:236:    for ( List<O_Cluster>::iterator it=this[01;31m-[00m>_Clusters.begin();
clusterFinder.cc:237:    		it!=this[01;31m-[00m>_Clusters.end(); it++ )
clusterFinder.cc:239:	double dist = (*it)[01;31m-[00m>distanceToEntry(entry);
clusterFinder.cc:242:	    if ( bestCluster[01;31m-[00m>notNil() )
clusterFinder.cc:255:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:257:    this[01;31m-[00m>_AtomNames.clear();
clusterFinder.cc:258:    for ( it=fragCoords[01;31m-[00m>begin_AllAtomNames(); it!=fragCoords[01;31m-[00m>end_AllAtomNames(); it++ )
clusterFinder.cc:260:	this[01;31m-[00m>_AtomNames.push_back(*it);
clusterFinder.cc:262:    if ( this[01;31m-[00m>_Clusters.size() != 0 )
clusterFinder.cc:264:	RPCluster firstCluster = this[01;31m-[00m>_Clusters.get(0);
clusterFinder.cc:265:	if ( firstCluster[01;31m-[00m>clusterSize() != 0 )
clusterFinder.cc:267:	    RPClusterEntry entry = firstCluster[01;31m-[00m>getEntry(0);
clusterFinder.cc:268:	    if ( entry[01;31m-[00m>getCoordinateArray()[01;31m-[00m>size() != this[01;31m-[00m>_AtomNames.size() )
clusterFinder.cc:270:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("Mismatch between number of atom names and coordinates"));
clusterFinder.cc:279:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:280:    RPClusterEntry entry = O_ClusterEntry::create(this[01;31m-[00m>lisp());
clusterFinder.cc:281:    entry[01;31m-[00m>setCoordinateArray(arr);
clusterFinder.cc:282:    entry[01;31m-[00m>setData(obj);
clusterFinder.cc:283:    this[01;31m-[00m>_AllEntries.push_back(entry);
clusterFinder.cc:288:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:290:    this[01;31m-[00m>_Clusters.clear();
clusterFinder.cc:291:    for( List<O_ClusterEntry>::iterator it=this[01;31m-[00m>_AllEntries.begin();
clusterFinder.cc:292:    		it!=this[01;31m-[00m>_AllEntries.end(); it++ )
clusterFinder.cc:294:	RPCluster cluster = this[01;31m-[00m>bestCluster(rmsDistance,*it,overlappingClusters);
clusterFinder.cc:297:	    cluster[01;31m-[00m>setCollisions(cluster[01;31m-[00m>getCollisions()+1);
clusterFinder.cc:299:	if ( cluster[01;31m-[00m>isNil() )
clusterFinder.cc:301:	    cluster = O_Cluster::create(this[01;31m-[00m>lisp());
clusterFinder.cc:302:	    this[01;31m-[00m>_Clusters.push_back(cluster);
clusterFinder.cc:304:	cluster[01;31m-[00m>addEntry(*it);
clusterFinder.cc:310:{_F(this[01;31m-[00m>lisp());
clusterFinder.cc:311:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
clusterFinder.cc:313:    for ( List<O_Cluster>::iterator it=this[01;31m-[00m>_Clusters.begin(); 
clusterFinder.cc:314:    		it!=this[01;31m-[00m>_Clusters.end(); it++ )
clusterFinder.cc:316:	RPCons one = O_Cons::create(*it,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
clusterFinder.cc:317:	cur[01;31m-[00m>setCdr(one);
clusterFinder.cc:320:    return first[01;31m-[00m>cdr();
clusterFinder.cc:326:    RPMonomerContext context = monCoords[01;31m-[00m>getContext();
clusterFinder.cc:327:    RPMonomerSetBase focus = context[01;31m-[00m>getFocus();
clusterFinder.cc:328:    string monomerName = focus[01;31m-[00m>getOnlyMonomerName();
clusterFinder.cc:329:    RPBuilderDatabase bdb = focus[01;31m-[00m>getBuilderDatabase();
clusterFinder.cc:331:    ASSERT(bdb[01;31m-[00m>notNil());
clusterFinder.cc:332:    RPConstitution constitution = bdb[01;31m-[00m>constitutionForNameOrPdb(monomerName);
clusterFinder.cc:333:    RPResidue res = constitution[01;31m-[00m>getResidue();
clusterFinder.cc:334:    RPRenderFrameList frameList = O_RenderFrameList::create(this[01;31m-[00m>lisp());
clusterFinder.cc:335:    frameList[01;31m-[00m>setSliderName("cluster");
clusterFinder.cc:336:    frameList[01;31m-[00m>setName("clusters");
clusterFinder.cc:337:    for ( List<O_Cluster>::iterator it=this[01;31m-[00m>_Clusters.begin(); 
clusterFinder.cc:338:    		it!=this[01;31m-[00m>_Clusters.end(); it++ )
clusterFinder.cc:340:	frameList[01;31m-[00m>add((*it)[01;31m-[00m>renderWithBonds(res,this[01;31m-[00m>_AtomNames));
clusterFinder.cc:350:	class_<O_ClusterEntry>(this[01;31m-[00m>lisp())
clusterFinder.cc:373:	class_<O_Cluster>(this[01;31m-[00m>lisp())
clusterFinder.cc:402:	class_<O_ClusterFinder>(this[01;31m-[00m>lisp())
commandOligomer.cc:38:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:39:    this[01;31m-[00m>_Oligomer = olig;
commandOligomer.cc:40://    this[01;31m-[00m>_BuilderDatabaseRef = O_BuilderDatabaseReference::create(this[01;31m-[00m>lisp(),cdb,"");
commandOligomer.cc:47:    this[01;31m-[00m>Base::archiveBase(node);
commandOligomer.cc:48:    node[01;31m-[00m>archiveObject("oligomer",this[01;31m-[00m>_Oligomer);
commandOligomer.cc:49://    node[01;31m-[00m>archiveObject("bdbRef",this[01;31m-[00m>_BuilderDatabaseRef);
commandOligomer.cc:54:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:55:    ASSERT_NOT_NULL(this[01;31m-[00m>_Oligomer);
commandOligomer.cc:56://    ASSERT_NOT_NULL(this[01;31m-[00m>_BuilderDatabaseRef);
commandOligomer.cc:61:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:62:    ASSERT_NOT_NULL(this[01;31m-[00m>_Oligomer);
commandOligomer.cc:63://    ASSERT_NOT_NULL(this[01;31m-[00m>_BuilderDatabaseRef);
commandOligomer.cc:68:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:69:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:71:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:72:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:73:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:81:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:82:    this[01;31m-[00m>O_CommandOligomer::setup(olig,cdb);
commandOligomer.cc:83:    this[01;31m-[00m>_MonomerFrom = monomerFrom;
commandOligomer.cc:84:    this[01;31m-[00m>_CouplingName = couplingName;
commandOligomer.cc:85:    this[01;31m-[00m>_GroupName = groupName;
commandOligomer.cc:86:    this[01;31m-[00m>_Pos2D = pos2D;
commandOligomer.cc:90:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:91:    this[01;31m-[00m>Base::archiveBase(node);
commandOligomer.cc:92:    node[01;31m-[00m>archiveObject("monomerFrom",this[01;31m-[00m>_MonomerFrom);
commandOligomer.cc:93:    node[01;31m-[00m>archiveObject("monomerAdded",this[01;31m-[00m>_MonomerAdded);
commandOligomer.cc:94:    node[01;31m-[00m>attribute("couplingName",this[01;31m-[00m>_CouplingName);
commandOligomer.cc:95:    node[01;31m-[00m>attribute("groupName",this[01;31m-[00m>_GroupName);
commandOligomer.cc:96:    node[01;31m-[00m>archivePlainObject<Vector2>( "pos2","Vector2",
commandOligomer.cc:97:    					this[01;31m-[00m>_Pos2D );
commandOligomer.cc:102:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:106:    this[01;31m-[00m>O_CommandOligomer::doIt();
commandOligomer.cc:107:    coup = O_DirectionalCoupling::create(this[01;31m-[00m>lisp());
commandOligomer.cc:108:    coup[01;31m-[00m>setName(this[01;31m-[00m>_CouplingName);
commandOligomer.cc:109:    monTo = O_MultiMonomer::create(this[01;31m-[00m>lisp());
commandOligomer.cc:110:    monTo[01;31m-[00m>setGroupName(this[01;31m-[00m>_GroupName);
commandOligomer.cc:111:    monTo[01;31m-[00m>setPosition2D(this[01;31m-[00m>_Pos2D);
commandOligomer.cc:112:    this[01;31m-[00m>_MonomerAdded = monTo;
commandOligomer.cc:113:    coup[01;31m-[00m>setOutMonomer(monTo);
commandOligomer.cc:114:    monTo[01;31m-[00m>setInCoupling(coup);
commandOligomer.cc:116:    monFrom = this[01;31m-[00m>_MonomerFrom;
commandOligomer.cc:117:    monFrom[01;31m-[00m>addOutCoupling(coup);
commandOligomer.cc:118:    coup[01;31m-[00m>setInMonomer(monFrom);
commandOligomer.cc:119:    this[01;31m-[00m>_Oligomer[01;31m-[00m>addMonomer(monTo);
commandOligomer.cc:120:    this[01;31m-[00m>_Oligomer[01;31m-[00m>addCoupling(coup);
commandOligomer.cc:121:    monFrom[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:122:    monTo[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:123:    coup[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:127:    this[01;31m-[00m>_Oligomer[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:130:    changedMonomers.insert(this[01;31m-[00m>_MonomerFrom);
commandOligomer.cc:131:    changedMonomers.insert(this[01;31m-[00m>_MonomerAdded);
commandOligomer.cc:132:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:133:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signalConnectivityChanged();
commandOligomer.cc:137:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:142:    this[01;31m-[00m>O_CommandOligomer::undoIt();
commandOligomer.cc:143:    monomerToRemove = this[01;31m-[00m>_MonomerAdded;
commandOligomer.cc:144:    if ( !monomerToRemove[01;31m-[00m>hasInCoupling() )
commandOligomer.cc:146:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Trying to remove a leaf monomer that has no in coupling! in "+monomerToRemove[01;31m-[00m>description()));
commandOligomer.cc:148:    couplingCount = monomerToRemove[01;31m-[00m>numberOfCouplings();
commandOligomer.cc:151:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Trying to remove a leaf monomer but it has out couplings! in "+monomerToRemove[01;31m-[00m>description()));
commandOligomer.cc:153:    couplingToRemove = monomerToRemove[01;31m-[00m>getInCoupling()[01;31m-[00m>as<O_DirectionalCoupling>();
commandOligomer.cc:154:    monomerToRemain = this[01;31m-[00m>_MonomerFrom;
commandOligomer.cc:155:    monomerToRemain[01;31m-[00m>removeCoupling(couplingToRemove);
commandOligomer.cc:156:    this[01;31m-[00m>_Oligomer[01;31m-[00m>removeMonomer(monomerToRemove);
commandOligomer.cc:157:    this[01;31m-[00m>_Oligomer[01;31m-[00m>removeCoupling(couplingToRemove);
commandOligomer.cc:158:    monomerToRemain[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:162:    this[01;31m-[00m>_Oligomer[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:165:    changedMonomers.insert(this[01;31m-[00m>_MonomerFrom);
commandOligomer.cc:166:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:167:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signalConnectivityChanged();
commandOligomer.cc:173:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:174:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:176:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:177:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:178:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:184:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:185:    this[01;31m-[00m>Base::archiveBase(node);
commandOligomer.cc:186:    node[01;31m-[00m>archiveObject("monomerToDelete",this[01;31m-[00m>_MonomerToDelete);
commandOligomer.cc:187:    node[01;31m-[00m>archiveObject("couplingToDelete",this[01;31m-[00m>_CouplingToDelete);
commandOligomer.cc:188:    node[01;31m-[00m>archiveList("couplingsToRewire",this[01;31m-[00m>_CouplingsToRewire);
commandOligomer.cc:189:    node[01;31m-[00m>archiveObject("monomerToRewireTo",this[01;31m-[00m>_MonomerToRewireTo);
commandOligomer.cc:195:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:196:    this[01;31m-[00m>O_CommandOligomer::setup(olig,cdb);
commandOligomer.cc:197:    this[01;31m-[00m>_MonomerToDelete = monomerToDelete;
commandOligomer.cc:198:    this[01;31m-[00m>_CouplingToDelete = monomerToDelete[01;31m-[00m>getInCoupling()[01;31m-[00m>as<O_DirectionalCoupling>();
commandOligomer.cc:199:    this[01;31m-[00m>_CouplingsToRewire = monomerToDelete[01;31m-[00m>getOutCouplings();
commandOligomer.cc:200:    this[01;31m-[00m>_MonomerToRewireTo = this[01;31m-[00m>_CouplingToDelete[01;31m-[00m>getInMonomer();
commandOligomer.cc:204:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:207:    this[01;31m-[00m>O_CommandOligomer::doIt();
commandOligomer.cc:208:    this[01;31m-[00m>_Oligomer[01;31m-[00m>removeMonomer(this[01;31m-[00m>_MonomerToDelete);
commandOligomer.cc:209:    this[01;31m-[00m>_Oligomer[01;31m-[00m>removeCoupling(this[01;31m-[00m>_CouplingToDelete);
commandOligomer.cc:210:    this[01;31m-[00m>_MonomerToRewireTo[01;31m-[00m>removeCouplingToMonomer(this[01;31m-[00m>_MonomerToDelete);
commandOligomer.cc:213:    for ( c=this[01;31m-[00m>_CouplingsToRewire.begin();
commandOligomer.cc:214:    	c!=this[01;31m-[00m>_CouplingsToRewire.end(); c++ )
commandOligomer.cc:216:	this[01;31m-[00m>_MonomerToRewireTo[01;31m-[00m>addOutCoupling(*c);
commandOligomer.cc:217:	RPDirectionalCoupling dirCoup = (*c)[01;31m-[00m>as<O_DirectionalCoupling>();
commandOligomer.cc:218:	dirCoup[01;31m-[00m>setInMonomer(this[01;31m-[00m>_MonomerToRewireTo); // added
commandOligomer.cc:219:	dirCoup[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:220:	changedMonomers.insert((dirCoup)[01;31m-[00m>getOutMonomer());
commandOligomer.cc:222:    changedMonomers.insert(this[01;31m-[00m>_MonomerToRewireTo);
commandOligomer.cc:225:    this[01;31m-[00m>_MonomerToRewireTo[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:230:    this[01;31m-[00m>_Oligomer[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:233:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:234:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signalConnectivityChanged();
commandOligomer.cc:238:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:241:    this[01;31m-[00m>O_CommandOligomer::undoIt();
commandOligomer.cc:243:    for ( c=this[01;31m-[00m>_CouplingsToRewire.begin();
commandOligomer.cc:244:    	c!=this[01;31m-[00m>_CouplingsToRewire.end(); c++ )
commandOligomer.cc:246:	this[01;31m-[00m>_MonomerToRewireTo[01;31m-[00m>removeCoupling(*c);
commandOligomer.cc:247:	RPDirectionalCoupling dc = (*c)[01;31m-[00m>as<O_DirectionalCoupling>();
commandOligomer.cc:248:	dc[01;31m-[00m>setInMonomer(this[01;31m-[00m>_MonomerToDelete);
commandOligomer.cc:249:	dc[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:250:	changedMonomers.insert(dc[01;31m-[00m>getOutMonomer());
commandOligomer.cc:252:    changedMonomers.insert(this[01;31m-[00m>_CouplingToDelete[01;31m-[00m>getInMonomer() );
commandOligomer.cc:253:    changedMonomers.insert(this[01;31m-[00m>_CouplingToDelete[01;31m-[00m>getOutMonomer() );
commandOligomer.cc:254:    changedMonomers.insert(this[01;31m-[00m>_MonomerToDelete);	// may be redundant _CouplingToDelete points to it
commandOligomer.cc:255:    this[01;31m-[00m>_MonomerToRewireTo[01;31m-[00m>addOutCoupling(this[01;31m-[00m>_CouplingToDelete);
commandOligomer.cc:256:    this[01;31m-[00m>_Oligomer[01;31m-[00m>addMonomer(this[01;31m-[00m>_MonomerToDelete);
commandOligomer.cc:257:    this[01;31m-[00m>_Oligomer[01;31m-[00m>addCoupling(this[01;31m-[00m>_CouplingToDelete);
commandOligomer.cc:258:    this[01;31m-[00m>_MonomerToRewireTo[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:259:    this[01;31m-[00m>_CouplingToDelete[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:260:    this[01;31m-[00m>_MonomerToDelete[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:264:    this[01;31m-[00m>_Oligomer[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:266:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:267:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signalConnectivityChanged();
commandOligomer.cc:272:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:273:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:275:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:276:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:277:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:296:	outCouplings = spanNext[01;31m-[00m>getOutCouplings();
commandOligomer.cc:299:	    if ( (*ic)[01;31m-[00m>isOfClass<O_DirectionalCoupling>() )
commandOligomer.cc:301:		RPDirectionalCoupling dc = (*ic)[01;31m-[00m>as<O_DirectionalCoupling>();
commandOligomer.cc:302:	        outMon = dc[01;31m-[00m>getOutMonomer();
commandOligomer.cc:317:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:324:    this[01;31m-[00m>O_CommandOligomer::setup(olig,cdb);
commandOligomer.cc:325:    this[01;31m-[00m>_MonomerToInsertBefore = beforeMon;
commandOligomer.cc:326:    inCoupling = beforeMon[01;31m-[00m>getInCoupling()[01;31m-[00m>as<O_DirectionalCoupling>();
commandOligomer.cc:328:    inMonomer = inCoupling[01;31m-[00m>getInMonomer();
commandOligomer.cc:330:    start = inMonomer[01;31m-[00m>getPosition2D();
commandOligomer.cc:331:    stop = beforeMon[01;31m-[00m>getPosition2D();
commandOligomer.cc:332:    this[01;31m-[00m>_Offset = Vector2( 0,stop.getY()[01;31m-[00mstart.getY());
commandOligomer.cc:333:    this[01;31m-[00m>_MonomersToMove = monomersBelow(beforeMon);
commandOligomer.cc:334:    mon = O_MultiMonomer::create(this[01;31m-[00m>lisp());
commandOligomer.cc:335:    mon[01;31m-[00m>setGroupName(groupName);
commandOligomer.cc:336:    coup = O_DirectionalCoupling::create(this[01;31m-[00m>lisp());
commandOligomer.cc:337:    coup[01;31m-[00m>setName(couplingName);
commandOligomer.cc:338:    mon[01;31m-[00m>setPosition2D(stop);
commandOligomer.cc:339:    this[01;31m-[00m>_CouplingToInsertAfter = beforeMon[01;31m-[00m>getInCoupling()[01;31m-[00m>as<O_DirectionalCoupling>();
commandOligomer.cc:340:    this[01;31m-[00m>_MonomerNew = mon;
commandOligomer.cc:341:    this[01;31m-[00m>_CouplingToInsertBeforeNew = coup;
commandOligomer.cc:345:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:346:    this[01;31m-[00m>Base::archiveBase(node);
commandOligomer.cc:347:    node[01;31m-[00m>archiveObject("monomerToInsertBefore",this[01;31m-[00m>_MonomerToInsertBefore);
commandOligomer.cc:348:    node[01;31m-[00m>archiveList("monomersToMove",this[01;31m-[00m>_MonomersToMove);
commandOligomer.cc:349:    node[01;31m-[00m>archiveObject("CouplingToInsertAfter",this[01;31m-[00m>_CouplingToInsertAfter);
commandOligomer.cc:350:    node[01;31m-[00m>archiveObject("MonomerNew",this[01;31m-[00m>_MonomerNew);
commandOligomer.cc:351:    node[01;31m-[00m>archiveObject("CoupingToInsertBeforeNew",this[01;31m-[00m>_CouplingToInsertBeforeNew);
commandOligomer.cc:352:    node[01;31m-[00m>archiveObject("MonomerToInsertBefore",this[01;31m-[00m>_MonomerToInsertBefore);
commandOligomer.cc:353:    node[01;31m-[00m>archivePlainObject<Vector2>( "pos","Vector2", this[01;31m-[00m>_Offset );
commandOligomer.cc:358:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:360:    this[01;31m-[00m>O_CommandOligomer::doIt();
commandOligomer.cc:363:    for ( im=this[01;31m-[00m>_MonomersToMove.begin(); im!=this[01;31m-[00m>_MonomersToMove.end(); im++ )
commandOligomer.cc:365:	pos = (*im)[01;31m-[00m>getPosition2D();
commandOligomer.cc:366:	pos = pos.add(this[01;31m-[00m>_Offset);
commandOligomer.cc:367:	(*im)[01;31m-[00m>setPosition2D(pos);
commandOligomer.cc:369:    this[01;31m-[00m>_Oligomer[01;31m-[00m>addCoupling(this[01;31m-[00m>_CouplingToInsertBeforeNew);
commandOligomer.cc:370:    this[01;31m-[00m>_Oligomer[01;31m-[00m>addMonomer(this[01;31m-[00m>_MonomerNew);
commandOligomer.cc:371:    this[01;31m-[00m>_CouplingToInsertAfter[01;31m-[00m>setOutMonomer(this[01;31m-[00m>_MonomerNew);
commandOligomer.cc:372:    this[01;31m-[00m>_MonomerNew[01;31m-[00m>setInCoupling(this[01;31m-[00m>_CouplingToInsertAfter);
commandOligomer.cc:373:    this[01;31m-[00m>_MonomerNew[01;31m-[00m>addOutCoupling(this[01;31m-[00m>_CouplingToInsertBeforeNew);
commandOligomer.cc:374:    this[01;31m-[00m>_CouplingToInsertBeforeNew[01;31m-[00m>setInMonomer(this[01;31m-[00m>_MonomerNew);
commandOligomer.cc:375:    LOG(BF("Setting outMonomer for coupling: %s") % this[01;31m-[00m>_CouplingToInsertBeforeNew[01;31m-[00m>description().c_str() ); // vp0(("Setting outMonomer for coupling: %s",this[01;31m-[00m>_CouplingToInsertBeforeNew[01;31m-[00m>description().c_str()));
commandOligomer.cc:376:    this[01;31m-[00m>_CouplingToInsertBeforeNew[01;31m-[00m>setOutMonomer(this[01;31m-[00m>_MonomerToInsertBefore);
commandOligomer.cc:377:    LOG(BF("Setting in coupling for monomerToInsertBefore: %s") % this[01;31m-[00m>_MonomerToInsertBefore[01;31m-[00m>description().c_str() ); // vp0(("Setting in coupling for monomerToInsertBefore: %s",this[01;31m-[00m>_MonomerToInsertBefore[01;31m-[00m>description().c_str()));
commandOligomer.cc:378:    this[01;31m-[00m>_MonomerToInsertBefore[01;31m-[00m>setInCoupling(this[01;31m-[00m>_CouplingToInsertBeforeNew);
commandOligomer.cc:379:    this[01;31m-[00m>_MonomerToInsertBefore[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:380:    this[01;31m-[00m>_MonomerNew[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:381:    this[01;31m-[00m>_CouplingToInsertAfter[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:382:    this[01;31m-[00m>_CouplingToInsertBeforeNew[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:386:    this[01;31m-[00m>_Oligomer[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:389:    changedMonomers.insert(this[01;31m-[00m>_MonomerNew);
commandOligomer.cc:390:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:391:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signalConnectivityChanged();
commandOligomer.cc:395:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:399:    this[01;31m-[00m>O_CommandOligomer::undoIt();
commandOligomer.cc:400:    putBack = Vector2([01;31m-[00mthis[01;31m-[00m>_Offset.getX(),[01;31m-[00mthis[01;31m-[00m>_Offset.getY());
commandOligomer.cc:402:    for ( im=this[01;31m-[00m>_MonomersToMove.begin(); im!=this[01;31m-[00m>_MonomersToMove.end(); im++ )
commandOligomer.cc:404:	pos = (*im)[01;31m-[00m>getPosition2D();
commandOligomer.cc:405:	pos = pos.add(this[01;31m-[00m>_Offset);
commandOligomer.cc:406:	(*im)[01;31m-[00m>setPosition2D(pos);
commandOligomer.cc:408:    this[01;31m-[00m>_CouplingToInsertAfter[01;31m-[00m>setOutMonomer(this[01;31m-[00m>_MonomerToInsertBefore);
commandOligomer.cc:409:    this[01;31m-[00m>_MonomerToInsertBefore[01;31m-[00m>setInCoupling(this[01;31m-[00m>_CouplingToInsertAfter);
commandOligomer.cc:410:    this[01;31m-[00m>_Oligomer[01;31m-[00m>removeCoupling(this[01;31m-[00m>_CouplingToInsertBeforeNew);
commandOligomer.cc:411:    this[01;31m-[00m>_Oligomer[01;31m-[00m>removeMonomer(this[01;31m-[00m>_MonomerNew);
commandOligomer.cc:412:    this[01;31m-[00m>_MonomerNew[01;31m-[00m>resetInCoupling();
commandOligomer.cc:413:    this[01;31m-[00m>_CouplingToInsertBeforeNew[01;31m-[00m>resetOut();
commandOligomer.cc:414:    this[01;31m-[00m>_MonomerToInsertBefore[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:415:    this[01;31m-[00m>_CouplingToInsertAfter[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:419:    this[01;31m-[00m>_Oligomer[01;31m-[00m>throwIfBadConnections();
commandOligomer.cc:423:    for ( mmi=this[01;31m-[00m>_MonomerNew[01;31m-[00m>begin_value_WeakCouplings(); mmi!=this[01;31m-[00m>_MonomerNew[01;31m-[00m>end_value_WeakCouplings(); mmi++ )
commandOligomer.cc:426:	coupling = (*mmi).lock()[01;31m-[00m>as<O_DirectionalCoupling>();
commandOligomer.cc:427:	otherMonomer = coupling[01;31m-[00m>getOtherSideMonomer(this[01;31m-[00m>_MonomerNew);
commandOligomer.cc:430:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNotNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:431:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signalConnectivityChanged();
commandOligomer.cc:439:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:440:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:442:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:443:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:444:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:450:    this[01;31m-[00m>Base::initialize();
commandOligomer.cc:451:    this[01;31m-[00m>_OldGroupNames = O_StringList::create(this[01;31m-[00m>lisp());
commandOligomer.cc:463:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:465:    this[01;31m-[00m>O_CommandOligomer::setup(olig,cdb);
commandOligomer.cc:466:    this[01;31m-[00m>_NewGroupName = newGroupName;
commandOligomer.cc:467:    this[01;31m-[00m>_MonomersToMutate.clear();
commandOligomer.cc:468:    this[01;31m-[00m>_OldGroupNames[01;31m-[00m>clear();
commandOligomer.cc:469:    for (mi=olig[01;31m-[00m>begin_Monomers(); mi!=olig[01;31m-[00m>end_Monomers(); mi++ )
commandOligomer.cc:471:        if ( (*mi)[01;31m-[00m>isSelected() )
commandOligomer.cc:473:	    this[01;31m-[00m>_MonomersToMutate.append(*mi);
commandOligomer.cc:474:	    this[01;31m-[00m>_OldGroupNames[01;31m-[00m>append((*mi)[01;31m-[00m>getGroupName());
commandOligomer.cc:482:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:483:    this[01;31m-[00m>Base::archiveBase(node);
commandOligomer.cc:484:    node[01;31m-[00m>attribute("newGroupName",this[01;31m-[00m>_NewGroupName);
commandOligomer.cc:485:    node[01;31m-[00m>archiveList("monomersToMutate",this[01;31m-[00m>_MonomersToMutate);
commandOligomer.cc:486:    node[01;31m-[00m>archiveObject("oldGroupNames",this[01;31m-[00m>_OldGroupNames);
commandOligomer.cc:493:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:495:    this[01;31m-[00m>O_CommandOligomer::doIt();
commandOligomer.cc:496:    LOG(BF("Setting new group names to(%s)") % this[01;31m-[00m>_NewGroupName.c_str()  ); // vp0(("Setting new group names to(%s)",this[01;31m-[00m>_NewGroupName.c_str() ));
commandOligomer.cc:497:    for ( it=this[01;31m-[00m>_MonomersToMutate.begin(); it!=this[01;31m-[00m>_MonomersToMutate.end(); it++ )
commandOligomer.cc:499:        (*it)[01;31m-[00m>setGroupName(this[01;31m-[00m>_NewGroupName);
commandOligomer.cc:502:    ASSERT_NOT_NULL(this[01;31m-[00m>_Oligomer);
commandOligomer.cc:503:    set<RPMonomer>	changedMonomers(this[01;31m-[00m>_MonomersToMutate.begin(),this[01;31m-[00m>_MonomersToMutate.end());
commandOligomer.cc:504:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:505:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signal_monomerContentsChanged();
commandOligomer.cc:514:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:517:    this[01;31m-[00m>O_CommandOligomer::doIt();
commandOligomer.cc:518:    for ( it=this[01;31m-[00m>_MonomersToMutate.begin(), si=this[01;31m-[00m>_OldGroupNames[01;31m-[00m>begin();
commandOligomer.cc:519:    	it!=this[01;31m-[00m>_MonomersToMutate.end(); it++, si++ )
commandOligomer.cc:521:        (*it)[01;31m-[00m>setGroupName((*si));
commandOligomer.cc:524:    set<RPMonomer>	changedMonomers(this[01;31m-[00m>_MonomersToMutate.begin(),this[01;31m-[00m>_MonomersToMutate.end());
commandOligomer.cc:525:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:526:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signal_monomerContentsChanged();
commandOligomer.cc:533:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:534:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:536:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:537:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:538:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:546:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:550:    this[01;31m-[00m>O_CommandOligomer::setup(olig,cdb);
commandOligomer.cc:551:    this[01;31m-[00m>_Monomer = mon;
commandOligomer.cc:552:    this[01;31m-[00m>_NewGroupName = newGroupName;
commandOligomer.cc:553:    this[01;31m-[00m>_NewAliases = newAliases;
commandOligomer.cc:554:    this[01;31m-[00m>_NewComment = newComment;
commandOligomer.cc:555:    this[01;31m-[00m>_OldGroupName = mon[01;31m-[00m>getGroupName();
commandOligomer.cc:556:    this[01;31m-[00m>_OldAliases = mon[01;31m-[00m>getAliasesAsString();
commandOligomer.cc:557:    this[01;31m-[00m>_OldComment = mon[01;31m-[00m>getComment();
commandOligomer.cc:563:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:564:    this[01;31m-[00m>Base::archiveBase(node);
commandOligomer.cc:565:    node[01;31m-[00m>archiveObject("monomer",this[01;31m-[00m>_Monomer );
commandOligomer.cc:566:    node[01;31m-[00m>attribute("newGroupName",this[01;31m-[00m>_NewGroupName);
commandOligomer.cc:567:    node[01;31m-[00m>attribute("newAliases",this[01;31m-[00m>_NewAliases);
commandOligomer.cc:568:    node[01;31m-[00m>attribute("newComment",this[01;31m-[00m>_NewComment);
commandOligomer.cc:569:    node[01;31m-[00m>attribute("oldGroupName",this[01;31m-[00m>_OldGroupName);
commandOligomer.cc:570:    node[01;31m-[00m>attribute("oldAliases",this[01;31m-[00m>_OldAliases);
commandOligomer.cc:571:    node[01;31m-[00m>attribute("oldComment",this[01;31m-[00m>_OldComment);
commandOligomer.cc:578:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:580:    this[01;31m-[00m>O_CommandOligomer::doIt();
commandOligomer.cc:581:    LOG(BF("Setting new group names to(%s)") % this[01;31m-[00m>_NewGroupName.c_str()  ); // vp0(("Setting new group names to(%s)",this[01;31m-[00m>_NewGroupName.c_str() ));
commandOligomer.cc:582:    this[01;31m-[00m>_Monomer[01;31m-[00m>setGroupName(this[01;31m-[00m>_NewGroupName);
commandOligomer.cc:583:    this[01;31m-[00m>_Monomer[01;31m-[00m>setAliasesFromString(this[01;31m-[00m>_NewAliases);
commandOligomer.cc:584:    this[01;31m-[00m>_Monomer[01;31m-[00m>setComment(this[01;31m-[00m>_NewComment);
commandOligomer.cc:588:    changedMonomers.insert(this[01;31m-[00m>_Monomer);
commandOligomer.cc:589:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:590:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signal_monomerContentsChanged();
commandOligomer.cc:599:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:601:    this[01;31m-[00m>O_CommandOligomer::undoIt();
commandOligomer.cc:602:    LOG(BF("Setting old group names to(%s)") % this[01;31m-[00m>_OldGroupName.c_str()  ); // vp0(("Setting old group names to(%s)",this[01;31m-[00m>_OldGroupName.c_str() ));
commandOligomer.cc:603:    this[01;31m-[00m>_Monomer[01;31m-[00m>setGroupName(this[01;31m-[00m>_OldGroupName);
commandOligomer.cc:604:    this[01;31m-[00m>_Monomer[01;31m-[00m>setAliasesFromString(this[01;31m-[00m>_OldAliases);
commandOligomer.cc:605:    this[01;31m-[00m>_Monomer[01;31m-[00m>setComment(this[01;31m-[00m>_OldComment);
commandOligomer.cc:609:    changedMonomers.insert(this[01;31m-[00m>_Monomer);
commandOligomer.cc:610:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:611:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signal_monomerContentsChanged();
commandOligomer.cc:617:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:618:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:620:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:621:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:622:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:628:    this[01;31m-[00m>Base::initialize();
commandOligomer.cc:629:    this[01;31m-[00m>_OldCouplingNames = O_StringList::create(this[01;31m-[00m>lisp());
commandOligomer.cc:641:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:643:    this[01;31m-[00m>O_CommandOligomer::setup(olig,cdb);
commandOligomer.cc:644:    this[01;31m-[00m>_NewCouplingName = newCouplingName;
commandOligomer.cc:645:    this[01;31m-[00m>_CouplingsToMutate.clear();
commandOligomer.cc:646:    this[01;31m-[00m>_OldCouplingNames[01;31m-[00m>clear();
commandOligomer.cc:647:    for (mi=olig[01;31m-[00m>begin_Couplings(); mi!=olig[01;31m-[00m>end_Couplings(); mi++ )
commandOligomer.cc:649:        if ( (*mi)[01;31m-[00m>isSelected() )
commandOligomer.cc:651:	    RPDirectionalCoupling dc = (*mi)[01;31m-[00m>as<O_DirectionalCoupling>();
commandOligomer.cc:652:	    this[01;31m-[00m>_CouplingsToMutate.append(dc);
commandOligomer.cc:653:	    this[01;31m-[00m>_OldCouplingNames[01;31m-[00m>append(dc[01;31m-[00m>getName());
commandOligomer.cc:661:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:662:    this[01;31m-[00m>Base::archiveBase(node);
commandOligomer.cc:663:    node[01;31m-[00m>attribute("newCouplingName",this[01;31m-[00m>_NewCouplingName);
commandOligomer.cc:664:    node[01;31m-[00m>archiveList("monomersToMutate",this[01;31m-[00m>_CouplingsToMutate);
commandOligomer.cc:665:    node[01;31m-[00m>archiveObject("oldCouplingNames",this[01;31m-[00m>_OldCouplingNames);
commandOligomer.cc:672:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:675:    this[01;31m-[00m>O_CommandOligomer::doIt();
commandOligomer.cc:676:    LOG(BF("Setting new group names to(%s)") % this[01;31m-[00m>_NewCouplingName.c_str()  ); // vp0(("Setting new group names to(%s)",this[01;31m-[00m>_NewCouplingName.c_str() ));
commandOligomer.cc:677:    for ( it=this[01;31m-[00m>_CouplingsToMutate.begin(); it!=this[01;31m-[00m>_CouplingsToMutate.end(); it++ )
commandOligomer.cc:679:        (*it)[01;31m-[00m>setName(this[01;31m-[00m>_NewCouplingName);
commandOligomer.cc:680:	changedMonomers.insert((*it)[01;31m-[00m>getInMonomer());
commandOligomer.cc:681:	changedMonomers.insert((*it)[01;31m-[00m>getOutMonomer());
commandOligomer.cc:684:    ASSERT_NOT_NULL(this[01;31m-[00m>_Oligomer);
commandOligomer.cc:685:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:686:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signal_monomerContentsChanged();
commandOligomer.cc:695:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:699:    this[01;31m-[00m>O_CommandOligomer::doIt();
commandOligomer.cc:700:    for ( it=this[01;31m-[00m>_CouplingsToMutate.begin(), si=this[01;31m-[00m>_OldCouplingNames[01;31m-[00m>begin();
commandOligomer.cc:701:    	it!=this[01;31m-[00m>_CouplingsToMutate.end(); it++, si++ )
commandOligomer.cc:703:        (*it)[01;31m-[00m>setName((*si));
commandOligomer.cc:704:	changedMonomers.insert((*it)[01;31m-[00m>getInMonomer());
commandOligomer.cc:705:	changedMonomers.insert((*it)[01;31m-[00m>getOutMonomer());
commandOligomer.cc:707:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:708:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signal_monomerContentsChanged();
commandOligomer.cc:715:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:716:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:718:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:719:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:720:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
commandOligomer.cc:727:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:729:    this[01;31m-[00m>O_CommandOligomer::setup(olig,cdb);
commandOligomer.cc:730:    this[01;31m-[00m>_Coupling = mon;
commandOligomer.cc:731:    this[01;31m-[00m>_NewCouplingName = newCouplingName;
commandOligomer.cc:732:    this[01;31m-[00m>_OldCouplingName = mon[01;31m-[00m>getName();
commandOligomer.cc:738:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:739:    this[01;31m-[00m>Base::archiveBase(node);
commandOligomer.cc:740:    node[01;31m-[00m>archiveObject("monomer",this[01;31m-[00m>_Coupling );
commandOligomer.cc:741:    node[01;31m-[00m>attribute("newCouplingName",this[01;31m-[00m>_NewCouplingName);
commandOligomer.cc:742:    node[01;31m-[00m>attribute("oldCouplingName",this[01;31m-[00m>_OldCouplingName);
commandOligomer.cc:749:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:751:    this[01;31m-[00m>O_CommandOligomer::doIt();
commandOligomer.cc:752:    LOG(BF("Setting new group names to(%s)") % this[01;31m-[00m>_NewCouplingName.c_str()  ); // vp0(("Setting new group names to(%s)",this[01;31m-[00m>_NewCouplingName.c_str() ));
commandOligomer.cc:753:    this[01;31m-[00m>_Coupling[01;31m-[00m>setName(this[01;31m-[00m>_NewCouplingName);
commandOligomer.cc:756:    changedMonomers.insert(this[01;31m-[00m>_Coupling[01;31m-[00m>getInMonomer());
commandOligomer.cc:757:    changedMonomers.insert(this[01;31m-[00m>_Coupling[01;31m-[00m>getOutMonomer());
commandOligomer.cc:758:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:759:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signal_monomerContentsChanged();
commandOligomer.cc:768:{_F(this[01;31m-[00m>lisp());
commandOligomer.cc:770:    this[01;31m-[00m>O_CommandOligomer::undoIt();
commandOligomer.cc:771:    LOG(BF("Setting old group names to(%s)") % this[01;31m-[00m>_OldCouplingName.c_str()  ); // vp0(("Setting old group names to(%s)",this[01;31m-[00m>_OldCouplingName.c_str() ));
commandOligomer.cc:772:    this[01;31m-[00m>_Coupling[01;31m-[00m>setName(this[01;31m-[00m>_OldCouplingName);
commandOligomer.cc:774:    changedMonomers.insert(this[01;31m-[00m>_Coupling[01;31m-[00m>getInMonomer());
commandOligomer.cc:775:    changedMonomers.insert(this[01;31m-[00m>_Coupling[01;31m-[00m>getOutMonomer());
commandOligomer.cc:776:    this[01;31m-[00m>_Oligomer[01;31m-[00m>checkMonomersAndNeighborsForErrors(this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase(), changedMonomers );
commandOligomer.cc:777:    this[01;31m-[00m>_Oligomer[01;31m-[00m>signal_monomerContentsChanged();
complexRestraints.cc:29:	class_<O_ComplexRestraint>(env[01;31m-[00m>lisp())
complexRestraints.cc:47:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
complexRestraints.cc:53:    this[01;31m-[00m>Base::initialize();
complexRestraints.cc:58:    this[01;31m-[00m>Base::archiveBase(node);
complexRestraints.cc:64:    class_<O_RestrainedPiBond>(env[01;31m-[00m>lisp())
complexRestraints.cc:106:    node[01;31m-[00m>attribute( "Configuration",this[01;31m-[00m>_Configuration);
complexRestraints.cc:107://    node[01;31m-[00m>attribute( "Priority1AtomOnAtomX",this[01;31m-[00m>_Priority1AtomOnAtomX);
complexRestraints.cc:108://    node[01;31m-[00m>attribute( "Priority2AtomOnAtomX",this[01;31m-[00m>_Priority2AtomOnAtomX);
complexRestraints.cc:109:    node[01;31m-[00m>attribute( "PiAtomX",this[01;31m-[00m>_PiAtomX);
complexRestraints.cc:110://    node[01;31m-[00m>attribute( "Priority1AtomOnAtomY",this[01;31m-[00m>_Priority1AtomOnAtomY);
complexRestraints.cc:111://    node[01;31m-[00m>attribute( "Priority2AtomOnAtomY",this[01;31m-[00m>_Priority2AtomOnAtomY);
complexRestraints.cc:112:    node[01;31m-[00m>attribute( "PiAtomY",this[01;31m-[00m>_PiAtomY);
complexRestraints.cc:117:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
complexRestraints.cc:118:    this[01;31m-[00m>_Configuration = dict[01;31m-[00m>getStringAndRemove("config"); 
complexRestraints.cc:119:    if ( this[01;31m-[00m>_Configuration != "E" && this[01;31m-[00m>_Configuration != "Z" )
complexRestraints.cc:121:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("config:  must be ""E"" or ""Z""" ));
complexRestraints.cc:123:    RPCons piAtoms = dict[01;31m-[00m>getAndRemove("piAtoms")[01;31m-[00m>as<O_Cons>();
complexRestraints.cc:124:    if ( piAtoms[01;31m-[00m>length() != 2 )
complexRestraints.cc:126:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must supply two atom names in piAtoms: argument"));
complexRestraints.cc:128:    this[01;31m-[00m>_PiAtomX = piAtoms[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
complexRestraints.cc:129:    this[01;31m-[00m>_PiAtomY = piAtoms[01;31m-[00m>cadr<O_Text>()[01;31m-[00m>get();
complexRestraints.cc:137:    RPRestraintDihedral dih = O_RestraintDihedral::create(this[01;31m-[00m>lisp());
complexRestraints.cc:138:    dih[01;31m-[00m>setAtomA(p1X);
complexRestraints.cc:139:    dih[01;31m-[00m>setAtomB(pX);
complexRestraints.cc:140:    dih[01;31m-[00m>setAtomC(pY);
complexRestraints.cc:141:    dih[01;31m-[00m>setAtomD(p1Y);
complexRestraints.cc:142:    dih[01;31m-[00m>setParameters(min,max,weight);
complexRestraints.cc:143:    restraints[01;31m-[00m>addRestraint(dih);
complexRestraints.cc:162:    string config = this[01;31m-[00m>_Configuration;
complexRestraints.cc:163:    RPAtom pX  = residue[01;31m-[00m>atomWithName(this[01;31m-[00m>getPiAtomX());
complexRestraints.cc:164:    RPAtom pY  = residue[01;31m-[00m>atomWithName(this[01;31m-[00m>getPiAtomY());
complexRestraints.cc:166:    RPAtom p1X = pX[01;31m-[00m>highestPriorityNeighborThatIsnt(pY);
complexRestraints.cc:167:    RPAtom p2X = pX[01;31m-[00m>lowestPriorityNeighborThatIsnt(pY);
complexRestraints.cc:170:	p2X = O_Atom::nil(this[01;31m-[00m>lisp());
complexRestraints.cc:172:    RPAtom p1Y = pY[01;31m-[00m>highestPriorityNeighborThatIsnt(pX);
complexRestraints.cc:173:    RPAtom p2Y = pY[01;31m-[00m>lowestPriorityNeighborThatIsnt(pX);
complexRestraints.cc:176:	p2Y = O_Atom::nil(this[01;31m-[00m>lisp());
complexRestraints.cc:178:    if ( pX[01;31m-[00m>numberOfBonds() < 2 || pX[01;31m-[00m>numberOfBonds() > 3  )
complexRestraints.cc:181:	ss << "Dihedral restraints X atom: " << this[01;31m-[00m>_PiAtomX;
complexRestraints.cc:182:	ss << " must have between 2 and 3 bonds [01;31m-[00m it has " << pX[01;31m-[00m>numberOfBonds();
complexRestraints.cc:183:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>(ss.str() ));
complexRestraints.cc:185:    if ( pY[01;31m-[00m>numberOfBonds() < 2 || pY[01;31m-[00m>numberOfBonds() > 3  )
complexRestraints.cc:188:	ss << "Dihedral restraints Y atom: " << this[01;31m-[00m>_PiAtomY;
complexRestraints.cc:189:	ss << " must have between 2 and 3 bonds [01;31m-[00m it has " << pY[01;31m-[00m>numberOfBonds();
complexRestraints.cc:190:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>(ss.str() ));
complexRestraints.cc:192:    double transMin = [01;31m-[00m170.0;
complexRestraints.cc:195:    double cisMax = [01;31m-[00m10.0;
complexRestraints.cc:199:	this[01;31m-[00m>fillOneDihedralRestraint(restraints,p1X,pX,pY,p1Y,cisMin,cisMax,weight);
complexRestraints.cc:200:	if ( p2Y[01;31m-[00m>notNil() ) 
complexRestraints.cc:202:	    this[01;31m-[00m>fillOneDihedralRestraint(restraints,p1X,pX,pY,p2Y,transMin,transMax,weight);
complexRestraints.cc:204:	if ( p2X[01;31m-[00m>notNil() ) 
complexRestraints.cc:206:	    this[01;31m-[00m>fillOneDihedralRestraint(restraints,p2X,pX,pY,p1Y,transMin,transMax,weight);
complexRestraints.cc:208:	if ( p2X[01;31m-[00m>notNil() && p2Y[01;31m-[00m>notNil() )
complexRestraints.cc:210:	    this[01;31m-[00m>fillOneDihedralRestraint(restraints,p2X,pX,pY,p2Y,cisMin,cisMax,weight);
complexRestraints.cc:214:	this[01;31m-[00m>fillOneDihedralRestraint(restraints,p1X,pX,pY,p1Y,transMin,transMax,weight);
complexRestraints.cc:215:	if ( p2Y[01;31m-[00m>notNil() )
complexRestraints.cc:217:	    this[01;31m-[00m>fillOneDihedralRestraint(restraints,p1X,pX,pY,p2Y,cisMin,cisMax,weight);
complexRestraints.cc:219:	if ( p2X[01;31m-[00m>notNil() )
complexRestraints.cc:221:	    this[01;31m-[00m>fillOneDihedralRestraint(restraints,p2X,pX,pY,p1Y,cisMin,cisMax,weight);
complexRestraints.cc:223:	if ( p2X[01;31m-[00m>notNil() && p2Y[01;31m-[00m>notNil() )
complexRestraints.cc:225:	    this[01;31m-[00m>fillOneDihedralRestraint(restraints,p2X,pX,pY,p2Y,transMin,transMax,weight);
complexRestraints.cc:229:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Illegal Pi bond configuration: "+config+" must be E or Z"));
complexRestraints.cc:236:	class_<O_RestrainedExoCyclicAtom>(env[01;31m-[00m>lisp())
complexRestraints.cc:259:	O_RestrainedExoCyclicAtom::_AtomExoToSixMemberedRing = O_ChemInfo::create(this[01;31m-[00m>lisp());
complexRestraints.cc:260:	bool success = O_RestrainedExoCyclicAtom::_AtomExoToSixMemberedRing[01;31m-[00m>compileSmarts("[*]9[*]1[*]2[*]3[*]4[*]5[*]6[?9]");
complexRestraints.cc:263:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Error compiling SMARTS code for _AtomExoToSixMemberedRing"));
complexRestraints.cc:270:    this[01;31m-[00m>_ExoCyclicAtomName = "";
complexRestraints.cc:271:    this[01;31m-[00m>_Axial = true;
complexRestraints.cc:276:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
complexRestraints.cc:281:    this[01;31m-[00m>Base::archiveBase(node);
complexRestraints.cc:282:    node[01;31m-[00m>attribute("exoCyclicAtomName",this[01;31m-[00m>_ExoCyclicAtomName);
complexRestraints.cc:283:    node[01;31m-[00m>attribute("axial",this[01;31m-[00m>_Axial);
complexRestraints.cc:290:    this[01;31m-[00m>lazyInitializeSmarts();
complexRestraints.cc:291:    if ( !residue[01;31m-[00m>hasAtomWithName(this[01;31m-[00m>_ExoCyclicAtomName) )
complexRestraints.cc:293:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Residue(%s) doesn't have atom with name(%s)") % residue[01;31m-[00m>description() % this[01;31m-[00m>_ExoCyclicAtomName ));
complexRestraints.cc:295:    RPAtom exoCyclicAtom = residue[01;31m-[00m>atomWithName(this[01;31m-[00m>_ExoCyclicAtomName);
complexRestraints.cc:296:    O_RestrainedExoCyclicAtom::_AtomExoToSixMemberedRing[01;31m-[00m>matches(exoCyclicAtom);
complexRestraints.cc:297:    RPChemInfoMatch match = O_RestrainedExoCyclicAtom::_AtomExoToSixMemberedRing[01;31m-[00m>getMatch();
complexRestraints.cc:298:    if ( !match[01;31m-[00m>matches() )
complexRestraints.cc:300:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("In residue(%s) the atom with name(%s) is not exo[01;31m-[00mcyclic to a six[01;31m-[00mmembered ring") % residue[01;31m-[00m>description() % this[01;31m-[00m>_ExoCyclicAtomName ));
complexRestraints.cc:302:    RPAtom a1 = match[01;31m-[00m>tag("1");
complexRestraints.cc:303:    RPAtom a2 = match[01;31m-[00m>tag("2");
complexRestraints.cc:304:    RPAtom a3 = match[01;31m-[00m>tag("3");
complexRestraints.cc:305:    RPAtom a4 = match[01;31m-[00m>tag("4");
complexRestraints.cc:306:    RPAtom a5 = match[01;31m-[00m>tag("5");
complexRestraints.cc:307:    RPAtom a6 = match[01;31m-[00m>tag("6");
conditionHandlerList.cc:37:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
conditionHandlerList.cc:43:    this[01;31m-[00m>Base::initialize();
conditionHandlerList.cc:48:    this[01;31m-[00m>Base::archiveBase(node);
conditions.cc:39:    class_<O_ConditionWithStackTrace>(env[01;31m-[00m>lisp())
conditions.cc:45:    this[01;31m-[00m>saveStackTrace(lisp[01;31m-[00m>debugLog().cppCallStack()); 
conditions.cc:50:    this[01;31m-[00m>_CppCallStack = c._CppCallStack;
conditions.cc:56:    this[01;31m-[00m>_CppCallStack.copyFromOther(copy);
conditions.cc:62:    return this[01;31m-[00m>_CppCallStack.asString();
conditions.cc:74:    ss << this[01;31m-[00m>getStackTraceDump();
conditions.cc:81:    class_<O_CandoException>(env[01;31m-[00m>lisp())
conditions.cc:92:    this[01;31m-[00m>_Message = msg;
conditions.cc:97:	this[01;31m-[00m>_Message += msg;
conditions.cc:102:	this[01;31m-[00m>_Message += f.str();
conditions.cc:108:    ss << this[01;31m-[00m>_Message << endl;
conditions.cc:109:    ss << this[01;31m-[00m>getStackTraceDump() << endl;
conditions.cc:115:    this[01;31m-[00m>_Message = f.str(); 
conditions.cc:121:    this[01;31m-[00m>_Message = e._Message;
conditions.cc:126:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
conditions.cc:127:    ASSERTP(kargs[01;31m-[00m>numberOfPositionalArguments()<2, "Condition can have at most one argument");
conditions.cc:128:    this[01;31m-[00m>_Message = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
conditions.cc:133:    this[01;31m-[00m>__setClass(env[01;31m-[00m>classObject<O_CandoException>());
conditions.cc:140:    class_<O_FileNotFoundException>(env[01;31m-[00m>lisp())
conditions.cc:148:    e[01;31m-[00m>setMessage((BF("Could not find file(%s)") % fileName ).str() );
conditions.cc:164:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
conditions.cc:169:    this[01;31m-[00m>__setClass(env[01;31m-[00m>classObject<O_FileNotFoundException>());
conditions.cc:175:    class_<O_MathException>(env[01;31m-[00m>lisp())
conditions.cc:182:    e[01;31m-[00m>setMessage(m);
conditions.cc:189:    this[01;31m-[00m>__setClass(env[01;31m-[00m>classObject<O_MathException>());
conditions.cc:195:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
conditions.cc:201:    class_<O_LispError>(env[01;31m-[00m>lisp())
conditions.cc:207:    this[01;31m-[00m>__setClass(env[01;31m-[00m>classObject<O_LispError>());
conditions.cc:215:	err[01;31m-[00m>setMessage(fmt.str());
conditions.cc:223:	err[01;31m-[00m>setMessage(str);
conditions.cc:233:    class_<O_ContentException>(env[01;31m-[00m>lisp())
conditions.cc:239:    this[01;31m-[00m>__setClass(env[01;31m-[00m>classObject<O_ContentException>());
conditions.cc:247:    e[01;31m-[00m>setMessage(msg);
conditions.cc:254:    e[01;31m-[00m>setMessage(msg+msg2);
conditions.cc:261:    e[01;31m-[00m>setMessage(fmt.str());
conditions.cc:267:    this[01;31m-[00m>_ConditionObject = cond;
conditions.cc:272:    this[01;31m-[00m>_ConditionObject = cc._ConditionObject;
conditions.cc:282:    HARD_ASSERT(this[01;31m-[00m>_ConditionObject.use_count()!=0);
conditions.cc:283:    return this[01;31m-[00m>_ConditionObject;
conditions.cc:288:    this[01;31m-[00m>_ConditionObject = co;
conditions.cc:293:    return this[01;31m-[00m>_ConditionObject[01;31m-[00m>message();
confSearchDatabase.cc:32:    this[01;31m-[00m>Base::initialize();
confSearchDatabase.cc:33:    this[01;31m-[00m>_EnergyCutOff = 5.0; // kCal/mole
confSearchDatabase.cc:34:    this[01;31m-[00m>setRmsCutOff(0.1);
confSearchDatabase.cc:35:    this[01;31m-[00m>enableDisplayProgress();
confSearchDatabase.cc:40:{_F(this[01;31m-[00m>lisp());
confSearchDatabase.cc:41:    this[01;31m-[00m>O_SuperposableConformationCollection::clearEntries();
confSearchDatabase.cc:51:{_F(this[01;31m-[00m>lisp());
confSearchDatabase.cc:55:    if ( this[01;31m-[00m>numberOfEntries() == 0 )
confSearchDatabase.cc:57:        this[01;31m-[00m>O_SuperposableConformationCollection::addEntry(entry);
confSearchDatabase.cc:61:    firstEntry = this[01;31m-[00m>getEntry(0);
confSearchDatabase.cc:62:    lowestEnergy = firstEntry[01;31m-[00m>getData()[01;31m-[00m>getDouble("energy");
confSearchDatabase.cc:63:    newEnergy = entry[01;31m-[00m>getData()[01;31m-[00m>getDouble("energy");
confSearchDatabase.cc:64:    if ( newEnergy[01;31m-[00mlowestEnergy > this[01;31m-[00m>_EnergyCutOff )
confSearchDatabase.cc:68:    for ( O_SuperposableConformationCollection::entryIterator ei=this[01;31m-[00m>begin_Entries(); ei!=this[01;31m-[00m>end_Entries(); ei++ )
confSearchDatabase.cc:70:        if ( (*ei)[01;31m-[00m>getData()[01;31m-[00m>getDouble("energy") > newEnergy )
confSearchDatabase.cc:72:	    this[01;31m-[00m>_Entries.insert(ei,entry);
confSearchDatabase.cc:76:    this[01;31m-[00m>_Entries.append(entry);
confSearchDatabase.cc:89:    this[01;31m-[00m>Base::archiveBase(node);
confSearchDatabase.cc:90:    node[01;31m-[00m>attribute( "EnergyCutOff", this[01;31m-[00m>_EnergyCutOff );
confSearchDatabase.cc:91:    node[01;31m-[00m>attribute( "DisplayProgress", this[01;31m-[00m>_DisplayProgress );
confSearchDatabase.cc:99:{_F(this[01;31m-[00m>lisp());
confSearchDatabase.cc:108:    if ( this[01;31m-[00m>numberOfEntries() <= 0 ) return;
confSearchDatabase.cc:111:    firstEntry = this[01;31m-[00m>firstEntry();
confSearchDatabase.cc:112:    superposer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SuperposeEngine>();
confSearchDatabase.cc:113:    this[01;31m-[00m>setEntryCoordinatesAsFixedWithinSuperposeEngine(firstEntry,superposer);
confSearchDatabase.cc:118:    firstEntry[01;31m-[00m>writeCoordinatesToMatter(this[01;31m-[00m>_Matter);
confSearchDatabase.cc:119:    firstEntry[01;31m-[00m>getData()[01;31m-[00m>setDouble("energyWrtFirst",0.0);
confSearchDatabase.cc:120:    firstEntry[01;31m-[00m>getData()[01;31m-[00m>setDouble("rmsWrtFirst",0.0);
confSearchDatabase.cc:121:    energy = firstEntry[01;31m-[00m>getData()[01;31m-[00m>getDouble("energy");
confSearchDatabase.cc:130:    uint highIndex = this[01;31m-[00m>_Entries.size()[01;31m-[00m1;
confSearchDatabase.cc:132:    double lowestEnergy = (*(this[01;31m-[00m>_Entries.begin()))[01;31m-[00m>getData()[01;31m-[00m>getDouble("energy");
confSearchDatabase.cc:134:    for ( i=1,ei=this[01;31m-[00m>begin_Entries()+1; ei!=this[01;31m-[00m>end_Entries(); i++,ei++ )
confSearchDatabase.cc:136:        energy = (*ei)[01;31m-[00m>getData()[01;31m-[00m>getDouble("energy");
confSearchDatabase.cc:138:	double deltaEnergy = energy[01;31m-[00mlowestEnergy;
confSearchDatabase.cc:139:		// If delta > this[01;31m-[00m>_EnergyCutOff then throw this and following
confSearchDatabase.cc:141:	if ( deltaEnergy > this[01;31m-[00m>_EnergyCutOff )
confSearchDatabase.cc:143:	    lastUsefulEntry = i[01;31m-[00m1;
confSearchDatabase.cc:146:        this[01;31m-[00m>setEntryCoordinatesAsMoveableWithinSuperposeEngine(*ei,superposer);
confSearchDatabase.cc:147:	transform = superposer[01;31m-[00m>superpose();
confSearchDatabase.cc:148:	rms = superposer[01;31m-[00m>rootMeanSquareDifference();
confSearchDatabase.cc:149:	(*ei)[01;31m-[00m>getData()[01;31m-[00m>setDouble("energyWrtFirst",deltaEnergy);
confSearchDatabase.cc:150:	(*ei)[01;31m-[00m>getData()[01;31m-[00m>setDouble("rmsWrtFirst",rms);
confSearchDatabase.cc:151:        (*ei)[01;31m-[00m>writeCoordinatesToMatter(this[01;31m-[00m>_Matter);
confSearchDatabase.cc:152:	this[01;31m-[00m>_Matter[01;31m-[00m>applyTransformToAtoms(transform);
confSearchDatabase.cc:153:	(*ei)[01;31m-[00m>extractCoordinatesFromMatter(this[01;31m-[00m>_Matter);
confSearchDatabase.cc:154:	if ( this[01;31m-[00m>_DisplayProgress)
confSearchDatabase.cc:156:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("CONFSEARCH: Entry %d  energy(%lf) rms(%lf)") % i% energy % rms );
confSearchDatabase.cc:160:    if ( lastUsefulEntry < this[01;31m-[00m>_Entries.size()[01;31m-[00m1 )
confSearchDatabase.cc:162:	if ( this[01;31m-[00m>_DisplayProgress )
confSearchDatabase.cc:164:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "CONFSEARCH: Trimming search entry table to %d elements") % (lastUsefulEntry+1) );
confSearchDatabase.cc:167:	this[01;31m-[00m>_Entries.resize(lastUsefulEntry+1);
conformationCollection.cc:37:    this[01;31m-[00m>Base::initialize();
conformationCollection.cc:38:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
conformationCollection.cc:39:    this[01;31m-[00m>_AllCoordinates = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>();
conformationCollection.cc:45:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:46:    node[01;31m-[00m>archiveWeakPointer( "ConformationCollection",
conformationCollection.cc:47:   		 this[01;31m-[00m>_WeakConformationCollection );
conformationCollection.cc:48:    node[01;31m-[00m>archiveObject("AllCoordinates", this[01;31m-[00m>_AllCoordinates );
conformationCollection.cc:49:    node[01;31m-[00m>archiveObject("Data",this[01;31m-[00m>_Data);
conformationCollection.cc:50:    if ( node[01;31m-[00m>loading() )
conformationCollection.cc:53:	LOG(BF("allCoords =%s") % (this[01;31m-[00m>_AllCoordinates[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("allCoords =%s",this[01;31m-[00m>_AllCoordinates[01;31m-[00m>asXmlString().c_str() ));
conformationCollection.cc:57:	LOG(BF("allCoords =%s") % (this[01;31m-[00m>_AllCoordinates[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("allCoords =%s",this[01;31m-[00m>_AllCoordinates[01;31m-[00m>asXmlString().c_str() ));
conformationCollection.cc:65:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:67:    this[01;31m-[00m>_WeakConformationCollection = s;
conformationCollection.cc:68:    ca = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>(s[01;31m-[00m>numberOfAllAtoms());
conformationCollection.cc:69:    this[01;31m-[00m>_AllCoordinates = ca;
conformationCollection.cc:74:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:76:    LOG(BF("setAllCoordinates:%s") % (ac[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("setAllCoordinates:%s",ac[01;31m-[00m>asXmlString().c_str() ));
conformationCollection.cc:78:    this[01;31m-[00m>_AllCoordinates = ac;
conformationCollection.cc:84:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:88:    sl = this[01;31m-[00m>getConformationCollection();
conformationCollection.cc:89:    for ( ai=sl[01;31m-[00m>begin_AllAtoms(),ci=this[01;31m-[00m>_AllCoordinates[01;31m-[00m>begin(); ai!=sl[01;31m-[00m>end_AllAtoms(); ai++, ci++ )
conformationCollection.cc:91:        (*ai)[01;31m-[00m>setPosition(*ci);
conformationCollection.cc:97:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:102:    this[01;31m-[00m>_Status[01;31m-[00m>addMessage("extractCoordinatesFromMatter");
conformationCollection.cc:105:    sl = this[01;31m-[00m>getConformationCollection();
conformationCollection.cc:108:    RPCoordinateArray coords = sl[01;31m-[00m>_extractCoordinateArray(matter);
conformationCollection.cc:110:    this[01;31m-[00m>_AllCoordinates = coords;
conformationCollection.cc:116:    this[01;31m-[00m>Base::initialize();
conformationCollection.cc:117:    this[01;31m-[00m>_Matter = O_Matter::nil(this[01;31m-[00m>lisp());
conformationCollection.cc:118:    this[01;31m-[00m>_AllAtoms.clear();
conformationCollection.cc:119:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
conformationCollection.cc:120:    this[01;31m-[00m>clearEntries();
conformationCollection.cc:125:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:126:    this[01;31m-[00m>_Entries.clear();
conformationCollection.cc:132:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:136:    this[01;31m-[00m>_Status[01;31m-[00m>addMessage("extractCoordinatesFromMatter");
conformationCollection.cc:140:    RPCoordinateArray coords = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>(this[01;31m-[00m>numberOfAllAtoms());
conformationCollection.cc:142:    for ( ai=this[01;31m-[00m>begin_AllAtoms(),ci=coords[01;31m-[00m>begin(); ai!=this[01;31m-[00m>end_AllAtoms(); ai++, ci++ )
conformationCollection.cc:144:        LOG(BF("Getting position of %s") % (*ai)[01;31m-[00m>description().c_str()  ); // vp0(("Getting position of %s",(*ai)[01;31m-[00m>description().c_str() ));
conformationCollection.cc:145:        *ci = (*ai)[01;31m-[00m>getPosition();
conformationCollection.cc:153:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:156:    this[01;31m-[00m>_Matter = matter;
conformationCollection.cc:157:    this[01;31m-[00m>_AllAtoms.clear();
conformationCollection.cc:162:	this[01;31m-[00m>_AllAtoms.insert(a);
conformationCollection.cc:170:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:171:    this[01;31m-[00m>_Entries.append(entry);
conformationCollection.cc:179:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:183:    matter = orig[01;31m-[00m>getMatter();
conformationCollection.cc:184:    ASSERTP(matter==this[01;31m-[00m>getMatter(),"The Matter objects must match");
conformationCollection.cc:185:    for ( si=orig[01;31m-[00m>begin_Entries(); si!=orig[01;31m-[00m>end_Entries(); si++ )
conformationCollection.cc:187:        (*si)[01;31m-[00m>writeCoordinatesToMatter(matter);
conformationCollection.cc:188:	entry = this[01;31m-[00m>createEntry();
conformationCollection.cc:189:	entry[01;31m-[00m>extractCoordinatesFromMatter(matter);
conformationCollection.cc:190:        this[01;31m-[00m>addEntry(entry);
conformationCollection.cc:197:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:202:    matter = orig[01;31m-[00m>getMatter();
conformationCollection.cc:203:    ASSERTP(matter==this[01;31m-[00m>getMatter(),"The Matter objects must match");
conformationCollection.cc:204:    for ( si=orig[01;31m-[00m>begin_Entries(); si!=orig[01;31m-[00m>end_Entries(); si++ )
conformationCollection.cc:206:    	entryStage = (*si)[01;31m-[00m>getLastCompleteEntryStage();
conformationCollection.cc:207:        entryStage[01;31m-[00m>writeCoordinatesToMatter(matter);
conformationCollection.cc:208:	entry = this[01;31m-[00m>createEntry();
conformationCollection.cc:209:	entry[01;31m-[00m>extractCoordinatesFromMatter(matter);
conformationCollection.cc:210:        this[01;31m-[00m>addEntry(entry);
conformationCollection.cc:216:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:221:    matter = orig[01;31m-[00m>getMatter();
conformationCollection.cc:222:    ASSERTP(matter==this[01;31m-[00m>getMatter(),"The Matter objects must match");
conformationCollection.cc:223:    for ( si=orig[01;31m-[00m>begin_Entries(); si!=orig[01;31m-[00m>end_Entries(); si++ )
conformationCollection.cc:225:        ASSERTP((*si)[01;31m-[00m>hasSelectedStage(),"Entry missing selected stage");
conformationCollection.cc:226:    	entryStage = (*si)[01;31m-[00m>getSelectedStage();
conformationCollection.cc:227:        entryStage[01;31m-[00m>writeCoordinatesToMatter(matter);
conformationCollection.cc:228:	entry = this[01;31m-[00m>createEntry();
conformationCollection.cc:229:	entry[01;31m-[00m>extractCoordinatesFromMatter(matter);
conformationCollection.cc:230:        this[01;31m-[00m>addEntry(entry);
conformationCollection.cc:243:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:244:    node[01;31m-[00m>archiveObject( "Matter", this[01;31m-[00m>_Matter );
conformationCollection.cc:245:    node[01;31m-[00m>archiveOrderedSet( "AllAtoms", this[01;31m-[00m>_AllAtoms );
conformationCollection.cc:246:    node[01;31m-[00m>archiveList( "Entries", this[01;31m-[00m>_Entries );
conformationCollection.cc:247:    node[01;31m-[00m>archiveObjectIfDefined( "Data", this[01;31m-[00m>_Data );
conformationCollection.cc:251:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:252:    this[01;31m-[00m>archiveBase(node);
conformationCollection.cc:259:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:270:    frames = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderFrameList>();
conformationCollection.cc:271:    matter = this[01;31m-[00m>getMatter();
conformationCollection.cc:272:    for ( si=this[01;31m-[00m>begin_Entries(); si!=this[01;31m-[00m>end_Entries(); si++ )
conformationCollection.cc:274:        (*si)[01;31m-[00m>writeCoordinatesToMatter(matter);
conformationCollection.cc:275:	dlMatter = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderMatter>();
conformationCollection.cc:276:	dlMatter[01;31m-[00m>setName("gaussianMinimized");
conformationCollection.cc:277:	dlMatter[01;31m-[00m>setFromMatter(matter);
conformationCollection.cc:278:	frames[01;31m-[00m>add(dlMatter);
conformationCollection.cc:292:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:295:    xml = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_XmlSaveArchive>();
conformationCollection.cc:296:    xml[01;31m-[00m>put("ConformationCollection",this[01;31m-[00m>sharedThis<O_ConformationCollection>());
conformationCollection.cc:297:    xml[01;31m-[00m>saveAs(fn);
conformationCollection.cc:302:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:305:    for ( i=0,ei=this[01;31m-[00m>_Entries.begin(); ei!=this[01;31m-[00m>_Entries.end(); ei++,i++ )
conformationCollection.cc:312:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find entry in ConformationCollection"));
conformationCollection.cc:319:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:320:    ASSERT_lessThan(i,this[01;31m-[00m>_Entries.size());
conformationCollection.cc:322:    e = this[01;31m-[00m>_Entries[i];
conformationCollection.cc:327:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:328:    ASSERT(this[01;31m-[00m>_Entries.size() > 0 );
conformationCollection.cc:329:    return this[01;31m-[00m>_Entries[0];
conformationCollection.cc:334:{_F(this[01;31m-[00m>lisp());
conformationCollection.cc:336:    entry = RP_Create<O_ConformationCollectionEntry>(this[01;31m-[00m>lisp());
conformationCollection.cc:337:    entry[01;31m-[00m>setConformationCollection(this[01;31m-[00m>sharedThis<O_ConformationCollection>());
conformationExplorer.cc:38:    this[01;31m-[00m>Base::initialize();
conformationExplorer.cc:39:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
conformationExplorer.cc:40:    this[01;31m-[00m>_FinalCoordinates = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>();
conformationExplorer.cc:41:    this[01;31m-[00m>_WeakConformationExplorerEntry = O_ConformationExplorerEntry::nil(this[01;31m-[00m>lisp());
conformationExplorer.cc:42:    this[01;31m-[00m>_Complete = true;
conformationExplorer.cc:43:    this[01;31m-[00m>_EnergyKCal = 0.0;
conformationExplorer.cc:44:    this[01;31m-[00m>_ExternalInterfaceName = "";
conformationExplorer.cc:45:    this[01;31m-[00m>_Model = "";
conformationExplorer.cc:50:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:52:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakConformationExplorerEntry);
conformationExplorer.cc:53:    entry = this[01;31m-[00m>_WeakConformationExplorerEntry.lock();
conformationExplorer.cc:58:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:60:    explorer = this[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:61:    superposer[01;31m-[00m>setFixedPoints(explorer[01;31m-[00m>_getSuperposeAtomIndices(), this[01;31m-[00m>_FinalCoordinates );
conformationExplorer.cc:66:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:68:    explorer = this[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:69:    superposer[01;31m-[00m>setMoveablePoints(explorer[01;31m-[00m>_getSuperposeAtomIndices(), this[01;31m-[00m>_FinalCoordinates );
conformationExplorer.cc:75:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:77:    explorer = this[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:78:    superposer[01;31m-[00m>setFixedAllPoints(this[01;31m-[00m>_FinalCoordinates);
conformationExplorer.cc:83:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:85:    explorer = this[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:86:    superposer[01;31m-[00m>setMoveableAllPoints(this[01;31m-[00m>_FinalCoordinates);
conformationExplorer.cc:92:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:94:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakConformationExplorerEntry);
conformationExplorer.cc:95:    entry = this[01;31m-[00m>getConformationExplorerEntry();
conformationExplorer.cc:96:    return entry[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:101:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:102:     RPSuperposeEngine superposer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SuperposeEngine>();
conformationExplorer.cc:103:     entryStage[01;31m-[00m>setSuperposableCoordinatesAsFixedWithinSuperposeEngine(superposer);
conformationExplorer.cc:104:     this[01;31m-[00m>setSuperposableCoordinatesAsMoveableWithinSuperposeEngine(superposer);
conformationExplorer.cc:105:     Matrix transform = superposer[01;31m-[00m>superpose();
conformationExplorer.cc:106:     this[01;31m-[00m>_FinalCoordinates[01;31m-[00m>transform(transform);
conformationExplorer.cc:115:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:122:    explorer = this[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:123:    dlAll = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
conformationExplorer.cc:124:    dlAll[01;31m-[00m>setName(this[01;31m-[00m>_StageName);
conformationExplorer.cc:127:	matter = explorer[01;31m-[00m>getMatter();
conformationExplorer.cc:128:	this[01;31m-[00m>writeCoordinatesToMatter(matter);
conformationExplorer.cc:129:	dlMatter = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderMatter>();
conformationExplorer.cc:130:	dlMatter[01;31m-[00m>setName("molecule");
conformationExplorer.cc:131:	dlMatter[01;31m-[00m>setFromMatter(matter);
conformationExplorer.cc:132:	dlAll[01;31m-[00m>add(dlMatter);
conformationExplorer.cc:137:	dlSuperpose = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
conformationExplorer.cc:138:	dlSuperpose[01;31m-[00m>setName("superposeAtoms");
conformationExplorer.cc:139:	dlSuperpose[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("yellow"));
conformationExplorer.cc:140:	RPGrSphereList sphereList = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrSphereList>();
conformationExplorer.cc:141:	sphereList[01;31m-[00m>setRadius(0.2);
conformationExplorer.cc:142:	for ( ii=explorer[01;31m-[00m>superposeAtomIndices_begin(); ii!=explorer[01;31m-[00m>superposeAtomIndices_end(); ii++ )
conformationExplorer.cc:144:	    sphereList[01;31m-[00m>addVertex(explorer[01;31m-[00m>_getAtomAtIndex(*ii)[01;31m-[00m>getPosition());
conformationExplorer.cc:146:	dlSuperpose[01;31m-[00m>add(sphereList);
conformationExplorer.cc:147:	dlAll[01;31m-[00m>add(dlSuperpose);
conformationExplorer.cc:152:    sinfo << "Stage name: "<< this[01;31m-[00m>_StageName << endl;
conformationExplorer.cc:153:    sinfo << "Based on stage: "<< this[01;31m-[00m>_BasedOnStageName << endl;
conformationExplorer.cc:154:    sinfo << "Is complete: " << this[01;31m-[00m>_Complete << endl;
conformationExplorer.cc:156:    		<< this[01;31m-[00m>_EnergyKCal << endl;
conformationExplorer.cc:157:    sinfo << "Generated by package: " << this[01;31m-[00m>_ExternalInterfaceName << endl;
conformationExplorer.cc:158:    sinfo << "Model: " << this[01;31m-[00m>_Model << endl;
conformationExplorer.cc:159:    if ( this[01;31m-[00m>getData()[01;31m-[00m>contains("Convergence") )
conformationExplorer.cc:161:        sinfo << this[01;31m-[00m>getData()[01;31m-[00m>getTextBlock("Convergence");
conformationExplorer.cc:163:    info = O_GrInformation::create(sinfo.str(),this[01;31m-[00m>lisp());
conformationExplorer.cc:164:    dlAll[01;31m-[00m>add(info);
conformationExplorer.cc:165:    RPRender dlDict = this[01;31m-[00m>getData()[01;31m-[00m>rendered(opts);
conformationExplorer.cc:166:    dlAll[01;31m-[00m>add(dlDict);
conformationExplorer.cc:176:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:177:    node[01;31m-[00m>attribute("StageName",this[01;31m-[00m>_StageName);
conformationExplorer.cc:178:    node[01;31m-[00m>attributeIfNotDefault<string>("BasedOnStageName",this[01;31m-[00m>_BasedOnStageName,"");
conformationExplorer.cc:179:    node[01;31m-[00m>attributeIfNotDefault<string>("ExternalInterfaceName",this[01;31m-[00m>_ExternalInterfaceName,"");
conformationExplorer.cc:180:    node[01;31m-[00m>attributeIfNotDefault<string>("Model",this[01;31m-[00m>_Model,"");
conformationExplorer.cc:181:    node[01;31m-[00m>attributeIfNotDefault("EnergyKCal",this[01;31m-[00m>_EnergyKCal,0.0);
conformationExplorer.cc:182:    node[01;31m-[00m>attributeIfNotDefault("Complete",this[01;31m-[00m>_Complete,true);
conformationExplorer.cc:183:    node[01;31m-[00m>archiveWeakPointer( "ConformationExplorerEntry",
conformationExplorer.cc:184:   		 this[01;31m-[00m>_WeakConformationExplorerEntry );
conformationExplorer.cc:185:    node[01;31m-[00m>archiveObject("AllCoordinates", this[01;31m-[00m>_FinalCoordinates );
conformationExplorer.cc:186:    node[01;31m-[00m>archiveObject("Data",this[01;31m-[00m>_Data);
conformationExplorer.cc:193:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:196:    this[01;31m-[00m>_WeakConformationExplorerEntry = s;
conformationExplorer.cc:197:    explorer = this[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:198:    ca = O_CoordinateArray::create(explorer[01;31m-[00m>numberOfAllAtoms(),this[01;31m-[00m>lisp());
conformationExplorer.cc:199:    this[01;31m-[00m>_FinalCoordinates = ca;
conformationExplorer.cc:204:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:206:    LOG(BF("setFinalCoordinates:%s") % (ac[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("setFinalCoordinates:%s",ac[01;31m-[00m>asXmlString().c_str() ));
conformationExplorer.cc:208:    this[01;31m-[00m>_FinalCoordinates = ac;
conformationExplorer.cc:214:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:217:    explorer = this[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:218:    idx = explorer[01;31m-[00m>indexOfAtom(atom);
conformationExplorer.cc:219:    ASSERT_NOT_NULL(this[01;31m-[00m>_FinalCoordinates);
conformationExplorer.cc:220:    ASSERT(this[01;31m-[00m>_FinalCoordinates[01;31m-[00m>size() == explorer[01;31m-[00m>numberOfAllAtoms());
conformationExplorer.cc:221:    this[01;31m-[00m>_FinalCoordinates[01;31m-[00m>setElement(idx,pos);
conformationExplorer.cc:226:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:230:    sl = this[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:231:    for ( ai=sl[01;31m-[00m>begin_AllAtoms(),ci=this[01;31m-[00m>_FinalCoordinates[01;31m-[00m>begin(); ai!=sl[01;31m-[00m>end_AllAtoms(); ai++, ci++ )
conformationExplorer.cc:233:        (*ai)[01;31m-[00m>setPosition(*ci);
conformationExplorer.cc:239:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:244:    sl = this[01;31m-[00m>getConformationExplorer();
conformationExplorer.cc:247:    RPCoordinateArray coords = sl[01;31m-[00m>_extractCoordinateArray(matter);
conformationExplorer.cc:249:    this[01;31m-[00m>_FinalCoordinates = coords;
conformationExplorer.cc:273:    this[01;31m-[00m>Base::initialize();
conformationExplorer.cc:274:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
conformationExplorer.cc:281:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:282:    node[01;31m-[00m>archiveWeakPointer( "ConformationExplorer",
conformationExplorer.cc:283:   		 this[01;31m-[00m>_WeakConformationExplorer );
conformationExplorer.cc:284:    node[01;31m-[00m>archiveList("Stages", this[01;31m-[00m>_Stages);
conformationExplorer.cc:285:    node[01;31m-[00m>archiveObjectIfDefined("SelectedStage",this[01;31m-[00m>_SelectedStage);
conformationExplorer.cc:286:    node[01;31m-[00m>archiveObject("Data",this[01;31m-[00m>_Data);
conformationExplorer.cc:290:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:291:    if ( !this[01;31m-[00m>hasSelectedStage() )
conformationExplorer.cc:293:	return O_ConformationExplorerEntryStage::nil(this[01;31m-[00m>lisp());
conformationExplorer.cc:295:    return this[01;31m-[00m>_SelectedStage;
conformationExplorer.cc:299:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:301:    stageEntry = stage[01;31m-[00m>getConformationExplorerEntry();
conformationExplorer.cc:303:    this[01;31m-[00m>_SelectedStage = stage;
conformationExplorer.cc:309:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:311:    stage = RP_Create<O_ConformationExplorerEntryStage>(this[01;31m-[00m>lisp());
conformationExplorer.cc:312:    stage[01;31m-[00m>setConformationExplorerEntry(this[01;31m-[00m>sharedThis<O_ConformationExplorerEntry>());
conformationExplorer.cc:318:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:320:    this[01;31m-[00m>_WeakConformationExplorer = s;
conformationExplorer.cc:327:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:328:    if ( this[01;31m-[00m>_Stages.size() == 0 ) return "";
conformationExplorer.cc:329:    return this[01;31m-[00m>_Stages[this[01;31m-[00m>_Stages.size()[01;31m-[00m1][01;31m-[00m>getStageName();
conformationExplorer.cc:335:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:336:    ASSERTP(this[01;31m-[00m>_Stages.size()>0,"There must be at least one complete stage");
conformationExplorer.cc:337:    int idx = this[01;31m-[00m>_Stages.size()[01;31m-[00m1;
conformationExplorer.cc:338:    return this[01;31m-[00m>_Stages[idx];
conformationExplorer.cc:343:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:345:    lastStage = this[01;31m-[00m>getLastCompleteEntryStage();
conformationExplorer.cc:346:    return( lastStage[01;31m-[00m>getStageName() == stageName );
conformationExplorer.cc:351:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:353:    lastStage = this[01;31m-[00m>getLastEntryStage();
conformationExplorer.cc:354:    if ( lastStage[01;31m-[00m>isComplete() )
conformationExplorer.cc:356:	if ( lastStage[01;31m-[00m>getStageName() != stageName )
conformationExplorer.cc:358:	    newStage = this[01;31m-[00m>createEntryStage();
conformationExplorer.cc:359:	    newStage[01;31m-[00m>setComplete(false);
conformationExplorer.cc:360:	    newStage[01;31m-[00m>setStageName(stageName);
conformationExplorer.cc:361:	    this[01;31m-[00m>appendEntryStage(newStage);
conformationExplorer.cc:364:	    newStage = O_ConformationExplorerEntryStage::nil(this[01;31m-[00m>lisp());
conformationExplorer.cc:370:	newStage[01;31m-[00m>setStageName(stageName);
conformationExplorer.cc:371:	newStage[01;31m-[00m>setComplete(false);
conformationExplorer.cc:378:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:379:    ASSERTP(this[01;31m-[00m>_Stages.size()>0,"There must be at least one complete stage");
conformationExplorer.cc:380:    int idx = this[01;31m-[00m>_Stages.size()[01;31m-[00m1;
conformationExplorer.cc:381:    if ( this[01;31m-[00m>_Stages[idx][01;31m-[00m>isComplete() )
conformationExplorer.cc:383:        return this[01;31m-[00m>_Stages[idx];
conformationExplorer.cc:386:    idx[01;31m-[00m[01;31m-[00m;
conformationExplorer.cc:387:    if ( this[01;31m-[00m>_Stages[idx][01;31m-[00m>isComplete() )
conformationExplorer.cc:389:        return this[01;31m-[00m>_Stages[idx];
conformationExplorer.cc:391:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Only the last stage can be incomplete"));
conformationExplorer.cc:401:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:403:    for ( si=this[01;31m-[00m>_Stages.begin(); si!=this[01;31m-[00m>_Stages.end(); si++ )
conformationExplorer.cc:405:	if ( (*si)[01;31m-[00m>getStageName() == key ) return true;
conformationExplorer.cc:412:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:414:    for ( si=this[01;31m-[00m>_Stages.begin(); si!=this[01;31m-[00m>_Stages.end(); si++ )
conformationExplorer.cc:416:	if ( (*si)[01;31m-[00m>getStageName() == key )
conformationExplorer.cc:421:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find key: "+key));
conformationExplorer.cc:427:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:431:    dlAll = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
conformationExplorer.cc:432://    dlAll[01;31m-[00m>setName("stages");
conformationExplorer.cc:433:    LOG(BF("Rendering %d stages")%this[01;31m-[00m>_Stages.size());
conformationExplorer.cc:434:    for ( si=this[01;31m-[00m>_Stages.begin(); si!=this[01;31m-[00m>_Stages.end(); si++ )
conformationExplorer.cc:435:    {_BLOCK_TRACEF(BF("Rendering stage: %s")%(*si)[01;31m-[00m>getStageName());
conformationExplorer.cc:436:        if ( (*si)[01;31m-[00m>isComplete() )
conformationExplorer.cc:439:	    dlStage = (*si)[01;31m-[00m>rendered(opts);
conformationExplorer.cc:440:	    dlAll[01;31m-[00m>add(dlStage);
conformationExplorer.cc:453:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:454:    ASSERTP(!this[01;31m-[00m>hasEntryStageWithName(stage[01;31m-[00m>getStageName()),"Stage with key: "+stage[01;31m-[00m>getStageName()+" already exists!");
conformationExplorer.cc:455:    this[01;31m-[00m>_Stages.push_back(stage);
conformationExplorer.cc:459:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:460:    RPStringSet stageNames = O_StringSet::create(this[01;31m-[00m>lisp());
conformationExplorer.cc:462:    for ( it=this[01;31m-[00m>begin_Stages(); it!=this[01;31m-[00m>end_Stages(); it++ )
conformationExplorer.cc:464:	stageNames[01;31m-[00m>insert((*it)[01;31m-[00m>getStageName());
conformationExplorer.cc:473:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
conformationExplorer.cc:480:    this[01;31m-[00m>Base::initialize();
conformationExplorer.cc:481:    this[01;31m-[00m>_Matter = O_Matter::nil(this[01;31m-[00m>lisp());
conformationExplorer.cc:482:    this[01;31m-[00m>_AllAtoms.clear();
conformationExplorer.cc:483:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
conformationExplorer.cc:484:    this[01;31m-[00m>clearEntries();
conformationExplorer.cc:485:    this[01;31m-[00m>_SuperposeAtomIndices = O_IntArray::create(this[01;31m-[00m>lisp());
conformationExplorer.cc:490:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:491:    this[01;31m-[00m>_Entries.clear();
conformationExplorer.cc:498:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:499:    ASSERT_lessThan(i,this[01;31m-[00m>_AllAtoms.size());
conformationExplorer.cc:500:    return this[01;31m-[00m>_AllAtoms[i];
conformationExplorer.cc:506:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:510:    this[01;31m-[00m>_Status[01;31m-[00m>addMessage("extractCoordinatesFromMatter");
conformationExplorer.cc:514:    uint numberOfAtoms = agg[01;31m-[00m>numberOfAtoms();
conformationExplorer.cc:515:    RPCoordinateArray coords = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>(numberOfAtoms);
conformationExplorer.cc:518:    for ( ai=this[01;31m-[00m>begin_AllAtoms(),ci=coords[01;31m-[00m>begin(); ai!=this[01;31m-[00m>end_AllAtoms(); ai++, ci++ )
conformationExplorer.cc:520:        LOG(BF("Getting position of ATOM(%d) %s") % aidx % (*ai)[01;31m-[00m>description().c_str() );
conformationExplorer.cc:521:	if ( !(*ai)[01;31m-[00m>isContainedBy(agg) )
conformationExplorer.cc:523:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You asked a ConformationExplorer to extract coordinates from the Matter(%s) but the ConformationExplorer atom(%s) is not contained within that Matter")%agg[01;31m-[00m>description()%(*ai)[01;31m-[00m>description()));
conformationExplorer.cc:527:	    LOG(BF("You asked a ConformationExplorer to extract coordinates from the Matter(%s) and the ConformationExplorer atom(%s) IS contained within that Matter")%agg[01;31m-[00m>description()%(*ai)[01;31m-[00m>description());
conformationExplorer.cc:530:        *ci = (*ai)[01;31m-[00m>getPosition();
conformationExplorer.cc:540:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:543:    this[01;31m-[00m>_Matter = matter;
conformationExplorer.cc:544:    this[01;31m-[00m>_AllAtoms.clear();
conformationExplorer.cc:549:	this[01;31m-[00m>_AllAtoms.insert(a);
conformationExplorer.cc:557:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:558:    entry[01;31m-[00m>setConformationExplorer(this[01;31m-[00m>sharedThis<O_ConformationExplorer>());
conformationExplorer.cc:559:    this[01;31m-[00m>_Entries.append(entry);
conformationExplorer.cc:564:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:565:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()), O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
conformationExplorer.cc:568:    for ( si=this[01;31m-[00m>begin_Entries(); si!=this[01;31m-[00m>end_Entries(); si++ )
conformationExplorer.cc:570:	RPCons newCons = O_Cons::create(*si,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
conformationExplorer.cc:571:	cur[01;31m-[00m>setCdr(newCons);
conformationExplorer.cc:574:    return first[01;31m-[00m>cdr();
conformationExplorer.cc:586:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:587:    if ( !node[01;31m-[00m>loading() )
conformationExplorer.cc:589:        ASSERT_NOT_NULL(this[01;31m-[00m>_Matter);
conformationExplorer.cc:591:    node[01;31m-[00m>archiveObject( "Matter", this[01;31m-[00m>_Matter );
conformationExplorer.cc:592:    node[01;31m-[00m>archiveList( "Entries", this[01;31m-[00m>_Entries );
conformationExplorer.cc:593:    node[01;31m-[00m>archiveOrderedSet( "AllAtoms", this[01;31m-[00m>_AllAtoms );
conformationExplorer.cc:594:    node[01;31m-[00m>archiveObject( "SuperposeAtomIndices", this[01;31m-[00m>_SuperposeAtomIndices );
conformationExplorer.cc:595:    node[01;31m-[00m>archiveObjectIfDefined( "Data", this[01;31m-[00m>_Data );
conformationExplorer.cc:599:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:600:    this[01;31m-[00m>archiveBase(node);
conformationExplorer.cc:607:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:616:    RPRenderDisplayList dlAll = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
conformationExplorer.cc:618:    frames = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderFrameList>();
conformationExplorer.cc:620:    if ( this[01;31m-[00m>numberOfEntries() == 0 )
conformationExplorer.cc:623:	ASSERT_NOT_NULL(this[01;31m-[00m>_Matter);
conformationExplorer.cc:624:	if ( this[01;31m-[00m>_Matter[01;31m-[00m>notNil() )
conformationExplorer.cc:627:	    dlEntry = this[01;31m-[00m>_Matter[01;31m-[00m>rendered(opts);
conformationExplorer.cc:629:	    frames[01;31m-[00m>add(dlEntry);
conformationExplorer.cc:634:	LOG(BF("FLAG! There are %d entries") % this[01;31m-[00m>_Entries.size());
conformationExplorer.cc:635:	for ( si=this[01;31m-[00m>begin_Entries(); si!=this[01;31m-[00m>end_Entries(); si++ )
conformationExplorer.cc:637:	    dlEntry = (*si)[01;31m-[00m>rendered(opts);
conformationExplorer.cc:638:	    frames[01;31m-[00m>add(dlEntry);
conformationExplorer.cc:642:    dlAll[01;31m-[00m>add(frames);
conformationExplorer.cc:644:    dlAll[01;31m-[00m>add(this[01;31m-[00m>_Data[01;31m-[00m>rendered(opts));
conformationExplorer.cc:653:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:654:    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeAtomIndices);
conformationExplorer.cc:655:    this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>clear();
conformationExplorer.cc:661:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:664:    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeAtomIndices);
conformationExplorer.cc:665:    for ( idx=0,ai=this[01;31m-[00m>begin_AllAtoms(); ai!=this[01;31m-[00m>end_AllAtoms(); idx++,ai++ )
conformationExplorer.cc:669:	    this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>append(idx);
conformationExplorer.cc:673:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("You cannot add superpose atom: "+a[01;31m-[00m>description()+" because it isn't in the ConformationCollection"));
conformationExplorer.cc:678:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:680:    this[01;31m-[00m>clearSuperposeAtoms();
conformationExplorer.cc:683:        this[01;31m-[00m>addSuperposeAtom(*ai);
conformationExplorer.cc:688:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:691:    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeAtomIndices);
conformationExplorer.cc:692:    this[01;31m-[00m>clearSuperposeAtoms();
conformationExplorer.cc:693:    for ( idx=0,ai=this[01;31m-[00m>begin_AllAtoms(); ai!=this[01;31m-[00m>end_AllAtoms(); idx++,ai++ )
conformationExplorer.cc:695:        if ( (*ai)[01;31m-[00m>getElement() != element_H )
conformationExplorer.cc:697:	    this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>append(idx);
conformationExplorer.cc:704:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:708:    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeAtomIndices);
conformationExplorer.cc:709:    for ( si=this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>begin();si!=this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>end(); si++ )
conformationExplorer.cc:711:        a = this[01;31m-[00m>_AllAtoms[*si];
conformationExplorer.cc:719:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:720:    return this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>size();
conformationExplorer.cc:732:	xStage = x[01;31m-[00m>getEntryStage(this[01;31m-[00m>_StageName);
conformationExplorer.cc:733:	yStage = y[01;31m-[00m>getEntryStage(this[01;31m-[00m>_StageName);
conformationExplorer.cc:734:	RPObject xValue = xStage[01;31m-[00m>getData()[01;31m-[00m>get(this[01;31m-[00m>_KeyName);
conformationExplorer.cc:735:	RPObject yValue = yStage[01;31m-[00m>getData()[01;31m-[00m>get(this[01;31m-[00m>_KeyName);
conformationExplorer.cc:736:	if ( xValue[01;31m-[00m>lt(yValue) ) return true;
conformationExplorer.cc:745:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:749:    sort::quickSort(this[01;31m-[00m>_Entries.begin(), this[01;31m-[00m>_Entries.end(), comparer,this[01;31m-[00m>lisp());
conformationExplorer.cc:759:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:762:    xml = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_XmlSaveArchive>();
conformationExplorer.cc:763:    xml[01;31m-[00m>put("ConformationExplorer",this[01;31m-[00m>sharedThis<O_ConformationExplorer>());
conformationExplorer.cc:764:    xml[01;31m-[00m>saveAs(fn);
conformationExplorer.cc:769:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:772:    for ( i=0,ei=this[01;31m-[00m>_Entries.begin(); ei!=this[01;31m-[00m>_Entries.end(); ei++,i++ )
conformationExplorer.cc:779:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find entry in ConformationExplorer"));
conformationExplorer.cc:786:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:787:    ASSERT_lessThan(i,this[01;31m-[00m>_Entries.size());
conformationExplorer.cc:789:    e = this[01;31m-[00m>_Entries[i];
conformationExplorer.cc:794:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:795:    ASSERT(this[01;31m-[00m>_Entries.size() > 0 );
conformationExplorer.cc:796:    return this[01;31m-[00m>_Entries[0];
conformationExplorer.cc:804:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:806:    entry = RP_Create<O_ConformationExplorerEntry>(this[01;31m-[00m>lisp());
conformationExplorer.cc:807:    entry[01;31m-[00m>setConformationExplorer(this[01;31m-[00m>sharedThis<O_ConformationExplorer>());
conformationExplorer.cc:816:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:820:    for ( ei=this[01;31m-[00m>begin_Entries(); ei!=this[01;31m-[00m>end_Entries(); ei++ )
conformationExplorer.cc:822:	if ( !(*ei)[01;31m-[00m>hasEntryStageWithName(stageKey) )
conformationExplorer.cc:839:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:845:    bestStage = O_ConformationExplorerEntryStage::nil(this[01;31m-[00m>lisp());
conformationExplorer.cc:848:    uint numSuperposeAtoms = this[01;31m-[00m>numberOfSuperposeAtoms();
conformationExplorer.cc:851:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There must be at least one superpose atom"));
conformationExplorer.cc:856:	for ( ei=this[01;31m-[00m>begin_Entries(); ei!=this[01;31m-[00m>end_Entries(); ei++, entryIndex++ )
conformationExplorer.cc:858:	    if ( (*ei)[01;31m-[00m>hasEntryStageWithName(stageName) )
conformationExplorer.cc:860:		stage = (*ei)[01;31m-[00m>getEntryStage(stageName);
conformationExplorer.cc:869:	superposer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SuperposeEngine>();
conformationExplorer.cc:870:	matterConf = this[01;31m-[00m>_extractCoordinateArray(matter);
conformationExplorer.cc:871:	superposer[01;31m-[00m>setFixedPoints(this[01;31m-[00m>_SuperposeAtomIndices,matterConf);
conformationExplorer.cc:874:	for ( ei=this[01;31m-[00m>begin_Entries(); ei!=this[01;31m-[00m>end_Entries(); ei++, entryIndex++ )
conformationExplorer.cc:876:	    if ( (*ei)[01;31m-[00m>hasEntryStageWithName(stageName) )
conformationExplorer.cc:878:		stage = (*ei)[01;31m-[00m>getEntryStage(stageName);
conformationExplorer.cc:879:		stage[01;31m-[00m>setSuperposableCoordinatesAsMoveableWithinSuperposeEngine(superposer);
conformationExplorer.cc:880:		superposer[01;31m-[00m>superpose();
conformationExplorer.cc:881:		rms = superposer[01;31m-[00m>rootMeanSquareDifference();
conformationExplorer.cc:901:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:902:    uint idx = match[01;31m-[00m>getClosestMatchIndex();
conformationExplorer.cc:903:    return this[01;31m-[00m>getEntry(idx);
conformationExplorer.cc:907:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:908:    uint idx = match[01;31m-[00m>getClosestMatchIndex();
conformationExplorer.cc:909:    RPConformationExplorerEntry e = this[01;31m-[00m>getEntry(idx);
conformationExplorer.cc:910:    RPConformationExplorerEntryStage s = e[01;31m-[00m>getEntryStage(match[01;31m-[00m>getMatchStageName());
conformationExplorer.cc:919:    ss << this[01;31m-[00m>Base::__str__();
conformationExplorer.cc:920:    ss << "#ConformationExplorerEntries: " << this[01;31m-[00m>_Entries.size() << endl;
conformationExplorer.cc:921:    RPStringSet stageNames = O_StringSet::create(this[01;31m-[00m>lisp());
conformationExplorer.cc:923:    for ( ei=this[01;31m-[00m>_Entries.const_begin(); ei!=this[01;31m-[00m>_Entries.const_end(); ei++ )
conformationExplorer.cc:925:	RPStringSet oneEntryStageNames = (*ei)[01;31m-[00m>getEntryStageNames();
conformationExplorer.cc:926:	stageNames[01;31m-[00m>insertStringSet(oneEntryStageNames);
conformationExplorer.cc:928:    ss << "EntryStageNames: %s\n", stageNames[01;31m-[00m>asString().c_str();
conformationExplorer.cc:936:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:940:    match[01;31m-[00m>setMatches(false);
conformationExplorer.cc:941:    match[01;31m-[00m>setMatchStageName(stageKey);
conformationExplorer.cc:942:    bool gotBest = this[01;31m-[00m>findMostSimilarConformationEntryStageWithStageName(matter,stageKey,bestRms,bestStage,bestIndex);
conformationExplorer.cc:951:	match[01;31m-[00m>setMatches(true);
conformationExplorer.cc:953:    match[01;31m-[00m>setClosestMatchRms(bestRms);
conformationExplorer.cc:954:    match[01;31m-[00m>setClosestMatchIndex(bestIndex);
conformationExplorer.cc:961:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:962:    return this[01;31m-[00m>_AllAtoms.indexOf(atom,_lisp);
conformationExplorer.cc:968:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:969:    if ( !this[01;31m-[00m>hasStageNameInAllEntries(stageName) )
conformationExplorer.cc:971:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You have to have the stageName(%s) in all entries")%stageName));
conformationExplorer.cc:973:    if ( this[01;31m-[00m>_Entries.size() == 0 )
conformationExplorer.cc:975:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You have to have at least one entry"));
conformationExplorer.cc:977:    if ( this[01;31m-[00m>_Entries.size() < 2 ) return;
conformationExplorer.cc:978:    O_ConformationExplorer::entryIterator first = this[01;31m-[00m>_Entries.begin();
conformationExplorer.cc:979:    RPConformationExplorerEntryStage firstEntryStage = (*first)[01;31m-[00m>getEntryStage(stageName);
conformationExplorer.cc:982:    for ( ; rest!=this[01;31m-[00m>end_Entries(); rest++ )
conformationExplorer.cc:984:	RPConformationExplorerEntryStage entryStage = (*rest)[01;31m-[00m>getEntryStage(stageName);
conformationExplorer.cc:985:	(entryStage)[01;31m-[00m>alignCoordinatesTo(firstEntryStage);
conformationExplorer.cc:997:	RPConformationExplorerEntryStage xStage = x[01;31m-[00m>getEntryStage(this[01;31m-[00m>_StageName);
conformationExplorer.cc:998:	RPConformationExplorerEntryStage yStage = y[01;31m-[00m>getEntryStage(this[01;31m-[00m>_StageName);
conformationExplorer.cc:999:	return xStage[01;31m-[00m>getEnergyKCal()<yStage[01;31m-[00m>getEnergyKCal();
conformationExplorer.cc:1005:{_F(this[01;31m-[00m>lisp());
conformationExplorer.cc:1008:    sort::quickSort(this[01;31m-[00m>_Entries.begin(),this[01;31m-[00m>_Entries.end(),order,this[01;31m-[00m>lisp());
conformationExplorer.cc:1020:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
conformationExplorer.cc:1025:    this[01;31m-[00m>_Matches = false;
conformationExplorer.cc:1040:    class_<O_ConformationExplorerEntryStage>(this[01;31m-[00m>lisp())
conformationExplorer.cc:1103:    class_<O_ConformationExplorerEntry>(this[01;31m-[00m>lisp())
conformationExplorer.cc:1150:    class_<O_ConformationExplorer>(this[01;31m-[00m>lisp())
conformationExplorer.cc:1227:    class_<O_ConformationExplorerMatch>(this[01;31m-[00m>lisp())
cons.cc:50:    ASSERT_eq(kargs[01;31m-[00m>numberOfPositionalArguments(),2);
cons.cc:51:    this[01;31m-[00m>setCar(kargs[01;31m-[00m>getPositionalArgument(0));
cons.cc:52:    this[01;31m-[00m>setCdr(kargs[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Cons>());
cons.cc:57:    this[01;31m-[00m>Base::initialize();
cons.cc:58:    this[01;31m-[00m>_Car = O_Object::nil(this[01;31m-[00m>lisp());
cons.cc:59:    this[01;31m-[00m>_Cdr = O_Cons::nil(this[01;31m-[00m>lisp());
cons.cc:60:    this[01;31m-[00m>_CdrLength = 0;
cons.cc:69:	RPCons carg = O_Cons::create(e[01;31m-[00m>create<O_String>(argv[i]),O_Cons::nil(e),e);
cons.cc:70:	if ( curArg[01;31m-[00m>isNil() )
cons.cc:76:	    curArg[01;31m-[00m>setCdr(carg);
cons.cc:99:    if ( s == "false" || s == "False" ) return e[01;31m-[00m>_boolean(false);
cons.cc:100:    return e[01;31m-[00m>create<O_String>(s);
cons.cc:106: * keyed Arguments that start with "[01;31m-[00m[01;31m-[00m[01;31m-[00m" treat the words that follow them until
cons.cc:108: * keyed arguments that start with "[01;31m-[00m[01;31m-[00m" treat the single word that follow them
cons.cc:112: * eg: [01;31m-[00m[01;31m-[00mfile xxx.yyy [01;31m-[00m[01;31m-[00m[01;31m-[00mentries 1 2 3 4 5 [01;31m-[00m[01;31m-[00m [01;31m-[00mto hello
cons.cc:113: * 	[01;31m-[00m> file: "xxx.yyy" entries: (: 1 2 3 4 5) to: "hello"
cons.cc:124:		// Arguments that start with "[01;31m-[00m[01;31m-[00m[01;31m-[00m" parse their arguments as a list
cons.cc:126:	if ( (*it).substr(0,3)=="[01;31m-[00m[01;31m-[00m[01;31m-[00m" )
cons.cc:130:	    obj = lisp[01;31m-[00m>internKeyword(keyStr);
cons.cc:132:	    args[01;31m-[00m>setCdr(entry);
cons.cc:134:	    RPCons afirst = O_Cons::create(lisp[01;31m-[00m>onil(),lisp);
cons.cc:140:	        if (it==strings.end() || (*it).substr(0,2) == "[01;31m-[00m[01;31m-[00m" ) break;
cons.cc:143:		LOG(BF( "Accumulating object(%s) into list for argument") % aone[01;31m-[00m>__repr__().c_str() );
cons.cc:144:		acur[01;31m-[00m>setCdr(aone);
cons.cc:147:	    obj = afirst[01;31m-[00m>cdr();
cons.cc:148:	} else if ( (*it).substr(0,2)=="[01;31m-[00m[01;31m-[00m" )
cons.cc:152:	    obj = lisp[01;31m-[00m>internKeyword(keyStr);
cons.cc:161:	LOG( BF("Accumulating entry(%s) in main argument list") % obj[01;31m-[00m>__repr__() );
cons.cc:163:	args[01;31m-[00m>setCdr(entry);
cons.cc:166:    LOG(BF( "After parse|%s|") % first[01;31m-[00m>cdr()[01;31m-[00m>__repr__() );
cons.cc:167:    return first[01;31m-[00m>cdr();
cons.cc:178:    this[01;31m-[00m>_CdrLength = 0;
cons.cc:193:{_F(this[01;31m-[00m>lisp());
cons.cc:194:    node[01;31m-[00m>archiveObjectIfDefined("car",this[01;31m-[00m>_Car);
cons.cc:195:    node[01;31m-[00m>archiveObjectIfDefined("cdr",this[01;31m-[00m>_Cdr);
cons.cc:196:    node[01;31m-[00m>attribute("cdrl",this[01;31m-[00m>_CdrLength);
cons.cc:203:    ASSERT(this[01;31m-[00m>notNil());
cons.cc:205:    RPCons cur = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:207:    while ( cur[01;31m-[00m>notNil() )
cons.cc:210:	cur = cur[01;31m-[00m>cdr();
cons.cc:212:    last[01;31m-[00m>setCdr(rest);
cons.cc:218:    if ( this[01;31m-[00m>eqV(obj) ) return true;
cons.cc:219:    if ( !obj[01;31m-[00m>isOfClass<O_Cons>() ) return false;
cons.cc:220:    RPCons other = obj[01;31m-[00m>as<O_Cons>();
cons.cc:221:    if ( !this[01;31m-[00m>ocar()[01;31m-[00m>equal(other[01;31m-[00m>ocar() ) ) return false;
cons.cc:222:    if ( !this[01;31m-[00m>cdr()[01;31m-[00m>equal(other[01;31m-[00m>cdr() ) ) return false;
cons.cc:230:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
cons.cc:233:    RPCons cur = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:234:    while ( cur[01;31m-[00m>notNil() )
cons.cc:236:	newCur = O_Cons::create(cur[01;31m-[00m>ocar(),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
cons.cc:237:	nc[01;31m-[00m>setCdr(newCur);
cons.cc:239:	cur = cur[01;31m-[00m>cdr();
cons.cc:243:    while ( cur[01;31m-[00m>notNil() )
cons.cc:245:	newCur = O_Cons::create(cur[01;31m-[00m>ocar(),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
cons.cc:246:	nc[01;31m-[00m>setCdr(newCur);
cons.cc:248:	cur = cur[01;31m-[00m>cdr();
cons.cc:250:    return first[01;31m-[00m>cdr();
cons.cc:255:{_F(this[01;31m-[00m>lisp());
cons.cc:258:    dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
cons.cc:259:    for ( cur=this[01;31m-[00m>sharedThis<O_Cons>(); cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
cons.cc:261:	RPObject obj = cur[01;31m-[00m>ocar();
cons.cc:262:	if ( obj[01;31m-[00m>canRender() )
cons.cc:264:	    dl[01;31m-[00m>add(obj[01;31m-[00m>rendered(options));
cons.cc:272:{_F(this[01;31m-[00m>lisp());
cons.cc:273:    RPCons reversed = O_Cons::nil(this[01;31m-[00m>lisp());
cons.cc:274:    RPCons cur = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:275:    while ( cur[01;31m-[00m>notNil() )
cons.cc:277:	reversed = O_Cons::create(cur[01;31m-[00m>ocar(),reversed,this[01;31m-[00m>lisp());
cons.cc:278:	cur = cur[01;31m-[00m>cdr();
cons.cc:286:{_F(this[01;31m-[00m>lisp());
cons.cc:287:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
cons.cc:289:    for ( RPCons cur=this[01;31m-[00m>sharedThis<O_Cons>();cur[01;31m-[00m>notNil();cur=cur[01;31m-[00m>cdr() )
cons.cc:291:	if ( cur[01;31m-[00m>ocar()[01;31m-[00m>notNil() )
cons.cc:293:	    RPCons one = O_Cons::create(cur[01;31m-[00m>ocar(),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
cons.cc:294:	    newCur[01;31m-[00m>setCdr(one);
cons.cc:295:	    newCur = newCur[01;31m-[00m>cdr();
cons.cc:298:    return first[01;31m-[00m>cdr();
cons.cc:303:{_F(this[01;31m-[00m>lisp());
cons.cc:305:    for ( cur=this[01;31m-[00m>sharedThis<O_Cons>(); cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
cons.cc:307:	cur[01;31m-[00m>ocar()[01;31m-[00m>setOwner(obj);
cons.cc:316:	if ( args[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_OVector3>() )
cons.cc:320:	TOSS(_lisp[01;31m-[00m>error(BF("Illegal class(%s) for sum") % args[01;31m-[00m>ocar()[01;31m-[00m>className() ) );
cons.cc:327:{_F(this[01;31m-[00m>lisp());
cons.cc:328:    RPKeyedArguments keyed = O_KeyedArguments::create(this[01;31m-[00m>lisp());
cons.cc:329:    RPCons cur = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:331:    while ( cur[01;31m-[00m>notNil() )
cons.cc:333:	if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
cons.cc:335:	    RPSymbol key = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
cons.cc:336:	    cur = cur[01;31m-[00m>cdr();
cons.cc:337:	    RPObject value = cur[01;31m-[00m>ocar();
cons.cc:338:	    cur = cur[01;31m-[00m>cdr();
cons.cc:342:	    keyed[01;31m-[00m>set(key[01;31m-[00m>identifierName(),value);
cons.cc:346:	if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Text>() )
cons.cc:348:	    string t = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
cons.cc:349:	    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>findSymbol(t);
cons.cc:350:	    if ( sym[01;31m-[00m>notNil() && sym[01;31m-[00m>isKeywordSymbol() )
cons.cc:352:		cur = cur[01;31m-[00m>cdr();
cons.cc:353:		RPObject obj = cur[01;31m-[00m>ocar();
cons.cc:354:		cur = cur[01;31m-[00m>cdr();
cons.cc:355:		keyed[01;31m-[00m>set(sym[01;31m-[00m>identifierName(),obj);
cons.cc:360:	keyed[01;31m-[00m>appendPositionalArgument(cur[01;31m-[00m>ocar());
cons.cc:361:	cur = cur[01;31m-[00m>cdr();
cons.cc:370:{_F(this[01;31m-[00m>lisp());
cons.cc:371:    return O_IterateCons::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>sharedThis<O_Cons>());
cons.cc:375:{_F(this[01;31m-[00m>lisp());
cons.cc:378:    prev = O_Cons::nil(this[01;31m-[00m>lisp());
cons.cc:379:    p = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:380:    if ( p[01;31m-[00m>isNil() ) return O_Cons::nil(this[01;31m-[00m>lisp());
cons.cc:381:    while ( p[01;31m-[00m>notNil() )
cons.cc:386:	ANN(p[01;31m-[00m>cdr());
cons.cc:389:	p = p[01;31m-[00m>cdr();
cons.cc:395:    ANN(prev[01;31m-[00m>ocar());
cons.cc:396:    return prev[01;31m-[00m>ocar();
cons.cc:402:{_F(this[01;31m-[00m>lisp());
cons.cc:404:    first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
cons.cc:406:    RPCons p = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:407:    while ( p[01;31m-[00m>notNil() )
cons.cc:409:	cur[01;31m-[00m>setCdr(O_Cons::create(p[01;31m-[00m>ocar(),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp()));
cons.cc:410:	cur = cur[01;31m-[00m>cdr();
cons.cc:411:	p = p[01;31m-[00m>cdr();
cons.cc:413:    return first[01;31m-[00m>cdr();
cons.cc:418:{_L(this[01;31m-[00m>lisp());
cons.cc:422:    p = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:423:    while ( p[01;31m-[00m>notNil() )
cons.cc:426:	p = p[01;31m-[00m>cdr();
cons.cc:433:{_L(this[01;31m-[00m>lisp());
cons.cc:436:    LOG(BF("Evaluating the length of list: %s") % this[01;31m-[00m>__repr__().c_str()  ); // vp0(("Evaluating the length of list: %s",this[01;31m-[00m>__repr__().c_str() ));
cons.cc:437:    p = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:438:    while ( p[01;31m-[00m>notNil() )
cons.cc:443:	p = p[01;31m-[00m>cdr();
cons.cc:445:    if ( p[01;31m-[00m>isNil() )
cons.cc:449:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
cons.cc:451:    return p[01;31m-[00m>ocar();
cons.cc:456:{_F(this[01;31m-[00m>lisp());
cons.cc:459:    p = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:460:    while ( p[01;31m-[00m>notNil() )
cons.cc:465:	p = p[01;31m-[00m>cdr();
cons.cc:467:    if ( p[01;31m-[00m>isNil() )
cons.cc:470:	ss << "You did not provide enough arguments for a call to a C++ function [01;31m-[00m it expected at least "<<idx<<" arguments and you passed only "<< i;
cons.cc:471:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
cons.cc:473:    return p[01;31m-[00m>ocar();
cons.cc:480:    this[01;31m-[00m>_Cdr = c;
cons.cc:481:    this[01;31m-[00m>_CdrLength = c[01;31m-[00m>cdrLength()+1;
cons.cc:483:    if ( this[01;31m-[00m>_CdrLength > WARN_CONS_LENGTH )
cons.cc:485:	string sss = this[01;31m-[00m>_Car[01;31m-[00m>__repr__().substr(0,30);
cons.cc:486:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("WARNING@%s:%d  Cons length is > %d [01;31m-[00m its cdr length is(%d) : trunated head: %s") % __FILE__ % __LINE__ % WARN_CONS_LENGTH % this[01;31m-[00m>_CdrLength % sss );
cons.cc:487:	LOG(BF("WARNING: Cons length is > %d it is %d cdr cells : truncated head: %s") % WARN_CONS_LENGTH % this[01;31m-[00m>_CdrLength % this[01;31m-[00m>_Car[01;31m-[00m>__repr__().substr(0,30));
cons.cc:488:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Cons length was too long length=%d") % this[01;31m-[00m>_CdrLength ));
cons.cc:498:    ASSERTP(keyword[01;31m-[00m>isKeywordSymbol(), "You can only search for keyword symbols");
cons.cc:499:    LOG(BF("lookup %s in %s")% keyword[01;31m-[00m>__repr__() % this[01;31m-[00m>__repr__() );
cons.cc:500:    p = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:501:    LOG(BF("Got start of list to search: %s") % p[01;31m-[00m>__repr__().c_str()  ); // vp0(("Got start of list to search: %s",p[01;31m-[00m>__repr__().c_str() ));
cons.cc:502:    for ( ; p[01;31m-[00m>notNil(); p = p[01;31m-[00m>cdr() )
cons.cc:504:	if ( p[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
cons.cc:506:	    RPSymbol ps = p[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
cons.cc:507:	    if ( ps[01;31m-[00m>isKeywordSymbol() )
cons.cc:511:		    return p[01;31m-[00m>ocadr();
cons.cc:523:{_F(this[01;31m-[00m>lisp());
cons.cc:525:    return this[01;31m-[00m>olookupKeyObjectDefault(key,O_Object::nil(this[01;31m-[00m>lisp()));
cons.cc:530:    if ( this[01;31m-[00m>isNil() )
cons.cc:534:    RPCons start = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:538:    for ( p = start; p[01;31m-[00m>notNil(); p = p[01;31m-[00m>cdr() )
cons.cc:540:    	ANN(p[01;31m-[00m>ocar());
cons.cc:541:        if ( p[01;31m-[00m>ocar()[01;31m-[00m>isNil() )
cons.cc:546:	    RPObject obj = p[01;31m-[00m>ocar();
cons.cc:547:	    sout << obj[01;31m-[00m>__repr__() << " ";
cons.cc:603:    ll[01;31m-[00m>setCar(car);
cons.cc:604:    ll[01;31m-[00m>setCdr(cdr);
cons.cc:605:    ll[01;31m-[00m>_ParsePosLineNumber = lineNumber;
cons.cc:606:    ll[01;31m-[00m>_ParsePosColumn = column;
cons.cc:607:    ll[01;31m-[00m>_FileName = fileName;
cons.cc:616:    parsed[01;31m-[00m>getParsePos(lineNumber,col);
cons.cc:617:    string fileName = parsed[01;31m-[00m>getParsePosFileName();
cons.cc:626:    if ( this[01;31m-[00m>eqV(obj) ) return true;
cons.cc:627:    if ( !obj[01;31m-[00m>isOfClass<O_ParsingCons>() ) return false;
cons.cc:628:    RPParsingCons other = obj[01;31m-[00m>as<O_ParsingCons>();
cons.cc:629:    if ( this[01;31m-[00m>_FileName != other[01;31m-[00m>_FileName ) return false;
cons.cc:630:    if ( this[01;31m-[00m>_ParsePosLineNumber != other[01;31m-[00m>_ParsePosLineNumber ) return false;
cons.cc:631:    if ( this[01;31m-[00m>_ParsePosColumn != other[01;31m-[00m>_ParsePosColumn ) return false;
cons.cc:632:    if ( !this[01;31m-[00m>ocar()[01;31m-[00m>equal(other[01;31m-[00m>ocar() ) ) return false;
cons.cc:633:    if ( !this[01;31m-[00m>cdr()[01;31m-[00m>equal(other[01;31m-[00m>cdr() ) ) return false;
cons.cc:646:    p = this[01;31m-[00m>sharedThis<O_Cons>();
cons.cc:647:    for ( ; p[01;31m-[00m>notNil(); p = p[01;31m-[00m>cdr() )
cons.cc:649:    	ANN(p[01;31m-[00m>ocar());
cons.cc:650:        if ( p[01;31m-[00m>ocar()[01;31m-[00m>isNil() )
cons.cc:655:	    sout << p[01;31m-[00m>car<O_Object>()[01;31m-[00m>__repr__() << " ";
cons.cc:660:    sout << this[01;31m-[00m>_ParsePosLineNumber;
cons.cc:661:    sout << ":" << this[01;31m-[00m>_ParsePosColumn;
cons.cc:668:{_F(this[01;31m-[00m>lisp());
cons.cc:669:    this[01;31m-[00m>Base::archiveBase(node);
cons.cc:670:    node[01;31m-[00m>attribute("ParsePosLineNumber",this[01;31m-[00m>_ParsePosLineNumber);
cons.cc:671:    node[01;31m-[00m>attribute("ParsePosColumn",this[01;31m-[00m>_ParsePosColumn);
cons.cc:680:    class_<O_Cons>(this[01;31m-[00m>lisp())
cons.cc:714:    class_<O_ParsingCons>(this[01;31m-[00m>lisp())
constitution.cc:30:{_F(this[01;31m-[00m>lisp());
constitution.cc:31:    this[01;31m-[00m>_Name = keyed[01;31m-[00m>getStringAndRemove("name");
constitution.cc:32:    this[01;31m-[00m>_Comment = keyed[01;31m-[00m>getStringAndRemoveOrDefault("comment","");
constitution.cc:33:    this[01;31m-[00m>_MetaConstitution = keyed[01;31m-[00m>getStringAndRemoveOrDefault("metaConstitution","");
constitution.cc:34:    this[01;31m-[00m>_Residue = keyed[01;31m-[00m>getAndRemove("residue")[01;31m-[00m>as<O_Residue>();
constitution.cc:35:    this[01;31m-[00m>_Residue[01;31m-[00m>setOwner(this[01;31m-[00m>sharedThis<O_Constitution>());
constitution.cc:36:    this[01;31m-[00m>_StereoInformation = keyed[01;31m-[00m>getAndRemove("stereoInformation")[01;31m-[00m>as<O_StereoInformation>();
constitution.cc:37:    this[01;31m-[00m>_StereoInformation[01;31m-[00m>setOwner(this[01;31m-[00m>sharedThis<O_Constitution>());
constitution.cc:38:    this[01;31m-[00m>_StereoInformation[01;31m-[00m>validate();
constitution.cc:39:    this[01;31m-[00m>_Frames.clear();
constitution.cc:41:    c = keyed[01;31m-[00m>getAndRemove("frames")[01;31m-[00m>as<O_Cons>();
constitution.cc:42:    c[01;31m-[00m>setOwnerOfAllEntries(this[01;31m-[00m>sharedThis<O_Constitution>());
constitution.cc:43:    for ( ; c[01;31m-[00m>notNil(); c = c[01;31m-[00m>cdr() )
constitution.cc:45:	RPFrame f = c[01;31m-[00m>car<O_Frame>();
constitution.cc:46:	if ( this[01;31m-[00m>_Frames.count(f[01;31m-[00m>getName())>0 )
constitution.cc:48:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is already a frame named: "+f[01;31m-[00m>getName() ));
constitution.cc:50:	this[01;31m-[00m>_Frames.set(f[01;31m-[00m>getName(),f);
constitution.cc:52:    c = keyed[01;31m-[00m>getAndRemove("plugs")[01;31m-[00m>as<O_Cons>();
constitution.cc:53:    c[01;31m-[00m>setOwnerOfAllEntries(this[01;31m-[00m>sharedThis<O_Constitution>());
constitution.cc:54:    this[01;31m-[00m>_PlugsByName.clear();
constitution.cc:55:    for ( ; c[01;31m-[00m>notNil(); c = c[01;31m-[00m>cdr() )
constitution.cc:57:	RPPlug p = c[01;31m-[00m>car<O_Plug>();
constitution.cc:58:	if ( this[01;31m-[00m>_PlugsByName.count(p[01;31m-[00m>getName())>0 )
constitution.cc:60:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is already a plug named: "+p[01;31m-[00m>getName() ));
constitution.cc:62:	this[01;31m-[00m>_PlugsByName.set(p[01;31m-[00m>getName(),p);
constitution.cc:64:    c = keyed[01;31m-[00m>getAndRemove("fragments")[01;31m-[00m>as<O_Cons>();
constitution.cc:65:    c[01;31m-[00m>setOwnerOfAllEntries(this[01;31m-[00m>sharedThis<O_Constitution>());
constitution.cc:66:    this[01;31m-[00m>_Fragments.clear();
constitution.cc:67:    for ( ; c[01;31m-[00m>notNil(); c = c[01;31m-[00m>cdr() )
constitution.cc:69:	RPFragment f = c[01;31m-[00m>car<O_Fragment>();
constitution.cc:70:	if ( this[01;31m-[00m>_Fragments.count(f[01;31m-[00m>getName())>0 )
constitution.cc:72:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is already a fragment named: "+f[01;31m-[00m>getName() ));
constitution.cc:74:	this[01;31m-[00m>_Fragments.set(f[01;31m-[00m>getName(),f);
constitution.cc:76:    c = keyed[01;31m-[00m>getAndRemove("topologies")[01;31m-[00m>as<O_Cons>();
constitution.cc:77:    c[01;31m-[00m>setOwnerOfAllEntries(this[01;31m-[00m>sharedThis<O_Constitution>());
constitution.cc:78:    this[01;31m-[00m>_Topologies.clear();
constitution.cc:79:    for ( ; c[01;31m-[00m>notNil(); c = c[01;31m-[00m>cdr() )
constitution.cc:81:	RPTopology t = c[01;31m-[00m>car<O_Topology>();
constitution.cc:82:	if ( this[01;31m-[00m>_Topologies.count(t[01;31m-[00m>getName())>0 )
constitution.cc:84:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is already a topology named: "+t[01;31m-[00m>getName() ));
constitution.cc:86:	this[01;31m-[00m>_Topologies.set(t[01;31m-[00m>getName(),t);
constitution.cc:100:{_F(this[01;31m-[00m>lisp());
constitution.cc:107:    residueConstitution = res[01;31m-[00m>getConstitution();
constitution.cc:108:    stereoisomerConstitution = this[01;31m-[00m>getBuilderDatabase()[01;31m-[00m>constitutionForNameOrPdb(stereoisomerName);
constitution.cc:110:    if (!residueConstitution[01;31m-[00m>isSameAs(stereoisomerConstitution)) {
constitution.cc:111:	LOG(BF("residueConstitution = %s")%residueConstitution[01;31m-[00m>__repr__());
constitution.cc:112:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("The residue constitution(%s) is different from the stereoisomer(%s) constitution(%s) that you want to change it too") % residueConstitution[01;31m-[00m>getName() % stereoisomerName % stereoisomerConstitution[01;31m-[00m>getName() ));
constitution.cc:114:    bdb = this[01;31m-[00m>getBuilderDatabase();
constitution.cc:115:    fullName = bdb[01;31m-[00m>getMonomerNameForNameOrPdb(stereoisomerName);
constitution.cc:116:    pdbName = bdb[01;31m-[00m>getPdbNameForNameOrPdb(stereoisomerName);
constitution.cc:117:    res[01;31m-[00m>setName(fullName);
constitution.cc:118:    res[01;31m-[00m>setPdbName(pdbName);
constitution.cc:124:    si = this[01;31m-[00m>_StereoInformation[01;31m-[00m>getStereoisomer(stereoisomerName);
constitution.cc:126:    for (sci=si[01;31m-[00m>_Configurations_begin();sci!=si[01;31m-[00m>_Configurations_end();sci++){
constitution.cc:127:	aa = res[01;31m-[00m>atomWithName((*sci)[01;31m-[00m>getAtomName());
constitution.cc:128:	LOG(BF("Setting the configuration of atom(%s) to(%s)") % aa[01;31m-[00m>description().c_str() % (*sci)[01;31m-[00m>getConfiguration().c_str()  ); // vp0(( "Setting the configuration of atom(%s) to(%s)", aa[01;31m-[00m>description().c_str(), (*sci)[01;31m-[00m>getConfiguration().c_str() ));
constitution.cc:129:	if ( (*sci)[01;31m-[00m>getConfiguration() == "S" ) {
constitution.cc:130:	    aa[01;31m-[00m>setConfiguration( S_Configuration );
constitution.cc:131:	} else if ( (*sci)[01;31m-[00m>getConfiguration() == "R" ) {
constitution.cc:132:	    aa[01;31m-[00m>setConfiguration( R_Configuration );
constitution.cc:140:    RPRestraintList restraints = res[01;31m-[00m>getRestraints();
constitution.cc:142:    for ( tpi=this[01;31m-[00m>_StereoInformation[01;31m-[00m>begin_ComplexRestraints(); 
constitution.cc:143:    		tpi!=this[01;31m-[00m>_StereoInformation[01;31m-[00m>end_ComplexRestraints(); tpi++ )
constitution.cc:145:	(*tpi)[01;31m-[00m>fillRestraints(restraints,res);
constitution.cc:151:    return this[01;31m-[00m>_StereoInformation[01;31m-[00m>recognizesNameOrPdb(nm);
constitution.cc:156:{_F(this[01;31m-[00m>lisp());
constitution.cc:158:    RPObjectList allRepresentatives  = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectList>();
constitution.cc:159:    for (si=this[01;31m-[00m>begin_Stereoisomers(); si!=this[01;31m-[00m>end_Stereoisomers(); si++){
constitution.cc:160:	RPObjectList oneList = (*si)[01;31m-[00m>expandedRepresentativeList();
constitution.cc:161:	allRepresentatives[01;31m-[00m>extend(oneList);
constitution.cc:169:{_F(this[01;31m-[00m>lisp());
constitution.cc:171:    missing = O_RingClosingPlug::nil(this[01;31m-[00m>lisp());
constitution.cc:173:    for ( ti=this[01;31m-[00m>_Topologies.begin(); ti!=this[01;31m-[00m>_Topologies.end(); ti++ ) 
constitution.cc:175:	plug = (ti[01;31m-[00m>second)[01;31m-[00m>provideMissingRingClosingPlug(mon);
constitution.cc:176:	if ( plug[01;31m-[00m>notNil() ) 
constitution.cc:178:	    if ( missing[01;31m-[00m>notNil() ) 
constitution.cc:181:		ss << "In Constitution(" << this[01;31m-[00m>getName() << " MetaConstitution(" << this[01;31m-[00m>getMetaConstitutionName() << ")" << endl;
constitution.cc:182:		ss << "there are two topologies that match the current monomer environment: " << mon[01;31m-[00m>description() << endl;
constitution.cc:184:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str() ));
constitution.cc:193:	return this[01;31m-[00m>_StereoInformation[01;31m-[00m>pdbFromNameOrPdb(nm);
constitution.cc:196:	return this[01;31m-[00m>_StereoInformation[01;31m-[00m>getMonomerNamesAsStringList();
constitution.cc:200:    return this[01;31m-[00m>_StereoInformation[01;31m-[00m>getMonomerNamesAsStringSet();
constitution.cc:204:	return this[01;31m-[00m>_StereoInformation[01;31m-[00m>getPdbNamesAsStringList();
constitution.cc:211:{_F(this[01;31m-[00m>lisp());
constitution.cc:214:    for (si=this[01;31m-[00m>begin_Stereoisomers(); si!=this[01;31m-[00m>end_Stereoisomers(); si++)
constitution.cc:216:	LOG(BF("Looking at stereoisomer name(%s)") % (*si)[01;31m-[00m>getName().c_str()  ); // vp0(( "Looking at stereoisomer name(%s)", (*si)[01;31m-[00m>getName().c_str() ));
constitution.cc:217:	if ( (*si)[01;31m-[00m>getName() == stereoisomerName )
constitution.cc:230:    res = this[01;31m-[00m>getFrameWithName(name);
constitution.cc:232:    return (res[01;31m-[00m>notNil());
constitution.cc:235:RPCons O_Constitution::stereoisomersAsCons() { return this[01;31m-[00m>_StereoInformation[01;31m-[00m>stereoisomersAsCons(); };
constitution.cc:236:RPCons O_Constitution::topologiesAsCons() { return this[01;31m-[00m>_Topologies.asCons(this[01;31m-[00m>lisp()); };
constitution.cc:237:RPCons O_Constitution::plugsAsCons() { return this[01;31m-[00m>_PlugsByName.asCons(this[01;31m-[00m>lisp()); };
constitution.cc:239:{_F(this[01;31m-[00m>lisp());
constitution.cc:240:    RPCons first = O_Cons::nil(this[01;31m-[00m>lisp());
constitution.cc:242:    for ( mi=this[01;31m-[00m>_PlugsByName.begin(); mi!=this[01;31m-[00m>_PlugsByName.end(); mi++ )
constitution.cc:244:	if ( mi[01;31m-[00m>second[01;31m-[00m>hasMates() )
constitution.cc:246:	    first = O_Cons::create(mi[01;31m-[00m>second,first,this[01;31m-[00m>lisp());
constitution.cc:254:    return this[01;31m-[00m>_StereoInformation[01;31m-[00m>begin_Stereoisomers();
constitution.cc:258:    return this[01;31m-[00m>_StereoInformation[01;31m-[00m>end_Stereoisomers();
constitution.cc:265:    for ( fi=this[01;31m-[00m>begin_Frames(); fi!=this[01;31m-[00m>end_Frames(); fi++ )
constitution.cc:267:        if ( (*fi)[01;31m-[00m>getName() == name ) return *fi;
constitution.cc:269:    return O_Frame::nil(this[01;31m-[00m>lisp());
constitution.cc:275:{_F(this[01;31m-[00m>lisp());
constitution.cc:276:    LOG(BF("Looking for fragment with name(%s) in Constitution(%s)") % name.c_str() % this[01;31m-[00m>getName().c_str()  ); // vp0(("Looking for fragment with name(%s) in Constitution(%s)",name.c_str(),this[01;31m-[00m>getName().c_str() ));
constitution.cc:277:    ASSERT(this[01;31m-[00m>_Fragments.contains(name));
constitution.cc:278:    return this[01;31m-[00m>_Fragments.get(name);
constitution.cc:285:{_F(this[01;31m-[00m>lisp());
constitution.cc:286:    RPResidue originalResidue = this[01;31m-[00m>_Residue;
constitution.cc:287:    RPResidue res = originalResidue[01;31m-[00m>copy()[01;31m-[00m>as<O_Residue>();
constitution.cc:288:    if ( res[01;31m-[00m>getConstitution() != originalResidue[01;31m-[00m>getConstitution() )
constitution.cc:290:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("The originalResidue constitution(%s) is not the same as the copy residue constitution(%s)") % originalResidue[01;31m-[00m>getConstitution()[01;31m-[00m>__repr__() % res[01;31m-[00m>getConstitution() ));
constitution.cc:292:    this[01;31m-[00m>makeResidueConsistentWithStereoisomerNamed(res,stereoisomerName);
constitution.cc:293:    LOG(BF("Original _Residue[01;31m-[00m>getConstitution() = (%s)") % this[01;31m-[00m>_Residue[01;31m-[00m>getConstitution()[01;31m-[00m>__repr__() );
constitution.cc:294:    LOG(BF("    copy      res[01;31m-[00m>getConstitution() = (%s)") % res[01;31m-[00m>getConstitution()[01;31m-[00m>__repr__() );
constitution.cc:300:{ _F(this[01;31m-[00m>lisp());
constitution.cc:301:    ASSERT_NOT_NULL(this[01;31m-[00m>_StereoInformation);
constitution.cc:302:    return this[01;31m-[00m>_StereoInformation[01;31m-[00m>nameFromNameOrPdb(nm);
constitution.cc:310:    ss << this[01;31m-[00m>O_Object::description() << "[";
constitution.cc:311:    ss << "Name("<<this[01;31m-[00m>_Name<<") ";
constitution.cc:317:{_F(this[01;31m-[00m>lisp());
constitution.cc:318:    RPStringSet ss = O_StringSet::create(this[01;31m-[00m>lisp());
constitution.cc:320:    for ( pi=this[01;31m-[00m>_PlugsByName.begin(); pi!=this[01;31m-[00m>_PlugsByName.end(); pi++ )
constitution.cc:322:	ss[01;31m-[00m>insert(pi[01;31m-[00m>first);
constitution.cc:329:{_F(this[01;31m-[00m>lisp());
constitution.cc:333:    tres = O_Topology::nil(this[01;31m-[00m>lisp());
constitution.cc:335:    for ( ti=this[01;31m-[00m>_Topologies.begin(); ti!=this[01;31m-[00m>_Topologies.end(); ti++ ) {
constitution.cc:336:	if ( ti[01;31m-[00m>second[01;31m-[00m>hasPlugNamed(name) ) {
constitution.cc:337:	    temp = ti[01;31m-[00m>second[01;31m-[00m>getNumberOfPlugs();
constitution.cc:341:		tres = ti[01;31m-[00m>second;
constitution.cc:346:    if ( tres[01;31m-[00m>notNil() )
constitution.cc:348:        LOG(BF("simplest topology is named: %s") % tres[01;31m-[00m>getName().c_str()  ); // vp0(( "simplest topology is named: %s",tres[01;31m-[00m>getName().c_str() ));
constitution.cc:363:{_F(this[01;31m-[00m>lisp());
constitution.cc:366:    tres = O_Topology::nil(this[01;31m-[00m>lisp());
constitution.cc:367:    for ( ti=this[01;31m-[00m>_Topologies.begin(); ti!=this[01;31m-[00m>_Topologies.end(); ti++ ) 
constitution.cc:369:	LOG(BF("Checking topology(%s)")% ti[01;31m-[00m>first );
constitution.cc:370:	if ( ti[01;31m-[00m>second[01;31m-[00m>matchesMonomerEnvironment(mon) ) 
constitution.cc:372:	    return ti[01;31m-[00m>second;
constitution.cc:381:{_F(this[01;31m-[00m>lisp());
constitution.cc:384:    tres = O_Topology::nil(this[01;31m-[00m>lisp());
constitution.cc:385:    for ( ti=this[01;31m-[00m>_Topologies.begin(); ti!=this[01;31m-[00m>_Topologies.end(); ti++ ) {
constitution.cc:386:	if ( ti[01;31m-[00m>second[01;31m-[00m>matchesContext(cont) ) {
constitution.cc:387:	    return ti[01;31m-[00m>second;
constitution.cc:398:{_F(this[01;31m-[00m>lisp());
constitution.cc:401:    group = O_MonomerGroup::create(this[01;31m-[00m>lisp()); //,this[01;31m-[00m>getBuilderDatabase());
constitution.cc:402://    group[01;31m-[00m>setName(this[01;31m-[00m>getName());
constitution.cc:403:    for (si=this[01;31m-[00m>begin_Stereoisomers(); si!=this[01;31m-[00m>end_Stereoisomers(); si++){
constitution.cc:404:	group[01;31m-[00m>addMonomerName((*si)[01;31m-[00m>getName());
constitution.cc:424:    this[01;31m-[00m>defineCouplingInOutVector(in,out);
constitution.cc:438:    this[01;31m-[00m>defineCouplingInOutVector(in,out);
constitution.cc:456:    this[01;31m-[00m>defineCouplingInOutVector(in,out);
constitution.cc:476:    this[01;31m-[00m>defineCouplingInOutVector(in,out);
constitution.cc:492:    link[01;31m-[00m>setIn(in);
constitution.cc:493:    link[01;31m-[00m>setOut(out);
constitution.cc:494:    this[01;31m-[00m>links.push_back(link);
constitution.cc:507:    this[01;31m-[00m>defineCouplingOutVector(out);
constitution.cc:521:    this[01;31m-[00m>defineCouplingOutVector(out);
constitution.cc:537:    this[01;31m-[00m>defineCouplingOutVector(out);
constitution.cc:550:    link[01;31m-[00m>setIn("");
constitution.cc:551:    link[01;31m-[00m>setOut(out);
constitution.cc:552:    this[01;31m-[00m>links.push_back(link);
constitution.cc:560:{_F(this[01;31m-[00m>lisp());
constitution.cc:565:    cm[01;31m-[00m>dump();
constitution.cc:568:    for ( i=this[01;31m-[00m>links.begin(); i!= this[01;31m-[00m>links.end(); i++ ) {
constitution.cc:570:    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m  To constitution coupling map") ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m  To constitution coupling map" ));
constitution.cc:571:    (*i)[01;31m-[00m>dump();
constitution.cc:574:	if ( (*i)[01;31m-[00m>matchesTopology(cm) ) {
constitution.cc:592:    this[01;31m-[00m>Base::initialize();
constitution.cc:593:    this[01;31m-[00m>_Comment = "";
constitution.cc:594:    this[01;31m-[00m>_Residue = RP_Create<O_Residue>(this[01;31m-[00m>lisp());
constitution.cc:595:    this[01;31m-[00m>_StereoInformation = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_StereoInformation>();
constitution.cc:606:{_F(this[01;31m-[00m>lisp());
constitution.cc:607:    this[01;31m-[00m>Base::archiveBase(node);
constitution.cc:609:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
constitution.cc:611:    if ( node[01;31m-[00m>loading() )
constitution.cc:613:	if ( node[01;31m-[00m>hasAttribute("name") )
constitution.cc:615:	    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
constitution.cc:618:	    node[01;31m-[00m>attribute("_key",this[01;31m-[00m>_Name);
constitution.cc:622:	node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
constitution.cc:625:    node[01;31m-[00m>attributeIfNotDefault<string>("comment",this[01;31m-[00m>_Comment,"");
constitution.cc:626:    node[01;31m-[00m>attributeIfNotDefault<string>("metaConstitution",this[01;31m-[00m>_MetaConstitution,"");
constitution.cc:627:    node[01;31m-[00m>archiveObject("residue",this[01;31m-[00m>_Residue);
constitution.cc:628:    node[01;31m-[00m>archiveObject("stereoInformation", this[01;31m-[00m>_StereoInformation );
constitution.cc:629:    node[01;31m-[00m>archiveMap( "plugs", this[01;31m-[00m>_PlugsByName );
constitution.cc:630:    node[01;31m-[00m>archiveMap( "topologies", this[01;31m-[00m>_Topologies );
constitution.cc:631:    node[01;31m-[00m>archiveMap( "fragments", this[01;31m-[00m>_Fragments );
constitution.cc:632:    node[01;31m-[00m>archiveMap( "frames", this[01;31m-[00m>_Frames );
constitution.cc:646:    class_<O_Constitution>(this[01;31m-[00m>lisp())
constitution.cc:728:    names = this[01;31m-[00m>_StereoInformation[01;31m-[00m>getMonomerNamesAsStringList();
constitution.cc:729:    for ( vi=names[01;31m-[00m>begin(); vi!=names[01;31m-[00m>end(); vi++ ) {
container.cc:21:	class_<O_Container>(this[01;31m-[00m>lisp())
contender.cc:28:    class_<O_Contender>(e[01;31m-[00m>lisp())
contender.cc:52:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
contender.cc:53:    RPHit hit = kargs[01;31m-[00m>getAndRemove("hit")[01;31m-[00m>as<O_Hit>();
contender.cc:54:    this[01;31m-[00m>fillFromHit(hit);
contender.cc:61:    this[01;31m-[00m>Base::initialize();
contender.cc:62:    this[01;31m-[00m>_BuilderScorer = O_BuilderScorer::nil(this[01;31m-[00m>lisp());
contender.cc:63:    this[01;31m-[00m>_BuilderState = O_BuilderState::nil(this[01;31m-[00m>lisp());
contender.cc:64:    this[01;31m-[00m>_ConformationExplorer = O_ConformationExplorer::nil(this[01;31m-[00m>lisp());
contender.cc:65:    this[01;31m-[00m>_Data = O_ObjectDictionary::create(this[01;31m-[00m>lisp());
contender.cc:70:    this[01;31m-[00m>Base::archiveBase(node);
contender.cc:71:    node[01;31m-[00m>archiveString("Source",this[01;31m-[00m>_Source);
contender.cc:72:    node[01;31m-[00m>archiveObject("BuilderScorer",this[01;31m-[00m>_BuilderScorer);
contender.cc:73:    node[01;31m-[00m>archiveObject("BuilderState",this[01;31m-[00m>_BuilderState);
contender.cc:74:    node[01;31m-[00m>archiveObject("ConformationExplorer",this[01;31m-[00m>_ConformationExplorer);
contender.cc:75:    node[01;31m-[00m>archiveObject("Data",this[01;31m-[00m>_Data);
contender.cc:81:{_F(this[01;31m-[00m>lisp());
contender.cc:82:    this[01;31m-[00m>_BuilderScorer = hit[01;31m-[00m>getHitList()[01;31m-[00m>getBuilderScorer();
contender.cc:83:    this[01;31m-[00m>_BuilderState = hit[01;31m-[00m>getBuilderState();
contender.cc:84:    this[01;31m-[00m>_BuilderScorer[01;31m-[00m>restoreState(this[01;31m-[00m>_BuilderState);
contender.cc:85:    this[01;31m-[00m>_Data = O_ObjectDictionary::create(this[01;31m-[00m>lisp());
contender.cc:86:    RPScorerState ss = hit[01;31m-[00m>getScorerState();
contender.cc:87:    this[01;31m-[00m>_ConformationExplorer = O_ConformationExplorer::create(this[01;31m-[00m>lisp());
contender.cc:88:    this[01;31m-[00m>_ConformationExplorer[01;31m-[00m>setMatter(this[01;31m-[00m>_BuilderScorer[01;31m-[00m>getBuiltMoleculeWithCoordinates(ss));
contender.cc:94:{_F(this[01;31m-[00m>lisp());
contender.cc:95:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
contender.cc:96:    if ( this[01;31m-[00m>_BuilderState[01;31m-[00m>canRender() )
contender.cc:98:	dl[01;31m-[00m>add(this[01;31m-[00m>_BuilderState[01;31m-[00m>rendered(kopts));
contender.cc:100:    if ( this[01;31m-[00m>_BuilderScorer[01;31m-[00m>canRender() )
contender.cc:102:	dl[01;31m-[00m>add(this[01;31m-[00m>_BuilderScorer[01;31m-[00m>rendered(kopts));
contender.cc:104:    if ( this[01;31m-[00m>_Data[01;31m-[00m>canRender() )
contender.cc:106:	dl[01;31m-[00m>add(this[01;31m-[00m>_Data[01;31m-[00m>rendered(kopts));
contender.cc:108:    if ( this[01;31m-[00m>_ConformationExplorer[01;31m-[00m>canRender() )
contender.cc:110:	dl[01;31m-[00m>add(this[01;31m-[00m>_ConformationExplorer[01;31m-[00m>rendered(kopts));
coordSys.cc:43:{_F(this[01;31m-[00m>lisp());
coordSys.cc:47:        Vector3 c2xo = coord[01;31m-[00m>getX();
coordSys.cc:48:        Vector3 xycomp = Vector3( c2xo.getX(), c2xo.getY(), 0.0 ).normalized(this[01;31m-[00m>lisp());
coordSys.cc:53:	    this[01;31m-[00m>_RotZ = acos(cosXy);
coordSys.cc:55:	    this[01;31m-[00m>_RotZ = [01;31m-[00macos(cosXy);
coordSys.cc:57:	LOG(BF("this[01;31m-[00m>_RotZ = %lf degrees") % this[01;31m-[00m>_RotZ/DEGTORAD  ); // vp0(( "this[01;31m-[00m>_RotZ = %lf degrees", this[01;31m-[00m>_RotZ/DEGTORAD ));
coordSys.cc:62:        mrotz.rightHandedRotationZ([01;31m-[00mthis[01;31m-[00m>_RotZ);
coordSys.cc:66:	    this[01;31m-[00m>_RotY = acos(cosC2x);
coordSys.cc:68:	    this[01;31m-[00m>_RotY = [01;31m-[00macos(cosC2x);
coordSys.cc:70:	LOG(BF("this[01;31m-[00m>_RotY = %lf degrees") % this[01;31m-[00m>_RotY/DEGTORAD  ); // vp0(( "this[01;31m-[00m>_RotY = %lf degrees", this[01;31m-[00m>_RotY/DEGTORAD ));
coordSys.cc:72:        mroty.rightHandedRotationY([01;31m-[00mthis[01;31m-[00m>_RotY);
coordSys.cc:74:        Vector3 c2y = mrotz.multiplyByVector3(coord[01;31m-[00m>getY());
coordSys.cc:78:            this[01;31m-[00m>_RotX = acos(c3y.dotProduct(labY));
coordSys.cc:80:	    this[01;31m-[00m>_RotX = [01;31m-[00macos(c3y.dotProduct(labY));
coordSys.cc:82:	LOG(BF("this[01;31m-[00m>_RotX = %lf degrees") % this[01;31m-[00m>_RotX/DEGTORAD  ); // vp0(( "this[01;31m-[00m>_RotX = %lf degrees", this[01;31m-[00m>_RotX/DEGTORAD ));
coordSys.cc:83:        Vector3 trans = coord[01;31m-[00m>getOrigin();
coordSys.cc:84:        Vector3 transNorm = trans.normalized(this[01;31m-[00m>lisp());
coordSys.cc:86:        xycomp = Vector3( trans.getX(), trans.getY(),0.0 ).normalized(this[01;31m-[00m>lisp());
coordSys.cc:92:	    this[01;31m-[00m>_RotZZ = acos(cosXy);
coordSys.cc:94:	    this[01;31m-[00m>_RotZZ = [01;31m-[00macos(cosXy);
coordSys.cc:96:	LOG(BF("this[01;31m-[00m>_RotZZ = %lf degrees") % this[01;31m-[00m>_RotZZ/DEGTORAD  ); // vp0(( "this[01;31m-[00m>_RotZZ = %lf degrees", this[01;31m-[00m>_RotZZ/DEGTORAD ));
coordSys.cc:100:        mrotz.rightHandedRotationZ([01;31m-[00mthis[01;31m-[00m>_RotZZ);
coordSys.cc:107:	    this[01;31m-[00m>_RotYY = acos(cosC2x);
coordSys.cc:109:	    this[01;31m-[00m>_RotYY = [01;31m-[00macos(cosC2x);
coordSys.cc:111:	LOG(BF("this[01;31m-[00m>_RotYY = %lf degrees") % this[01;31m-[00m>_RotYY/DEGTORAD  ); // vp0(( "this[01;31m-[00m>_RotYY = %lf degrees", this[01;31m-[00m>_RotYY/DEGTORAD ));
coordSys.cc:112:        this[01;31m-[00m>_Distance = trans.length();
coordSys.cc:113:	LOG(BF("this[01;31m-[00m>_Distance = %lf") % this[01;31m-[00m>_Distance  ); // vp0(( "this[01;31m-[00m>_Distance = %lf", this[01;31m-[00m>_Distance ));
coordSys.cc:118://	// Calculate RotZ, the angle around the Z[01;31m-[00maxis I need to rotate X into the lab XY[01;31m-[00mplane
coordSys.cc:122://    node = labZ.crossProduct(coord[01;31m-[00m>getZ());
coordSys.cc:125://    LOG(BF("coordX = {%lf,%lf,%lf}") % coord[01;31m-[00m>getX().getX() % coord[01;31m-[00m>getX().getY() % coord[01;31m-[00m>getX().getZ()  ); // vp0(("coordX = {%lf,%lf,%lf}", coord[01;31m-[00m>getX().getX(),coord[01;31m-[00m>getX().getY(),coord[01;31m-[00m>getX().getZ() ));
coordSys.cc:126://    LOG(BF("coordY = {%lf,%lf,%lf}") % coord[01;31m-[00m>getY().getX() % coord[01;31m-[00m>getY().getY() % coord[01;31m-[00m>getY().getZ()  ); // vp0(("coordY = {%lf,%lf,%lf}",coord[01;31m-[00m>getY().getX(), coord[01;31m-[00m>getY().getY(), coord[01;31m-[00m>getY().getZ() ));
coordSys.cc:127://    LOG(BF("coordZ = {%lf,%lf,%lf}") % coord[01;31m-[00m>getZ().getX() % coord[01;31m-[00m>getZ().getY() % coord[01;31m-[00m>getZ().getZ()  ); // vp0(("coordZ = {%lf,%lf,%lf}",coord[01;31m-[00m>getZ().getX(), coord[01;31m-[00m>getZ().getY(), coord[01;31m-[00m>getZ().getZ() ));
coordSys.cc:128://    cosRotY = labZ.dotProduct(coord[01;31m-[00m>getZ());
coordSys.cc:133://	gamma = 0.0; // If the labZ and coord[01;31m-[00m>getZ() are parallel or anti[01;31m-[00mparallel then gamma=
coordSys.cc:138://        alpha = labX.angleToVectorAboutNormal(coord[01;31m-[00m>getX(),labZ);
coordSys.cc:143://	nodeNorm = node.normalized(this[01;31m-[00m>lisp());
coordSys.cc:146://	gamma = nodeNorm.angleToVectorAboutNormal(coord[01;31m-[00m>getX(),coord[01;31m-[00m>getZ());
coordSys.cc:157://    translate = coord[01;31m-[00m>getOrigin();
coordSys.cc:167://	Vector3 tn = translate.normalized(this[01;31m-[00m>lisp());
coordSys.cc:184://    this[01;31m-[00m>_RotX = alpha;
coordSys.cc:185://    this[01;31m-[00m>_RotY = beta;
coordSys.cc:186://    this[01;31m-[00m>_RotZ = gamma;
coordSys.cc:187://    this[01;31m-[00m>_Distance = distance;
coordSys.cc:188://    this[01;31m-[00m>_RotZZ = theta;
coordSys.cc:189://    this[01;31m-[00m>_RotYY = phi;
coordSys.cc:196:    ss << prefix << "RotX  = " << this[01;31m-[00m>_RotX/0.0174533 << " deg" << endl;
coordSys.cc:197:    ss << prefix << "RotY  = " << this[01;31m-[00m>_RotY/0.0174533 << " deg" << endl;
coordSys.cc:198:    ss << prefix << "RotZ  = " << this[01;31m-[00m>_RotZ/0.0174533 << " deg" << endl;
coordSys.cc:199:    ss << prefix << "RotYY = " << this[01;31m-[00m>_RotYY/0.0174533 << " deg" << endl;
coordSys.cc:200:    ss << prefix << "RotZZ = " << this[01;31m-[00m>_RotZZ/0.0174533 << " deg" << endl;
coordSys.cc:201:    ss << prefix << "Dist  = " << this[01;31m-[00m>_Distance << " A" << endl;
coordSys.cc:211:	ss << this[01;31m-[00m>_RotX/0.0174533 << " ";
coordSys.cc:212:	ss << this[01;31m-[00m>_RotY/0.0174533 << " " ;
coordSys.cc:213:	ss << this[01;31m-[00m>_RotZ/0.0174533 << " " ;
coordSys.cc:214:	ss << this[01;31m-[00m>_RotYY/0.0174533 << " ";
coordSys.cc:215:	ss << this[01;31m-[00m>_RotZZ/0.0174533 << " ";
coordSys.cc:216:	ss << this[01;31m-[00m>_Distance;
coordSys.cc:226:    toCanonical = start[01;31m-[00m>matrixToCanonical();
coordSys.cc:227:    transformedDest = dest[01;31m-[00m>copy();
coordSys.cc:228:    transformedDest[01;31m-[00m>transformWithMatrix(toCanonical);
coordSys.cc:229:    this[01;31m-[00m>defineForCoordinateSystem(transformedDest);
coordSys.cc:234:    this[01;31m-[00m>_RotX = g[01;31m-[00m>getRotX();
coordSys.cc:235:    this[01;31m-[00m>_RotY = g[01;31m-[00m>getRotY();
coordSys.cc:236:    this[01;31m-[00m>_RotZ = g[01;31m-[00m>getRotZ();
coordSys.cc:237:    this[01;31m-[00m>_RotYY = g[01;31m-[00m>getRotYY();
coordSys.cc:238:    this[01;31m-[00m>_RotZZ = g[01;31m-[00m>getRotZZ();
coordSys.cc:239:    this[01;31m-[00m>_Distance = g[01;31m-[00m>getDistance();
coordSys.cc:244:    n[01;31m-[00m>attribute("RotX",this[01;31m-[00m>_RotX );
coordSys.cc:245:    n[01;31m-[00m>attribute("RotY",this[01;31m-[00m>_RotY );
coordSys.cc:246:    n[01;31m-[00m>attribute("RotZ",this[01;31m-[00m>_RotZ );
coordSys.cc:247:    n[01;31m-[00m>attribute("Dist",this[01;31m-[00m>_Distance );
coordSys.cc:248:    n[01;31m-[00m>attribute("RotYY",this[01;31m-[00m>_RotYY );
coordSys.cc:249:    n[01;31m-[00m>attribute("RotZZ",this[01;31m-[00m>_RotZZ );
coordSys.cc:257:    c = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateSystem>();
coordSys.cc:258:    mt = this[01;31m-[00m>matrixFromCanonical();
coordSys.cc:259:    c[01;31m-[00m>transformWithMatrix(mt);
coordSys.cc:267:    Matrix mRotYY; mRotYY.rightHandedRotationY(this[01;31m-[00m>_RotYY);
coordSys.cc:268:    Matrix mRotZZ; mRotZZ.rightHandedRotationZ(this[01;31m-[00m>_RotZZ);
coordSys.cc:278:{_F(this[01;31m-[00m>lisp());
coordSys.cc:279:    Matrix mX; mX.rightHandedRotationX(this[01;31m-[00m>_RotX);
coordSys.cc:280:    Matrix mY; mY.rightHandedRotationY(this[01;31m-[00m>_RotY);
coordSys.cc:281:    Matrix mZ; mZ.rightHandedRotationZ(this[01;31m-[00m>_RotZ);
coordSys.cc:282:    Vector3 vTrans = this[01;31m-[00m>getDirection();
coordSys.cc:283:    vTrans = vTrans.multiplyByScalar(this[01;31m-[00m>_Distance);
coordSys.cc:295:    c = this[01;31m-[00m>getCoordinateSystem();
coordSys.cc:296:    return c[01;31m-[00m>matrixToCanonical();
coordSys.cc:304:{_F(this[01;31m-[00m>lisp());
coordSys.cc:308:	// Calculate Gamma, the angle around the Z[01;31m-[00maxis I need to rotate X into the lab XY[01;31m-[00mplane
coordSys.cc:312:    node = labZ.crossProduct(coord[01;31m-[00m>getZ());
coordSys.cc:315:    LOG(BF("coordX = {%lf,%lf,%lf}") % (coord[01;31m-[00m>getX().getX()) % (coord[01;31m-[00m>getX().getY()) % (coord[01;31m-[00m>getX().getZ() ) ); // vp0(("coordX = {%lf,%lf,%lf}",coord[01;31m-[00m>getX().getX(),coord[01;31m-[00m>getX().getY(),coord[01;31m-[00m>getX().getZ() ));
coordSys.cc:316:    LOG(BF("coordY = {%lf,%lf,%lf}") % (coord[01;31m-[00m>getY().getX()) % (coord[01;31m-[00m>getY().getY()) % (coord[01;31m-[00m>getY().getZ() ) ); // vp0(("coordY = {%lf,%lf,%lf}",coord[01;31m-[00m>getY().getX(), coord[01;31m-[00m>getY().getY(), coord[01;31m-[00m>getY().getZ() ));
coordSys.cc:317:    LOG(BF("coordZ = {%lf,%lf,%lf}") % (coord[01;31m-[00m>getZ().getX()) % (coord[01;31m-[00m>getZ().getY()) % (coord[01;31m-[00m>getZ().getZ() ) ); // vp0(("coordZ = {%lf,%lf,%lf}",coord[01;31m-[00m>getZ().getX(), coord[01;31m-[00m>getZ().getY(), coord[01;31m-[00m>getZ().getZ() ));
coordSys.cc:318:    cosBeta = labZ.dotProduct(coord[01;31m-[00m>getZ());
coordSys.cc:323:	gamma = 0.0; // If the labZ and coord[01;31m-[00m>getZ() are parallel or anti[01;31m-[00mparallel then gamma=
coordSys.cc:328:        alpha = labX.angleToVectorAboutNormal(coord[01;31m-[00m>getX(),labZ);
coordSys.cc:333:	nodeNorm = node.normalized(this[01;31m-[00m>lisp());
coordSys.cc:336:	gamma = nodeNorm.angleToVectorAboutNormal(coord[01;31m-[00m>getX(),coord[01;31m-[00m>getZ());
coordSys.cc:347:    translate = coord[01;31m-[00m>getOrigin();
coordSys.cc:357:	Vector3 tn = translate.normalized(this[01;31m-[00m>lisp());
coordSys.cc:374:    this[01;31m-[00m>_Alpha = alpha;
coordSys.cc:375:    this[01;31m-[00m>_Beta = beta;
coordSys.cc:376:    this[01;31m-[00m>_Gamma = gamma;
coordSys.cc:377:    this[01;31m-[00m>_Distance = distance;
coordSys.cc:378:    this[01;31m-[00m>_Theta = theta;
coordSys.cc:379:    this[01;31m-[00m>_Phi = phi;
coordSys.cc:385:    ss << "Alpha = " << this[01;31m-[00m>_Alpha/0.0174533 << endl;
coordSys.cc:386:    ss << "Beta = " << this[01;31m-[00m>_Beta/0.0174533 << endl;
coordSys.cc:387:    ss << "Gamma = " << this[01;31m-[00m>_Gamma/0.0174533 << endl;
coordSys.cc:388:    ss << "Phi = " << this[01;31m-[00m>_Phi/0.0174533 << endl;
coordSys.cc:389:    ss << "Theta = " << this[01;31m-[00m>_Theta/0.0174533 << endl;
coordSys.cc:390:    ss << "Distance = " << this[01;31m-[00m>_Distance << endl;
coordSys.cc:399:    toCanonical = start[01;31m-[00m>matrixToCanonical();
coordSys.cc:400:    transformedDest = dest[01;31m-[00m>copy();
coordSys.cc:401:    transformedDest[01;31m-[00m>transformWithMatrix(toCanonical);
coordSys.cc:402:    this[01;31m-[00m>defineForCoordinateSystem(transformedDest);
coordSys.cc:407:    n[01;31m-[00m>attribute("Alpha",this[01;31m-[00m>_Alpha );
coordSys.cc:408:    n[01;31m-[00m>attribute("Beta",this[01;31m-[00m>_Beta );
coordSys.cc:409:    n[01;31m-[00m>attribute("Gamma",this[01;31m-[00m>_Gamma );
coordSys.cc:410:    n[01;31m-[00m>attribute("Dist",this[01;31m-[00m>_Distance );
coordSys.cc:411:    n[01;31m-[00m>attribute("Phi",this[01;31m-[00m>_Phi );
coordSys.cc:412:    n[01;31m-[00m>attribute("Theta",this[01;31m-[00m>_Theta );
coordSys.cc:422:    c = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateSystem>();
coordSys.cc:423:    mt = this[01;31m-[00m>matrixFromCanonical();
coordSys.cc:424:    c[01;31m-[00m>transformWithMatrix(mt);
coordSys.cc:430:{_F(this[01;31m-[00m>lisp());
coordSys.cc:431:    Matrix mD; mD.rightHandedRotationZ(this[01;31m-[00m>_Alpha);
coordSys.cc:432:    Matrix mC; mC.rightHandedRotationX(this[01;31m-[00m>_Beta);
coordSys.cc:433:    Matrix mB; mB.rightHandedRotationZ(this[01;31m-[00m>_Gamma);
coordSys.cc:434:    Matrix mPhi; mPhi.rightHandedRotationZ(this[01;31m-[00m>_Phi);
coordSys.cc:435:    Matrix mTheta; mTheta.rightHandedRotationX(this[01;31m-[00m>_Theta);
coordSys.cc:436:    Vector3 vTrans; vTrans.set(0.0,0.0,this[01;31m-[00m>_Distance);
coordSys.cc:450:    c = this[01;31m-[00m>getCoordinateSystem();
coordSys.cc:451:    return c[01;31m-[00m>matrixToCanonical();
coordSys.cc:461:    this[01;31m-[00m>Base::initialize();
coordSys.cc:462:    this[01;31m-[00m>canonical();
coordSys.cc:469:    this[01;31m-[00m>origin = orig.origin;
coordSys.cc:470:    this[01;31m-[00m>x = orig.x;
coordSys.cc:471:    this[01;31m-[00m>y = orig.y;
coordSys.cc:472:    this[01;31m-[00m>z = orig.z;
coordSys.cc:485://	one unit along this ones X[01;31m-[00maxis
coordSys.cc:491:    mt.atColRowPut( 0, 0, this[01;31m-[00m>x.getX() );
coordSys.cc:492:    mt.atColRowPut( 0, 1, this[01;31m-[00m>x.getY() );
coordSys.cc:493:    mt.atColRowPut( 0, 2, this[01;31m-[00m>x.getZ() );
coordSys.cc:495:    mt.atColRowPut( 1, 0, this[01;31m-[00m>y.getX() );
coordSys.cc:496:    mt.atColRowPut( 1, 1, this[01;31m-[00m>y.getY() );
coordSys.cc:497:    mt.atColRowPut( 1, 2, this[01;31m-[00m>y.getZ() );
coordSys.cc:499:    mt.atColRowPut( 2, 0, this[01;31m-[00m>z.getX() );
coordSys.cc:500:    mt.atColRowPut( 2, 1, this[01;31m-[00m>z.getY() );
coordSys.cc:501:    mt.atColRowPut( 2, 2, this[01;31m-[00m>z.getZ() );
coordSys.cc:503:    m.translate(&(this[01;31m-[00m>origin));
coordSys.cc:517://	X[01;31m-[00maxis will be transformed to 1,0,0
coordSys.cc:523:    m.atRowColPut( 0, 0, this[01;31m-[00m>x.getX() );
coordSys.cc:524:    m.atRowColPut( 0, 1, this[01;31m-[00m>x.getY() );
coordSys.cc:525:    m.atRowColPut( 0, 2, this[01;31m-[00m>x.getZ() );
coordSys.cc:527:    m.atRowColPut( 1, 0, this[01;31m-[00m>y.getX() );
coordSys.cc:528:    m.atRowColPut( 1, 1, this[01;31m-[00m>y.getY() );
coordSys.cc:529:    m.atRowColPut( 1, 2, this[01;31m-[00m>y.getZ() );
coordSys.cc:531:    m.atRowColPut( 2, 0, this[01;31m-[00m>z.getX() );
coordSys.cc:532:    m.atRowColPut( 2, 1, this[01;31m-[00m>z.getY() );
coordSys.cc:533:    m.atRowColPut( 2, 2, this[01;31m-[00m>z.getZ() );
coordSys.cc:535:    vt = this[01;31m-[00m>origin.multiplyByScalar([01;31m-[00m1.0);
coordSys.cc:555:    this[01;31m-[00m>origin = Vector3(0.0,0.0,0.0);
coordSys.cc:556:    this[01;31m-[00m>x = Vector3(1.0,0.0,0.0);
coordSys.cc:557:    this[01;31m-[00m>y = Vector3(0.0,1.0,0.0);
coordSys.cc:558:    this[01;31m-[00m>z = Vector3(0.0,0.0,1.0);
coordSys.cc:567://	the x axis is along (ax[01;31m-[00maorigin)
coordSys.cc:571:{_F(this[01;31m-[00m>lisp());
coordSys.cc:573:    vo = aorigin[01;31m-[00m>getPosition();
coordSys.cc:575:    vx = (ax[01;31m-[00m>getPosition() [01;31m-[00m vo).normalized(this[01;31m-[00m>lisp());
coordSys.cc:577:    vxy = (axy[01;31m-[00m>getPosition() [01;31m-[00m vo).normalized(this[01;31m-[00m>lisp());
coordSys.cc:579:    vz = (vx.crossProduct(vxy)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:581:    vy = (vz.crossProduct(vx)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:583:    this[01;31m-[00m>origin = vo;
coordSys.cc:584:    this[01;31m-[00m>x = vx;
coordSys.cc:585:    this[01;31m-[00m>y = vy;
coordSys.cc:586:    this[01;31m-[00m>z = vz;
coordSys.cc:595://	the x axis is along (ax[01;31m-[00maorigin)
coordSys.cc:601:{_F(this[01;31m-[00m>lisp());
coordSys.cc:603:vx = (vax.sub(vo)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:604:vxy = (vaxy.sub(vo)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:609:    vz = (vx.crossProduct(vxy)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:611:    vy = (vz.crossProduct(vx)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:613:    this[01;31m-[00m>origin = vo;
coordSys.cc:614:    this[01;31m-[00m>x = vx;
coordSys.cc:615:    this[01;31m-[00m>y = vy;
coordSys.cc:616:    this[01;31m-[00m>z = vz;
coordSys.cc:624://	the x axis is along (ax[01;31m-[00maorigin)
coordSys.cc:629:{_F(this[01;31m-[00m>lisp());
coordSys.cc:631:vx = (vax.sub(vo)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:636:    vy = (vx.add(vOffset)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:642:	vy = (vx.add(vOffset)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:643:	vz = ( vx.crossProduct(vy) ).normalized(this[01;31m-[00m>lisp());
coordSys.cc:646:	vz = vz.normalized(this[01;31m-[00m>lisp());
coordSys.cc:648:    vy = (vz.crossProduct(vx)).normalized(this[01;31m-[00m>lisp());
coordSys.cc:651:    this[01;31m-[00m>origin = vo;
coordSys.cc:652:    this[01;31m-[00m>x = vx;
coordSys.cc:653:    this[01;31m-[00m>y = vy;
coordSys.cc:654:    this[01;31m-[00m>z = vz;
coordSys.cc:662://	the x axis is along (ax[01;31m-[00maorigin)
coordSys.cc:666:{_F(this[01;31m-[00m>lisp());
coordSys.cc:668:    this[01;31m-[00m>origin = vo;
coordSys.cc:669:    this[01;31m-[00m>x.set(1.0,0.0,0.0);
coordSys.cc:670:    this[01;31m-[00m>y.set(0.0,1.0,0.0);
coordSys.cc:671:    this[01;31m-[00m>z.set(0.0,0.0,1.0);
coordSys.cc:680://	of the X[01;31m-[00maxis and Y[01;31m-[00maxis.  The Z[01;31m-[00maxis is calculated from
coordSys.cc:681://	the cross[01;31m-[00mproduct of xDir and yDir.
coordSys.cc:689:    this[01;31m-[00m>origin = orig;
coordSys.cc:690:    this[01;31m-[00m>x = xDir.normalized(this[01;31m-[00m>lisp());
coordSys.cc:691:    this[01;31m-[00m>y = yDir.normalized(this[01;31m-[00m>lisp());
coordSys.cc:692:    vzt = (this[01;31m-[00m>x).crossProduct(this[01;31m-[00m>y);
coordSys.cc:693:    this[01;31m-[00m>z = vzt.normalized(this[01;31m-[00m>lisp());
coordSys.cc:701://	of the X[01;31m-[00maxis and a vector in the XY plane.
coordSys.cc:702://	The Z[01;31m-[00maxis is calculated from the cross[01;31m-[00mproduct of xDir and xyPlane.
coordSys.cc:710:    this[01;31m-[00m>origin = orig;
coordSys.cc:711:    this[01;31m-[00m>x = xDir.normalized(this[01;31m-[00m>lisp());
coordSys.cc:712:    vxy = xyPlane.normalized(this[01;31m-[00m>lisp());
coordSys.cc:713:    vzt = (this[01;31m-[00m>x).crossProduct(vxy);
coordSys.cc:714:    this[01;31m-[00m>z = vzt.normalized(this[01;31m-[00m>lisp());
coordSys.cc:715:    vyt = (this[01;31m-[00m>z).crossProduct(this[01;31m-[00m>x);
coordSys.cc:716:    this[01;31m-[00m>y = vyt.normalized(this[01;31m-[00m>lisp());
coordSys.cc:723://	of the Z[01;31m-[00maxis and a vector in the XZ plane.
coordSys.cc:724://	The Y[01;31m-[00maxis is calculated from the cross[01;31m-[00mproduct of xDir and xyPlane.
coordSys.cc:732:    this[01;31m-[00m>origin = orig;
coordSys.cc:733:    this[01;31m-[00m>z = zDir.normalized(this[01;31m-[00m>lisp());
coordSys.cc:734:    vxz = xzPlane.normalized(this[01;31m-[00m>lisp());
coordSys.cc:735:    vyt = (this[01;31m-[00m>z).crossProduct(vxz);
coordSys.cc:736:    this[01;31m-[00m>y = vyt.normalized(this[01;31m-[00m>lisp());
coordSys.cc:737:    vxt = (this[01;31m-[00m>y).crossProduct(this[01;31m-[00m>z);
coordSys.cc:738:    this[01;31m-[00m>x = vxt.normalized(this[01;31m-[00m>lisp());
coordSys.cc:748://	of the X[01;31m-[00maxis and Z[01;31m-[00maxis.  The Y[01;31m-[00maxis is calculated from
coordSys.cc:749://	the cross[01;31m-[00mproduct of xDir and zDir.
coordSys.cc:757:    this[01;31m-[00m>origin = orig;
coordSys.cc:758:    this[01;31m-[00m>x = xDir.normalized(this[01;31m-[00m>lisp());
coordSys.cc:759:    this[01;31m-[00m>z = zDir.normalized(this[01;31m-[00m>lisp());
coordSys.cc:760:    vyt = (this[01;31m-[00m>z).crossProduct(this[01;31m-[00m>x);
coordSys.cc:761:    this[01;31m-[00m>y = vyt.normalized(this[01;31m-[00m>lisp());
coordSys.cc:769:    x = randomNumber01(_lisp)*RANGE [01;31m-[00m (RANGE/2.0);
coordSys.cc:770:    y = randomNumber01(_lisp)*RANGE [01;31m-[00m (RANGE/2.0);
coordSys.cc:771:    z = randomNumber01(_lisp)*RANGE [01;31m-[00m (RANGE/2.0);
coordSys.cc:772:    this[01;31m-[00m>origin.set(x,y,z);
coordSys.cc:774:	x = randomNumber01(_lisp)*2.0[01;31m-[00m1.0;
coordSys.cc:775:	y = randomNumber01(_lisp)*2.0[01;31m-[00m1.0;
coordSys.cc:776:	z = randomNumber01(_lisp)*2.0[01;31m-[00m1.0;
coordSys.cc:777:	this[01;31m-[00m>x.set(x,y,z);
coordSys.cc:778:	if ( this[01;31m-[00m>x.length() > 0.00001 ) break;
coordSys.cc:780:    this[01;31m-[00m>x = this[01;31m-[00m>x.normalized(this[01;31m-[00m>lisp());
coordSys.cc:782:	x = randomNumber01(_lisp)*2.0[01;31m-[00m1.0;
coordSys.cc:783:	y = randomNumber01(_lisp)*2.0[01;31m-[00m1.0;
coordSys.cc:784:	z = randomNumber01(_lisp)*2.0[01;31m-[00m1.0;
coordSys.cc:785:	this[01;31m-[00m>y.set(x,y,z);
coordSys.cc:786:	if ( this[01;31m-[00m>y.length() > 0.00001 ) break;
coordSys.cc:788:    this[01;31m-[00m>z = this[01;31m-[00m>x.crossProduct(this[01;31m-[00m>y);
coordSys.cc:789:    this[01;31m-[00m>z = this[01;31m-[00m>z.normalized(this[01;31m-[00m>lisp());
coordSys.cc:790:    this[01;31m-[00m>y = this[01;31m-[00m>z.crossProduct(this[01;31m-[00m>x);
coordSys.cc:796:    this[01;31m-[00m>origin = c[01;31m-[00m>getOrigin();
coordSys.cc:797:    this[01;31m-[00m>x = c[01;31m-[00m>getX();
coordSys.cc:798:    this[01;31m-[00m>y = c[01;31m-[00m>getY();
coordSys.cc:799:    this[01;31m-[00m>z = c[01;31m-[00m>getZ();
coordSys.cc:805:    this[01;31m-[00m>origin.set(0.0,0.0,0.0);
coordSys.cc:806:    this[01;31m-[00m>x.set(1.0,0.0,0.0);
coordSys.cc:807:    this[01;31m-[00m>y.set(0.0,1.0,0.0);
coordSys.cc:808:    this[01;31m-[00m>z.set(0.0,0.0,1.0);
coordSys.cc:826:    m1 = this[01;31m-[00m>matrixToCanonical();
coordSys.cc:827:    m2 = cs[01;31m-[00m>matrixFromCanonical();
coordSys.cc:843:    vox = m*(this[01;31m-[00m>x + this[01;31m-[00m>origin);
coordSys.cc:844:    voy = m*(this[01;31m-[00m>y + this[01;31m-[00m>origin);
coordSys.cc:845:    voz = m*(this[01;31m-[00m>z + this[01;31m-[00m>origin);
coordSys.cc:846:    this[01;31m-[00m>origin = m*this[01;31m-[00m>origin;
coordSys.cc:847:    this[01;31m-[00m>x = vox [01;31m-[00m this[01;31m-[00m>origin;
coordSys.cc:848:    this[01;31m-[00m>y = voy [01;31m-[00m this[01;31m-[00m>origin;
coordSys.cc:849:    this[01;31m-[00m>z = voz [01;31m-[00m this[01;31m-[00m>origin;
coordSys.cc:861:    vox = (*m)*(this[01;31m-[00m>x + this[01;31m-[00m>origin);
coordSys.cc:862:    voy = (*m)*(this[01;31m-[00m>y + this[01;31m-[00m>origin);
coordSys.cc:863:    voz = (*m)*(this[01;31m-[00m>z + this[01;31m-[00m>origin);
coordSys.cc:864:    this[01;31m-[00m>origin = (*m)*this[01;31m-[00m>origin;
coordSys.cc:865:    this[01;31m-[00m>x = vox [01;31m-[00m this[01;31m-[00m>origin;
coordSys.cc:866:    this[01;31m-[00m>y = voy [01;31m-[00m this[01;31m-[00m>origin;
coordSys.cc:867:    this[01;31m-[00m>z = voz [01;31m-[00m this[01;31m-[00m>origin;
coordSys.cc:884:    line = xmlLine( XML_RED, (int)width, this[01;31m-[00m>origin,
coordSys.cc:885:				this[01;31m-[00m>origin+this[01;31m-[00m>x*axisLength );
coordSys.cc:886:    graalphacs[01;31m-[00m>addChild(line);
coordSys.cc:887:    line = xmlLine( XML_GREEN, (int)width, this[01;31m-[00m>origin,
coordSys.cc:888:				this[01;31m-[00m>origin+this[01;31m-[00m>y*axisLength );
coordSys.cc:889:    graalphacs[01;31m-[00m>addChild(line);
coordSys.cc:890:    line = xmlLine( XML_BLUE, (int)width, this[01;31m-[00m>origin,
coordSys.cc:891:				this[01;31m-[00m>origin+this[01;31m-[00m>z*axisLength );
coordSys.cc:892:    graalphacs[01;31m-[00m>addChild(line);
coordSys.cc:907:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("origin: ( %lf, %lf, %lf )") %	this[01;31m-[00m>origin.getX()% this[01;31m-[00m>origin.getY() % this[01;31m-[00m>origin.getZ() );
coordSys.cc:908:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("x[01;31m-[00maxis: ( %lf, %lf, %lf )") %	this[01;31m-[00m>x.getX()% this[01;31m-[00m>x.getY() % this[01;31m-[00m>x.getZ() );
coordSys.cc:909:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("y[01;31m-[00maxis: ( %lf, %lf, %lf )") %	this[01;31m-[00m>y.getX()% this[01;31m-[00m>y.getY() % this[01;31m-[00m>y.getZ() );
coordSys.cc:910:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("z[01;31m-[00maxis: ( %lf, %lf, %lf )") %	this[01;31m-[00m>z.getX()% this[01;31m-[00m>z.getY() % this[01;31m-[00m>z.getZ() );
coordSys.cc:915:    node[01;31m-[00m>archivePlainObject<Vector3>( "origin", "Vector", this[01;31m-[00m>origin );
coordSys.cc:916:    node[01;31m-[00m>archivePlainObject<Vector3>( "x", "Vector", this[01;31m-[00m>x );
coordSys.cc:917:    node[01;31m-[00m>archivePlainObject<Vector3>( "y", "Vector", this[01;31m-[00m>y );
coordSys.cc:918:    node[01;31m-[00m>archivePlainObject<Vector3>( "z", "Vector", this[01;31m-[00m>z );
coordSys.cc:932:    if ( !this[01;31m-[00m>origin.sameAs(c[01;31m-[00m>getOrigin()) ) return false;
coordSys.cc:933:    if ( !this[01;31m-[00m>x.sameAs(c[01;31m-[00m>getX()) ) return false;
coordSys.cc:934:    if ( !this[01;31m-[00m>y.sameAs(c[01;31m-[00m>getY()) ) return false;
coordSys.cc:935:    if ( !this[01;31m-[00m>z.sameAs(c[01;31m-[00m>getZ()) ) return false;
coordSys.cc:940:{_F(this[01;31m-[00m>lisp());
coordSys.cc:941:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
coordSys.cc:942:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("red"));
coordSys.cc:943:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(this[01;31m-[00m>origin,this[01;31m-[00m>origin+this[01;31m-[00m>x));
coordSys.cc:944:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("green"));
coordSys.cc:945:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(this[01;31m-[00m>origin,this[01;31m-[00m>origin+this[01;31m-[00m>y));
coordSys.cc:946:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("blue"));
coordSys.cc:947:    dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(this[01;31m-[00m>origin,this[01;31m-[00m>origin+this[01;31m-[00m>z));
coordSys.cc:954:    ss << "Origin: " << this[01;31m-[00m>origin.asString() << endl;
coordSys.cc:955:    ss << "xdir: " << this[01;31m-[00m>x.asString() << endl;
coordSys.cc:956:    ss << "ydir: " << this[01;31m-[00m>y.asString() << endl;
coordSys.cc:957:    ss << "zdir: " << this[01;31m-[00m>z.asString() << endl;
coordSys.cc:965:    transformToCanonical = this[01;31m-[00m>matrixToCanonical();
coordSys.cc:975:	class_<O_CoordinateSystem>(this[01;31m-[00m>lisp())
coordinateArray.cc:25:    this[01;31m-[00m>Base::initialize();
coordinateArray.cc:26:    this[01;31m-[00m>_Points.clear();
coordinateArray.cc:32:    uint sz = elements[01;31m-[00m>length();
coordinateArray.cc:35:    for ( ; elements[01;31m-[00m>notNil(); elements = elements[01;31m-[00m>cdr() )
coordinateArray.cc:37:	res[01;31m-[00m>setElement(idx,elements[01;31m-[00m>ocar()[01;31m-[00m>as<O_OVector3>()[01;31m-[00m>get());
coordinateArray.cc:44:{_F(this[01;31m-[00m>lisp());
coordinateArray.cc:47:    this[01;31m-[00m>_Points.resize(iElement,zero);
coordinateArray.cc:52:    return this[01;31m-[00m>_Points.begin();
coordinateArray.cc:57:    return this[01;31m-[00m>_Points.end();
coordinateArray.cc:61:{_F(this[01;31m-[00m>lisp());
coordinateArray.cc:62:    ASSERT_lessThan(i,this[01;31m-[00m>_Points.size() );
coordinateArray.cc:63:    Vector3 &res = this[01;31m-[00m>_Points[i];
coordinateArray.cc:68:{_F(this[01;31m-[00m>lisp());
coordinateArray.cc:69:    ASSERT_lessThan(i,this[01;31m-[00m>_Points.size() );
coordinateArray.cc:70:    Vector3 res = this[01;31m-[00m>_Points[i];
coordinateArray.cc:74:{_F(this[01;31m-[00m>lisp());
coordinateArray.cc:75:    ASSERT_lessThan(i,this[01;31m-[00m>_Points.size() );
coordinateArray.cc:76:    this[01;31m-[00m>_Points[i] = pos;
coordinateArray.cc:86:    this[01;31m-[00m>resize(sz);
coordinateArray.cc:88:	this[01;31m-[00m>_Points[i] = c._Points[i];
coordinateArray.cc:95:    sz = this[01;31m-[00m>_Points.size();
coordinateArray.cc:97:	this[01;31m-[00m>_Points[i].set(0.0,0.0,0.0);
coordinateArray.cc:104:    ASSERT_eq(this[01;31m-[00m>_Points.size(),y[01;31m-[00m>size());
coordinateArray.cc:105:    sz = this[01;31m-[00m>_Points.size();
coordinateArray.cc:107:	this[01;31m-[00m>_Points[i] = this[01;31m-[00m>_Points[i].add(y[01;31m-[00m>getElement(i));
coordinateArray.cc:116:    sz = this[01;31m-[00m>_Points.size();
coordinateArray.cc:117:    ASSERT_eq(this[01;31m-[00m>_Points.size(),y[01;31m-[00m>size());
coordinateArray.cc:118:    ASSERT(this[01;31m-[00m>_Points.size()>0);
coordinateArray.cc:120:	Vector3 v = this[01;31m-[00m>_Points[i].sub(y[01;31m-[00m>getElement(i));
coordinateArray.cc:132:    sz = this[01;31m-[00m>_Points.size();
coordinateArray.cc:135:	this[01;31m-[00m>_Points[i] = this[01;31m-[00m>_Points[i].multiplyByScalar(d);
coordinateArray.cc:140:{_F(this[01;31m-[00m>lisp());
coordinateArray.cc:142:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
coordinateArray.cc:143:    RPGrPointList pl = O_GrPointList::create(this[01;31m-[00m>lisp());
coordinateArray.cc:144:    sz = this[01;31m-[00m>_Points.size();
coordinateArray.cc:147:	pl[01;31m-[00m>addVertex(this[01;31m-[00m>_Points[i]);
coordinateArray.cc:149:    dl[01;31m-[00m>add(pl);
coordinateArray.cc:156:    sz = this[01;31m-[00m>_Points.size();
coordinateArray.cc:158:	this[01;31m-[00m>_Points[i] = tm.multiplyByVector3(this[01;31m-[00m>_Points[i]);
coordinateArray.cc:164:{_F(this[01;31m-[00m>lisp());
coordinateArray.cc:167:    sz = this[01;31m-[00m>_Points.size();
coordinateArray.cc:169:        ss << this[01;31m-[00m>_Points[i].asString() << endl;
coordinateArray.cc:179:{_F(this[01;31m-[00m>lisp());
coordinateArray.cc:180:    if ( node[01;31m-[00m>saving() ) {
coordinateArray.cc:181:        uint sz = this[01;31m-[00m>size();
coordinateArray.cc:182:        node[01;31m-[00m>attribute("size",sz);
coordinateArray.cc:186:	for ( i=0,vi=this[01;31m-[00m>_Points.begin(); vi!=this[01;31m-[00m>_Points.end(); i++,vi++ ) {
coordinateArray.cc:187:	    vnode = node[01;31m-[00m>createChildNode("V");
coordinateArray.cc:188:	    vnode[01;31m-[00m>attribute("i",i);
coordinateArray.cc:193:	node[01;31m-[00m>attribute("size",sz);
coordinateArray.cc:194:	this[01;31m-[00m>resize(sz);
coordinateArray.cc:197:	for ( vi=node[01;31m-[00m>begin_Children(); vi!=node[01;31m-[00m>end_Children(); vi++ ) {
coordinateArray.cc:198:	    (*vi)[01;31m-[00m>setRecognized(true);
coordinateArray.cc:199:	    (*vi)[01;31m-[00m>attribute("i",i);
coordinateArray.cc:200:	    this[01;31m-[00m>_Points[i].archive(*vi);
coordinateArray.cc:209:    this[01;31m-[00m>archiveBase(node);
coordinateArray.cc:216:{_F(this[01;31m-[00m>lisp());
coordinateArray.cc:226:    h[01;31m-[00m>resize(sz);
coordinateArray.cc:238:    this[01;31m-[00m>Base::initialize();
coordinateArray.cc:239:    this[01;31m-[00m>_Hash = UndefinedUnsignedInt;
coordinateArray.cc:244:    this[01;31m-[00m>Base::archiveBase(node);
coordinateArray.cc:245:    node[01;31m-[00m>attribute("hash",this[01;31m-[00m>_Hash);
coordinateArray.cc:254:	class_<O_CoordinateArray>(this[01;31m-[00m>lisp())
coordinateArray.cc:286:	class_<O_CoordinateArrayWithHash>(this[01;31m-[00m>lisp())
coupling.cc:32:    this[01;31m-[00m>Base::initialize();
coupling.cc:33:    this[01;31m-[00m>_WeakOligomer = O_Oligomer::nil(this[01;31m-[00m>lisp());
coupling.cc:34:    this[01;31m-[00m>_HasError = false;
coupling.cc:35:    this[01;31m-[00m>_StatusMessage.str("");
coupling.cc:36:    this[01;31m-[00m>_Selected = false;
coupling.cc:40:{_F(this[01;31m-[00m>lisp());
coupling.cc:41:    LOG(BF("checking if coupling(%s) contains monomer: %s") % this[01;31m-[00m>description().c_str() % mon[01;31m-[00m>description().c_str() ); // vp0(("checking if coupling(%s) contains monomer: %s",this[01;31m-[00m>description().c_str(),mon[01;31m-[00m>description().c_str()));
coupling.cc:42:    LOG(BF("About to check monomer1: %s") % this[01;31m-[00m>getMonomer1()[01;31m-[00m>description().c_str() ); // vp0(("About to check monomer1: %s",this[01;31m-[00m>getMonomer1()[01;31m-[00m>description().c_str()));
coupling.cc:43:    if ( mon == this[01;31m-[00m>getMonomer1() ) { return true; };
coupling.cc:44:    LOG(BF("About to check out monomer: %s") % this[01;31m-[00m>getMonomer2()[01;31m-[00m>description().c_str() ); // vp0(("About to check out monomer: %s",this[01;31m-[00m>getMonomer2()[01;31m-[00m>description().c_str()));
coupling.cc:45:    if ( mon == this[01;31m-[00m>getMonomer2() ) { return true; };
coupling.cc:52:{_F(this[01;31m-[00m>lisp());
coupling.cc:53:    this[01;31m-[00m>Base::archiveBase(node);
coupling.cc:54:    node[01;31m-[00m>archiveWeakPointer("oligomer",this[01;31m-[00m>_WeakOligomer );
coupling.cc:55:    node[01;31m-[00m>attribute("hasError", this[01;31m-[00m>_HasError );
coupling.cc:56:    node[01;31m-[00m>attribute("statusMessage", this[01;31m-[00m>_StatusMessage);
coupling.cc:62:    this[01;31m-[00m>_WeakOligomer = o[01;31m-[00m>sharedThis<O_Oligomer>();
coupling.cc:67:{_F(this[01;31m-[00m>lisp());
coupling.cc:68:    this[01;31m-[00m>_WeakOligomer = O_Oligomer::nil(this[01;31m-[00m>lisp());
coupling.cc:73:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakOligomer);
coupling.cc:74:    return this[01;31m-[00m>_WeakOligomer.lock();
coupling.cc:149:    this[01;31m-[00m>Base::initialize();
coupling.cc:150:    this[01;31m-[00m>_InMonomer = O_Monomer::nil(this[01;31m-[00m>lisp());
coupling.cc:151:    this[01;31m-[00m>_OutMonomer = O_Monomer::nil(this[01;31m-[00m>lisp());
coupling.cc:152:    this[01;31m-[00m>_Name = "?";
coupling.cc:161:{_F(this[01;31m-[00m>lisp());
coupling.cc:162:    this[01;31m-[00m>_InMonomer = O_Monomer::nil(this[01;31m-[00m>lisp());
coupling.cc:167:{_F(this[01;31m-[00m>lisp());
coupling.cc:168:    this[01;31m-[00m>_OutMonomer = O_Monomer::nil(this[01;31m-[00m>lisp());
coupling.cc:175:{_F(this[01;31m-[00m>lisp());
coupling.cc:176:    this[01;31m-[00m>setHasError(false);
coupling.cc:177:    this[01;31m-[00m>statusMessageStream().str("");
coupling.cc:178:    ANN(this[01;31m-[00m>_InMonomer);
coupling.cc:179:    if ( this[01;31m-[00m>_InMonomer.lock()[01;31m-[00m>isNil() )
coupling.cc:181:        this[01;31m-[00m>setHasError(true);
coupling.cc:182:	this[01;31m-[00m>statusMessageStream() << "InMonomer is NULL" << endl;
coupling.cc:184:    ANN(this[01;31m-[00m>_OutMonomer);
coupling.cc:185:    if ( this[01;31m-[00m>_OutMonomer.lock()[01;31m-[00m>isNil() )
coupling.cc:187:        this[01;31m-[00m>setHasError(true);
coupling.cc:188:	this[01;31m-[00m>statusMessageStream() << "OutMonomer is NULL" << endl;
coupling.cc:193:{_F(this[01;31m-[00m>lisp());
coupling.cc:196:    ANN(this[01;31m-[00m>_InMonomer);
coupling.cc:197:    if ( this[01;31m-[00m>_InMonomer.lock()[01;31m-[00m>isNil() )
coupling.cc:202:    mon = this[01;31m-[00m>_InMonomer.lock();
coupling.cc:203:    LOG(BF("InMonomer is: %s") % mon[01;31m-[00m>description().c_str()  ); // vp0(("InMonomer is: %s",mon[01;31m-[00m>description().c_str() ));
coupling.cc:204:    if ( !mon[01;31m-[00m>hasCouplingWithPlugName(O_DirectionalCoupling::outPlugName(this[01;31m-[00m>getName(),_lisp)))
coupling.cc:209:    if ( !mon[01;31m-[00m>hasMatchingPlugNameAndCoupling(O_DirectionalCoupling::outPlugName(this[01;31m-[00m>getName(),_lisp),
coupling.cc:210:    					this[01;31m-[00m>sharedThis<O_DirectionalCoupling>() ) )
coupling.cc:215:    ASSERT_NOT_NULL(this[01;31m-[00m>_OutMonomer);
coupling.cc:216:    if ( this[01;31m-[00m>_OutMonomer.lock()[01;31m-[00m>isNil() )
coupling.cc:221:    mon = this[01;31m-[00m>_OutMonomer.lock();
coupling.cc:222:    LOG(BF("OutMonomer is: %s") % mon[01;31m-[00m>description().c_str()  ); // vp0(("OutMonomer is: %s",mon[01;31m-[00m>description().c_str() ));
coupling.cc:223:    if ( !mon[01;31m-[00m>hasCouplingWithPlugName(O_DirectionalCoupling::inPlugName(this[01;31m-[00m>getName(),_lisp)))
coupling.cc:228:    if ( !mon[01;31m-[00m>hasMatchingPlugNameAndCoupling(O_DirectionalCoupling::inPlugName(this[01;31m-[00m>getName(),_lisp),
coupling.cc:229:    					this[01;31m-[00m>sharedThis<O_DirectionalCoupling>() ) )
coupling.cc:236:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("Bad coupling %s") % this[01;31m-[00m>sharedThis<O_DirectionalCoupling>()[01;31m-[00m>description() ));
coupling.cc:241:{_F(this[01;31m-[00m>lisp());
coupling.cc:242:    this[01;31m-[00m>Base::archiveBase(node);
coupling.cc:243:    node[01;31m-[00m>attribute("name", this[01;31m-[00m>_Name );
coupling.cc:244:    node[01;31m-[00m>archiveWeakPointer("inMonomer", this[01;31m-[00m>_InMonomer );
coupling.cc:245:    node[01;31m-[00m>archiveWeakPointer("outMonomer", this[01;31m-[00m>_OutMonomer );
coupling.cc:250:{_F(this[01;31m-[00m>lisp());
coupling.cc:252:    ASSERT_NOT_NULL(this[01;31m-[00m>_OutMonomer);
coupling.cc:254:    return this[01;31m-[00m>_OutMonomer.lock() == mon;
coupling.cc:261:    ASSERT_NOT_NULLP(this[01;31m-[00m>_InMonomer,
coupling.cc:262:    	"InMonomer is NULL for coupling: "+this[01;31m-[00m>description());
coupling.cc:263:    return this[01;31m-[00m>_InMonomer.lock();
coupling.cc:268:    ASSERT_NOT_NULLP(this[01;31m-[00m>_InMonomer,
coupling.cc:269:    	"InMonomer is NULL for coupling: "+this[01;31m-[00m>description());
coupling.cc:270:    return this[01;31m-[00m>_InMonomer.lock();
coupling.cc:276:    ASSERT_NOT_NULLP(this[01;31m-[00m>_OutMonomer,
coupling.cc:277:    	"OutMonomer is NULL for coupling: "+this[01;31m-[00m>description());
coupling.cc:278:    return this[01;31m-[00m>_OutMonomer.lock();
coupling.cc:283:    ASSERT_NOT_NULLP(this[01;31m-[00m>_OutMonomer,
coupling.cc:284:    	"OutMonomer is NULL for coupling: "+this[01;31m-[00m>description());
coupling.cc:285:    return this[01;31m-[00m>_OutMonomer.lock();
coupling.cc:291: * inPlugNames for couplings are the out[01;31m-[00mplugs for monomers
coupling.cc:294:{_F(this[01;31m-[00m>lisp());
coupling.cc:295:    return O_DirectionalCoupling::outPlugName(this[01;31m-[00m>_Name,_lisp);
coupling.cc:300: * inPlugNames for couplings are the out[01;31m-[00mplugs for monomers
coupling.cc:303:{_F(this[01;31m-[00m>lisp());
coupling.cc:304:    return O_DirectionalCoupling::inPlugName(this[01;31m-[00m>_Name,_lisp);
coupling.cc:312:    ss << "DirectionalCoupling( "<< this[01;31m-[00m>getName_const();
coupling.cc:316:    ANN(this[01;31m-[00m>_InMonomer);
coupling.cc:317:    if ( this[01;31m-[00m>_InMonomer.lock()[01;31m-[00m>isNil())
coupling.cc:319:	ss << "[01;31m-[00mNULL_Monomer[01;31m-[00m";
coupling.cc:322:	ss << this[01;31m-[00m>getInMonomer_const()[01;31m-[00m>description();
coupling.cc:324:    ss << "[01;31m-[00m>";
coupling.cc:325:    ANN(this[01;31m-[00m>_OutMonomer);
coupling.cc:326:    if ( this[01;31m-[00m>_OutMonomer.lock()[01;31m-[00m>isNil() )
coupling.cc:328:	ss << "[01;31m-[00mNULL_Monomer[01;31m-[00m";
coupling.cc:331:	ss << this[01;31m-[00m>getOutMonomer_const()[01;31m-[00m>description();
coupling.cc:341:{_F(this[01;31m-[00m>lisp());
coupling.cc:342:    this[01;31m-[00m>_Name = O_DirectionalCoupling::couplingName(nm,_lisp);
coupling.cc:343:    ANN(this[01;31m-[00m>_InMonomer);
coupling.cc:344:    if ( this[01;31m-[00m>_InMonomer.lock()[01;31m-[00m>notNil() )
coupling.cc:346:	this[01;31m-[00m>_InMonomer.lock()[01;31m-[00m>fixPlugNameForCoupling(this[01;31m-[00m>sharedThis<O_DirectionalCoupling>());
coupling.cc:348:    ANN(this[01;31m-[00m>_OutMonomer);
coupling.cc:349:    if ( this[01;31m-[00m>_OutMonomer.lock()[01;31m-[00m>notNil() )
coupling.cc:351:	this[01;31m-[00m>_OutMonomer.lock()[01;31m-[00m>fixPlugNameForCoupling(this[01;31m-[00m>sharedThis<O_DirectionalCoupling>());
coupling.cc:357:{_F(this[01;31m-[00m>lisp());
coupling.cc:359:    this[01;31m-[00m>_InMonomer = m[01;31m-[00m>sharedThis<O_Monomer>();
coupling.cc:360:    LOG(BF("Setting in monomer to (%s)") % m[01;31m-[00m>description().c_str()  ); // vp0(("Setting in monomer to (%s)",m[01;31m-[00m>description().c_str() ));
coupling.cc:364:{_F(this[01;31m-[00m>lisp());
coupling.cc:366:    this[01;31m-[00m>_OutMonomer = m[01;31m-[00m>sharedThis<O_Monomer>();
coupling.cc:367:    LOG(BF("Setting out monomer to (%s)") % m[01;31m-[00m>description().c_str()  ); // vp0(("Setting out monomer to (%s)",m[01;31m-[00m>description().c_str() ));
coupling.cc:373:{_F(this[01;31m-[00m>lisp());
coupling.cc:374:    this[01;31m-[00m>setInMonomer_NoSignal(m);
coupling.cc:379:{_F(this[01;31m-[00m>lisp());
coupling.cc:380:    this[01;31m-[00m>setOutMonomer_NoSignal(m);
coupling.cc:390:    ASSERT(mon[01;31m-[00m>notNil());
coupling.cc:391:    if ( mon == this[01;31m-[00m>getInMonomer() ) return InSide;
coupling.cc:392:    if ( mon == this[01;31m-[00m>getOutMonomer() ) return OutSide;
coupling.cc:401:{_F(this[01;31m-[00m>lisp());
coupling.cc:403:    if ( mon == this[01;31m-[00m>getInMonomer() ) { return this[01;31m-[00m>getOutMonomer(); };
coupling.cc:405:    if ( mon == this[01;31m-[00m>getOutMonomer() ) { return this[01;31m-[00m>getInMonomer(); };
coupling.cc:407:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("Monomer is not in coupling %s") % mon[01;31m-[00m>description()));
coupling.cc:416:{_F(this[01;31m-[00m>lisp());
coupling.cc:422:    if ( this[01;31m-[00m>getHasError() ) return;
coupling.cc:423:    min = this[01;31m-[00m>getInMonomer();
coupling.cc:424:    mout = this[01;31m-[00m>getOutMonomer();
coupling.cc:425:    if ( min[01;31m-[00m>getHasError() ) return;
coupling.cc:426:    if ( mout[01;31m-[00m>getHasError() ) return;
coupling.cc:427:    ASSERT(min[01;31m-[00m>notNil());
coupling.cc:428:    ASSERT(mout[01;31m-[00m>notNil());
coupling.cc:429:    minPlug = min[01;31m-[00m>getPlugNamed(this[01;31m-[00m>getInMonomerPlugName())[01;31m-[00m>as<O_PlugWithMates>();
coupling.cc:430:    moutPlug = mout[01;31m-[00m>getPlugNamed(this[01;31m-[00m>getOutMonomerPlugName())[01;31m-[00m>as<O_PlugWithMates>();
coupling.cc:439:    weakInRes = min[01;31m-[00m>getTemporaryResidue();
coupling.cc:443:    weakOutRes = mout[01;31m-[00m>getTemporaryResidue();
coupling.cc:449:    inB0 = inResidue[01;31m-[00m>atomWithName(minPlug[01;31m-[00m>getB0());
coupling.cc:450:    outB0 = outResidue[01;31m-[00m>atomWithName(moutPlug[01;31m-[00m>getB0());
coupling.cc:451:    b = inB0[01;31m-[00m>bondTo(outB0,singleBond);
coupling.cc:452:    if ( moutPlug[01;31m-[00m>getB1() != "" ) {
coupling.cc:453:	outB1 = outResidue[01;31m-[00m>atomWithName(moutPlug[01;31m-[00m>getB1());
coupling.cc:454:	if ( minPlug[01;31m-[00m>getB1() != "" ) {
coupling.cc:455:	    inB1 = inResidue[01;31m-[00m>atomWithName(minPlug[01;31m-[00m>getB1());
coupling.cc:459:	    b = inB1[01;31m-[00m>bondTo(outB1,singleBond);
coupling.cc:465:	    b = inB0[01;31m-[00m>bondTo(outB1,singleBond);
coupling.cc:467:    } else if ( minPlug[01;31m-[00m>getB1() != "" ) {
coupling.cc:471:	b = inB1[01;31m-[00m>bondTo(outB0,singleBond);
coupling.cc:478:{_F(this[01;31m-[00m>lisp());
coupling.cc:479:    if ( this[01;31m-[00m>_InMonomer.lock() == mon ) {
coupling.cc:480:	string plugName = this[01;31m-[00m>getInMonomerPlugName();
coupling.cc:481:	ASSERT(this[01;31m-[00m>_InMonomer.lock()[01;31m-[00m>notNil());
coupling.cc:482:	return this[01;31m-[00m>_InMonomer.lock()[01;31m-[00m>getPlugNamed(plugName);
coupling.cc:484:    string plugName = this[01;31m-[00m>getOutMonomerPlugName();
coupling.cc:485:    ASSERT(this[01;31m-[00m>_OutMonomer.lock()[01;31m-[00m>notNil());
coupling.cc:486:    return this[01;31m-[00m>_OutMonomer.lock()[01;31m-[00m>getPlugNamed(plugName);
coupling.cc:490:{_F(this[01;31m-[00m>lisp());
coupling.cc:491:    if ( this[01;31m-[00m>_InMonomer.lock() == mon ) {
coupling.cc:492:	string plugName = this[01;31m-[00m>getOutMonomerPlugName();
coupling.cc:493:	ASSERT(this[01;31m-[00m>_OutMonomer.lock()[01;31m-[00m>notNil());
coupling.cc:494:	return this[01;31m-[00m>_OutMonomer.lock()[01;31m-[00m>getPlugNamed(plugName);
coupling.cc:496:    string plugName = this[01;31m-[00m>getInMonomerPlugName();
coupling.cc:497:    ASSERT(this[01;31m-[00m>_InMonomer.lock()[01;31m-[00m>notNil());
coupling.cc:498:    return this[01;31m-[00m>_InMonomer.lock()[01;31m-[00m>getPlugNamed(plugName);
coupling.cc:510:TOSS(_lisp[01;31m-[00m>create<O_LispError>("I wasn't sure if this was ever called.  Take out this THROW if it is"));
coupling.cc:511:    this[01;31m-[00m>setInMonomer_NoSignal(sin);
coupling.cc:512:    this[01;31m-[00m>setOutMonomer_NoSignal(sout);
coupling.cc:513:    me = this[01;31m-[00m>sharedThis<O_DirectionalCoupling>();
coupling.cc:514:    string inMonomerPlugName = O_DirectionalCoupling::outPlugName(this[01;31m-[00m>getName(),_lisp);
coupling.cc:515:    string outMonomerPlugName = O_DirectionalCoupling::inPlugName(this[01;31m-[00m>getName(),_lisp);
coupling.cc:516:    sin[01;31m-[00m>addCoupling(inMonomerPlugName,me);
coupling.cc:517:    sout[01;31m-[00m>addCoupling(outMonomerPlugName,me);
coupling.cc:529:    this[01;31m-[00m>Base::initialize();
coupling.cc:530:    this[01;31m-[00m>_Monomer1 = O_Monomer::nil(this[01;31m-[00m>lisp());
coupling.cc:531:    this[01;31m-[00m>_Monomer2 = O_Monomer::nil(this[01;31m-[00m>lisp());
coupling.cc:532:    this[01;31m-[00m>_Plug1 = "?";
coupling.cc:533:    this[01;31m-[00m>_Plug2 = "?";
coupling.cc:537:{_F(this[01;31m-[00m>lisp());
coupling.cc:538:    this[01;31m-[00m>Base::archiveBase(node);
coupling.cc:539:    node[01;31m-[00m>attribute("plug1", this[01;31m-[00m>_Plug1);
coupling.cc:540:    node[01;31m-[00m>attribute("plug2", this[01;31m-[00m>_Plug2);
coupling.cc:541:    node[01;31m-[00m>archiveWeakPointer("monomer1", this[01;31m-[00m>_Monomer1 );
coupling.cc:542:    node[01;31m-[00m>archiveWeakPointer("monomer2", this[01;31m-[00m>_Monomer2 );
coupling.cc:548:{_F(this[01;31m-[00m>lisp());
coupling.cc:549:    return "ringCoupling("+this[01;31m-[00m>_Plug1+"[01;31m-[00m"+this[01;31m-[00m>_Plug2+")";
coupling.cc:553:{_F(this[01;31m-[00m>lisp());
coupling.cc:554:    return "ringCoupling("+this[01;31m-[00m>_Plug1+"[01;31m-[00m"+this[01;31m-[00m>_Plug2+")";
coupling.cc:558:{_F(this[01;31m-[00m>lisp());
coupling.cc:559:    this[01;31m-[00m>_Monomer1 = mon;
coupling.cc:564:    ASSERT_NOT_NULLP(this[01;31m-[00m>_Monomer1,
coupling.cc:565:    	"InMonomer is NULL for coupling: "+this[01;31m-[00m>description());
coupling.cc:566:    return this[01;31m-[00m>_Monomer1.lock();
coupling.cc:571:    ASSERT_NOT_NULLP(this[01;31m-[00m>_Monomer1,
coupling.cc:572:    	"InMonomer is NULL for coupling: "+this[01;31m-[00m>description());
coupling.cc:573:    return this[01;31m-[00m>_Monomer1.lock();
coupling.cc:578:{_F(this[01;31m-[00m>lisp());
coupling.cc:579:    this[01;31m-[00m>_Monomer2 = mon;
coupling.cc:584:    ASSERT_NOT_NULLP(this[01;31m-[00m>_Monomer2,
coupling.cc:585:    	"Monomer2 is NULL for coupling: "+this[01;31m-[00m>description());
coupling.cc:586:    return this[01;31m-[00m>_Monomer2.lock();
coupling.cc:591:    ASSERT_NOT_NULLP(this[01;31m-[00m>_Monomer2,
coupling.cc:592:    	"Monomer2 is NULL for coupling: "+this[01;31m-[00m>description());
coupling.cc:593:    return this[01;31m-[00m>_Monomer2.lock();
coupling.cc:597:{_F(this[01;31m-[00m>lisp());
coupling.cc:599:    if ( mon == this[01;31m-[00m>getMonomer1() ) { return this[01;31m-[00m>getMonomer2(); };
coupling.cc:601:    if ( mon == this[01;31m-[00m>getMonomer2() ) { return this[01;31m-[00m>getMonomer1(); };
coupling.cc:603:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("Monomer is not in coupling %s" ) % mon[01;31m-[00m>description()));
coupling.cc:609:{_F(this[01;31m-[00m>lisp());
coupling.cc:610:    this[01;31m-[00m>setHasError(false);
coupling.cc:611:    this[01;31m-[00m>statusMessageStream().str("");
coupling.cc:612:    ANN(this[01;31m-[00m>_Monomer1);
coupling.cc:613:    if ( this[01;31m-[00m>_Monomer1.lock()[01;31m-[00m>isNil() )
coupling.cc:615:        this[01;31m-[00m>setHasError(true);
coupling.cc:616:	this[01;31m-[00m>statusMessageStream() << "Monomer1 is NULL" << endl;
coupling.cc:618:    ANN(this[01;31m-[00m>_Monomer2);
coupling.cc:619:    if ( this[01;31m-[00m>_Monomer2.lock()[01;31m-[00m>isNil() )
coupling.cc:621:        this[01;31m-[00m>setHasError(true);
coupling.cc:622:	this[01;31m-[00m>statusMessageStream() << "Monomer2 is NULL" << endl;
coupling.cc:627:{_F(this[01;31m-[00m>lisp());
coupling.cc:630:    ANN(this[01;31m-[00m>_Monomer1);
coupling.cc:631:    if ( this[01;31m-[00m>_Monomer1.lock()[01;31m-[00m>isNil() )
coupling.cc:636:    mon = this[01;31m-[00m>_Monomer1.lock();
coupling.cc:637:    LOG(BF("Monomer1 is: %s") % mon[01;31m-[00m>description().c_str()  ); // vp0(("Monomer1 is: %s",mon[01;31m-[00m>description().c_str() ));
coupling.cc:638:    if ( !mon[01;31m-[00m>hasCouplingWithPlugName(O_DirectionalCoupling::outPlugName(this[01;31m-[00m>getPlug1(),_lisp)))
coupling.cc:643:    if ( !mon[01;31m-[00m>hasMatchingPlugNameAndCoupling(O_DirectionalCoupling::outPlugName(this[01;31m-[00m>getPlug1(),_lisp),
coupling.cc:644:    					this[01;31m-[00m>sharedThis<O_RingCoupling>() ) )
coupling.cc:649:    ASSERT_NOT_NULL(this[01;31m-[00m>_Monomer2);
coupling.cc:650:    if ( this[01;31m-[00m>_Monomer2.lock()[01;31m-[00m>isNil() )
coupling.cc:655:    mon = this[01;31m-[00m>_Monomer2.lock();
coupling.cc:656:    LOG(BF("Monomer2 is: %s") % mon[01;31m-[00m>description().c_str()  ); // vp0(("Monomer2 is: %s",mon[01;31m-[00m>description().c_str() ));
coupling.cc:657:    if ( !mon[01;31m-[00m>hasCouplingWithPlugName(O_DirectionalCoupling::outPlugName(this[01;31m-[00m>getPlug2(),_lisp)))
coupling.cc:662:    if ( !mon[01;31m-[00m>hasMatchingPlugNameAndCoupling(O_DirectionalCoupling::outPlugName(this[01;31m-[00m>getPlug2(),_lisp),
coupling.cc:663:    					this[01;31m-[00m>sharedThis<O_RingCoupling>() ) )
coupling.cc:670:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("Bad coupling %s" ) % this[01;31m-[00m>sharedThis<O_RingCoupling>()[01;31m-[00m>description() ));
coupling.cc:676:    this[01;31m-[00m>_Plug1 = p;
coupling.cc:681:    this[01;31m-[00m>_Plug2 = p;
coupling.cc:686:    return O_DirectionalCoupling::outPlugName(this[01;31m-[00m>_Plug1,_lisp);
coupling.cc:690:    return O_DirectionalCoupling::outPlugName(this[01;31m-[00m>_Plug2,_lisp);
coupling.cc:696:    ss << "RingCoupling( "<< this[01;31m-[00m>getName_const();
coupling.cc:700:    ANN(this[01;31m-[00m>_Monomer1);
coupling.cc:701:    if ( this[01;31m-[00m>_Monomer1.lock()[01;31m-[00m>isNil())
coupling.cc:703:	ss << "[01;31m-[00mNULL_Monomer[01;31m-[00m";
coupling.cc:706:	ss << this[01;31m-[00m>getMonomer1_const()[01;31m-[00m>description();
coupling.cc:708:    ss << "[01;31m-[00m>";
coupling.cc:709:    ANN(this[01;31m-[00m>_Monomer2);
coupling.cc:710:    if ( this[01;31m-[00m>_Monomer2.lock()[01;31m-[00m>isNil() )
coupling.cc:712:	ss << "[01;31m-[00mNULL_Monomer[01;31m-[00m";
coupling.cc:715:	ss << this[01;31m-[00m>getMonomer2_const()[01;31m-[00m>description();
coupling.cc:724:{_F(this[01;31m-[00m>lisp());
coupling.cc:730:    if ( this[01;31m-[00m>getHasError() ) return;
coupling.cc:731:    mon1 = this[01;31m-[00m>getMonomer1();
coupling.cc:732:    mon2 = this[01;31m-[00m>getMonomer2();
coupling.cc:733:    if ( mon1[01;31m-[00m>getHasError() ) return;
coupling.cc:734:    if ( mon2[01;31m-[00m>getHasError() ) return;
coupling.cc:735:    ASSERT(mon1[01;31m-[00m>notNil());
coupling.cc:736:    ASSERT(mon2[01;31m-[00m>notNil());
coupling.cc:737:    mon1Plug = mon1[01;31m-[00m>getPlugNamed(this[01;31m-[00m>getPlug1())[01;31m-[00m>as<O_PlugWithMates>();
coupling.cc:738:    mon2Plug = mon2[01;31m-[00m>getPlugNamed(this[01;31m-[00m>getPlug2())[01;31m-[00m>as<O_PlugWithMates>();
coupling.cc:747:    weakInRes = mon1[01;31m-[00m>getTemporaryResidue();
coupling.cc:751:    weakOutRes = mon2[01;31m-[00m>getTemporaryResidue();
coupling.cc:757:    inB0 = inResidue[01;31m-[00m>atomWithName(mon1Plug[01;31m-[00m>getB0());
coupling.cc:758:    outB0 = outResidue[01;31m-[00m>atomWithName(mon2Plug[01;31m-[00m>getB0());
coupling.cc:759:    b = inB0[01;31m-[00m>bondTo(outB0,singleBond);
coupling.cc:760:    if ( mon2Plug[01;31m-[00m>getB1() != "" ) {
coupling.cc:761:	outB1 = outResidue[01;31m-[00m>atomWithName(mon2Plug[01;31m-[00m>getB1());
coupling.cc:762:	if ( mon1Plug[01;31m-[00m>getB1() != "" ) {
coupling.cc:763:	    inB1 = inResidue[01;31m-[00m>atomWithName(mon1Plug[01;31m-[00m>getB1());
coupling.cc:767:	    b = inB1[01;31m-[00m>bondTo(outB1,singleBond);
coupling.cc:773:	    b = inB0[01;31m-[00m>bondTo(outB1,singleBond);
coupling.cc:775:    } else if ( mon1Plug[01;31m-[00m>getB1() != "" ) {
coupling.cc:779:	b = inB1[01;31m-[00m>bondTo(outB0,singleBond);
coupling.cc:796:    class_<O_Coupling>(this[01;31m-[00m>lisp())
coupling.cc:831:    class_<O_DirectionalCoupling>(this[01;31m-[00m>lisp())
coupling.cc:845:	defInPackage(MbbPackage,"DirectionalCoupling_otherSidePlugName", &O_DirectionalCoupling::otherPlugName, this[01;31m-[00m>lisp() );
coupling.cc:846:	defInPackage(MbbPackage,"DirectionalCoupling_isInPlugName", &O_DirectionalCoupling::isInPlugName, this[01;31m-[00m>lisp() );
coupling.cc:847:	defInPackage(MbbPackage,"DirectionalCoupling_inPlugName", &O_DirectionalCoupling::inPlugName, this[01;31m-[00m>lisp() );
coupling.cc:848:	defInPackage(MbbPackage,"DirectionalCoupling_couplingName", &O_DirectionalCoupling::couplingName, this[01;31m-[00m>lisp() );
coupling.cc:849:	defInPackage(MbbPackage,"DirectionalCoupling_outPlugName", &O_DirectionalCoupling::outPlugName, this[01;31m-[00m>lisp() );
coupling.cc:881:    class_<O_RingCoupling>(this[01;31m-[00m>lisp())
deer.cc:12:  limits min, max; n [01;31m-[00m number of points.
deer.cc:35:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
deer.cc:37:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
deer.cc:40:const double hbar = 1.05457e[01;31m-[00m34;
deer.cc:41:const double h = 6.62608e[01;31m-[00m34;
deer.cc:46://	    parameterd = (1.0e[01;31m-[00m7)*(gammae*gammae*hbar)/((r*1.0e[01;31m-[00m10)
deer.cc:47://				*(r*1.0e[01;31m-[00m10)*(r*1.0e[01;31m-[00m10));
deer.cc:55:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
deer.cc:60:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
deer.cc:84:    res = sinx*cos((tp*1.0e[01;31m-[00m9*parameterd)*(3.0*cosx*cosx[01;31m-[00m1.0));
deer.cc:87:    return sin(x)*cos((tp*1.0e[01;31m-[00m9*parameterd)*(3.0*cos(x)*cos(x)[01;31m-[00m1.0));
deer.cc:93:double length=max[01;31m-[00mmin;  // Calculate the interval.
deer.cc:94:double dx=length/(n[01;31m-[00m1); // Calculate increment.
deer.cc:101:    finalAnswer = dx / 48.0 *(48.0*answer [01;31m-[00m31.0 * func(min) +11.0
deer.cc:102:		* func(min + dx) [01;31m-[00m5.0 * func(min +2.0*dx)
deer.cc:103:		+func(min +3.0*dx) +func(max [01;31m-[00m3.0*dx) [01;31m-[00m5.0
deer.cc:104:		* func(max [01;31m-[00m2.0*dx) +11.0 * func(max [01;31m-[00m dx) [01;31m-[00m31.0 * func(min));
deer.cc:129:{ _F(this[01;31m-[00m>lisp());
deer.cc:134:    result = nv[01;31m-[00m>lisp()[01;31m-[00m>create<O_NumericalFunction>();
deer.cc:135:    result[01;31m-[00m>setXAxisName("r");
deer.cc:136:    result[01;31m-[00m>setYAxisName("p(r)");
deer.cc:137:    result[01;31m-[00m>setXStart(tp);
deer.cc:138:    result[01;31m-[00m>setXInc(aStepSize);
deer.cc:145://    cout<<"Welcome to the program for 4[01;31m-[00mpulses DEER simulation ! "<<endl<<endl;
deer.cc:189:	for ( int ip=0; ip < nf[01;31m-[00m>getNumberOfValues(); ip++ ) {
deer.cc:190:	    r = nf[01;31m-[00m>getXValueAtIndex(ip);
deer.cc:192:	    pq = nf[01;31m-[00m>getYValueAtIndex(ip);
deer.cc:194:	    parameterd = (1.0e[01;31m-[00m7)*(gammae*gammae*hbar)/((r*1.0e[01;31m-[00m10)
deer.cc:195:				*(r*1.0e[01;31m-[00m10)*(r*1.0e[01;31m-[00m10));
deer.cc:197:	    parameterd = (1.0e[01;31m-[00m7)*(gammae*gammae*hbar)/((r*1.0e[01;31m-[00m10)
deer.cc:198:				*(r*1.0e[01;31m-[00m10)*(r*1.0e[01;31m-[00m10));
deer.cc:216://	result[01;31m-[00m>addValues(tp,average);
deer.cc:217:	result[01;31m-[00m>appendValue(average);
deer.cc:218://   	ofs << tp*1.0e[01;31m-[00m3 <<"  " << average << "  "<< "  "<<endl;//time in microseconds
deer.cc:227://   WinExec ( "Fft.exe [01;31m-[00mm time.txt freq.txt", SW_SHOWNORMAL );
elements.cc:280:	if ( ai[01;31m-[00m>_Valid )
elements.cc:282:	    elementFromAtomicSymbol[ai[01;31m-[00m>_AtomicSymbol] = ai[01;31m-[00m>_ElementEnum;
elements.cc:283:	    if ( ai[01;31m-[00m>_Valid && ai[01;31m-[00m>_RealElement )
elements.cc:285:		if ( ai[01;31m-[00m>_AtomicSymbol.size() == 2 )
elements.cc:287:		    twoCharacterElementNames.insert(ai[01;31m-[00m>_AtomicSymbol);
elements.cc:288:		} else if ( ai[01;31m-[00m>_AtomicSymbol.size() == 1 )
elements.cc:290:		    oneCharacterElementNames.insert(ai[01;31m-[00m>_AtomicSymbol);
elements.cc:301:    RPSymbolToEnumConverter elementConverter = lisp[01;31m-[00m>create<O_SymbolToEnumConverter>("Element");
elements.cc:304:	if ( ai[01;31m-[00m>_Valid )
elements.cc:306:	    RPSymbol sym = lisp[01;31m-[00m>internKeyword(ai[01;31m-[00m>_AtomicSymbol);
elements.cc:307:	    elementConverter[01;31m-[00m>addSymbolEnumPair(sym,ai[01;31m-[00m>_AtomicSymbol,ai[01;31m-[00m>_ElementEnum);
elements.cc:310:    lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>extend(lisp[01;31m-[00m>symbol(_sym_MbbPackage_elementToSymbolConverter),elementConverter);
elements.cc:315:    RPSymbolToEnumConverter hybridizationConverter = lisp[01;31m-[00m>create<O_SymbolToEnumConverter>("Hybridization");
elements.cc:318:	    RPSymbol sym = lisp[01;31m-[00m>internKeyword(hi[01;31m-[00m>_HybridizationSymbol);
elements.cc:319:	    hybridizationConverter[01;31m-[00m>addSymbolEnumPair(sym,hi[01;31m-[00m>_HybridizationSymbol,hi[01;31m-[00m>_HybridizationEnum);
elements.cc:321:    lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>extend(lisp[01;31m-[00m>symbol(_sym_MbbPackage_hybridizationToSymbolConverter),hybridizationConverter);
elements.cc:333:    RPSymbolToEnumConverter elementConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_elementToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
elements.cc:334:    return elementConverter[01;31m-[00m>symbolForEnum<Element>(element);
elements.cc:342:    RPSymbolToEnumConverter hybridizationConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_hybridizationToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
elements.cc:343:    return hybridizationConverter[01;31m-[00m>symbolForEnum<Hybridization>(hybridization);
elements.cc:357:{_F(sym[01;31m-[00m>lisp());
elements.cc:358:    RPLisp lisp = sym[01;31m-[00m>lisp();
elements.cc:359:    RPSymbolToEnumConverter elementConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_elementToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
elements.cc:360:    return elementConverter[01;31m-[00m>enumForSymbol<Element>(sym);
elements.cc:364:{_F(sym[01;31m-[00m>lisp());
elements.cc:365:    RPLisp lisp = sym[01;31m-[00m>lisp();
elements.cc:366:    RPSymbolToEnumConverter hybridizationConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_hybridizationToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
elements.cc:367:    return hybridizationConverter[01;31m-[00m>enumForSymbol<Hybridization>(sym);
elements.cc:373:    RPSymbolToEnumConverter hybridizationConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_hybridizationToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
elements.cc:374:    return hybridizationConverter[01;31m-[00m>enumForString<Hybridization>(sym);
elements.cc:380:    RPSymbolToEnumConverter hybridizationConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_hybridizationToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
elements.cc:381:    return hybridizationConverter[01;31m-[00m>symbolStringForEnum<Hybridization>(h);
elements.cc:386:    RPSymbolToEnumConverter elementConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_elementToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
elements.cc:387:    return elementConverter[01;31m-[00m>symbolStringForEnum<Element>(h);
elements.cc:418:    RPSymbolToEnumConverter elementConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_elementToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
elements.cc:419:    Element element = elementConverter[01;31m-[00m>enumForSymbol<Element>(sym);
energyAnchorRestraint.cc:25:    this[01;31m-[00m>_Atom1.reset();
energyAnchorRestraint.cc:35:    node[01;31m-[00m>attribute("ka",this[01;31m-[00m>term.ka);
energyAnchorRestraint.cc:36:    node[01;31m-[00m>attribute("xa",this[01;31m-[00m>term.xa);
energyAnchorRestraint.cc:37:    node[01;31m-[00m>attribute("ya",this[01;31m-[00m>term.ya);
energyAnchorRestraint.cc:38:    node[01;31m-[00m>attribute("za",this[01;31m-[00m>term.za);
energyAnchorRestraint.cc:39:    node[01;31m-[00m>attribute("I1",this[01;31m-[00m>term.I1);
energyAnchorRestraint.cc:40:    node[01;31m-[00m>archiveObject("a1",this[01;31m-[00m>_Atom1);
energyAnchorRestraint.cc:42:    node[01;31m-[00m>attributeIfDefined("calcForce",this[01;31m-[00m>_calcForce,this[01;31m-[00m>_calcForce);
energyAnchorRestraint.cc:43:    node[01;31m-[00m>attributeIfDefined("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian,this[01;31m-[00m>_calcDiagonalHessian);
energyAnchorRestraint.cc:44:    node[01;31m-[00m>attributeIfDefined("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian,this[01;31m-[00m>_calcOffDiagonalHessian);
energyAnchorRestraint.cc:54:    node[01;31m-[00m>addAttributeString("atomName",this[01;31m-[00m>_Atom1[01;31m-[00m>getName());
energyAnchorRestraint.cc:55:    node[01;31m-[00m>addAttributeInt("I1",this[01;31m-[00m>term.I1);
energyAnchorRestraint.cc:56:    node[01;31m-[00m>addAttributeDoubleScientific("ka",this[01;31m-[00m>term.ka);
energyAnchorRestraint.cc:57:    node[01;31m-[00m>addAttributeDoubleScientific("xa",this[01;31m-[00m>term.xa);
energyAnchorRestraint.cc:58:    node[01;31m-[00m>addAttributeDoubleScientific("ya",this[01;31m-[00m>term.ya);
energyAnchorRestraint.cc:59:    node[01;31m-[00m>addAttributeDoubleScientific("za",this[01;31m-[00m>term.za);
energyAnchorRestraint.cc:62:    xml[01;31m-[00m>addAttributeBool("calcForce",this[01;31m-[00m>_calcForce );
energyAnchorRestraint.cc:63:    xml[01;31m-[00m>addAttributeBool("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian );
energyAnchorRestraint.cc:64:    xml[01;31m-[00m>addAttributeBool("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian );
energyAnchorRestraint.cc:66:    node[01;31m-[00m>addChild(xml);
energyAnchorRestraint.cc:74:    this[01;31m-[00m>term.ka = xml[01;31m-[00m>getAttributeDouble("ka");
energyAnchorRestraint.cc:75:    this[01;31m-[00m>term.I1 = xml[01;31m-[00m>getAttributeInt("I1");
energyAnchorRestraint.cc:76:    this[01;31m-[00m>term.xa = xml[01;31m-[00m>getAttributeDouble("xa");
energyAnchorRestraint.cc:77:    this[01;31m-[00m>term.ya = xml[01;31m-[00m>getAttributeDouble("ya");
energyAnchorRestraint.cc:78:    this[01;31m-[00m>term.za = xml[01;31m-[00m>getAttributeDouble("za");
energyAnchorRestraint.cc:79:    this[01;31m-[00m>_Atom1 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I1)[01;31m-[00m>_Atom;
energyAnchorRestraint.cc:116:    this[01;31m-[00m>_Terms.push_back(r);
energyAnchorRestraint.cc:147:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyAnchorRestraint.cc:150:#define	ANCHOR_RESTRAINT_SET_PARAMETER(x)	{x=cri[01;31m-[00m>term.x;}
energyAnchorRestraint.cc:152:#define	ANCHOR_RESTRAINT_SET_POSITION(x,ii,of) {x=nvPosition[01;31m-[00m>element(ii+of);}
energyAnchorRestraint.cc:161:	  m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyAnchorRestraint.cc:165:	  m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyAnchorRestraint.cc:171:    if ( this[01;31m-[00m>isEnabled() ) {
energyAnchorRestraint.cc:176:	for ( vector<EnergyAnchorRestraint>::iterator cri=this[01;31m-[00m>_Terms.begin();
energyAnchorRestraint.cc:177:		    cri!=this[01;31m-[00m>_Terms.end(); cri++ ) {
energyAnchorRestraint.cc:201:_F(this[01;31m-[00m>lisp());
energyAnchorRestraint.cc:208:bool	hasForce = force[01;31m-[00m>notNil();
energyAnchorRestraint.cc:209:bool	hasHessian = hessian[01;31m-[00m>notNil();
energyAnchorRestraint.cc:210:bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
energyAnchorRestraint.cc:216:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyAnchorRestraint.cc:222:#define	ANCHOR_RESTRAINT_SET_PARAMETER(x)	{x = cri[01;31m-[00m>term.x;}
energyAnchorRestraint.cc:224:#define	ANCHOR_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>element(ii+of);}
energyAnchorRestraint.cc:228:#define	ANCHOR_RESTRAINT_ENERGY_ACCUMULATE(e) this[01;31m-[00m>_TotalEnergy += (e);
energyAnchorRestraint.cc:237:	if ( this[01;31m-[00m>isEnabled() ) {
energyAnchorRestraint.cc:242:	    for ( i=0,cri=this[01;31m-[00m>_Terms.begin();
energyAnchorRestraint.cc:243:			cri!=this[01;31m-[00m>_Terms.end(); cri++,i++ ) {
energyAnchorRestraint.cc:245:		    if ( this[01;31m-[00m>_Debug_NumberOfAnchorRestraintTermsToCalculate > 0 ) {
energyAnchorRestraint.cc:246:			if ( i>= this[01;31m-[00m>_Debug_NumberOfAnchorRestraintTermsToCalculate ) {
energyAnchorRestraint.cc:257:		    cri[01;31m-[00m>_calcForce = calcForce;
energyAnchorRestraint.cc:258:		    cri[01;31m-[00m>_calcDiagonalHessian = calcDiagonalHessian;
energyAnchorRestraint.cc:259:		    cri [01;31m-[00m>_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyAnchorRestraint.cc:262:		    #define	EVAL_SET(var,val)	{ cri[01;31m-[00m>eval.var=val;};
energyAnchorRestraint.cc:274:		    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyAnchorRestraint.cc:275:		    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyAnchorRestraint.cc:276:		    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyAnchorRestraint.cc:300://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyAnchorRestraint.cc:306:#define	ANCHOR_RESTRAINT_SET_PARAMETER(x)	{x = cri[01;31m-[00m>term.x;}
energyAnchorRestraint.cc:308:#define	ANCHOR_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>element(ii+of);}
energyAnchorRestraint.cc:321:	if ( this[01;31m-[00m>isEnabled() ) {
energyAnchorRestraint.cc:327:	    for ( i=0,cri=this[01;31m-[00m>_Terms.begin();
energyAnchorRestraint.cc:328:			cri!=this[01;31m-[00m>_Terms.end(); cri++,i++ ) {
energyAnchorRestraint.cc:361:    this[01;31m-[00m>_BeyondThresholdTerms.clear();
energyAnchorRestraint.cc:366://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyAnchorRestraint.cc:372:#define	ANCHOR_RESTRAINT_SET_PARAMETER(x)	{x = cri[01;31m-[00m>term.x;}
energyAnchorRestraint.cc:374:#define	ANCHOR_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>element(ii+of);}
energyAnchorRestraint.cc:387:	if ( this[01;31m-[00m>isEnabled() ) {
energyAnchorRestraint.cc:393:	    for ( i=0,cri=this[01;31m-[00m>_Terms.begin();
energyAnchorRestraint.cc:394:			cri!=this[01;31m-[00m>_Terms.end(); cri++,i++ ) {
energyAnchorRestraint.cc:398:		if ( AnchorDeviation>this[01;31m-[00m>_ErrorThreshold ) {
energyAnchorRestraint.cc:402://		    info<< a1[01;31m-[00m>getAbsoluteIdPath() << " ";
energyAnchorRestraint.cc:404:		    info << a1[01;31m-[00m>getName() << " ";
energyAnchorRestraint.cc:406:		    this[01;31m-[00m>_BeyondThresholdTerms.push_back(*cri);
energyAnchorRestraint.cc:423:    class_<O_EnergyAnchorRestraint>(e[01;31m-[00m>lisp())
energyAnchorRestraint.cc:434:    this[01;31m-[00m>Base::initialize();
energyAnchorRestraint.cc:435:    this[01;31m-[00m>setErrorThreshold(0.2);
energyAnchorRestraint.cc:441:    this[01;31m-[00m>Base::archiveBase(node);
energyAngle.cc:28:    this[01;31m-[00m>_Atom1.reset();
energyAngle.cc:29:    this[01;31m-[00m>_Atom2.reset();
energyAngle.cc:30:    this[01;31m-[00m>_Atom3.reset();
energyAngle.cc:41://    node[01;31m-[00m>archiveObject("_Term",this[01;31m-[00m>_Term);
energyAngle.cc:42://    node[01;31m-[00m>attribute("_Type1",this[01;31m-[00m>_Type1);
energyAngle.cc:43://    node[01;31m-[00m>attribute("_Type2",this[01;31m-[00m>_Type2);
energyAngle.cc:44://    node[01;31m-[00m>attribute("_Type3",this[01;31m-[00m>_Type3);
energyAngle.cc:45://    node[01;31m-[00m>attribute("_K3",this[01;31m-[00m>_K3);
energyAngle.cc:46://    node[01;31m-[00m>attribute("_K4",this[01;31m-[00m>_K4);
energyAngle.cc:47://    node[01;31m-[00m>attribute("_Ub_k",this[01;31m-[00m>_Ub_k);
energyAngle.cc:48://    node[01;31m-[00m>attribute("_Ub_len",this[01;31m-[00m>_Ub_len);
energyAngle.cc:49:    node[01;31m-[00m>attribute("kt",this[01;31m-[00m>term.kt);
energyAngle.cc:50:    node[01;31m-[00m>attribute("t0",this[01;31m-[00m>term.t0);
energyAngle.cc:51:    node[01;31m-[00m>attribute("I1",this[01;31m-[00m>term.I1);
energyAngle.cc:52:    node[01;31m-[00m>attribute("I2",this[01;31m-[00m>term.I2);
energyAngle.cc:53:    node[01;31m-[00m>attribute("I3",this[01;31m-[00m>term.I3);
energyAngle.cc:54:    node[01;31m-[00m>archiveObject("a1",this[01;31m-[00m>_Atom1);
energyAngle.cc:55:    node[01;31m-[00m>archiveObject("a2",this[01;31m-[00m>_Atom2);
energyAngle.cc:56:    node[01;31m-[00m>archiveObject("a3",this[01;31m-[00m>_Atom3);
energyAngle.cc:58:    node[01;31m-[00m>attributeIfDefined("calcForce",this[01;31m-[00m>_calcForce,this[01;31m-[00m>_calcForce);
energyAngle.cc:59:    node[01;31m-[00m>attributeIfDefined("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian,this[01;31m-[00m>_calcDiagonalHessian);
energyAngle.cc:60:    node[01;31m-[00m>attributeIfDefined("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian,this[01;31m-[00m>_calcOffDiagonalHessian);
energyAngle.cc:68:{_F(term[01;31m-[00m>lisp());
energyAngle.cc:70://    this[01;31m-[00m>_Term = term;
energyAngle.cc:71://    this[01;31m-[00m>_Type1 = term[01;31m-[00m>_Type1;
energyAngle.cc:72://    this[01;31m-[00m>_Type2 = term[01;31m-[00m>_Type2;
energyAngle.cc:73://    this[01;31m-[00m>_Type3 = term[01;31m-[00m>_Type3;
energyAngle.cc:74:    this[01;31m-[00m>term.t0 = term[01;31m-[00m>_AngRad;
energyAngle.cc:75:    this[01;31m-[00m>term.kt = term[01;31m-[00m>_K2*scale;
energyAngle.cc:76://    this[01;31m-[00m>_K3 = term[01;31m-[00m>_K3;
energyAngle.cc:77://    this[01;31m-[00m>_K4 = term[01;31m-[00m>_K4;
energyAngle.cc:78://    this[01;31m-[00m>_Ub_k = term[01;31m-[00m>_Ub_k;
energyAngle.cc:79://    this[01;31m-[00m>_Ub_len = term[01;31m-[00m>_Ub_len;
energyAngle.cc:80:    this[01;31m-[00m>_Atom1 = ea1[01;31m-[00m>_Atom;
energyAngle.cc:81:    this[01;31m-[00m>_Atom2 = ea2[01;31m-[00m>_Atom;
energyAngle.cc:82:    this[01;31m-[00m>_Atom3 = ea3[01;31m-[00m>_Atom;
energyAngle.cc:83:    this[01;31m-[00m>term.I1 = ea1[01;31m-[00m>_CoordinateIndex;
energyAngle.cc:84:    this[01;31m-[00m>term.I2 = ea2[01;31m-[00m>_CoordinateIndex;
energyAngle.cc:85:    this[01;31m-[00m>term.I3 = ea3[01;31m-[00m>_CoordinateIndex;
energyAngle.cc:93:    this[01;31m-[00m>_Type1 = ea1[01;31m-[00m>_Atom[01;31m-[00m>getTypeString();
energyAngle.cc:94:    this[01;31m-[00m>_Type2 = ea2[01;31m-[00m>_Atom[01;31m-[00m>getTypeString();
energyAngle.cc:95:    this[01;31m-[00m>_Type3 = ea3[01;31m-[00m>_Atom[01;31m-[00m>getTypeString();
energyAngle.cc:103:    pos1 = this[01;31m-[00m>_Atom1[01;31m-[00m>getPosition();
energyAngle.cc:104:    pos2 = this[01;31m-[00m>_Atom2[01;31m-[00m>getPosition();
energyAngle.cc:105:    pos3 = this[01;31m-[00m>_Atom3[01;31m-[00m>getPosition();
energyAngle.cc:106:    angle = mbb::calculateAngle( pos1, pos2, pos3,this[01;31m-[00m>lisp() );
energyAngle.cc:116:    node[01;31m-[00m>addAttributeString("atom1Name",this[01;31m-[00m>_Atom1[01;31m-[00m>getName());
energyAngle.cc:117:    node[01;31m-[00m>addAttributeString("atom2Name",this[01;31m-[00m>_Atom2[01;31m-[00m>getName());
energyAngle.cc:118:    node[01;31m-[00m>addAttributeString("atom3Name",this[01;31m-[00m>_Atom3[01;31m-[00m>getName());
energyAngle.cc:119://    node[01;31m-[00m>addAttributeString("atom1Type",this[01;31m-[00m>_Type1 );
energyAngle.cc:120://    node[01;31m-[00m>addAttributeString("atom2Type",this[01;31m-[00m>_Type2 );
energyAngle.cc:121://    node[01;31m-[00m>addAttributeString("atom3Type",this[01;31m-[00m>_Type3 );
energyAngle.cc:122:    node[01;31m-[00m>addAttributeInt("I1",this[01;31m-[00m>term.I1);
energyAngle.cc:123:    node[01;31m-[00m>addAttributeInt("I2",this[01;31m-[00m>term.I2);
energyAngle.cc:124:    node[01;31m-[00m>addAttributeInt("I3",this[01;31m-[00m>term.I3);
energyAngle.cc:125:    node[01;31m-[00m>addAttributeDoubleScientific("kt",this[01;31m-[00m>term.kt);
energyAngle.cc:126:    node[01;31m-[00m>addAttributeDoubleScientific("t0",this[01;31m-[00m>term.t0);
energyAngle.cc:129:    xml[01;31m-[00m>addAttributeBool("calcForce",this[01;31m-[00m>_calcForce );
energyAngle.cc:130:    xml[01;31m-[00m>addAttributeBool("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian );
energyAngle.cc:131:    xml[01;31m-[00m>addAttributeBool("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian );
energyAngle.cc:133:    node[01;31m-[00m>addChild(xml);
energyAngle.cc:141:    int i1 = xml[01;31m-[00m>getAttributeInt("idx1");
energyAngle.cc:142:    int i2 = xml[01;31m-[00m>getAttributeInt("idx2");
energyAngle.cc:143:    int i3 = xml[01;31m-[00m>getAttributeInt("idx3");
energyAngle.cc:144:    this[01;31m-[00m>_Atom1 = atomTable[01;31m-[00m>findEnergyAtom(i1)[01;31m-[00m>_Atom;
energyAngle.cc:145:    this[01;31m-[00m>_Atom2 = atomTable[01;31m-[00m>findEnergyAtom(i2)[01;31m-[00m>_Atom;
energyAngle.cc:146:    this[01;31m-[00m>_Atom3 = atomTable[01;31m-[00m>findEnergyAtom(i3)[01;31m-[00m>_Atom;
energyAngle.cc:147:    this[01;31m-[00m>term.kt = xml[01;31m-[00m>getAttributeDouble("kt");
energyAngle.cc:148:    this[01;31m-[00m>term.t0 = xml[01;31m-[00m>getAttributeDouble("t0");
energyAngle.cc:149:    this[01;31m-[00m>term.I1 = xml[01;31m-[00m>getAttributeInt("I1");
energyAngle.cc:150:    this[01;31m-[00m>term.I2 = xml[01;31m-[00m>getAttributeInt("I2");
energyAngle.cc:151:    this[01;31m-[00m>term.I3 = xml[01;31m-[00m>getAttributeInt("I3");
energyAngle.cc:203:    this[01;31m-[00m>_Terms.push_back(term);
energyAngle.cc:219:    for (eai=this[01;31m-[00m>_Terms.begin();eai!=this[01;31m-[00m>_Terms.end();eai++)
energyAngle.cc:221:	as1 = atomLabel(eai[01;31m-[00m>_Atom1);
energyAngle.cc:222:	as2 = atomLabel(eai[01;31m-[00m>_Atom2);
energyAngle.cc:223:	as3 = atomLabel(eai[01;31m-[00m>_Atom3);
energyAngle.cc:233:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("TERM 2ANG %[01;31m-[00m9s [01;31m-[00m %[01;31m-[00m9s [01;31m-[00m %[01;31m-[00m9s %8.2lf %8.2lf")
energyAngle.cc:237:			    % eai[01;31m-[00m>term.kt
energyAngle.cc:238:			    % (eai[01;31m-[00m>term.t0/0.0174533) );
energyAngle.cc:258:#define	ANGLE_SET_PARAMETER(x)	{x=ai[01;31m-[00m>term.x;}
energyAngle.cc:260:#define	ANGLE_SET_POSITION(x,ii,of)	{x=nvPosition[01;31m-[00m>element(ii+of);}
energyAngle.cc:267:	m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyAngle.cc:271:	m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyAngle.cc:277:    if ( this[01;31m-[00m>isEnabled() ) {
energyAngle.cc:284:	for ( vector<EnergyAngle>::iterator ai=this[01;31m-[00m>_Terms.begin();
energyAngle.cc:285:		    ai!=this[01;31m-[00m>_Terms.end(); ai++ ) {
energyAngle.cc:305:{_F(this[01;31m-[00m>lisp());
energyAngle.cc:306:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyAngle.cc:309:	LOG_ENERGY(BF("%s {\n")% this[01;31m-[00m>className());
energyAngle.cc:317:bool	hasForce = force[01;31m-[00m>notNil();
energyAngle.cc:318:bool	hasHessian = hessian[01;31m-[00m>notNil();
energyAngle.cc:319:bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
energyAngle.cc:329:#define ANGLE_SET_PARAMETER(x)	{x=ai[01;31m-[00m>term.x;}
energyAngle.cc:331:#define ANGLE_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyAngle.cc:333:#define ANGLE_ENERGY_ACCUMULATE(e) this[01;31m-[00m>_TotalEnergy += (e);
energyAngle.cc:343:    if ( this[01;31m-[00m>isEnabled() ) 
energyAngle.cc:353:	for ( i=0,ai=this[01;31m-[00m>_Terms.begin();
energyAngle.cc:354:		    ai!=this[01;31m-[00m>_Terms.end(); ai++,i++ ) {
energyAngle.cc:356:		if ( this[01;31m-[00m>_Debug_NumberOfTermsToCalculate > 0 ) {
energyAngle.cc:357:		    if ( i>= this[01;31m-[00m>_Debug_NumberOfTermsToCalculate ) {
energyAngle.cc:368:		prob._Atom1 = ai[01;31m-[00m>_Atom1;
energyAngle.cc:369:		prob._Atom2 = ai[01;31m-[00m>_Atom2;
energyAngle.cc:370:		prob._Atom3 = ai[01;31m-[00m>_Atom3;
energyAngle.cc:374:		ai[01;31m-[00m>_calcForce = calcForce;
energyAngle.cc:375:		ai[01;31m-[00m>_calcDiagonalHessian = calcDiagonalHessian;
energyAngle.cc:376:		ai[01;31m-[00m>_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyAngle.cc:378:		#define	EVAL_SET(var,val)	{ ai[01;31m-[00m>eval.var=val;};
energyAngle.cc:381:	    if ( this[01;31m-[00m>_DebugEnergy ) 
energyAngle.cc:413:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyAngle.cc:414:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyAngle.cc:415:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyAngle.cc:416:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyAngle.cc:417:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyAngle.cc:418:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyAngle.cc:419:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx3>10000.0);
energyAngle.cc:420:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy3>10000.0);
energyAngle.cc:421:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz3>10000.0);
energyAngle.cc:425:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyAngle.cc:427:	LOG_ENERGY(BF("%s }\n")% this[01;31m-[00m>className());
energyAngle.cc:454:#define ANGLE_SET_PARAMETER(x)	{x=ai[01;31m-[00m>term.x;}
energyAngle.cc:456:#define ANGLE_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyAngle.cc:466:	if ( this[01;31m-[00m>isEnabled() ) {
energyAngle.cc:475:	    for ( i=0,ai=this[01;31m-[00m>_Terms.begin();
energyAngle.cc:476:			ai!=this[01;31m-[00m>_Terms.end(); ai++,i++ ) {
energyAngle.cc:477:		LOG(BF("ai[01;31m-[00m>term.kt = %le") % ai[01;31m-[00m>term.kt  ); // vp0(( "ai[01;31m-[00m>term.kt = %le", ai[01;31m-[00m>term.kt ));
energyAngle.cc:478:		LOG(BF("ai[01;31m-[00m>term.t0 = %le") % ai[01;31m-[00m>term.t0  ); // vp0(( "ai[01;31m-[00m>term.t0 = %le", ai[01;31m-[00m>term.t0 ));
energyAngle.cc:480:		LOG(BF("ai[01;31m-[00m>x1 = %le") % pos[01;31m-[00m>element(ai[01;31m-[00m>term.I1 ) ); // vp0(( "ai[01;31m-[00m>x1 = %le", pos[01;31m-[00m>element(ai[01;31m-[00m>term.I1 )));
energyAngle.cc:481:		LOG(BF("ai[01;31m-[00m>y1 = %le") % pos[01;31m-[00m>element(ai[01;31m-[00m>term.I1+1 ) ); // vp0(( "ai[01;31m-[00m>y1 = %le", pos[01;31m-[00m>element(ai[01;31m-[00m>term.I1+1 )));
energyAngle.cc:482:		LOG(BF("ai[01;31m-[00m>z1 = %le") % pos[01;31m-[00m>element(ai[01;31m-[00m>term.I1+2 ) ); // vp0(( "ai[01;31m-[00m>z1 = %le", pos[01;31m-[00m>element(ai[01;31m-[00m>term.I1+2 )));
energyAngle.cc:483:		LOG(BF("ai[01;31m-[00m>x2 = %le") % pos[01;31m-[00m>element(ai[01;31m-[00m>term.I2 ) ); // vp0(( "ai[01;31m-[00m>x2 = %le", pos[01;31m-[00m>element(ai[01;31m-[00m>term.I2 )));
energyAngle.cc:484:		LOG(BF("ai[01;31m-[00m>y2 = %le") % pos[01;31m-[00m>element(ai[01;31m-[00m>term.I2+1 ) ); // vp0(( "ai[01;31m-[00m>y2 = %le", pos[01;31m-[00m>element(ai[01;31m-[00m>term.I2+1 )));
energyAngle.cc:485:		LOG(BF("ai[01;31m-[00m>z2 = %le") % pos[01;31m-[00m>element(ai[01;31m-[00m>term.I2+2 ) ); // vp0(( "ai[01;31m-[00m>z2 = %le", pos[01;31m-[00m>element(ai[01;31m-[00m>term.I2+2 )));
energyAngle.cc:486:		LOG(BF("ai[01;31m-[00m>x3 = %le") % pos[01;31m-[00m>element(ai[01;31m-[00m>term.I3 ) ); // vp0(( "ai[01;31m-[00m>x3 = %le", pos[01;31m-[00m>element(ai[01;31m-[00m>term.I3 )));
energyAngle.cc:487:		LOG(BF("ai[01;31m-[00m>y3 = %le") % pos[01;31m-[00m>element(ai[01;31m-[00m>term.I3+1 ) ); // vp0(( "ai[01;31m-[00m>y3 = %le", pos[01;31m-[00m>element(ai[01;31m-[00m>term.I3+1 )));
energyAngle.cc:488:		LOG(BF("ai[01;31m-[00m>z3 = %le") % pos[01;31m-[00m>element(ai[01;31m-[00m>term.I3+2 ) ); // vp0(( "ai[01;31m-[00m>z3 = %le", pos[01;31m-[00m>element(ai[01;31m-[00m>term.I3+2 )));
energyAngle.cc:518:    this[01;31m-[00m>_BeyondThresholdTerms.clear();
energyAngle.cc:528:#define ANGLE_SET_PARAMETER(x)	{x=ai[01;31m-[00m>term.x;}
energyAngle.cc:530:#define ANGLE_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyAngle.cc:540:	if ( this[01;31m-[00m>isEnabled() ) {
energyAngle.cc:550:	    for ( i=0,ai=this[01;31m-[00m>_Terms.begin();
energyAngle.cc:551:			ai!=this[01;31m-[00m>_Terms.end(); ai++,i++ ) {
energyAngle.cc:553:		if ( fabs(AngleDeviation)/t0 > this[01;31m-[00m>_ErrorThreshold ) {
energyAngle.cc:559://		    info<< a1[01;31m-[00m>getAbsoluteIdPath() << " ";
energyAngle.cc:560://		    info<< a2[01;31m-[00m>getAbsoluteIdPath() << " ";
energyAngle.cc:561://		    info<< a3[01;31m-[00m>getAbsoluteIdPath() << " ";
energyAngle.cc:563:		    info<<"threshold " << this[01;31m-[00m>_ErrorThreshold << " Atoms(";
energyAngle.cc:564:		    info << a1[01;31m-[00m>getName() << " ";
energyAngle.cc:565:		    info << a2[01;31m-[00m>getName() << " ";
energyAngle.cc:566:		    info << a3[01;31m-[00m>getName() << ") ";
energyAngle.cc:568:		    this[01;31m-[00m>_BeyondThresholdTerms.push_back(*ai);
energyAngle.cc:585:    class_<O_EnergyAngle>(e[01;31m-[00m>lisp())
energyAngle.cc:597:    this[01;31m-[00m>Base::initialize();
energyAngle.cc:598:    this[01;31m-[00m>setErrorThreshold(0.2);
energyAngle.cc:603:    this[01;31m-[00m>Base::archiveBase(node);
energyAtomTable.cc:27:    this[01;31m-[00m>_Atom = a1;
energyAtomTable.cc:28:    this[01;31m-[00m>_CoordinateIndex = coordinateIndex;
energyAtomTable.cc:29:    this[01;31m-[00m>_TypeIndex = forceField[01;31m-[00m>getNonbondDb()[01;31m-[00m>findTypeIndex(a1[01;31m-[00m>getTypeString());
energyAtomTable.cc:30:    this[01;31m-[00m>_Charge = a1[01;31m-[00m>getCharge();
energyAtomTable.cc:35:    node[01;31m-[00m>archiveObject("atom",this[01;31m-[00m>_Atom);
energyAtomTable.cc:36:    node[01;31m-[00m>attribute("coordIdx", this[01;31m-[00m>_CoordinateIndex);
energyAtomTable.cc:45:    path = this[01;31m-[00m>_Atom[01;31m-[00m>getIdPath(parent);
energyAtomTable.cc:46:    node[01;31m-[00m>addAttributeString("storagePath",path);
energyAtomTable.cc:47:    node[01;31m-[00m>addAttributeString("atomName",this[01;31m-[00m>_Atom[01;31m-[00m>getName());
energyAtomTable.cc:48:    node[01;31m-[00m>addAttributeInt("coordinateIndex",this[01;31m-[00m>_CoordinateIndex);
energyAtomTable.cc:49:    node[01;31m-[00m>addAttributeDoubleScientific("x",this[01;31m-[00m>_Atom[01;31m-[00m>getPosition().getX());
energyAtomTable.cc:50:    node[01;31m-[00m>addAttributeDoubleScientific("y",this[01;31m-[00m>_Atom[01;31m-[00m>getPosition().getY());
energyAtomTable.cc:51:    node[01;31m-[00m>addAttributeDoubleScientific("z",this[01;31m-[00m>_Atom[01;31m-[00m>getPosition().getZ());
energyAtomTable.cc:52:    node[01;31m-[00m>addAttributeDoubleScientific("fx",this[01;31m-[00m>_Atom[01;31m-[00m>getForce().getX());
energyAtomTable.cc:53:    node[01;31m-[00m>addAttributeDoubleScientific("fy",this[01;31m-[00m>_Atom[01;31m-[00m>getForce().getY());
energyAtomTable.cc:54:    node[01;31m-[00m>addAttributeDoubleScientific("fz",this[01;31m-[00m>_Atom[01;31m-[00m>getForce().getZ());
energyAtomTable.cc:61:{_F(parent[01;31m-[00m>lisp());
energyAtomTable.cc:65:    LOG(BF("parsing xml with localName=%s") % xml[01;31m-[00m>getLocalName().c_str() ); // vp0(( "parsing xml with localName=%s",xml[01;31m-[00m>getLocalName().c_str()));
energyAtomTable.cc:66:    path = xml[01;31m-[00m>getAttributeString("storagePath");
energyAtomTable.cc:67:    this[01;31m-[00m>_Atom = downcast<mbb::O_Atom>(parent[01;31m-[00m>getContentForIdPath(path));
energyAtomTable.cc:68:    ASSERT_NOT_NULL(this[01;31m-[00m>_Atom);
energyAtomTable.cc:69:    this[01;31m-[00m>_CoordinateIndex = xml[01;31m-[00m>getAttributeInt("coordinateIndex");
energyAtomTable.cc:70:    x = xml[01;31m-[00m>getAttributeDouble("x");
energyAtomTable.cc:71:    y = xml[01;31m-[00m>getAttributeDouble("y");
energyAtomTable.cc:72:    z = xml[01;31m-[00m>getAttributeDouble("z");
energyAtomTable.cc:74:    this[01;31m-[00m>_Atom[01;31m-[00m>setPosition(v);
energyAtomTable.cc:75:    fx = xml[01;31m-[00m>getAttributeDouble("fx");
energyAtomTable.cc:76:    fy = xml[01;31m-[00m>getAttributeDouble("fy");
energyAtomTable.cc:77:    fz = xml[01;31m-[00m>getAttributeDouble("fz");
energyAtomTable.cc:79:    this[01;31m-[00m>_Atom[01;31m-[00m>setForce(v);
energyAtomTable.cc:87:    res = this[01;31m-[00m>_Atom[01;31m-[00m>getResidueContainedBy()[01;31m-[00m>as<O_Residue>();
energyAtomTable.cc:89:    ss << ":"<<res[01;31m-[00m>getId()<<"@"<<this[01;31m-[00m>_Atom[01;31m-[00m>getName();
energyAtomTable.cc:97:{_F(this[01;31m-[00m>lisp());
energyAtomTable.cc:98:    if ( node[01;31m-[00m>loading() )
energyAtomTable.cc:100:        this[01;31m-[00m>_Atoms.clear();
energyAtomTable.cc:103:        for (vi=node[01;31m-[00m>begin_Children(); vi!=node[01;31m-[00m>end_Children(); vi++ )
energyAtomTable.cc:106:	    this[01;31m-[00m>_Atoms.push_back(ea);
energyAtomTable.cc:107:	    (*vi)[01;31m-[00m>setRecognized(true);
energyAtomTable.cc:113:        for ( eai=this[01;31m-[00m>_Atoms.begin(); eai!=this[01;31m-[00m>_Atoms.end(); eai++ )
energyAtomTable.cc:115:	    child = node[01;31m-[00m>createChildNode("EnergyAtom");
energyAtomTable.cc:116:	    eai[01;31m-[00m>archive(child);
energyAtomTable.cc:130:    for ( eai=this[01;31m-[00m>_Atoms.begin(); eai!=this[01;31m-[00m>_Atoms.end(); eai++ ) {
energyAtomTable.cc:131:	as1 = atomLabel(eai[01;31m-[00m>_Atom);
energyAtomTable.cc:132:	str1 = eai[01;31m-[00m>_Atom[01;31m-[00m>getTypeString();
energyAtomTable.cc:133:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("TERM 0ATOM %[01;31m-[00m9s %[01;31m-[00m9s") %	as1.c_str() % str1.c_str() );
energyChiralRestraint.cc:31:    this[01;31m-[00m>_Atom1.reset();
energyChiralRestraint.cc:32:    this[01;31m-[00m>_Atom2.reset();
energyChiralRestraint.cc:33:    this[01;31m-[00m>_Atom3.reset();
energyChiralRestraint.cc:34:    this[01;31m-[00m>_Atom4.reset();
energyChiralRestraint.cc:45:    node[01;31m-[00m>attribute("K",this[01;31m-[00m>term.K);
energyChiralRestraint.cc:46:    node[01;31m-[00m>attribute("CO",this[01;31m-[00m>term.CO);
energyChiralRestraint.cc:47:    node[01;31m-[00m>attribute("I1",this[01;31m-[00m>term.I1);
energyChiralRestraint.cc:48:    node[01;31m-[00m>attribute("I2",this[01;31m-[00m>term.I2);
energyChiralRestraint.cc:49:    node[01;31m-[00m>attribute("I3",this[01;31m-[00m>term.I3);
energyChiralRestraint.cc:50:    node[01;31m-[00m>attribute("I4",this[01;31m-[00m>term.I4);
energyChiralRestraint.cc:51:    node[01;31m-[00m>archiveObject("a1",this[01;31m-[00m>_Atom1);
energyChiralRestraint.cc:52:    node[01;31m-[00m>archiveObject("a2",this[01;31m-[00m>_Atom2);
energyChiralRestraint.cc:53:    node[01;31m-[00m>archiveObject("a3",this[01;31m-[00m>_Atom3);
energyChiralRestraint.cc:54:    node[01;31m-[00m>archiveObject("a4",this[01;31m-[00m>_Atom4);
energyChiralRestraint.cc:56:    node[01;31m-[00m>attributeIfDefined("calcForce",this[01;31m-[00m>_calcForce,this[01;31m-[00m>_calcForce);
energyChiralRestraint.cc:57:    node[01;31m-[00m>attributeIfDefined("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian,this[01;31m-[00m>_calcDiagonalHessian);
energyChiralRestraint.cc:58:    node[01;31m-[00m>attributeIfDefined("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian,this[01;31m-[00m>_calcOffDiagonalHessian);
energyChiralRestraint.cc:69:    ss << this[01;31m-[00m>_Atom1[01;31m-[00m>description() << "[01;31m-[00m";
energyChiralRestraint.cc:70:    ss << this[01;31m-[00m>_Atom2[01;31m-[00m>description() << "[01;31m-[00m";
energyChiralRestraint.cc:71:    ss << this[01;31m-[00m>_Atom3[01;31m-[00m>description() << "[01;31m-[00m";
energyChiralRestraint.cc:72:    ss << this[01;31m-[00m>_Atom4[01;31m-[00m>description() ;
energyChiralRestraint.cc:74:    ss << " eval.Energy=" << this[01;31m-[00m>eval.Energy;
energyChiralRestraint.cc:87:    node[01;31m-[00m>addAttributeString("atom1Name",this[01;31m-[00m>_Atom1[01;31m-[00m>getName());
energyChiralRestraint.cc:88:    node[01;31m-[00m>addAttributeString("atom2Name",this[01;31m-[00m>_Atom2[01;31m-[00m>getName());
energyChiralRestraint.cc:89:    node[01;31m-[00m>addAttributeString("atom3Name",this[01;31m-[00m>_Atom3[01;31m-[00m>getName());
energyChiralRestraint.cc:90:    node[01;31m-[00m>addAttributeString("atom4Name",this[01;31m-[00m>_Atom4[01;31m-[00m>getName());
energyChiralRestraint.cc:91:    node[01;31m-[00m>addAttributeInt("I1",this[01;31m-[00m>term.I1);
energyChiralRestraint.cc:92:    node[01;31m-[00m>addAttributeInt("I2",this[01;31m-[00m>term.I2);
energyChiralRestraint.cc:93:    node[01;31m-[00m>addAttributeInt("I3",this[01;31m-[00m>term.I3);
energyChiralRestraint.cc:94:    node[01;31m-[00m>addAttributeInt("I4",this[01;31m-[00m>term.I4);
energyChiralRestraint.cc:95:    node[01;31m-[00m>addAttributeDoubleScientific("K",this[01;31m-[00m>term.K);
energyChiralRestraint.cc:98:    xml[01;31m-[00m>addAttributeBool("calcForce",this[01;31m-[00m>_calcForce );
energyChiralRestraint.cc:99:    xml[01;31m-[00m>addAttributeBool("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian );
energyChiralRestraint.cc:100:    xml[01;31m-[00m>addAttributeBool("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian );
energyChiralRestraint.cc:102:    node[01;31m-[00m>addChild(xml);
energyChiralRestraint.cc:110:    this[01;31m-[00m>term.K = xml[01;31m-[00m>getAttributeDouble("K");
energyChiralRestraint.cc:111:    this[01;31m-[00m>term.I1 = xml[01;31m-[00m>getAttributeInt("I1");
energyChiralRestraint.cc:112:    this[01;31m-[00m>term.I2 = xml[01;31m-[00m>getAttributeInt("I2");
energyChiralRestraint.cc:113:    this[01;31m-[00m>term.I3 = xml[01;31m-[00m>getAttributeInt("I3");
energyChiralRestraint.cc:114:    this[01;31m-[00m>term.I4 = xml[01;31m-[00m>getAttributeInt("I4");
energyChiralRestraint.cc:115:    this[01;31m-[00m>_Atom1 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I1)[01;31m-[00m>_Atom;
energyChiralRestraint.cc:116:    this[01;31m-[00m>_Atom2 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I2)[01;31m-[00m>_Atom;
energyChiralRestraint.cc:117:    this[01;31m-[00m>_Atom3 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I3)[01;31m-[00m>_Atom;
energyChiralRestraint.cc:118:    this[01;31m-[00m>_Atom4 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I4)[01;31m-[00m>_Atom;
energyChiralRestraint.cc:161:    this[01;31m-[00m>_Terms.push_back(e);
energyChiralRestraint.cc:188:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyChiralRestraint.cc:192:#define	CHIRAL_RESTRAINT_SET_PARAMETER(x)	{x=cri[01;31m-[00m>term.x;}
energyChiralRestraint.cc:194:#define	CHIRAL_RESTRAINT_SET_POSITION(x,ii,of) {x=nvPosition[01;31m-[00m>element(ii+of);}
energyChiralRestraint.cc:203:	  m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyChiralRestraint.cc:207:	  m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyChiralRestraint.cc:213:    if ( this[01;31m-[00m>isEnabled() ) {
energyChiralRestraint.cc:217:	for ( vector<EnergyChiralRestraint>::iterator cri=this[01;31m-[00m>_Terms.begin();
energyChiralRestraint.cc:218:		    cri!=this[01;31m-[00m>_Terms.end(); cri++ ) {
energyChiralRestraint.cc:239:{_F(this[01;31m-[00m>lisp());
energyChiralRestraint.cc:240:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyChiralRestraint.cc:243:	LOG_ENERGY(BF("%s {\n")% this[01;31m-[00m>className());
energyChiralRestraint.cc:251:bool	hasForce = force[01;31m-[00m>notNil();
energyChiralRestraint.cc:252:bool	hasHessian = hessian[01;31m-[00m>notNil();
energyChiralRestraint.cc:253:bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
energyChiralRestraint.cc:259:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyChiralRestraint.cc:266:#define	CHIRAL_RESTRAINT_SET_PARAMETER(x)	{x = cri[01;31m-[00m>term.x;}
energyChiralRestraint.cc:268:#define	CHIRAL_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>element(ii+of);}
energyChiralRestraint.cc:272:#define	CHIRAL_RESTRAINT_ENERGY_ACCUMULATE(e) this[01;31m-[00m>_TotalEnergy += (e);
energyChiralRestraint.cc:281:    if ( this[01;31m-[00m>isEnabled() ) {
energyChiralRestraint.cc:286:	for ( i=0,cri=this[01;31m-[00m>_Terms.begin();
energyChiralRestraint.cc:287:		    cri!=this[01;31m-[00m>_Terms.end(); cri++,i++ ) {
energyChiralRestraint.cc:289:		if ( this[01;31m-[00m>_Debug_NumberOfChiralRestraintTermsToCalculate > 0 ) {
energyChiralRestraint.cc:290:		    if ( i>= this[01;31m-[00m>_Debug_NumberOfChiralRestraintTermsToCalculate ) {
energyChiralRestraint.cc:301:		cri[01;31m-[00m>_calcForce = calcForce;
energyChiralRestraint.cc:302:		cri[01;31m-[00m>_calcDiagonalHessian = calcDiagonalHessian;
energyChiralRestraint.cc:303:		cri [01;31m-[00m>_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyChiralRestraint.cc:306:		#define	EVAL_SET(var,val)	{ cri[01;31m-[00m>eval.var=val;};
energyChiralRestraint.cc:310:	    if ( this[01;31m-[00m>_DebugEnergy ) {
energyChiralRestraint.cc:347:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyChiralRestraint.cc:348:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyChiralRestraint.cc:349:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyChiralRestraint.cc:350:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyChiralRestraint.cc:351:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyChiralRestraint.cc:352:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyChiralRestraint.cc:353:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx3>10000.0);
energyChiralRestraint.cc:354:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy3>10000.0);
energyChiralRestraint.cc:355:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz3>10000.0);
energyChiralRestraint.cc:356:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx4>10000.0);
energyChiralRestraint.cc:357:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy4>10000.0);
energyChiralRestraint.cc:358:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz4>10000.0);
energyChiralRestraint.cc:362:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyChiralRestraint.cc:364:	LOG_ENERGY(BF("%s }\n")% this[01;31m-[00m>className());
energyChiralRestraint.cc:386://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyChiralRestraint.cc:392:#define	CHIRAL_RESTRAINT_SET_PARAMETER(x)	{x = cri[01;31m-[00m>term.x;}
energyChiralRestraint.cc:394:#define	CHIRAL_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>element(ii+of);}
energyChiralRestraint.cc:407:	if ( this[01;31m-[00m>isEnabled() ) {
energyChiralRestraint.cc:413:	    for ( i=0,cri=this[01;31m-[00m>_Terms.begin();
energyChiralRestraint.cc:414:			cri!=this[01;31m-[00m>_Terms.end(); cri++,i++ ) {
energyChiralRestraint.cc:441:{_F(this[01;31m-[00m>lisp());
energyChiralRestraint.cc:447:    this[01;31m-[00m>_BeyondThresholdTerms.clear();
energyChiralRestraint.cc:452://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyChiralRestraint.cc:459:#define	CHIRAL_RESTRAINT_SET_PARAMETER(x)	{x = cri[01;31m-[00m>term.x;}
energyChiralRestraint.cc:461:#define	CHIRAL_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>element(ii+of);}
energyChiralRestraint.cc:474:    if ( this[01;31m-[00m>isEnabled() ) {
energyChiralRestraint.cc:480:	LOG(BF("Entering checking loop, there are %d terms") % this[01;31m-[00m>_Terms.end()[01;31m-[00mthis[01;31m-[00m>_Terms.begin() ); // vp0(( "Entering checking loop, there are %d terms", this[01;31m-[00m>_Terms.end()[01;31m-[00mthis[01;31m-[00m>_Terms.begin()));
energyChiralRestraint.cc:481:	for ( i=0,cri=this[01;31m-[00m>_Terms.begin();
energyChiralRestraint.cc:482:		    cri!=this[01;31m-[00m>_Terms.end(); cri++,i++ ) {
energyChiralRestraint.cc:497:		info << a1[01;31m-[00m>getName() << " ";
energyChiralRestraint.cc:498:		info << a2[01;31m-[00m>getName() << " ";
energyChiralRestraint.cc:499:		info << a3[01;31m-[00m>getName() << " ";
energyChiralRestraint.cc:500:		info << a4[01;31m-[00m>getName() << ")";
energyChiralRestraint.cc:503:		this[01;31m-[00m>_BeyondThresholdTerms.push_back(*cri);
energyChiralRestraint.cc:522:    class_<O_EnergyChiralRestraint>(e[01;31m-[00m>lisp())
energyChiralRestraint.cc:533:    this[01;31m-[00m>Base::initialize();
energyChiralRestraint.cc:534:    this[01;31m-[00m>setErrorThreshold(0.2);
energyChiralRestraint.cc:540:    this[01;31m-[00m>Base::archiveBase(node);
energyComponent.cc:20:    class_<O_EnergyComponent>(e[01;31m-[00m>lisp())
energyComponent.cc:50:    this[01;31m-[00m>Base::initialize();
energyComponent.cc:51:    this[01;31m-[00m>enable();
energyComponent.cc:52:    this[01;31m-[00m>zeroEnergy();
energyComponent.cc:53:    this[01;31m-[00m>disableDebug();
energyComponent.cc:54:    this[01;31m-[00m>setScale(1.0);
energyComponent.cc:55:    this[01;31m-[00m>setDebug_NumberOfTermsToCalculate([01;31m-[00m1);
energyComponent.cc:61:    this[01;31m-[00m>_TotalEnergy = 0.0;
energyComponent.cc:66:    this[01;31m-[00m>Base::archiveBase(node);
energyComponent.cc:67:    node[01;31m-[00m>attribute("_Enabled",this[01;31m-[00m>_Enabled);
energyComponent.cc:68:    node[01;31m-[00m>attribute("_Scale",this[01;31m-[00m>_Scale);
energyComponent.cc:69:    node[01;31m-[00m>attribute("_ErrorThreshold",this[01;31m-[00m>_ErrorThreshold);
energyComponent.cc:70:    node[01;31m-[00m>attribute("_DebugEnergy",this[01;31m-[00m>_DebugEnergy);
energyComponent.cc:71:    node[01;31m-[00m>attribute("_TotalEnergy",this[01;31m-[00m>_TotalEnergy);
energyComponent.cc:72:    node[01;31m-[00m>attribute("_Debug_NumberOfTermsToCalculate",this[01;31m-[00m>_Debug_NumberOfTermsToCalculate);
energyComponent.cc:73:    node[01;31m-[00m>attribute("_Scale",this[01;31m-[00m>_Scale);
energyComponent.cc:80:	    return this[01;31m-[00m>_DebugLog.str();
energyComponent.cc:82:	    return this[01;31m-[00m>className()+"[01;31m-[00mno_log";
energyComponent.cc:90:    if ( this[01;31m-[00m>isEnabled() ) 
energyComponent.cc:92:	ss<<this[01;31m-[00m>className();
energyComponent.cc:94:	if ( this[01;31m-[00m>_Debug_NumberOfTermsToCalculate < 0 ) {
energyComponent.cc:98:	    ss<<this[01;31m-[00m>_Debug_NumberOfTermsToCalculate<<")";
energyComponent.cc:110:    ss<< this[01;31m-[00m>className();
energyComponent.cc:111:    ss << " energy: " << this[01;31m-[00m>getEnergy() << endl;
energyDihedral.cc:28:    this[01;31m-[00m>_Atom1.reset();
energyDihedral.cc:29:    this[01;31m-[00m>_Atom2.reset();
energyDihedral.cc:30:    this[01;31m-[00m>_Atom3.reset();
energyDihedral.cc:31:    this[01;31m-[00m>_Atom4.reset();
energyDihedral.cc:41://    node[01;31m-[00m>attribute("_Type1",this[01;31m-[00m>_Type1);
energyDihedral.cc:42://    node[01;31m-[00m>attribute("_Type2",this[01;31m-[00m>_Type2);
energyDihedral.cc:43://    node[01;31m-[00m>attribute("_Type3",this[01;31m-[00m>_Type3);
energyDihedral.cc:44://    node[01;31m-[00m>attribute("_Type4",this[01;31m-[00m>_Type4);
energyDihedral.cc:45:    node[01;31m-[00m>attribute("_Proper",this[01;31m-[00m>_Proper);
energyDihedral.cc:46:    node[01;31m-[00m>attribute("_PhaseRad",this[01;31m-[00m>_PhaseRad);
energyDihedral.cc:47:    node[01;31m-[00m>attribute("sinPhase",this[01;31m-[00m>term.sinPhase);
energyDihedral.cc:48:    node[01;31m-[00m>attribute("cosPhase",this[01;31m-[00m>term.cosPhase);
energyDihedral.cc:49:    node[01;31m-[00m>attribute("V",this[01;31m-[00m>term.V);
energyDihedral.cc:50:    node[01;31m-[00m>attribute("DN",this[01;31m-[00m>term.DN);
energyDihedral.cc:51:    node[01;31m-[00m>attribute("IN",this[01;31m-[00m>term.IN);
energyDihedral.cc:52:    node[01;31m-[00m>attribute("I1",this[01;31m-[00m>term.I1);
energyDihedral.cc:53:    node[01;31m-[00m>attribute("I2",this[01;31m-[00m>term.I2);
energyDihedral.cc:54:    node[01;31m-[00m>attribute("I3",this[01;31m-[00m>term.I3);
energyDihedral.cc:55:    node[01;31m-[00m>attribute("I4",this[01;31m-[00m>term.I4);
energyDihedral.cc:56:    node[01;31m-[00m>archiveObject("a1",this[01;31m-[00m>_Atom1);
energyDihedral.cc:57:    node[01;31m-[00m>archiveObject("a2",this[01;31m-[00m>_Atom2);
energyDihedral.cc:58:    node[01;31m-[00m>archiveObject("a3",this[01;31m-[00m>_Atom3);
energyDihedral.cc:59:    node[01;31m-[00m>archiveObject("a4",this[01;31m-[00m>_Atom4);
energyDihedral.cc:61:    node[01;31m-[00m>attributeIfDefined("calcForce",this[01;31m-[00m>_calcForce,this[01;31m-[00m>_calcForce);
energyDihedral.cc:62:    node[01;31m-[00m>attributeIfDefined("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian,this[01;31m-[00m>_calcDiagonalHessian);
energyDihedral.cc:63:    node[01;31m-[00m>attributeIfDefined("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian,this[01;31m-[00m>_calcOffDiagonalHessian);
energyDihedral.cc:77:    sinNPhiCosNPhi(n[01;31m-[00m1,&sinNm1Phi,&cosNm1Phi,sinPhi,cosPhi);
energyDihedral.cc:79:    *cosNPhi = cosPhi*cosNm1Phi[01;31m-[00msinPhi*sinNm1Phi;
energyDihedral.cc:86://    this[01;31m-[00m>_Term = term;
energyDihedral.cc:87:    this[01;31m-[00m>_Proper = true;
energyDihedral.cc:88://    this[01;31m-[00m>_Type1 = term[01;31m-[00m>_T1;
energyDihedral.cc:89://    this[01;31m-[00m>_Type2 = term[01;31m-[00m>_T2;
energyDihedral.cc:90://    this[01;31m-[00m>_Type3 = term[01;31m-[00m>_T3;
energyDihedral.cc:91://    this[01;31m-[00m>_Type4 = term[01;31m-[00m>_T4;
energyDihedral.cc:92:    this[01;31m-[00m>_Atom1 = ea1[01;31m-[00m>_Atom;
energyDihedral.cc:93:    this[01;31m-[00m>_Atom2 = ea2[01;31m-[00m>_Atom;
energyDihedral.cc:94:    this[01;31m-[00m>_Atom3 = ea3[01;31m-[00m>_Atom;
energyDihedral.cc:95:    this[01;31m-[00m>_Atom4 = ea4[01;31m-[00m>_Atom;
energyDihedral.cc:96:    this[01;31m-[00m>_PhaseRad = term[01;31m-[00m>_PhaseRads[n[01;31m-[00m1];
energyDihedral.cc:97:    this[01;31m-[00m>term.sinPhase = sin(this[01;31m-[00m>_PhaseRad);
energyDihedral.cc:98:    this[01;31m-[00m>term.cosPhase = cos(this[01;31m-[00m>_PhaseRad);
energyDihedral.cc:99:    this[01;31m-[00m>term.V = term[01;31m-[00m>_Vs[n[01;31m-[00m1]*scale;
energyDihedral.cc:100:    this[01;31m-[00m>term.DN = n;
energyDihedral.cc:101:    this[01;31m-[00m>term.IN = n;
energyDihedral.cc:102:    this[01;31m-[00m>term.I1 = ea1[01;31m-[00m>_CoordinateIndex;
energyDihedral.cc:103:    this[01;31m-[00m>term.I2 = ea2[01;31m-[00m>_CoordinateIndex;
energyDihedral.cc:104:    this[01;31m-[00m>term.I3 = ea3[01;31m-[00m>_CoordinateIndex;
energyDihedral.cc:105:    this[01;31m-[00m>term.I4 = ea4[01;31m-[00m>_CoordinateIndex;
energyDihedral.cc:112:    pos1 = this[01;31m-[00m>_Atom1[01;31m-[00m>getPosition();
energyDihedral.cc:113:    pos2 = this[01;31m-[00m>_Atom2[01;31m-[00m>getPosition();
energyDihedral.cc:114:    pos3 = this[01;31m-[00m>_Atom3[01;31m-[00m>getPosition();
energyDihedral.cc:115:    pos4 = this[01;31m-[00m>_Atom4[01;31m-[00m>getPosition();
energyDihedral.cc:116:    angle = calculateDihedral( pos1, pos2, pos3, pos4, this[01;31m-[00m>lisp());
energyDihedral.cc:124:    pos1 = this[01;31m-[00m>_Atom1[01;31m-[00m>getPosition();
energyDihedral.cc:125:    pos2 = this[01;31m-[00m>_Atom2[01;31m-[00m>getPosition();
energyDihedral.cc:126:    pos3 = this[01;31m-[00m>_Atom3[01;31m-[00m>getPosition();
energyDihedral.cc:127:    pos4 = this[01;31m-[00m>_Atom4[01;31m-[00m>getPosition();
energyDihedral.cc:128:    phi = calculateDihedral( pos1, pos2, pos3, pos4, this[01;31m-[00m>lisp());
energyDihedral.cc:129:    dev = 1.0+cos(this[01;31m-[00m>term.DN*phi[01;31m-[00mthis[01;31m-[00m>_PhaseRad);
energyDihedral.cc:136://    this[01;31m-[00m>_Term = term;
energyDihedral.cc:137:    this[01;31m-[00m>_Proper = false;
energyDihedral.cc:138://    this[01;31m-[00m>_Type1 = term[01;31m-[00m>_T1;
energyDihedral.cc:139://    this[01;31m-[00m>_Type2 = term[01;31m-[00m>_T2;
energyDihedral.cc:140://    this[01;31m-[00m>_Type3 = term[01;31m-[00m>_T3;
energyDihedral.cc:141://    this[01;31m-[00m>_Type4 = term[01;31m-[00m>_T4;
energyDihedral.cc:142:    this[01;31m-[00m>_Atom1 = ea1[01;31m-[00m>_Atom;
energyDihedral.cc:143:    this[01;31m-[00m>_Atom2 = ea2[01;31m-[00m>_Atom;
energyDihedral.cc:144:    this[01;31m-[00m>_Atom3 = ea3[01;31m-[00m>_Atom;
energyDihedral.cc:145:    this[01;31m-[00m>_Atom4 = ea4[01;31m-[00m>_Atom;
energyDihedral.cc:146:    this[01;31m-[00m>term.DN = n;
energyDihedral.cc:147:    this[01;31m-[00m>term.IN = n;
energyDihedral.cc:148:    this[01;31m-[00m>term.V = term[01;31m-[00m>_Vs[n[01;31m-[00m1]*scale;
energyDihedral.cc:149:    this[01;31m-[00m>_PhaseRad = term[01;31m-[00m>_PhaseRads[n[01;31m-[00m1];
energyDihedral.cc:150:    this[01;31m-[00m>term.cosPhase = cos(this[01;31m-[00m>_PhaseRad);
energyDihedral.cc:151:    this[01;31m-[00m>term.sinPhase = sin(this[01;31m-[00m>_PhaseRad);
energyDihedral.cc:152:    this[01;31m-[00m>term.I1 = ea1[01;31m-[00m>_CoordinateIndex;
energyDihedral.cc:153:    this[01;31m-[00m>term.I2 = ea2[01;31m-[00m>_CoordinateIndex;
energyDihedral.cc:154:    this[01;31m-[00m>term.I3 = ea3[01;31m-[00m>_CoordinateIndex;
energyDihedral.cc:155:    this[01;31m-[00m>term.I4 = ea4[01;31m-[00m>_CoordinateIndex;
energyDihedral.cc:161:    this[01;31m-[00m>_Proper = true;
energyDihedral.cc:162://    this[01;31m-[00m>_Type1 = ea1[01;31m-[00m>_Atom[01;31m-[00m>getTypeString();
energyDihedral.cc:163://    this[01;31m-[00m>_Type2 = ea2[01;31m-[00m>_Atom[01;31m-[00m>getTypeString();
energyDihedral.cc:164:/    this[01;31m-[00m>_Type3 = ea3[01;31m-[00m>_Atom[01;31m-[00m>getTypeString();
energyDihedral.cc:165:    this[01;31m-[00m>_Type4 = ea4[01;31m-[00m>_Atom[01;31m-[00m>getTypeString();
energyDihedral.cc:175:    node[01;31m-[00m>addAttributeBool("proper",this[01;31m-[00m>_Proper );
energyDihedral.cc:176:    node[01;31m-[00m>addAttributeString("atom1Name",this[01;31m-[00m>_Atom1[01;31m-[00m>getName());
energyDihedral.cc:177:    node[01;31m-[00m>addAttributeString("atom2Name",this[01;31m-[00m>_Atom2[01;31m-[00m>getName());
energyDihedral.cc:178:    node[01;31m-[00m>addAttributeString("atom3Name",this[01;31m-[00m>_Atom3[01;31m-[00m>getName());
energyDihedral.cc:179:    node[01;31m-[00m>addAttributeString("atom4Name",this[01;31m-[00m>_Atom4[01;31m-[00m>getName());
energyDihedral.cc:180://    node[01;31m-[00m>addAttributeString("atom1Type",this[01;31m-[00m>_Type1 );
energyDihedral.cc:181://    node[01;31m-[00m>addAttributeString("atom2Type",this[01;31m-[00m>_Type2 );
energyDihedral.cc:182://    node[01;31m-[00m>addAttributeString("atom3Type",this[01;31m-[00m>_Type3 );
energyDihedral.cc:183://    node[01;31m-[00m>addAttributeString("atom4Type",this[01;31m-[00m>_Type4 );
energyDihedral.cc:184:    node[01;31m-[00m>addAttributeInt("I1",this[01;31m-[00m>term.I1);
energyDihedral.cc:185:    node[01;31m-[00m>addAttributeInt("I2",this[01;31m-[00m>term.I2);
energyDihedral.cc:186:    node[01;31m-[00m>addAttributeInt("I3",this[01;31m-[00m>term.I3);
energyDihedral.cc:187:    node[01;31m-[00m>addAttributeInt("I4",this[01;31m-[00m>term.I4);
energyDihedral.cc:188:    node[01;31m-[00m>addAttributeDoubleScientific("DN",this[01;31m-[00m>term.DN);
energyDihedral.cc:189:    node[01;31m-[00m>addAttributeInt("IN",this[01;31m-[00m>term.IN);
energyDihedral.cc:190:    node[01;31m-[00m>addAttributeDoubleScientific("V",this[01;31m-[00m>term.V);
energyDihedral.cc:191:    node[01;31m-[00m>addAttributeDoubleScientific("PhaseRad",this[01;31m-[00m>_PhaseRad);
energyDihedral.cc:194:    xml[01;31m-[00m>addAttributeBool("calcForce",this[01;31m-[00m>_calcForce );
energyDihedral.cc:195:    xml[01;31m-[00m>addAttributeBool("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian );
energyDihedral.cc:196:    xml[01;31m-[00m>addAttributeBool("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian );
energyDihedral.cc:198:    node[01;31m-[00m>addChild(xml);
energyDihedral.cc:206:    this[01;31m-[00m>term.I1 = xml[01;31m-[00m>getAttributeInt("I1");
energyDihedral.cc:207:    this[01;31m-[00m>term.I2 = xml[01;31m-[00m>getAttributeInt("I2");
energyDihedral.cc:208:    this[01;31m-[00m>term.I3 = xml[01;31m-[00m>getAttributeInt("I3");
energyDihedral.cc:209:    this[01;31m-[00m>term.I4 = xml[01;31m-[00m>getAttributeInt("I4");
energyDihedral.cc:210:    this[01;31m-[00m>_Atom1 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I1)[01;31m-[00m>_Atom;
energyDihedral.cc:211:    this[01;31m-[00m>_Atom2 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I2)[01;31m-[00m>_Atom;
energyDihedral.cc:212:    this[01;31m-[00m>_Atom3 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I3)[01;31m-[00m>_Atom;
energyDihedral.cc:213:    this[01;31m-[00m>_Atom4 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I4)[01;31m-[00m>_Atom;
energyDihedral.cc:214:    this[01;31m-[00m>term.DN = xml[01;31m-[00m>getAttributeDouble("DN");
energyDihedral.cc:215:    this[01;31m-[00m>term.IN = xml[01;31m-[00m>getAttributeInt("IN");
energyDihedral.cc:216:    this[01;31m-[00m>term.V = xml[01;31m-[00m>getAttributeDouble("V");
energyDihedral.cc:217:    this[01;31m-[00m>_PhaseRad = xml[01;31m-[00m>getAttributeDouble("PhaseRad");
energyDihedral.cc:218:    this[01;31m-[00m>_Proper = xml[01;31m-[00m>getAttributeBool("proper");
energyDihedral.cc:265:    this[01;31m-[00m>_Terms.push_back(term);
energyDihedral.cc:282:    for (edi=this[01;31m-[00m>_Terms.begin();edi!=this[01;31m-[00m>_Terms.end();edi++)
energyDihedral.cc:284:	if ( edi[01;31m-[00m>term.V == 0.0 ) continue;
energyDihedral.cc:285:	if ( edi[01;31m-[00m>_Proper ) {
energyDihedral.cc:290:	as1 = atomLabel(edi[01;31m-[00m>_Atom1);
energyDihedral.cc:291:	as2 = atomLabel(edi[01;31m-[00m>_Atom2);
energyDihedral.cc:292:	as3 = atomLabel(edi[01;31m-[00m>_Atom3);
energyDihedral.cc:293:	as4 = atomLabel(edi[01;31m-[00m>_Atom4);
energyDihedral.cc:294:	if ( edi[01;31m-[00m>_Proper ) {
energyDihedral.cc:321:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("TERM 3DIH %s %[01;31m-[00m9s [01;31m-[00m %[01;31m-[00m9s [01;31m-[00m %[01;31m-[00m9s [01;31m-[00m %[01;31m-[00m9s %8.2lf %8.2lf %2.0lf")
energyDihedral.cc:327:			% edi[01;31m-[00m>term.V
energyDihedral.cc:328:			% edi[01;31m-[00m>_PhaseRad
energyDihedral.cc:329:			% edi[01;31m-[00m>term.DN);
energyDihedral.cc:348:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyDihedral.cc:351:#define	DIHEDRAL_SET_PARAMETER(x)	{x=di[01;31m-[00m>term.x;}
energyDihedral.cc:353:#define	DIHEDRAL_SET_POSITION(x,ii,of)	{x=nvPosition[01;31m-[00m>element(ii+of);}
energyDihedral.cc:360:	m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyDihedral.cc:364:	m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyDihedral.cc:369:    if ( this[01;31m-[00m>isEnabled() ) {
energyDihedral.cc:379:	for ( vector<EnergyDihedral>::iterator di=this[01;31m-[00m>_Terms.begin();
energyDihedral.cc:380:		    di!=this[01;31m-[00m>_Terms.end(); di++ ) {
energyDihedral.cc:400:{ _F(this[01;31m-[00m>lisp());
energyDihedral.cc:401:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyDihedral.cc:404:	LOG_ENERGY(BF("%s {\n")% this[01;31m-[00m>className());
energyDihedral.cc:412:bool	hasForce = force[01;31m-[00m>notNil();
energyDihedral.cc:413:bool	hasHessian = hessian[01;31m-[00m>notNil();
energyDihedral.cc:414:bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
energyDihedral.cc:420:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyDihedral.cc:425:#define	DIHEDRAL_SET_PARAMETER(x)	{x=di[01;31m-[00m>term.x;}
energyDihedral.cc:427:#define	DIHEDRAL_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyDihedral.cc:429:#define	DIHEDRAL_ENERGY_ACCUMULATE(e) this[01;31m-[00m>_TotalEnergy += (e);
energyDihedral.cc:439:    if ( this[01;31m-[00m>isEnabled() ) 
energyDihedral.cc:451:	for ( i=0,di=this[01;31m-[00m>_Terms.begin();
energyDihedral.cc:452:		    di!=this[01;31m-[00m>_Terms.end(); di++,i++ ) {
energyDihedral.cc:454:		if ( this[01;31m-[00m>_Debug_NumberOfDihedralTermsToCalculate > 0 ) {
energyDihedral.cc:455:		    if ( i>= this[01;31m-[00m>_Debug_NumberOfDihedralTermsToCalculate ) {
energyDihedral.cc:464:	       problem._Atom1 = di[01;31m-[00m>_Atom1;
energyDihedral.cc:465:	       problem._Atom2 = di[01;31m-[00m>_Atom2;
energyDihedral.cc:466:	       problem._Atom3 = di[01;31m-[00m>_Atom3;
energyDihedral.cc:467:	       problem._Atom4 = di[01;31m-[00m>_Atom4;
energyDihedral.cc:474:		di[01;31m-[00m>_calcForce = calcForce;
energyDihedral.cc:475:		di[01;31m-[00m>_calcDiagonalHessian = calcDiagonalHessian;
energyDihedral.cc:476:		di[01;31m-[00m>_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyDihedral.cc:478:		#define	EVAL_SET(var,val)	{ di[01;31m-[00m>eval.var=val;};
energyDihedral.cc:482:	    if ( this[01;31m-[00m>_DebugEnergy ) 
energyDihedral.cc:526:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyDihedral.cc:527:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyDihedral.cc:528:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyDihedral.cc:529:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyDihedral.cc:530:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyDihedral.cc:531:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyDihedral.cc:532:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx3>10000.0);
energyDihedral.cc:533:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy3>10000.0);
energyDihedral.cc:534:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz3>10000.0);
energyDihedral.cc:535:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx4>10000.0);
energyDihedral.cc:536:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy4>10000.0);
energyDihedral.cc:537:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz4>10000.0);
energyDihedral.cc:541:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyDihedral.cc:543:	LOG_ENERGY(BF("%s }\n")% this[01;31m-[00m>className());
energyDihedral.cc:565://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyDihedral.cc:570:#define	DIHEDRAL_SET_PARAMETER(x)	{x=di[01;31m-[00m>term.x;}
energyDihedral.cc:572:#define	DIHEDRAL_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyDihedral.cc:584:	if ( this[01;31m-[00m>isEnabled() ) {
energyDihedral.cc:676:	    for ( i=0,di=this[01;31m-[00m>_Terms.begin();
energyDihedral.cc:677:			di!=this[01;31m-[00m>_Terms.end(); di++,i++ ) {
energyDihedral.cc:696:    this[01;31m-[00m>_BeyondThresholdTerms.clear();
energyDihedral.cc:701://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyDihedral.cc:707:#define	DIHEDRAL_SET_PARAMETER(x)	{x=di[01;31m-[00m>term.x;}
energyDihedral.cc:709:#define	DIHEDRAL_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyDihedral.cc:720:	if ( this[01;31m-[00m>isEnabled() ) {
energyDihedral.cc:732:	    for ( i=0,di=this[01;31m-[00m>_Terms.begin();
energyDihedral.cc:733:			di!=this[01;31m-[00m>_Terms.end(); di++,i++ ) {
energyDihedral.cc:735:		if ( fabs(DihedralDeviation)>this[01;31m-[00m>_ErrorThreshold) {
energyDihedral.cc:742://		    info<< a1[01;31m-[00m>getAbsoluteIdPath() << " ";
energyDihedral.cc:743://		    info<< a2[01;31m-[00m>getAbsoluteIdPath() << " ";
energyDihedral.cc:744://		    info<< a3[01;31m-[00m>getAbsoluteIdPath() << " ";
energyDihedral.cc:745://		    info<< a4[01;31m-[00m>getAbsoluteIdPath() << " ";
energyDihedral.cc:747:		    info<<"threshold " << this[01;31m-[00m>_ErrorThreshold;
energyDihedral.cc:748:		    info << a1[01;31m-[00m>getName() << " ";
energyDihedral.cc:749:		    info << a2[01;31m-[00m>getName() << " ";
energyDihedral.cc:750:		    info << a3[01;31m-[00m>getName() << " ";
energyDihedral.cc:751:		    info << a4[01;31m-[00m>getName() << " ";
energyDihedral.cc:755:		    this[01;31m-[00m>_BeyondThresholdTerms.push_back(ed);
energyDihedral.cc:771:    class_<O_EnergyDihedral>(e[01;31m-[00m>lisp())
energyDihedral.cc:783:    this[01;31m-[00m>Base::initialize();
energyDihedral.cc:784:    this[01;31m-[00m>setErrorThreshold(3.0);
energyDihedral.cc:789:    this[01;31m-[00m>Base::archiveBase(node);
energyFixedNonbond.cc:18:    this[01;31m-[00m>_FixedAtom.reset();
energyFixedNonbond.cc:30:    node[01;31m-[00m>attributeIfDefined("calcForce",this[01;31m-[00m>_calcForce,this[01;31m-[00m>_calcForce);
energyFixedNonbond.cc:31:    node[01;31m-[00m>attributeIfDefined("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian,this[01;31m-[00m>_calcDiagonalHessian);
energyFixedNonbond.cc:32:    node[01;31m-[00m>attributeIfDefined("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian,this[01;31m-[00m>_calcOffDiagonalHessian);
energyFixedNonbond.cc:48:    node[01;31m-[00m>addAttributeString("atom1Name",this[01;31m-[00m>_Atom1[01;31m-[00m>getName());
energyFixedNonbond.cc:49:    node[01;31m-[00m>addAttributeString("atom2Name",this[01;31m-[00m>_Atom2[01;31m-[00m>getName());
energyFixedNonbond.cc:50:    node[01;31m-[00m>addAttributeInt("I1",this[01;31m-[00m>I1);
energyFixedNonbond.cc:51:    node[01;31m-[00m>addAttributeInt("I2",this[01;31m-[00m>I2);
energyFixedNonbond.cc:52:    node[01;31m-[00m>addAttributeBool("is14",this[01;31m-[00m>_Is14);
energyFixedNonbond.cc:53:    node[01;31m-[00m>addAttributeString("atom1Type",this[01;31m-[00m>_Atom1[01;31m-[00m>getTypeString());
energyFixedNonbond.cc:54:    node[01;31m-[00m>addAttributeString("atom2Type",this[01;31m-[00m>_Atom2[01;31m-[00m>getTypeString());
energyFixedNonbond.cc:55:    node[01;31m-[00m>addAttributeDoubleScientific("RStar",this[01;31m-[00m>_RStar);
energyFixedNonbond.cc:56:    node[01;31m-[00m>addAttributeDoubleScientific("A",this[01;31m-[00m>_A);
energyFixedNonbond.cc:57:    node[01;31m-[00m>addAttributeDoubleScientific("C",this[01;31m-[00m>_C);
energyFixedNonbond.cc:58:    node[01;31m-[00m>addAttributeDoubleScientific("Charge1",this[01;31m-[00m>_Charge1);
energyFixedNonbond.cc:59:    node[01;31m-[00m>addAttributeDoubleScientific("Charge2",this[01;31m-[00m>_Charge2);
energyFixedNonbond.cc:60://    vdiff = this[01;31m-[00m>_Atom1[01;31m-[00m>_Atom[01;31m-[00m>getPosition() [01;31m-[00m this[01;31m-[00m>_Atom2[01;31m-[00m>_Atom[01;31m-[00m>getPosition();
energyFixedNonbond.cc:62://    node[01;31m-[00m>addAttributeDouble("_r",diff,5,2);
energyFixedNonbond.cc:64:    RPQDomNode xml = O_QDomNode::create(this[01;31m-[00m>lisp(),"Evaluated");
energyFixedNonbond.cc:65:    xml[01;31m-[00m>addAttributeBool("calcForce",this[01;31m-[00m>_calcForce );
energyFixedNonbond.cc:66:    xml[01;31m-[00m>addAttributeBool("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian );
energyFixedNonbond.cc:67:    xml[01;31m-[00m>addAttributeBool("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian );
energyFixedNonbond.cc:69:    node[01;31m-[00m>addChild(xml);
energyFixedNonbond.cc:71:    node[01;31m-[00m>addAttributeDoubleScientific("dA",this[01;31m-[00m>dA);
energyFixedNonbond.cc:72:    node[01;31m-[00m>addAttributeDoubleScientific("dC",this[01;31m-[00m>dC);
energyFixedNonbond.cc:73:    node[01;31m-[00m>addAttributeDoubleScientific("dQ1Q2",this[01;31m-[00m>dQ1Q2);
energyFixedNonbond.cc:86:    this[01;31m-[00m>dA = xml[01;31m-[00m>getAttributeDouble("dA");
energyFixedNonbond.cc:87:    this[01;31m-[00m>dC = xml[01;31m-[00m>getAttributeDouble("dC");
energyFixedNonbond.cc:88:    this[01;31m-[00m>dQ1Q2 = xml[01;31m-[00m>getAttributeDouble("dQ1Q2");
energyFixedNonbond.cc:89:    this[01;31m-[00m>_RStar = xml[01;31m-[00m>getAttributeDouble("RStar");
energyFixedNonbond.cc:90:    this[01;31m-[00m>_A = xml[01;31m-[00m>getAttributeDouble("A");
energyFixedNonbond.cc:91:    this[01;31m-[00m>_C = xml[01;31m-[00m>getAttributeDouble("C");
energyFixedNonbond.cc:92:    this[01;31m-[00m>_Charge1 = xml[01;31m-[00m>getAttributeDouble("Charge1");
energyFixedNonbond.cc:93:    this[01;31m-[00m>_Charge2 = xml[01;31m-[00m>getAttributeDouble("Charge2");
energyFixedNonbond.cc:94:    this[01;31m-[00m>I1 = xml[01;31m-[00m>getAttributeInt("I1");
energyFixedNonbond.cc:95:    this[01;31m-[00m>I2 = xml[01;31m-[00m>getAttributeInt("I2");
energyFixedNonbond.cc:96:    this[01;31m-[00m>_Is14 = xml[01;31m-[00m>getAttributeBool("is14");
energyFixedNonbond.cc:97:    this[01;31m-[00m>_Atom1 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>I1)[01;31m-[00m>_Atom;
energyFixedNonbond.cc:98:    this[01;31m-[00m>_Atom2 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>I2)[01;31m-[00m>_Atom;
energyFixedNonbond.cc:150:    this[01;31m-[00m>_MobileAtomTable = atomTable;
energyFixedNonbond.cc:151:    this[01;31m-[00m>_NonbondCrossTermTable = crossTerms;
energyFixedNonbond.cc:162:    this[01;31m-[00m>Base::zeroEnergy();
energyFixedNonbond.cc:163:    this[01;31m-[00m>_EnergyElectrostatic = 0.0;
energyFixedNonbond.cc:164:    this[01;31m-[00m>_EnergyVdw = 0.0;
energyFixedNonbond.cc:169:{_F(this[01;31m-[00m>lisp());
energyFixedNonbond.cc:171:    e = this[01;31m-[00m>getVdwEnergy();
energyFixedNonbond.cc:172:    e += this[01;31m-[00m>getElectrostaticEnergy();
energyFixedNonbond.cc:180:{_F(this[01;31m-[00m>lisp());
energyFixedNonbond.cc:183:    entry._FixedCharge = fa[01;31m-[00m>getCharge();
energyFixedNonbond.cc:186:        entry._FixedType = nonbondDb[01;31m-[00m>findTypeIndexOrThrow(fa[01;31m-[00m>getTypeString());
energyFixedNonbond.cc:190:	serr << "Unknown type("<<fa[01;31m-[00m>getTypeString()<<") for fixed atom: " << fa[01;31m-[00m>description() << endl;
energyFixedNonbond.cc:193:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
energyFixedNonbond.cc:195:    entry._FixedPosition = fa[01;31m-[00m>getPosition();
energyFixedNonbond.cc:196:    this[01;31m-[00m>_Terms.push_back(entry);
energyFixedNonbond.cc:207:    for ( eni=this[01;31m-[00m>_Terms.begin();
energyFixedNonbond.cc:208:	    eni!=this[01;31m-[00m>_Terms.end(); eni++ ) 
energyFixedNonbond.cc:210:	as1 = atomLabel(eni[01;31m-[00m>_FixedAtom);
energyFixedNonbond.cc:211:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "TERM 6FIXED_NONBOND %[01;31m-[00m9s") % as1.c_str() );
energyFixedNonbond.cc:217:{_F(this[01;31m-[00m>lisp());
energyFixedNonbond.cc:235:    if ( displayIn[01;31m-[00m>notNil() )
energyFixedNonbond.cc:238:	displayIn[01;31m-[00m>clear();
energyFixedNonbond.cc:239:	color = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>(RGB_yellow );
energyFixedNonbond.cc:240:	displayIn[01;31m-[00m>add(color);
energyFixedNonbond.cc:242:    for ( eni=this[01;31m-[00m>_Terms.begin();
energyFixedNonbond.cc:243:	    eni!=this[01;31m-[00m>_Terms.end(); eni++ )
energyFixedNonbond.cc:245:	ia1 = eni[01;31m-[00m>I1;
energyFixedNonbond.cc:246:	ia2 = eni[01;31m-[00m>I2;
energyFixedNonbond.cc:247:	x1 = pos[01;31m-[00m>element(ia1+0);
energyFixedNonbond.cc:248:	y1 = pos[01;31m-[00m>element(ia1+1);
energyFixedNonbond.cc:249:	z1 = pos[01;31m-[00m>element(ia1+2);
energyFixedNonbond.cc:250:	x2 = pos[01;31m-[00m>element(ia2+0);
energyFixedNonbond.cc:251:	y2 = pos[01;31m-[00m>element(ia2+1);
energyFixedNonbond.cc:252:	z2 = pos[01;31m-[00m>element(ia2+2);
energyFixedNonbond.cc:253:	cutoff = eni[01;31m-[00m>_RStar*scaleSumOfVdwRadii;
energyFixedNonbond.cc:255:	dx = x1[01;31m-[00mx2;
energyFixedNonbond.cc:256:	dy = y1[01;31m-[00my2;
energyFixedNonbond.cc:257:	dz = z1[01;31m-[00mz2;
energyFixedNonbond.cc:262:	    LOG(BF("Atom1 = %s") % eni[01;31m-[00m>_Atom1[01;31m-[00m>description().c_str()  ); // vp0(("Atom1 = %s",eni[01;31m-[00m>_Atom1[01;31m-[00m>description().c_str() ));
energyFixedNonbond.cc:263:	    LOG(BF("Atom2 = %s") % eni[01;31m-[00m>_Atom2[01;31m-[00m>description().c_str()  ); // vp0(("Atom2 = %s",eni[01;31m-[00m>_Atom2[01;31m-[00m>description().c_str() ));
energyFixedNonbond.cc:268:	        line = O_GrLine::create(v1,v2,this[01;31m-[00m>lisp());
energyFixedNonbond.cc:269:		displayIn[01;31m-[00m>add(line);
energyFixedNonbond.cc:290:{_F(this[01;31m-[00m>lisp());
energyFixedNonbond.cc:291:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyFixedNonbond.cc:294:	LOG_ENERGY(BF("%s {\n")% this[01;31m-[00m>className());
energyFixedNonbond.cc:296:    if ( this[01;31m-[00m>_Terms.size() == 0 ) return;
energyFixedNonbond.cc:297:    ASSERT_NOT_NULL(this[01;31m-[00m>_MobileAtomTable);
energyFixedNonbond.cc:298:    ASSERT(this[01;31m-[00m>_MobileAtomTable[01;31m-[00m>notNil());
energyFixedNonbond.cc:299:    ASSERT_NOT_NULL(this[01;31m-[00m>_NonbondCrossTermTable);
energyFixedNonbond.cc:300:    ASSERT(this[01;31m-[00m>_NonbondCrossTermTable[01;31m-[00m>notNil());
energyFixedNonbond.cc:308:    bool	hasForce = force[01;31m-[00m>notNil();
energyFixedNonbond.cc:309:    bool	hasHessian = hessian[01;31m-[00m>notNil();
energyFixedNonbond.cc:310:    bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
energyFixedNonbond.cc:316:    // [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFixedNonbond.cc:322:#define	FNONBOND_SET_PARAMETER(x)	{x=nbi[01;31m-[00m>x;}
energyFixedNonbond.cc:324:#define	FNONBOND_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyFixedNonbond.cc:326:#define	FNONBOND_EFEEL_ENERGY_ACCUMULATE(e) {this[01;31m-[00m>_EnergyElectrostatic +=(e);}
energyFixedNonbond.cc:328:#define	FNONBOND_EFVDW_ENERGY_ACCUMULATE(e) {this[01;31m-[00m>_EnergyVdw+=(e);}
energyFixedNonbond.cc:339:    if ( this[01;31m-[00m>isEnabled() ) 
energyFixedNonbond.cc:353:		uint fixedNonbondAtoms = this[01;31m-[00m>_Terms.size();
energyFixedNonbond.cc:354:		uint mobileNonbondAtoms = this[01;31m-[00m>_MobileAtomTable[01;31m-[00m>getNumberOfAtoms();
energyFixedNonbond.cc:358:		    FixedNonbondRestraint& fixedAtomEntry = this[01;31m-[00m>_Terms[ifixed];
energyFixedNonbond.cc:362:		    double fixedChargeMultiplier = fixedAtomEntry._FixedCharge * this[01;31m-[00m>getElectrostaticScale() / this[01;31m-[00m>_DielectricConstant * ELECTROSTATIC_MODIFIER;
energyFixedNonbond.cc:363:		    uint fixedTypeMajorIndex = this[01;31m-[00m>_NonbondCrossTermTable[01;31m-[00m>typeMajorIndex(fixedAtomEntry._FixedType);
energyFixedNonbond.cc:366:			EnergyAtom& mobileAtomEntry = this[01;31m-[00m>_MobileAtomTable[01;31m-[00m>energyAtomEntry(imobile);
energyFixedNonbond.cc:370:			FFNonbondCrossTerm crossTerm = this[01;31m-[00m>_NonbondCrossTermTable[01;31m-[00m>nonbondCrossTerm(crossTermIndex);
energyFixedNonbond.cc:371:			double dA = crossTerm._A*this[01;31m-[00m>getVdwScale();
energyFixedNonbond.cc:372:			double dC = crossTerm._C*this[01;31m-[00m>getVdwScale();
energyFixedNonbond.cc:384:			    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyFixedNonbond.cc:385:			    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyFixedNonbond.cc:386:			    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyFixedNonbond.cc:389:			if ( this[01;31m-[00m>_DebugEnergy ) 
energyFixedNonbond.cc:420:    LOG_ENERGY(BF( "          Vdw energy = %lf\n")% (double)this[01;31m-[00m>_EnergyVdw);
energyFixedNonbond.cc:421:    LOG_ENERGY(BF( "Electrostatic energy = %lf\n")% (double)this[01;31m-[00m>_EnergyElectrostatic);
energyFixedNonbond.cc:422:    LOG_ENERGY(BF("%s }\n")% this[01;31m-[00m>className() );
energyFixedNonbond.cc:445://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFixedNonbond.cc:452:#define	FNONBOND_SET_PARAMETER(x)	{x=nbi[01;31m-[00m>x;}
energyFixedNonbond.cc:454:#define	FNONBOND_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyFixedNonbond.cc:468:	if ( this[01;31m-[00m>isEnabled() ) {
energyFixedNonbond.cc:474:	    for ( i=0,nbi=this[01;31m-[00m>_Terms.begin();
energyFixedNonbond.cc:475:			nbi!=this[01;31m-[00m>_Terms.end(); nbi++,i++ ) {
energyFixedNonbond.cc:495:    this[01;31m-[00m>_BeyondThresholdTerms.clear();
energyFixedNonbond.cc:500://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFixedNonbond.cc:505:#define	FNONBOND_SET_PARAMETER(x)	{x=nbi[01;31m-[00m>x;}
energyFixedNonbond.cc:507:#define	FNONBOND_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyFixedNonbond.cc:521:    if ( this[01;31m-[00m>isEnabled() ) 
energyFixedNonbond.cc:531:	    uint fixedNonbondAtoms = this[01;31m-[00m>_Terms.size();
energyFixedNonbond.cc:532:	    uint mobileNonbondAtoms = this[01;31m-[00m>_MobileAtomTable[01;31m-[00m>getNumberOfAtoms();
energyFixedNonbond.cc:536:		FixedNonbondRestraint& fixedAtomEntry = this[01;31m-[00m>_Terms[ifixed];
energyFixedNonbond.cc:540:		double fixedChargeMultiplier = fixedAtomEntry._FixedCharge * this[01;31m-[00m>getElectrostaticScale() / this[01;31m-[00m>_DielectricConstant * ELECTROSTATIC_MODIFIER;
energyFixedNonbond.cc:541:		uint fixedTypeMajorIndex = this[01;31m-[00m>_NonbondCrossTermTable[01;31m-[00m>typeMajorIndex(fixedAtomEntry._FixedType);
energyFixedNonbond.cc:544:		    EnergyAtom& mobileAtomEntry = this[01;31m-[00m>_MobileAtomTable[01;31m-[00m>energyAtomEntry(imobile);
energyFixedNonbond.cc:548:		    FFNonbondCrossTerm crossTerm = this[01;31m-[00m>_NonbondCrossTermTable[01;31m-[00m>nonbondCrossTerm(crossTermIndex);
energyFixedNonbond.cc:549:		    double dA = crossTerm._A*this[01;31m-[00m>getVdwScale();
energyFixedNonbond.cc:550:		    double dC = crossTerm._C*this[01;31m-[00m>getVdwScale();
energyFixedNonbond.cc:552:		    if ( NonbondDistance < this[01;31m-[00m>_ErrorThreshold ) 
energyFixedNonbond.cc:558:	//		info<< a1[01;31m-[00m>getAbsoluteIdPath() << " ";
energyFixedNonbond.cc:559:	//		info<< af[01;31m-[00m>getAbsoluteIdPath() << " ";
energyFixedNonbond.cc:561:			info<<"threshold " << this[01;31m-[00m>_ErrorThreshold;
energyFixedNonbond.cc:562:			info << a1[01;31m-[00m>getName() << " ";
energyFixedNonbond.cc:563:			info << af[01;31m-[00m>getName() << " ";
energyFixedNonbond.cc:569:			this[01;31m-[00m>_BeyondThresholdTerms.push_back(bt);
energyFixedNonbond.cc:591:    class_<O_EnergyFixedNonbondRestraint>(e[01;31m-[00m>lisp())
energyFixedNonbond.cc:602:    this[01;31m-[00m>Base::initialize();
energyFixedNonbond.cc:603:    this[01;31m-[00m>setErrorThreshold(1.0);
energyFixedNonbond.cc:604:    this[01;31m-[00m>setDielectricConstant(80.0);
energyFixedNonbond.cc:605:    this[01;31m-[00m>setVdwScale(1.0);
energyFixedNonbond.cc:606:    this[01;31m-[00m>setElectrostaticScale(1.0);
energyFixedNonbond.cc:607:    this[01;31m-[00m>_MobileAtomTable = O_AtomTable::nil(this[01;31m-[00m>lisp());
energyFixedNonbond.cc:608:    this[01;31m-[00m>_NonbondCrossTermTable = O_FFNonbondCrossTermTable::nil(this[01;31m-[00m>lisp());
energyFixedNonbond.cc:614:    this[01;31m-[00m>Base::archiveBase(node);
energyFunction.cc:89:	rel = (fabs(numVal[01;31m-[00manalVal)/avg);
energyFunction.cc:103:    this[01;31m-[00m>Base::initialize();
energyFunction.cc:104:    this[01;31m-[00m>_NonbondCrossTermTable = O_FFNonbondCrossTermTable::nil(this[01;31m-[00m>lisp());
energyFunction.cc:105:    this[01;31m-[00m>_AtomTable = O_AtomTable::create(this[01;31m-[00m>lisp());
energyFunction.cc:106:    this[01;31m-[00m>_Stretch = O_EnergyStretch::create(this[01;31m-[00m>lisp());
energyFunction.cc:108:    this[01;31m-[00m>_Angle = O_EnergyAngle::create(this[01;31m-[00m>lisp());
energyFunction.cc:109:    this[01;31m-[00m>_Dihedral = O_EnergyDihedral::create(this[01;31m-[00m>lisp());
energyFunction.cc:110:    this[01;31m-[00m>_Nonbond = O_EnergyNonbond::create(this[01;31m-[00m>lisp());
energyFunction.cc:111:    this[01;31m-[00m>_ChiralRestraint = O_EnergyChiralRestraint::create(this[01;31m-[00m>lisp());
energyFunction.cc:112:    this[01;31m-[00m>_AnchorRestraint = O_EnergyAnchorRestraint::create(this[01;31m-[00m>lisp());
energyFunction.cc:113:    this[01;31m-[00m>_ImproperRestraint = O_EnergyImproperRestraint::create(this[01;31m-[00m>lisp());
energyFunction.cc:114:    this[01;31m-[00m>_FixedNonbondRestraint = O_EnergyFixedNonbondRestraint::create(this[01;31m-[00m>lisp());
energyFunction.cc:116:    this[01;31m-[00m>setName("");
energyFunction.cc:117:    this[01;31m-[00m>_Message = "";
energyFunction.cc:118:    this[01;31m-[00m>useDefaultSettings();
energyFunction.cc:123:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:124:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
energyFunction.cc:129:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:130:    ASSERT_NOT_NULL(this[01;31m-[00m>_Stretch);
energyFunction.cc:131:    ASSERT_NOT_NULL(this[01;31m-[00m>_Stretch);
energyFunction.cc:132:    ASSERT(this[01;31m-[00m>_Stretch[01;31m-[00m>notNil());
energyFunction.cc:133:    this[01;31m-[00m>_Stretch[01;31m-[00m>initialize();
energyFunction.cc:135:    ASSERT_NOT_NULL(this[01;31m-[00m>_Angle);
energyFunction.cc:136:    ASSERT(this[01;31m-[00m>_Angle[01;31m-[00m>notNil());
energyFunction.cc:137:    ASSERT_NOT_NULL(this[01;31m-[00m>_Dihedral);
energyFunction.cc:138:    ASSERT(this[01;31m-[00m>_Dihedral[01;31m-[00m>notNil());
energyFunction.cc:139:    ASSERT_NOT_NULL(this[01;31m-[00m>_Nonbond);
energyFunction.cc:140:    ASSERT(this[01;31m-[00m>_Nonbond[01;31m-[00m>notNil());
energyFunction.cc:141:    ASSERT_NOT_NULL(this[01;31m-[00m>_ChiralRestraint);
energyFunction.cc:142:    ASSERT(this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>notNil());
energyFunction.cc:143:    ASSERT_NOT_NULL(this[01;31m-[00m>_AnchorRestraint);
energyFunction.cc:144:    ASSERT(this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>notNil());
energyFunction.cc:145:    ASSERT_NOT_NULL(this[01;31m-[00m>_ImproperRestraint);
energyFunction.cc:146:    ASSERT(this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>notNil());
energyFunction.cc:147:    ASSERT_NOT_NULL(this[01;31m-[00m>_FixedNonbondRestraint);
energyFunction.cc:148:    ASSERT(this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>notNil());
energyFunction.cc:149:    this[01;31m-[00m>_Angle[01;31m-[00m>initialize();
energyFunction.cc:150:    this[01;31m-[00m>_Dihedral[01;31m-[00m>initialize();
energyFunction.cc:151:    this[01;31m-[00m>_Nonbond[01;31m-[00m>initialize();
energyFunction.cc:152:    this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>initialize();
energyFunction.cc:153:    this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>initialize();
energyFunction.cc:154:    this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>initialize();
energyFunction.cc:155:    this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>initialize();
energyFunction.cc:157:    this[01;31m-[00m>_ChiralRestraintWeight = DefaultChiralRestraintWeight;
energyFunction.cc:158:    this[01;31m-[00m>_ChiralRestraintOffset = DefaultChiralRestraintOffset;
energyFunction.cc:159:    this[01;31m-[00m>_AnchorRestraintWeight = DefaultAnchorRestraintWeight;
energyFunction.cc:160:    this[01;31m-[00m>_RestrainSecondaryAmides = true;
energyFunction.cc:170:    node[01;31m-[00m>attribute("_Name",this[01;31m-[00m>_Name);
energyFunction.cc:171:    node[01;31m-[00m>archiveObject("_Matter",this[01;31m-[00m>_Matter);
energyFunction.cc:172:    node[01;31m-[00m>archiveObject("_AtomTable",this[01;31m-[00m>_AtomTable );
energyFunction.cc:173://    node[01;31m-[00m>archiveSharedObject<Dumb_StretchComponent>("_Stretch","StretchTerms",this[01;31m-[00m>_Stretch);
energyFunction.cc:174://    node[01;31m-[00m>archiveSharedObject<Dumb_AngleComponent>("_Angle","AngleTerms",this[01;31m-[00m>_Angle);
energyFunction.cc:175://    node[01;31m-[00m>archiveSharedObject<Dumb_DihedralComponent>("_Dihedral","DihedralTerms",this[01;31m-[00m>_Dihedral);
energyFunction.cc:176://    node[01;31m-[00m>archiveSharedObject<Dumb_ImproperRestraintComponent>("_ImproperRestraint","ImproperRestraintTerms",this[01;31m-[00m>_ImproperRestraint);
energyFunction.cc:177://    node[01;31m-[00m>archiveSharedObject<Dumb_ChiralRestraintComponent>("_ChiralRestraint","ChiralRestraintTerms",this[01;31m-[00m>_ChiralRestraint);
energyFunction.cc:178://    node[01;31m-[00m>archiveSharedObject<Dumb_AnchorRestraintComponent>("_AnchorRestraint","AnchorRestraintTerms",this[01;31m-[00m>_AnchorRestraint);
energyFunction.cc:179://    node[01;31m-[00m>archiveSharedObject<Dumb_NonbondComponent>("_Nonbond","NonbondTerms",this[01;31m-[00m>_Nonbond);
energyFunction.cc:180:    node[01;31m-[00m>archiveObject("_Stretch",this[01;31m-[00m>_Stretch);
energyFunction.cc:182:    node[01;31m-[00m>archiveObject("_Angle",this[01;31m-[00m>_Angle);
energyFunction.cc:183:    node[01;31m-[00m>archiveObject("_Dihedral",this[01;31m-[00m>_Dihedral);
energyFunction.cc:184:    node[01;31m-[00m>archiveObject("_Nonbond",this[01;31m-[00m>_Nonbond);
energyFunction.cc:185:    node[01;31m-[00m>archiveObject("_ImproperRestraint",this[01;31m-[00m>_ImproperRestraint);
energyFunction.cc:186:    node[01;31m-[00m>archiveObject("_ChiralRestraint",this[01;31m-[00m>_ChiralRestraint);
energyFunction.cc:187:    node[01;31m-[00m>archiveObject("_AnchorRestraint",this[01;31m-[00m>_AnchorRestraint);
energyFunction.cc:188:    node[01;31m-[00m>archiveObject("_FixedNonbondRestraint",this[01;31m-[00m>_FixedNonbondRestraint);
energyFunction.cc:190:    node[01;31m-[00m>attribute("_ChiralRestraintWeight",this[01;31m-[00m>_ChiralRestraintWeight);
energyFunction.cc:191:    node[01;31m-[00m>attribute("_ChiralRestraintOffset",this[01;31m-[00m>_ChiralRestraintOffset);
energyFunction.cc:192:    node[01;31m-[00m>attribute("_AnchorRestraintWeight",this[01;31m-[00m>_AnchorRestraintWeight);
energyFunction.cc:193:    node[01;31m-[00m>attribute("_TotalEnergy",this[01;31m-[00m>_TotalEnergy);
energyFunction.cc:194:    node[01;31m-[00m>archiveString("_Message",this[01;31m-[00m>_Message);
energyFunction.cc:195:    node[01;31m-[00m>attribute("_DielectricConstant",this[01;31m-[00m>_DielectricConstant);
energyFunction.cc:203:    return this[01;31m-[00m>_AtomTable[01;31m-[00m>getNVectorSize();
energyFunction.cc:209:    return this[01;31m-[00m>_Dihedral[01;31m-[00m>getEnergy();
energyFunction.cc:214:    return this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>getEnergy();
energyFunction.cc:230:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:232:    RPBinder binder = O_Binder::createFromKeywordCons(options,validOptions,this[01;31m-[00m>lisp());
energyFunction.cc:234:    if ( binder[01;31m-[00m>contains(this[01;31m-[00m>lisp()[01;31m-[00m>predefinedSymbol(_sym_kw_nonbondTerm)) )
energyFunction.cc:236:	bool onval = binder[01;31m-[00m>lookup(this[01;31m-[00m>lisp()[01;31m-[00m>predefinedSymbol(_sym_kw_nonbondTerm))[01;31m-[00m>as<O_Bool>()[01;31m-[00m>get();
energyFunction.cc:238:	if ( onval ) this[01;31m-[00m>getNonbondComponent()[01;31m-[00m>enable();
energyFunction.cc:239:	else	this[01;31m-[00m>getNonbondComponent()[01;31m-[00m>disable();
energyFunction.cc:242:    if ( binder[01;31m-[00m>contains(this[01;31m-[00m>lisp()[01;31m-[00m>predefinedSymbol(_sym_kw_restraintAnchor) ))
energyFunction.cc:244:	bool onval = binder[01;31m-[00m>lookup(this[01;31m-[00m>lisp()[01;31m-[00m>predefinedSymbol(_sym_kw_restraintAnchor))[01;31m-[00m>as<O_Bool>()[01;31m-[00m>get();
energyFunction.cc:246:	if ( onval ) this[01;31m-[00m>getAnchorRestraintComponent()[01;31m-[00m>enable();
energyFunction.cc:247:	else	this[01;31m-[00m>getAnchorRestraintComponent()[01;31m-[00m>disable();
energyFunction.cc:255:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFunction.cc:256:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFunction.cc:257:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFunction.cc:258:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFunction.cc:259:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFunction.cc:271:	string	getError() { return "FiniteDifferenceMismatch"; } //  @"+this[01;31m-[00m>functionName()+" term:("+this[01;31m-[00m>termName+")";
energyFunction.cc:282:	double eLow = this[01;31m-[00m>func argLow;\
energyFunction.cc:283:	double eHigh = this[01;31m-[00m>func argHigh;\
energyFunction.cc:284:	double numForce = [01;31m-[00m(eHigh[01;31m-[00meLow)/(delta);\
energyFunction.cc:290:	double eLow = this[01;31m-[00m>func argLow;\
energyFunction.cc:291:	double eMiddle = this[01;31m-[00m>func argMiddle;\
energyFunction.cc:292:	double eHigh = this[01;31m-[00m>func argHigh;\
energyFunction.cc:293:	double numHessian = (eHigh+eLow[01;31m-[00m2.0*eMiddle)/(((delta)/2.0)*((delta)/2.0));\
energyFunction.cc:299:	double eMM = this[01;31m-[00m>func argMM;\
energyFunction.cc:300:	double eMP = this[01;31m-[00m>func argMP;\
energyFunction.cc:301:	double ePM = this[01;31m-[00m>func argPM;\
energyFunction.cc:302:	double ePP = this[01;31m-[00m>func argPP;\
energyFunction.cc:303:	double numHessian = ((ePP[01;31m-[00mePM)[01;31m-[00m(eMP[01;31m-[00meMM))/(delta*delta);\
energyFunction.cc:316:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:317:    _lisp[01;31m-[00m>profiler().timer(timerPreconditioner).start();
energyFunction.cc:318:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSetup).start();
energyFunction.cc:320:    m[01;31m-[00m>fill(0.0);
energyFunction.cc:322:    this[01;31m-[00m>_Stretch[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:324:    this[01;31m-[00m>_Angle[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:325:    this[01;31m-[00m>_Dihedral[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:327://    this[01;31m-[00m>_Nonbond[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:328:    this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:329:    this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:330:    this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:331://    this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:334:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSetup).stop();
energyFunction.cc:335:    _lisp[01;31m-[00m>profiler().timer(timerPreconditioner).stop();
energyFunction.cc:348:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Should there be something here?"));
energyFunction.cc:368:{_F(this[01;31m-[00m>lisp())
energyFunction.cc:373:        force[01;31m-[00m>setElement((i)+(o),(v)+force[01;31m-[00m>getElement((i)+(o)));\
energyFunction.cc:382:	    hessian[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyFunction.cc:385:	    hdvec[01;31m-[00m>addToElement((i1)+(o1),v*dvec[01;31m-[00m>element((i2)+(o2)));\
energyFunction.cc:386:	    hdvec[01;31m-[00m>addToElement((i2)+(o2),v*dvec[01;31m-[00m>element((i1)+(o1)));\
energyFunction.cc:395:	    hessian[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyFunction.cc:398:	    hdvec[01;31m-[00m>addToElement((i1)+(o1),v*dvec[01;31m-[00m>element((i1)+(o1)));\
energyFunction.cc:407:bool	hasForce = force[01;31m-[00m>notNil();
energyFunction.cc:408:bool	hasHessian = hessian[01;31m-[00m>notNil();
energyFunction.cc:409:bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
energyFunction.cc:419:    if ( hasForce && force[01;31m-[00m>size() < pos[01;31m-[00m>size() ) {
energyFunction.cc:420:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Force does not have the necessary dimensions"));
energyFunction.cc:425:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Inconsistant arguments: if you want to calcDiagonalHessian or calcOffDiagonalHessian you must calcForce"));
energyFunction.cc:428:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Inconsistant arguments: if you want to calcOffDiagonalHessian you must calcDiagonalHessian"));
energyFunction.cc:431:    _lisp[01;31m-[00m>profiler().pushTimerStates();
energyFunction.cc:435:	if ( hasForce ) force[01;31m-[00m>zero();
energyFunction.cc:436:	if ( hasHessian ) hessian[01;31m-[00m>zero();
energyFunction.cc:439:	    hdvec[01;31m-[00m>zero();	// Zero the result
energyFunction.cc:443:	_lisp[01;31m-[00m>profiler().timer(timerEnergy).start();
energyFunction.cc:445:	_lisp[01;31m-[00m>profiler().timer(timerBondAngleDihedral).start();
energyFunction.cc:450:	_lisp[01;31m-[00m>profiler().timer(timerBond).start();
energyFunction.cc:451:        this[01;31m-[00m>_Stretch[01;31m-[00m>evaluateAll( pos, calcForce, force,
energyFunction.cc:455:	_lisp[01;31m-[00m>profiler().timer(timerBond).stop();
energyFunction.cc:457:	_lisp[01;31m-[00m>profiler().timer(timerAngle).start();
energyFunction.cc:458:        this[01;31m-[00m>_Angle[01;31m-[00m>evaluateAll( pos, calcForce, force,
energyFunction.cc:462:	_lisp[01;31m-[00m>profiler().timer(timerAngle).stop();
energyFunction.cc:464:	_lisp[01;31m-[00m>profiler().timer(timerDihedral).start();
energyFunction.cc:465:        this[01;31m-[00m>_Dihedral[01;31m-[00m>evaluateAll( pos, calcForce, force,
energyFunction.cc:469:	_lisp[01;31m-[00m>profiler().timer(timerDihedral).stop();
energyFunction.cc:470:	_lisp[01;31m-[00m>profiler().timer(timerBondAngleDihedral).stop();
energyFunction.cc:472:	_lisp[01;31m-[00m>profiler().timer(timerNonbond).start();
energyFunction.cc:473:        this[01;31m-[00m>_Nonbond[01;31m-[00m>evaluateAll( pos, calcForce, force,
energyFunction.cc:475:	_lisp[01;31m-[00m>profiler().timer(timerNonbond).stop();
energyFunction.cc:477:	_lisp[01;31m-[00m>profiler().timer(timerImproperRestraint).start();
energyFunction.cc:478:        this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>evaluateAll( pos, calcForce, force,
energyFunction.cc:480:	_lisp[01;31m-[00m>profiler().timer(timerImproperRestraint).stop();
energyFunction.cc:482:	_lisp[01;31m-[00m>profiler().timer(timerChiralRestraint).start();
energyFunction.cc:483:        this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>evaluateAll( pos, calcForce, force,
energyFunction.cc:485:	_lisp[01;31m-[00m>profiler().timer(timerChiralRestraint).stop();
energyFunction.cc:487:	_lisp[01;31m-[00m>profiler().timer(timerAnchorRestraint).start();
energyFunction.cc:488:        this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>evaluateAll( pos, calcForce, force,
energyFunction.cc:490:	_lisp[01;31m-[00m>profiler().timer(timerAnchorRestraint).stop();
energyFunction.cc:492:	_lisp[01;31m-[00m>profiler().timer(timerFixedNonbondRestraint).start();
energyFunction.cc:493:        this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>evaluateAll( pos, calcForce, force,
energyFunction.cc:495:	_lisp[01;31m-[00m>profiler().timer(timerFixedNonbondRestraint).stop();
energyFunction.cc:497:	this[01;31m-[00m>_TotalEnergy = this[01;31m-[00m>_Stretch[01;31m-[00m>getEnergy();
energyFunction.cc:499:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_Angle[01;31m-[00m>getEnergy();
energyFunction.cc:500:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_Dihedral[01;31m-[00m>getEnergy();
energyFunction.cc:501:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_Nonbond[01;31m-[00m>getEnergy();
energyFunction.cc:502:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>getEnergy();
energyFunction.cc:503:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>getEnergy();
energyFunction.cc:504:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>getEnergy();
energyFunction.cc:505:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>getEnergy();
energyFunction.cc:508:	_lisp[01;31m-[00m>profiler().timer(timerEnergy).stop();
energyFunction.cc:511:        _lisp[01;31m-[00m>profiler().popTimerStates();
energyFunction.cc:512:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Interaction problem: %s")% ld.message() ));
energyFunction.cc:514:    _lisp[01;31m-[00m>profiler().popTimerStates();
energyFunction.cc:517:    return this[01;31m-[00m>_TotalEnergy;
energyFunction.cc:522:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:524:    ss << boost::format("Stretch(%lf)") % this[01;31m-[00m>_Stretch[01;31m-[00m>getEnergy() << endl;
energyFunction.cc:526:    ss << boost::format("Angle(%lf)") % this[01;31m-[00m>_Angle[01;31m-[00m>getEnergy() << endl;
energyFunction.cc:527:    ss << boost::format("Dihedral(%lf)") % this[01;31m-[00m>_Dihedral[01;31m-[00m>getEnergy() << endl;
energyFunction.cc:528:    ss << boost::format("Nonbond(%lf)") % this[01;31m-[00m>_Nonbond[01;31m-[00m>getEnergy() << endl;
energyFunction.cc:529:    ss << boost::format("ChiralRestraint(%lf)") % this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>getEnergy() << endl;
energyFunction.cc:530:    ss << boost::format("ImproperRestraint(%lf)") % this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>getEnergy() << endl;
energyFunction.cc:531:    ss << boost::format("AnchorRestraint(%lf)") % this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>getEnergy() << endl;
energyFunction.cc:532:    ss << boost::format("FixedNonbondRestraint(%lf)") % this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>getEnergy() << endl;
energyFunction.cc:548:        this[01;31m-[00m>_Stretch[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:550:        this[01;31m-[00m>_Angle[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:551:        this[01;31m-[00m>_Dihedral[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:552:        this[01;31m-[00m>_Nonbond[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:553:        this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:554:        this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:555:        this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:556:        this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:571:    RPNVector pos = O_NVector::create(this[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
energyFunction.cc:572:    this[01;31m-[00m>extractCoordinatesFromAtoms(pos);
energyFunction.cc:573:    return this[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:587:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:593:    pos = O_NVector::create(this[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
energyFunction.cc:594:    this[01;31m-[00m>extractCoordinatesFromAtoms(pos);
energyFunction.cc:596:    fails += this[01;31m-[00m>_Stretch[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:598:    fails += this[01;31m-[00m>_Angle[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:599:    fails += this[01;31m-[00m>_Dihedral[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:600:    fails += this[01;31m-[00m>_Nonbond[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:601:    fails += this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:602:    fails += this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:603:    fails += this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:604:    fails += this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:607:    this[01;31m-[00m>_Message = info.str();
energyFunction.cc:615:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFunction.cc:616:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFunction.cc:617:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyFunction.cc:627:    ss << this[01;31m-[00m>_Stretch[01;31m-[00m>enabledAsString();
energyFunction.cc:629:    ss << this[01;31m-[00m>_Angle[01;31m-[00m>enabledAsString();
energyFunction.cc:630:    ss << this[01;31m-[00m>_Dihedral[01;31m-[00m>enabledAsString();
energyFunction.cc:631:    ss << this[01;31m-[00m>_Nonbond[01;31m-[00m>enabledAsString();
energyFunction.cc:632:    ss << this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>enabledAsString();
energyFunction.cc:633:    ss << this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>enabledAsString();
energyFunction.cc:634:    ss << this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>enabledAsString();
energyFunction.cc:635:    ss << this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>enabledAsString();
energyFunction.cc:661:    dummyMatrix = O_AbstractLargeSquareMatrix::nil(this[01;31m-[00m>lisp());
energyFunction.cc:662:    dummyForce = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:663:    dummyHd = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:664:    dummyD = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:665:    energy = this[01;31m-[00m>evaluateAll(pos,
energyFunction.cc:675:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:681:    dummyMatrix = O_AbstractLargeSquareMatrix::nil(this[01;31m-[00m>lisp());
energyFunction.cc:682:    dummyHd = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:683:    dummyD = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:687:	rawGrad = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:689:    energy = this[01;31m-[00m>evaluateAll(pos,calcForce, rawGrad, false, false, dummyMatrix,
energyFunction.cc:705:    dummyHd = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:706:    dummyD = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:708:    else rawGrad = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:709:    energy = this[01;31m-[00m>evaluateAll( pos,
energyFunction.cc:724:    dummyHd = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:725:    dummyD = O_NVector::nil(this[01;31m-[00m>lisp());
energyFunction.cc:726:    pos = O_NVector::create(this[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
energyFunction.cc:727:    force = O_NVector::create(this[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
energyFunction.cc:728:    hessian = O_FullLargeSquareMatrix::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>getNVectorSize(),SymmetricDiagonalLower);
energyFunction.cc:729:    this[01;31m-[00m>extractCoordinatesFromAtoms(pos);
energyFunction.cc:730:    energy = this[01;31m-[00m>evaluateAll(pos, true, force,
energyFunction.cc:746:    x = pos[01;31m-[00m>element(i);
energyFunction.cc:747:    pos[01;31m-[00m>setElement(i,x[01;31m-[00mdeltaDiv2);
energyFunction.cc:748:    ylow = this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:749:    pos[01;31m-[00m>setElement(i,x+deltaDiv2);
energyFunction.cc:750:    yhigh = this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:751:    pos[01;31m-[00m>setElement(i,x);
energyFunction.cc:752:    fval = (yhigh[01;31m-[00mylow)/delta;
energyFunction.cc:758:{_TF(this[01;31m-[00m>lisp(),BF("O_EnergyFunction::calculateNumericalSecondDerivative for r,c=%d,%d") % i % j );
energyFunction.cc:762:        x = pos[01;31m-[00m>element(i);
energyFunction.cc:763:    	pos[01;31m-[00m>setElement(i,x[01;31m-[00mdelta);
energyFunction.cc:764:	fxmh = this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:765:	pos[01;31m-[00m>setElement(i,x+delta);
energyFunction.cc:766:	fxph = this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:767:	pos[01;31m-[00m>setElement(i,x);
energyFunction.cc:768:	fx = this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:769:	f2 = (fxph+fxmh[01;31m-[00m2.0*(fx))/(delta*delta);
energyFunction.cc:772:	x = pos[01;31m-[00m>element(i);
energyFunction.cc:773:	y = pos[01;31m-[00m>element(j);
energyFunction.cc:774:	pos[01;31m-[00m>setElement(i,x+deltaDiv2);
energyFunction.cc:775:	pos[01;31m-[00m>setElement(j,y+deltaDiv2);
energyFunction.cc:776:	fpipj = this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:777:	pos[01;31m-[00m>setElement(i,x+deltaDiv2);
energyFunction.cc:778:	pos[01;31m-[00m>setElement(j,y[01;31m-[00mdeltaDiv2);
energyFunction.cc:779:	fpimj = this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:780:	pos[01;31m-[00m>setElement(i,x[01;31m-[00mdeltaDiv2);
energyFunction.cc:781:	pos[01;31m-[00m>setElement(j,y+deltaDiv2);
energyFunction.cc:782:	fmipj = this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:783:	pos[01;31m-[00m>setElement(i,x[01;31m-[00mdeltaDiv2);
energyFunction.cc:784:	pos[01;31m-[00m>setElement(j,y[01;31m-[00mdeltaDiv2);
energyFunction.cc:785:	fmimj = this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:786:	pos[01;31m-[00m>setElement(i,x);
energyFunction.cc:787:	pos[01;31m-[00m>setElement(j,y);
energyFunction.cc:792:	fp = (fpipj[01;31m-[00mfpimj)/delta;
energyFunction.cc:793:	fm = (fmipj[01;31m-[00mfmimj)/delta;
energyFunction.cc:796:	f2 = (fp[01;31m-[00mfm)/delta;
energyFunction.cc:812:    for (i=0; i<pos[01;31m-[00m>size(); i++ ) {
energyFunction.cc:813:	fval = [01;31m-[00mthis[01;31m-[00m>calculateNumericalDerivative(pos,delta,i);
energyFunction.cc:814:	numForce[01;31m-[00m>setElement(i,fval);
energyFunction.cc:826:    if ( hessian[01;31m-[00m>columns() != pos[01;31m-[00m>size() || hessian[01;31m-[00m>rows()!=pos[01;31m-[00m>size() ) {
energyFunction.cc:827:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("evaluateNumericalHessian must have the right size")));
energyFunction.cc:829:    hessian[01;31m-[00m>zero();
energyFunction.cc:830:    for ( c=0; c<pos[01;31m-[00m>size(); c++ ) {
energyFunction.cc:831:	fval = this[01;31m-[00m>calculateNumericalSecondDerivative(pos,delta,c,c);
energyFunction.cc:832:	hessian[01;31m-[00m>setElement(c,c,fval);
energyFunction.cc:835:    for ( c=0; c<pos[01;31m-[00m>size(); c++ ) {
energyFunction.cc:836:	for ( r=0; r<pos[01;31m-[00m>size(); r++ ) {
energyFunction.cc:838:	        fval = this[01;31m-[00m>calculateNumericalSecondDerivative(pos,delta,c,r);
energyFunction.cc:839:	        hessian[01;31m-[00m>setElement(c,r,fval);
energyFunction.cc:850: * If there is a mis[01;31m-[00mmatch then dump the EnergyFunction into the result.
energyFunction.cc:861:    report = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ForceMatchReport>();
energyFunction.cc:863:    numForce = O_NVector::create(pos[01;31m-[00m>size(),this[01;31m-[00m>lisp());
energyFunction.cc:864:    this[01;31m-[00m>evaluateNumericalForce(pos,numForce,DELTA);
energyFunction.cc:865:    dot = numForce[01;31m-[00m>dotProduct(analyticalForce);
energyFunction.cc:866:    numericalMag = numForce[01;31m-[00m>magnitude();
energyFunction.cc:867:    analyticalMag = analyticalForce[01;31m-[00m>magnitude();
energyFunction.cc:868:    tempForce = O_NVector::create(pos[01;31m-[00m>size(),this[01;31m-[00m>lisp());
energyFunction.cc:870:    this[01;31m-[00m>evaluateEnergyForce(pos,true,tempForce);
energyFunction.cc:875:	report[01;31m-[00m>_Message = result.str();
energyFunction.cc:881:	report[01;31m-[00m>_Message = result.str();
energyFunction.cc:887:	report[01;31m-[00m>_Message = result.str();
energyFunction.cc:891:	report[01;31m-[00m>_Message = "average of Analytical & Numerical Forces is VERY small";
energyFunction.cc:898:    report[01;31m-[00m>_AnalyticalForce = analyticalForce;
energyFunction.cc:899:    report[01;31m-[00m>_NumericalForce = numForce;
energyFunction.cc:900:    if ( fabs(analyticalMag[01;31m-[00mnumericalMag)/avg >0.1 ) {
energyFunction.cc:905:	report[01;31m-[00m>_Message = result.str();
energyFunction.cc:906:	this[01;31m-[00m>writeCoordinatesAndForceToAtoms(pos,analyticalForce);
energyFunction.cc:914:	report[01;31m-[00m>_Message = result.str();
energyFunction.cc:915:	this[01;31m-[00m>writeCoordinatesAndForceToAtoms(pos,analyticalForce);
energyFunction.cc:918:    report[01;31m-[00m>_Message = "Analytical and Numerical forces are virtually identical";
energyFunction.cc:931:    this[01;31m-[00m>_AtomTable[01;31m-[00m>dumpTerms();
energyFunction.cc:932:    this[01;31m-[00m>_Stretch[01;31m-[00m>dumpTerms();
energyFunction.cc:934:    this[01;31m-[00m>_Angle[01;31m-[00m>dumpTerms();
energyFunction.cc:935:    this[01;31m-[00m>_Dihedral[01;31m-[00m>dumpTerms();
energyFunction.cc:936:    this[01;31m-[00m>_Nonbond[01;31m-[00m>dumpTerms();
energyFunction.cc:937:    this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>dumpTerms();
energyFunction.cc:938:    this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>dumpTerms();
energyFunction.cc:939:    this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>dumpTerms();
energyFunction.cc:940:    this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>dumpTerms();
energyFunction.cc:948:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:950:    restraintIterator[01;31m-[00m>first();
energyFunction.cc:951:    while ( restraintIterator[01;31m-[00m>notDone() )
energyFunction.cc:953:	RPRestraint restraint = restraintIterator[01;31m-[00m>current<O_Restraint>();
energyFunction.cc:954:	if ( restraint[01;31m-[00m>isOfClass<O_RestraintDihedral>() )
energyFunction.cc:958:	    energyTerm._Atom1 = dih[01;31m-[00m>getAtomA();
energyFunction.cc:959:	    energyTerm._Atom2 = dih[01;31m-[00m>getAtomB();
energyFunction.cc:960:	    energyTerm._Atom3 = dih[01;31m-[00m>getAtomC();
energyFunction.cc:961:	    energyTerm._Atom4 = dih[01;31m-[00m>getAtomD();
energyFunction.cc:962:	    EnergyAtom* ea1 = this[01;31m-[00m>getEnergyAtomPointer(dih[01;31m-[00m>getAtomA()[01;31m-[00m>getTempInt());
energyFunction.cc:963:	    EnergyAtom* ea2 = this[01;31m-[00m>getEnergyAtomPointer(dih[01;31m-[00m>getAtomB()[01;31m-[00m>getTempInt());
energyFunction.cc:964:	    EnergyAtom* ea3 = this[01;31m-[00m>getEnergyAtomPointer(dih[01;31m-[00m>getAtomC()[01;31m-[00m>getTempInt());
energyFunction.cc:965:	    EnergyAtom* ea4 = this[01;31m-[00m>getEnergyAtomPointer(dih[01;31m-[00m>getAtomD()[01;31m-[00m>getTempInt());
energyFunction.cc:966:	    energyTerm.term.I1 = ea1[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:967:	    energyTerm.term.I2 = ea2[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:968:	    energyTerm.term.I3 = ea3[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:969:	    energyTerm.term.I4 = ea4[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:970:	    energyTerm.term.U = dih[01;31m-[00m>getMaxDegrees()*0.0174533;
energyFunction.cc:971:	    energyTerm.term.L = dih[01;31m-[00m>getMinDegrees()*0.0174533;
energyFunction.cc:972:	    energyTerm.term.K = dih[01;31m-[00m>getWeight();
energyFunction.cc:973:	    this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>addTerm(energyTerm);
energyFunction.cc:974:	} else if ( restraint[01;31m-[00m>isOfClass<O_RestraintAnchor>() )
energyFunction.cc:979:	    RPAtom a1 = anchor[01;31m-[00m>getAtom();
energyFunction.cc:980:	    EnergyAtom* ea1 = this[01;31m-[00m>getEnergyAtomPointer(a1[01;31m-[00m>getTempInt());
energyFunction.cc:981:	    LOG(BF("Create an anchor restraint for %s") % a1[01;31m-[00m>description().c_str()  ); // vp0(( "Create an anchor restraint for %s",a1[01;31m-[00m>description().c_str() ));
energyFunction.cc:982:	    anchorPos = anchor[01;31m-[00m>getAnchorPos();
energyFunction.cc:986:	    iterm.term.ka = this[01;31m-[00m>_AnchorRestraintWeight;
energyFunction.cc:987:	    iterm.term.I1 = ea1[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:988:	    this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>addTerm(iterm);
energyFunction.cc:989:	} else if ( restraint[01;31m-[00m>isOfClass<O_RestraintFixedNonbond>() )
energyFunction.cc:991:	    this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>setupForEvaluation(this[01;31m-[00m>_AtomTable,this[01;31m-[00m>_NonbondCrossTermTable);
energyFunction.cc:992:	    RPRestraintFixedNonbond fixedNonbond = restraint[01;31m-[00m>as<O_RestraintFixedNonbond>();
energyFunction.cc:993:	    RPMatter matter = fixedNonbond[01;31m-[00m>getMatter();
energyFunction.cc:994:	    RPFFNonbondDb nonbondDb = forceField[01;31m-[00m>getNonbondDb();
energyFunction.cc:1003:		    if ( a1[01;31m-[00m>isAssignableTo<O_VirtualAtom>() ) continue; // skip virtuals
energyFunction.cc:1004:		    this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>addFixedAtom(nonbondDb,a1);
energyFunction.cc:1011:	restraintIterator[01;31m-[00m>next();
energyFunction.cc:1024:    EnergyAtom* ea1 = this[01;31m-[00m>getEnergyAtomPointer(energyTerm._Atom1[01;31m-[00m>getTempInt());
energyFunction.cc:1025:    EnergyAtom* ea2 = this[01;31m-[00m>getEnergyAtomPointer(energyTerm._Atom2[01;31m-[00m>getTempInt());
energyFunction.cc:1026:    EnergyAtom* ea3 = this[01;31m-[00m>getEnergyAtomPointer(energyTerm._Atom3[01;31m-[00m>getTempInt());
energyFunction.cc:1027:    EnergyAtom* ea4 = this[01;31m-[00m>getEnergyAtomPointer(energyTerm._Atom4[01;31m-[00m>getTempInt());
energyFunction.cc:1028:    energyTerm.term.I1 = ea1[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1029:    energyTerm.term.I2 = ea2[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1030:    energyTerm.term.I3 = ea3[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1031:    energyTerm.term.I4 = ea4[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1035:    this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>addTerm(energyTerm);
energyFunction.cc:1040:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:1042:    double transMin = [01;31m-[00m160.0;
energyFunction.cc:1045:    double cisMax = [01;31m-[00m20.0;
energyFunction.cc:1049:	if ( secondaryAmide[01;31m-[00m>matches(*ni) )
energyFunction.cc:1051:	    RPChemInfoMatch match = secondaryAmide[01;31m-[00m>getMatch();
energyFunction.cc:1052:	    RPAtom ax = match[01;31m-[00m>tag("1");
energyFunction.cc:1053:	    RPAtom ax1 = match[01;31m-[00m>tag("2");
energyFunction.cc:1054:	    RPAtom ax2 = match[01;31m-[00m>tag("3");
energyFunction.cc:1055:	    RPAtom ay = match[01;31m-[00m>tag("4");	// Carbonyl carbon
energyFunction.cc:1056:	    RPAtom ay1 = match[01;31m-[00m>tag("5");
energyFunction.cc:1057:	    RPAtom ay2 = match[01;31m-[00m>tag("6");
energyFunction.cc:1066:	    if ( ay[01;31m-[00m>getRingMembershipCount() > 0 )
energyFunction.cc:1072:	    LOG(BF("Applying a secondary amide restraint between %s and %s") % ax[01;31m-[00m>description().c_str() % ay[01;31m-[00m>description().c_str()  ); // vp0(( "Applying a secondary amide restraint between %s and %s", ax[01;31m-[00m>description().c_str(), ay[01;31m-[00m>description().c_str() ));
energyFunction.cc:1075:	    this[01;31m-[00m>_applyDihedralRestraint(ax1,ax,ay,ay1,cisMin,cisMax,weight);
energyFunction.cc:1076:	    LOG(BF("Restrain cis %s [01;31m-[00m %s [01;31m-[00m %s [01;31m-[00m%s") % ax1[01;31m-[00m>description().c_str() % ax[01;31m-[00m>description().c_str() % ay[01;31m-[00m>description().c_str() % ay1[01;31m-[00m>description().c_str()  ); // vp0(( "Restrain cis %s [01;31m-[00m %s [01;31m-[00m %s [01;31m-[00m%s", ax1[01;31m-[00m>description().c_str(), ax[01;31m-[00m>description().c_str(), ay[01;31m-[00m>description().c_str(), ay1[01;31m-[00m>description().c_str() ));
energyFunction.cc:1077:	    this[01;31m-[00m>_applyDihedralRestraint(ax1,ax,ay,ay2,transMin,transMax,weight);
energyFunction.cc:1078:	    LOG(BF("Restrain trans %s [01;31m-[00m %s [01;31m-[00m %s [01;31m-[00m%s") % ax1[01;31m-[00m>description().c_str() % ax[01;31m-[00m>description().c_str() % ay[01;31m-[00m>description().c_str() % ay2[01;31m-[00m>description().c_str()  ); // vp0(( "Restrain trans %s [01;31m-[00m %s [01;31m-[00m %s [01;31m-[00m%s", ax1[01;31m-[00m>description().c_str(), ax[01;31m-[00m>description().c_str(), ay[01;31m-[00m>description().c_str(), ay2[01;31m-[00m>description().c_str() ));
energyFunction.cc:1079:	    this[01;31m-[00m>_applyDihedralRestraint(ax2,ax,ay,ay1,transMin,transMax,weight);
energyFunction.cc:1080:	    LOG(BF("Restrain trans %s [01;31m-[00m %s [01;31m-[00m %s [01;31m-[00m%s") % ax2[01;31m-[00m>description().c_str() % ax[01;31m-[00m>description().c_str() % ay[01;31m-[00m>description().c_str() % ay1[01;31m-[00m>description().c_str()  ); // vp0(( "Restrain trans %s [01;31m-[00m %s [01;31m-[00m %s [01;31m-[00m%s", ax2[01;31m-[00m>description().c_str(), ax[01;31m-[00m>description().c_str(), ay[01;31m-[00m>description().c_str(), ay1[01;31m-[00m>description().c_str() ));
energyFunction.cc:1081:	    this[01;31m-[00m>_applyDihedralRestraint(ax2,ax,ay,ay2,cisMin,cisMax,weight);
energyFunction.cc:1082:	    LOG(BF("Restrain cis %s [01;31m-[00m %s [01;31m-[00m %s [01;31m-[00m%s") % ax2[01;31m-[00m>description().c_str() % ax[01;31m-[00m>description().c_str() % ay[01;31m-[00m>description().c_str() % ay2[01;31m-[00m>description().c_str()  ); // vp0(( "Restrain cis %s [01;31m-[00m %s [01;31m-[00m %s [01;31m-[00m%s", ax2[01;31m-[00m>description().c_str(), ax[01;31m-[00m>description().c_str(), ay[01;31m-[00m>description().c_str(), ay2[01;31m-[00m>description().c_str() ));
energyFunction.cc:1092:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:1115:	// Assign relative Cahn[01;31m-[00mIngold[01;31m-[00mPreylog priorities
energyFunction.cc:1125:    forceField[01;31m-[00m>assignTypes(matter);
energyFunction.cc:1126://    printf( "%s:%d dumping xml after assignTypes \n%s\n", __FILE__, __LINE__,matter[01;31m-[00m>asXmlString().c_str() );
energyFunction.cc:1132:    if ( !(matter[01;31m-[00m>isOfClass<O_Aggregate>() || matter[01;31m-[00m>isOfClass<O_Molecule>() ) )
energyFunction.cc:1134:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("You can only define energy functions for Aggregates or Molecules"));
energyFunction.cc:1139:    this[01;31m-[00m>_NonbondCrossTermTable = RP_Create<O_FFNonbondCrossTermTable>(this[01;31m-[00m>lisp());
energyFunction.cc:1140:    this[01;31m-[00m>_NonbondCrossTermTable[01;31m-[00m>fillUsingFFNonbondDb(forceField[01;31m-[00m>getNonbondDb());
energyFunction.cc:1146:    this[01;31m-[00m>_Matter= matter;
energyFunction.cc:1147:    this[01;31m-[00m>_DielectricConstant = 80.0;
energyFunction.cc:1148:    this[01;31m-[00m>_eraseMissingParameters();
energyFunction.cc:1157:	    if ( a1[01;31m-[00m>isAssignableTo<O_VirtualAtom>() ) continue; // skip virtuals
energyFunction.cc:1158:	    LOG(BF( "Atom = %s")% a1[01;31m-[00m>description() );
energyFunction.cc:1159:	    a1[01;31m-[00m>setTempInt(this[01;31m-[00m>_AtomTable[01;31m-[00m>getNumberOfAtoms());
energyFunction.cc:1160:	    if ( a1[01;31m-[00m>getElement() == element_N )
energyFunction.cc:1165:	    this[01;31m-[00m>_AtomTable[01;31m-[00m>add(energyAtom);
energyFunction.cc:1170:    lisp[01;31m-[00m>print(BF("%s:%d There were %d atoms") % __FILE__ % __LINE__ % this[01;31m-[00m>_AtomTable.size() );
energyFunction.cc:1173:	ASSERT_NOT_NULL(forceField[01;31m-[00m>_Stretches);
energyFunction.cc:1178:	    t1 = a1[01;31m-[00m>getTypeString();
energyFunction.cc:1179:	    t2 = a2[01;31m-[00m>getTypeString();
energyFunction.cc:1180:	    ea1 = this[01;31m-[00m>getEnergyAtomPointer(a1[01;31m-[00m>getTempInt());
energyFunction.cc:1181:	    ea2 = this[01;31m-[00m>getEnergyAtomPointer(a2[01;31m-[00m>getTempInt());
energyFunction.cc:1182:	    ffStretch  = forceField[01;31m-[00m>_Stretches[01;31m-[00m>findTerm(a1,a2);
energyFunction.cc:1184:	    if ( ffStretch[01;31m-[00m>level() != parameterized ) {
energyFunction.cc:1185:		this[01;31m-[00m>_addMissingParameter(ffStretch[01;31m-[00m>levelDescription());
energyFunction.cc:1187:	    energyStretch.defineFrom(ffStretch,ea1,ea2,this[01;31m-[00m>_Stretch[01;31m-[00m>getScale());
energyFunction.cc:1188:	    ea1[01;31m-[00m>_CloserThan15.insert(ea2[01;31m-[00m>_Atom);
energyFunction.cc:1189:	    ea2[01;31m-[00m>_CloserThan15.insert(ea1[01;31m-[00m>_Atom);
energyFunction.cc:1190:	    this[01;31m-[00m>_Stretch[01;31m-[00m>addTerm(energyStretch);
energyFunction.cc:1194:    lisp[01;31m-[00m>print(BF("%s:%d There were %d stretch terms") % __FILE__ % __LINE__ % this[01;31m-[00m>_Stretch.size() );
energyFunction.cc:1203:	    ea1 = this[01;31m-[00m>getEnergyAtomPointer(a1[01;31m-[00m>getTempInt());
energyFunction.cc:1204:	    ea2 = this[01;31m-[00m>getEnergyAtomPointer(a2[01;31m-[00m>getTempInt());
energyFunction.cc:1205:	    ea3 = this[01;31m-[00m>getEnergyAtomPointer(a3[01;31m-[00m>getTempInt());
energyFunction.cc:1206:	    ffAngle = forceField[01;31m-[00m>_Angles[01;31m-[00m>findTerm(a1,a2,a3);
energyFunction.cc:1207:	    if ( ffAngle[01;31m-[00m>level() != parameterized ) {
energyFunction.cc:1208:		LOG(BF("Missing angle parameter between types: %s[01;31m-[00m%s[01;31m-[00m%s") % a1[01;31m-[00m>getTypeString().c_str() % a2[01;31m-[00m>getTypeString().c_str() % a3[01;31m-[00m>getTypeString().c_str()  ); // vp0(( "Missing angle parameter between types: %s[01;31m-[00m%s[01;31m-[00m%s", a1[01;31m-[00m>getTypeString().c_str(), a2[01;31m-[00m>getTypeString().c_str(), a3[01;31m-[00m>getTypeString().c_str() ));
energyFunction.cc:1209:		this[01;31m-[00m>_addMissingParameter(ffAngle[01;31m-[00m>levelDescription());
energyFunction.cc:1213:	    energyAngle.defineFrom(ffAngle,ea1,ea2,ea3,this[01;31m-[00m>_Angle[01;31m-[00m>getScale());
energyFunction.cc:1214:	    ea1[01;31m-[00m>_CloserThan15.insert(ea3[01;31m-[00m>_Atom);
energyFunction.cc:1215:	    ea3[01;31m-[00m>_CloserThan15.insert(ea1[01;31m-[00m>_Atom);
energyFunction.cc:1216:	    this[01;31m-[00m>_Angle[01;31m-[00m>addTerm(energyAngle);
energyFunction.cc:1228:	    t1 = a1[01;31m-[00m>getTypeString();
energyFunction.cc:1229:	    t2 = a2[01;31m-[00m>getTypeString();
energyFunction.cc:1230:	    t3 = a3[01;31m-[00m>getTypeString();
energyFunction.cc:1231:	    t4 = a4[01;31m-[00m>getTypeString();
energyFunction.cc:1232:	    ea1 = this[01;31m-[00m>getEnergyAtomPointer(a1[01;31m-[00m>getTempInt());
energyFunction.cc:1233:	    ea2 = this[01;31m-[00m>getEnergyAtomPointer(a2[01;31m-[00m>getTempInt());
energyFunction.cc:1234:	    ea3 = this[01;31m-[00m>getEnergyAtomPointer(a3[01;31m-[00m>getTempInt());
energyFunction.cc:1235:	    ea4 = this[01;31m-[00m>getEnergyAtomPointer(a4[01;31m-[00m>getTempInt());
energyFunction.cc:1236:	    if ( !forceField[01;31m-[00m>_Ptors[01;31m-[00m>hasBestTerm(t1,t2,t3,t4) ) 
energyFunction.cc:1240:		ss << t1 << "[01;31m-[00m";
energyFunction.cc:1241:		ss << t2 << "[01;31m-[00m";
energyFunction.cc:1242:		ss << t3 << "[01;31m-[00m";
energyFunction.cc:1245:		ss << a1[01;31m-[00m>getName() << "[01;31m-[00m";
energyFunction.cc:1246:		ss << a2[01;31m-[00m>getName() << "[01;31m-[00m";
energyFunction.cc:1247:		ss << a3[01;31m-[00m>getName() << "[01;31m-[00m";
energyFunction.cc:1248:		ss << a4[01;31m-[00m>getName() << ")";
energyFunction.cc:1249:		this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % ss.str().c_str() );
energyFunction.cc:1251:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
energyFunction.cc:1252://		forceField[01;31m-[00m>_Ptors[01;31m-[00m>cantFind(t1,t2,t3,t4);
energyFunction.cc:1254://		this[01;31m-[00m>_MissingDihedralTerms.push_back(energyDihedral);
energyFunction.cc:1258:		ffPtor = forceField[01;31m-[00m>_Ptors[01;31m-[00m>findBestTerm(t1,t2,t3,t4);
energyFunction.cc:1261:		    if ( ffPtor[01;31m-[00m>_HasTerm[n[01;31m-[00m1] ) 
energyFunction.cc:1263:			LOG(BF( "Adding proper term for atoms %s[01;31m-[00m%s[01;31m-[00m%s[01;31m-[00m%s types: %s[01;31m-[00m%s[01;31m-[00m%s[01;31m-[00m%s")%
energyFunction.cc:1264:				    ea1[01;31m-[00m>getResidueAndName()
energyFunction.cc:1265:				    % ea2[01;31m-[00m>getResidueAndName()
energyFunction.cc:1266:				    % ea3[01;31m-[00m>getResidueAndName()
energyFunction.cc:1267:				    % ea4[01;31m-[00m>getResidueAndName()
energyFunction.cc:1271:			energyDihedral.defineFrom(n,ffPtor,ea1,ea2,ea3,ea4,this[01;31m-[00m>_Dihedral[01;31m-[00m>getScale());
energyFunction.cc:1272:			this[01;31m-[00m>_Dihedral[01;31m-[00m>addTerm(energyDihedral);
energyFunction.cc:1275:		if ( (ea1[01;31m-[00m>_CloserThan15.count(ea4[01;31m-[00m>_Atom)==0 &&
energyFunction.cc:1276:			ea4[01;31m-[00m>_CloserThan15.count(ea1[01;31m-[00m>_Atom)==0) ) 
energyFunction.cc:1286:		    LOG(BF("Adding 1[01;31m-[00m4 interaction %[01;31m-[00m9s[01;31m-[00m %[01;31m-[00m9s   ") % t1.c_str() % t4.c_str() ); // vp0(( "Adding 1[01;31m-[00m4 interaction %[01;31m-[00m9s[01;31m-[00m %[01;31m-[00m9s   ", t1.c_str(),t4.c_str()));
energyFunction.cc:1288:		    if ( energyNonbond.defineFrom(forceField, true, ea1, ea4, this[01;31m-[00m>_Nonbond ) ) 
energyFunction.cc:1290:		        this[01;31m-[00m>_Nonbond[01;31m-[00m>addTerm(energyNonbond);
energyFunction.cc:1301:		    LOG(BF("Ignoring 1[01;31m-[00m4 interaction %[01;31m-[00m9s[01;31m-[00m %[01;31m-[00m9s    ") % t1.c_str() % t4.c_str() ); // vp0(( "Ignoring 1[01;31m-[00m4 interaction %[01;31m-[00m9s[01;31m-[00m %[01;31m-[00m9s    ", t1.c_str(),t4.c_str()));
energyFunction.cc:1304:		ea1[01;31m-[00m>_CloserThan15.insert(ea4[01;31m-[00m>_Atom);
energyFunction.cc:1305:		ea4[01;31m-[00m>_CloserThan15.insert(ea1[01;31m-[00m>_Atom);
energyFunction.cc:1310:	aImproperCenter = O_Atom::nil(this[01;31m-[00m>lisp());
energyFunction.cc:1319:	    t1 = a1[01;31m-[00m>getTypeString();
energyFunction.cc:1320:	    t2 = a2[01;31m-[00m>getTypeString();
energyFunction.cc:1321:	    t3 = a3[01;31m-[00m>getTypeString();
energyFunction.cc:1322:	    t4 = a4[01;31m-[00m>getTypeString();
energyFunction.cc:1323:	    ea1 = this[01;31m-[00m>getEnergyAtomPointer(a1[01;31m-[00m>getTempInt());
energyFunction.cc:1324:	    ea2 = this[01;31m-[00m>getEnergyAtomPointer(a2[01;31m-[00m>getTempInt());
energyFunction.cc:1325:	    ea3 = this[01;31m-[00m>getEnergyAtomPointer(a3[01;31m-[00m>getTempInt());
energyFunction.cc:1326:	    ea4 = this[01;31m-[00m>getEnergyAtomPointer(a4[01;31m-[00m>getTempInt());
energyFunction.cc:1327:	    if ( forceField[01;31m-[00m>_Itors[01;31m-[00m>hasBestTerm(t1,t2,t3,t4) ) 
energyFunction.cc:1334:		    ffItor = forceField[01;31m-[00m>_Itors[01;31m-[00m>findBestTerm(t1,t2,t3,t4);
energyFunction.cc:1336:			if ( ffItor[01;31m-[00m>_Vs[n[01;31m-[00m1]!= 0.0 ) 
energyFunction.cc:1338:			    energyDihedral.defineFrom(n,ffItor,ea1,ea2,ea3,ea4,this[01;31m-[00m>_Dihedral[01;31m-[00m>getScale());
energyFunction.cc:1339:			    this[01;31m-[00m>_Dihedral[01;31m-[00m>addTerm(energyDihedral);
energyFunction.cc:1354:	for ( iea1 = this[01;31m-[00m>_AtomTable[01;31m-[00m>begin();
energyFunction.cc:1355:		iea1 != this[01;31m-[00m>_AtomTable[01;31m-[00m>end()[01;31m-[00m1; iea1++ ) {
energyFunction.cc:1356:	    for ( iea2 = iea1+1; iea2 != this[01;31m-[00m>_AtomTable[01;31m-[00m>end(); iea2++ ) {
energyFunction.cc:1357:		if ( !iea1[01;31m-[00m>_CloserThan15.count((iea2[01;31m-[00m>_Atom))) 
energyFunction.cc:1361:					&(*iea1),&(*iea2),this[01;31m-[00m>_Nonbond) )  {
energyFunction.cc:1362:		        this[01;31m-[00m>_Nonbond[01;31m-[00m>addTerm(energyNonbond);
energyFunction.cc:1381:	    if ( a1[01;31m-[00m>getStereochemistryType() != undefinedCenter ) 
energyFunction.cc:1383:		LOG(BF("Create a chiral restraint for %s") % a1[01;31m-[00m>description().c_str()  ); // vp0(( "Create a chiral restraint for %s",a1[01;31m-[00m>description().c_str() ));
energyFunction.cc:1387:			// Otherwise if its pro[01;31m-[00mchiral center then set it to "R"
energyFunction.cc:1391:			// "R" [01;31m-[00m> side = 1.0
energyFunction.cc:1392:			// "S" [01;31m-[00m> side = [01;31m-[00m1.0
energyFunction.cc:1396:			// default R[01;31m-[00mstereochemistry (1[01;31m-[00mcenter)x(2[01;31m-[00mcenter).(3[01;31m-[00mcenter) is POSITIVE
energyFunction.cc:1398:		if ( a1[01;31m-[00m>getConfiguration() != undefinedConfiguration )
energyFunction.cc:1400:		    if ( a1[01;31m-[00m>getConfiguration() == R_Configuration )
energyFunction.cc:1405:			side = [01;31m-[00m1.0;
energyFunction.cc:1409:		    if ( a1[01;31m-[00m>getStereochemistryType() == prochiralCenter )
energyFunction.cc:1414:			TOSS(_lisp[01;31m-[00m>create<O_LispError>("Chiral center ("+a1[01;31m-[00m>description()+") doesn't have its configuration set"));
energyFunction.cc:1417:		RPCons priority = a1[01;31m-[00m>getNeighborsByRelativePriority();
energyFunction.cc:1418:		ASSERTP(priority[01;31m-[00m>length() == 4, "There must be 4 neighbors to assign stereochemistry");
energyFunction.cc:1420:		n1 = cur[01;31m-[00m>car<O_Atom>();
energyFunction.cc:1421:		cur = cur[01;31m-[00m>cdr();
energyFunction.cc:1422:		n2 = cur[01;31m-[00m>car<O_Atom>();
energyFunction.cc:1423:		cur = cur[01;31m-[00m>cdr();
energyFunction.cc:1424:		n3 = cur[01;31m-[00m>car<O_Atom>();
energyFunction.cc:1425:		cur = cur[01;31m-[00m>cdr();
energyFunction.cc:1426:		n4 = cur[01;31m-[00m>car<O_Atom>();
energyFunction.cc:1428:		s1 = a1[01;31m-[00m>getConfigurationPriorityHighest();
energyFunction.cc:1429:		s2 = a1[01;31m-[00m>getConfigurationPriorityHigh();
energyFunction.cc:1430:		s3 = a1[01;31m-[00m>getConfigurationPriorityLow();
energyFunction.cc:1431:		s4 = a1[01;31m-[00m>getConfigurationPriorityLowest();
energyFunction.cc:1432:		n1 = a1[01;31m-[00m>bondedNeighborWithName(s1);
energyFunction.cc:1433:		n2 = a1[01;31m-[00m>bondedNeighborWithName(s2);
energyFunction.cc:1434:		n3 = a1[01;31m-[00m>bondedNeighborWithName(s3);
energyFunction.cc:1435:		n4 = a1[01;31m-[00m>bondedNeighborWithName(s4);
energyFunction.cc:1436:		ASSERT_NOT_NULLP(n1, "Atom("+a1[01;31m-[00m>getName()+") does not have neighbor1("+s1+")");
energyFunction.cc:1437:		ASSERT_NOT_NULLP(n2, "Atom("+a2[01;31m-[00m>getName()+") does not have neighbor2("+s2+")");
energyFunction.cc:1438:		ASSERT_NOT_NULLP(n3, "Atom("+a3[01;31m-[00m>getName()+") does not have neighbor3("+s3+")");
energyFunction.cc:1439:		ASSERT_NOT_NULLP(n4, "Atom("+a4[01;31m-[00m>getName()+") does not have neighbor4("+s4+")");
energyFunction.cc:1441:		eaCenter = this[01;31m-[00m>getEnergyAtomPointer(a1[01;31m-[00m>getTempInt());
energyFunction.cc:1442:		ea1 = this[01;31m-[00m>getEnergyAtomPointer(n1[01;31m-[00m>getTempInt());
energyFunction.cc:1443:		ea2 = this[01;31m-[00m>getEnergyAtomPointer(n2[01;31m-[00m>getTempInt());
energyFunction.cc:1444:		ea3 = this[01;31m-[00m>getEnergyAtomPointer(n3[01;31m-[00m>getTempInt());
energyFunction.cc:1445:		ea4 = this[01;31m-[00m>getEnergyAtomPointer(n4[01;31m-[00m>getTempInt());
energyFunction.cc:1448:			// Setup chiral restraints for 1[01;31m-[00m>2[01;31m-[00m>center[01;31m-[00m>3
energyFunction.cc:1449:			//			and 1[01;31m-[00m>2[01;31m-[00m>center[01;31m-[00m>4
energyFunction.cc:1451:		ichiral._Atom1 = ea1[01;31m-[00m>_Atom;
energyFunction.cc:1452:		ichiral._Atom2 = ea2[01;31m-[00m>_Atom;
energyFunction.cc:1453:		ichiral._Atom3 = eaCenter[01;31m-[00m>_Atom;
energyFunction.cc:1454:		ichiral._Atom4 = ea3[01;31m-[00m>_Atom;
energyFunction.cc:1455:		ichiral.term.I1 = ea1[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1456:		ichiral.term.I2 = ea2[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1457:		ichiral.term.I3 = eaCenter[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1458:		ichiral.term.I4 = ea3[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1459:		ichiral.term.K = this[01;31m-[00m>_ChiralRestraintWeight * side;
energyFunction.cc:1460:		ichiral.term.CO = this[01;31m-[00m>_ChiralRestraintOffset;
energyFunction.cc:1461:		this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>addTerm(ichiral);
energyFunction.cc:1465:		ichiral._Atom4 = ea4[01;31m-[00m>_Atom;
energyFunction.cc:1466:		ichiral.term.I4 = ea4[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1468:		ichiral.term.K = this[01;31m-[00m>_ChiralRestraintWeight * side * [01;31m-[00m1.0;
energyFunction.cc:1469:		ichiral.term.CO = this[01;31m-[00m>_ChiralRestraintOffset;
energyFunction.cc:1470:		this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>addTerm(ichiral);
energyFunction.cc:1476:			// Setup chiral restraints for 2[01;31m-[00m>4[01;31m-[00m>center[01;31m-[00m>3
energyFunction.cc:1477:			//			and 2[01;31m-[00m>4[01;31m-[00m>center[01;31m-[00m>1
energyFunction.cc:1479:		ichiral._Atom1 = ea2[01;31m-[00m>_Atom;
energyFunction.cc:1480:		ichiral._Atom2 = ea4[01;31m-[00m>_Atom;
energyFunction.cc:1481:		ichiral._Atom3 = eaCenter[01;31m-[00m>_Atom;
energyFunction.cc:1482:		ichiral._Atom4 = ea3[01;31m-[00m>_Atom;
energyFunction.cc:1483:		ichiral.term.I1 = ea2[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1484:		ichiral.term.I2 = ea4[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1485:		ichiral.term.I3 = eaCenter[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1486:		ichiral.term.I4 = ea3[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1487:		ichiral.term.K = this[01;31m-[00m>_ChiralRestraintWeight * side;
energyFunction.cc:1488:		ichiral.term.CO = this[01;31m-[00m>_ChiralRestraintOffset;
energyFunction.cc:1489:		this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>addTerm(ichiral);
energyFunction.cc:1493:		ichiral._Atom4 = ea1[01;31m-[00m>_Atom;
energyFunction.cc:1494:		ichiral.term.I4 = ea1[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1496:		ichiral.term.K = this[01;31m-[00m>_ChiralRestraintWeight * side * [01;31m-[00m1.0;
energyFunction.cc:1497:		ichiral.term.CO = this[01;31m-[00m>_ChiralRestraintOffset;
energyFunction.cc:1498:		this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>addTerm(ichiral);
energyFunction.cc:1501:		LOG(BF("There is no chiral restraint for: %s") % a1[01;31m-[00m>description().c_str()  ); // vp0(("There is no chiral restraint for: %s", a1[01;31m-[00m>description().c_str() ));
energyFunction.cc:1515:	for ( iea1 = this[01;31m-[00m>_AtomTable[01;31m-[00m>begin();
energyFunction.cc:1516:		iea1 != this[01;31m-[00m>_AtomTable[01;31m-[00m>end()[01;31m-[00m1; iea1++ ) {
energyFunction.cc:1517:	    a1 = iea1[01;31m-[00m>_Atom;
energyFunction.cc:1518:	    if ( a1[01;31m-[00m>isAnchorRestraintOn() ) {
energyFunction.cc:1519:		LOG(BF("Create an anchor restraint for %s") % a1[01;31m-[00m>description().c_str()  ); // vp0(( "Create an anchor restraint for %s",a1[01;31m-[00m>description().c_str() ));
energyFunction.cc:1520:		anchorPos = a1[01;31m-[00m>getAnchorPos();
energyFunction.cc:1524:		iterm.term.ka = this[01;31m-[00m>_AnchorRestraintWeight;
energyFunction.cc:1525:		iterm.term.I1 = iea1[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1526:		this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>addTerm(iterm);
energyFunction.cc:1534:    if ( this[01;31m-[00m>_RestrainSecondaryAmides )
energyFunction.cc:1536:        this[01;31m-[00m>__createSecondaryAmideRestraints(nitrogens);
energyFunction.cc:1539:	LOG(BF("Skipping Secondary amide restraints because _RestrainSecondaryAmides = %d") % this[01;31m-[00m>_RestrainSecondaryAmides ); // vp0(("Skipping Secondary amide restraints because _RestrainSecondaryAmides = %d", this[01;31m-[00m>_RestrainSecondaryAmides));
energyFunction.cc:1543:	// Set up force[01;31m-[00mfield restraints
energyFunction.cc:1545:    {_BLOCK_TRACE("Defining force[01;31m-[00mfield restraints");
energyFunction.cc:1546:	RPIterateRestraints restraintIt = O_IterateRestraints::create(this[01;31m-[00m>lisp(),matter);
energyFunction.cc:1547:	this[01;31m-[00m>_applyRestraints(forceField,restraintIt);
energyFunction.cc:1555:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:1557:    iterate = O_IterateCons::create(this[01;31m-[00m>lisp(),restraintList);
energyFunction.cc:1558:    this[01;31m-[00m>_applyRestraints(forceField,iterate);
energyFunction.cc:1562:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:1565:    if ( pos[01;31m-[00m>size() != this[01;31m-[00m>getNVectorSize()) {
energyFunction.cc:1566:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("NVector is the incorrect length"));
energyFunction.cc:1568:    for ( ai=this[01;31m-[00m>_AtomTable[01;31m-[00m>begin(); ai!=this[01;31m-[00m>_AtomTable[01;31m-[00m>end(); ai++ ) {
energyFunction.cc:1569:        ci = ai[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1570:        pos[01;31m-[00m>setElement(ci,ai[01;31m-[00m>_Atom[01;31m-[00m>getPosition().getX());
energyFunction.cc:1571:        pos[01;31m-[00m>setElement(ci+1, ai[01;31m-[00m>_Atom[01;31m-[00m>getPosition().getY());
energyFunction.cc:1572:        pos[01;31m-[00m>setElement(ci+2, ai[01;31m-[00m>_Atom[01;31m-[00m>getPosition().getZ());
energyFunction.cc:1579:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:1584:    for ( ai=this[01;31m-[00m>_AtomTable[01;31m-[00m>begin(); ai!=this[01;31m-[00m>_AtomTable[01;31m-[00m>end(); ai++ ) {
energyFunction.cc:1585:        ci = ai[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1586:        x = pos[01;31m-[00m>getElement(ci+0);
energyFunction.cc:1587:        y = pos[01;31m-[00m>getElement(ci+1);
energyFunction.cc:1588:        z = pos[01;31m-[00m>getElement(ci+2);
energyFunction.cc:1591:        ai[01;31m-[00m>_Atom[01;31m-[00m>setPosition(v);
energyFunction.cc:1601:    for ( ai=this[01;31m-[00m>_AtomTable[01;31m-[00m>begin(); ai!=this[01;31m-[00m>_AtomTable[01;31m-[00m>end(); ai++ ) {
energyFunction.cc:1602:        ci = ai[01;31m-[00m>_CoordinateIndex;
energyFunction.cc:1603:        x = force[01;31m-[00m>getElement(ci+0);
energyFunction.cc:1604:        y = force[01;31m-[00m>getElement(ci+1);
energyFunction.cc:1605:        z = force[01;31m-[00m>getElement(ci+2);
energyFunction.cc:1607:        ai[01;31m-[00m>_Atom[01;31m-[00m>setForce(v);
energyFunction.cc:1614:    this[01;31m-[00m>writeCoordinatesToAtoms(pos);
energyFunction.cc:1615:    this[01;31m-[00m>writeForceToAtoms(force);
energyFunction.cc:1621:    return this[01;31m-[00m>_AtomTable[01;31m-[00m>getEnergyAtomPointer(i);
energyFunction.cc:1627:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:1629:    pos = O_NVector::create(this[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
energyFunction.cc:1630:    this[01;31m-[00m>extractCoordinatesFromAtoms(pos);
energyFunction.cc:1631:    return this[01;31m-[00m>evaluateEnergy(pos);
energyFunction.cc:1640:    pos = O_NVector::create(this[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
energyFunction.cc:1641:    force = O_NVector::create(this[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
energyFunction.cc:1642:    this[01;31m-[00m>extractCoordinatesFromAtoms(pos);
energyFunction.cc:1643:    energy = this[01;31m-[00m>evaluateEnergyForce(pos,true,force);
energyFunction.cc:1644:    	// To calculate the force magnitude use force[01;31m-[00m>magnitude();
energyFunction.cc:1645:    	// To calculate the force rmsMagnitude use force[01;31m-[00m>rmsMagnitude();
energyFunction.cc:1646:    this[01;31m-[00m>writeForceToAtoms(force);
energyFunction.cc:1660:	    problem._Atom1[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1661:	    problem._Atom2[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1662:	    problem._Atom3[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1663:	    problem._Atom4[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1666:	    problem._Atom1[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1667:	    problem._Atom2[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1668:	    problem._Atom3[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1669:	    problem._Atom4[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1672:	    problem._Atom1[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1673:	    problem._Atom2[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1674:	    problem._Atom3[01;31m-[00m>bumpPosition(0.1);
energyFunction.cc:1677:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("O_EnergyFunction::dealWithProblem>> I am not handling this problem yet"));
energyFunction.cc:1689:    ss << this[01;31m-[00m>_Stretch[01;31m-[00m>beyondThresholdInteractionsAsString();
energyFunction.cc:1691:    ss << this[01;31m-[00m>_Angle[01;31m-[00m>beyondThresholdInteractionsAsString();
energyFunction.cc:1692:    ss << this[01;31m-[00m>_Dihedral[01;31m-[00m>beyondThresholdInteractionsAsString();
energyFunction.cc:1693:    ss << this[01;31m-[00m>_Nonbond[01;31m-[00m>beyondThresholdInteractionsAsString();
energyFunction.cc:1694:    ss << this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>beyondThresholdInteractionsAsString();
energyFunction.cc:1695:    ss << this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>beyondThresholdInteractionsAsString();
energyFunction.cc:1696:    ss << this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>beyondThresholdInteractionsAsString();
energyFunction.cc:1697:    ss << this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>beyondThresholdInteractionsAsString();
energyFunction.cc:1707:    ss << this[01;31m-[00m>_Stretch[01;31m-[00m>summarizeEnergyAsString();
energyFunction.cc:1709:    ss << this[01;31m-[00m>_Angle[01;31m-[00m>summarizeEnergyAsString();
energyFunction.cc:1710:    ss << this[01;31m-[00m>_Dihedral[01;31m-[00m>summarizeEnergyAsString();
energyFunction.cc:1711:    ss << this[01;31m-[00m>_Nonbond[01;31m-[00m>summarizeEnergyAsString();
energyFunction.cc:1712:    ss << this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>summarizeEnergyAsString();
energyFunction.cc:1713:    ss << this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>summarizeEnergyAsString();
energyFunction.cc:1714:    ss << this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>summarizeEnergyAsString();
energyFunction.cc:1715:    ss << this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>summarizeEnergyAsString();
energyFunction.cc:1717:    ss<< "             Total energy: " << this[01;31m-[00m>_TotalEnergy << endl;
energyFunction.cc:1725:    if ( this[01;31m-[00m>_MissingParameters.size() > 0 ) {
energyFunction.cc:1736:    for ( si=this[01;31m-[00m>_MissingParameters.begin();
energyFunction.cc:1737:		si!=this[01;31m-[00m>_MissingParameters.end(); si++ ) {
energyFunction.cc:1747:    ss << this[01;31m-[00m>_Stretch[01;31m-[00m>debugLogAsString() << endl;
energyFunction.cc:1749:    ss << this[01;31m-[00m>_Angle[01;31m-[00m>debugLogAsString() << endl;
energyFunction.cc:1750:    ss << this[01;31m-[00m>_Dihedral[01;31m-[00m>debugLogAsString() << endl;
energyFunction.cc:1751:    ss << this[01;31m-[00m>_Nonbond[01;31m-[00m>debugLogAsString() << endl;
energyFunction.cc:1752:    ss << this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>debugLogAsString() << endl;
energyFunction.cc:1753:    ss << this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>debugLogAsString() << endl;
energyFunction.cc:1754:    ss << this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>debugLogAsString() << endl;
energyFunction.cc:1755:    ss << this[01;31m-[00m>_FixedNonbondRestraint[01;31m-[00m>debugLogAsString() << endl;
energyFunction.cc:1773:{_F(this[01;31m-[00m>lisp());
energyFunction.cc:1778:    pos = O_NVector::create(this[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
energyFunction.cc:1779:    this[01;31m-[00m>extractCoordinatesFromAtoms(pos);
energyFunction.cc:1780:    nbComponent = this[01;31m-[00m>getNonbondComponent();
energyFunction.cc:1781:    i = nbComponent[01;31m-[00m>countBadVdwOverlaps(scaleSumOfVdwRadii,pos,displayIn,displayIn[01;31m-[00m>lisp());
energyFunction.cc:1792:    bool ok = secondaryAmide[01;31m-[00m>compileSmarts("[$(N1(C2)(~[#1]3)~C4(=O5)C6)]");
energyFunction.cc:1795:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Error compiling secondary amide MSMARTS"));
energyFunction.cc:1804:    this[01;31m-[00m>lisp()[01;31m-[00m>installGlobalInitializationCallback(&energyFunction_initializeSmarts);
energyFunction.cc:1805:    class_<O_EnergyFunction>(this[01;31m-[00m>lisp())
energyImproperRestraint.cc:29:    this[01;31m-[00m>_Atom1.reset();
energyImproperRestraint.cc:30:    this[01;31m-[00m>_Atom2.reset();
energyImproperRestraint.cc:31:    this[01;31m-[00m>_Atom3.reset();
energyImproperRestraint.cc:32:    this[01;31m-[00m>_Atom4.reset();
energyImproperRestraint.cc:43:    node[01;31m-[00m>attribute("_AboveThreshold",this[01;31m-[00m>_AboveThreshold);
energyImproperRestraint.cc:44:    node[01;31m-[00m>attribute("_AboveThreshold_Phi",this[01;31m-[00m>_AboveThreshold_Phi);
energyImproperRestraint.cc:45:    node[01;31m-[00m>attribute("U",this[01;31m-[00m>term.U);
energyImproperRestraint.cc:46:    node[01;31m-[00m>attribute("L",this[01;31m-[00m>term.L);
energyImproperRestraint.cc:47:    node[01;31m-[00m>attribute("K",this[01;31m-[00m>term.K);
energyImproperRestraint.cc:48:    node[01;31m-[00m>attribute("I1",this[01;31m-[00m>term.I1);
energyImproperRestraint.cc:49:    node[01;31m-[00m>attribute("I2",this[01;31m-[00m>term.I2);
energyImproperRestraint.cc:50:    node[01;31m-[00m>attribute("I3",this[01;31m-[00m>term.I3);
energyImproperRestraint.cc:51:    node[01;31m-[00m>attribute("I4",this[01;31m-[00m>term.I4);
energyImproperRestraint.cc:52:    node[01;31m-[00m>archiveObject("a1",this[01;31m-[00m>_Atom1);
energyImproperRestraint.cc:53:    node[01;31m-[00m>archiveObject("a2",this[01;31m-[00m>_Atom2);
energyImproperRestraint.cc:54:    node[01;31m-[00m>archiveObject("a3",this[01;31m-[00m>_Atom3);
energyImproperRestraint.cc:55:    node[01;31m-[00m>archiveObject("a4",this[01;31m-[00m>_Atom4);
energyImproperRestraint.cc:57:    node[01;31m-[00m>attributeIfDefined("calcForce",this[01;31m-[00m>_calcForce,this[01;31m-[00m>_calcForce);
energyImproperRestraint.cc:58:    node[01;31m-[00m>attributeIfDefined("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian,this[01;31m-[00m>_calcDiagonalHessian);
energyImproperRestraint.cc:59:    node[01;31m-[00m>attributeIfDefined("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian,this[01;31m-[00m>_calcOffDiagonalHessian);
energyImproperRestraint.cc:68:    pos1 = this[01;31m-[00m>_Atom1[01;31m-[00m>getPosition();
energyImproperRestraint.cc:69:    pos2 = this[01;31m-[00m>_Atom2[01;31m-[00m>getPosition();
energyImproperRestraint.cc:70:    pos3 = this[01;31m-[00m>_Atom3[01;31m-[00m>getPosition();
energyImproperRestraint.cc:71:    pos4 = this[01;31m-[00m>_Atom4[01;31m-[00m>getPosition();
energyImproperRestraint.cc:72:    return calculateDihedral(pos1,pos2,pos3,pos4,this[01;31m-[00m>lisp());
energyImproperRestraint.cc:83:    node[01;31m-[00m>addAttributeString("atom1Name",this[01;31m-[00m>_Atom1[01;31m-[00m>getName());
energyImproperRestraint.cc:84:    node[01;31m-[00m>addAttributeString("atom2Name",this[01;31m-[00m>_Atom2[01;31m-[00m>getName());
energyImproperRestraint.cc:85:    node[01;31m-[00m>addAttributeString("atom3Name",this[01;31m-[00m>_Atom3[01;31m-[00m>getName());
energyImproperRestraint.cc:86:    node[01;31m-[00m>addAttributeString("atom4Name",this[01;31m-[00m>_Atom4[01;31m-[00m>getName());
energyImproperRestraint.cc:87:    node[01;31m-[00m>addAttributeInt("I1",this[01;31m-[00m>term.I1);
energyImproperRestraint.cc:88:    node[01;31m-[00m>addAttributeInt("I2",this[01;31m-[00m>term.I2);
energyImproperRestraint.cc:89:    node[01;31m-[00m>addAttributeInt("I3",this[01;31m-[00m>term.I3);
energyImproperRestraint.cc:90:    node[01;31m-[00m>addAttributeInt("I4",this[01;31m-[00m>term.I4);
energyImproperRestraint.cc:91:    node[01;31m-[00m>addAttributeDouble("UDeg",this[01;31m-[00m>term.U/0.0174533,6,2);
energyImproperRestraint.cc:92:    node[01;31m-[00m>addAttributeDouble("LDeg",this[01;31m-[00m>term.L/0.0174533,6,2);
energyImproperRestraint.cc:93:    node[01;31m-[00m>addAttributeDoubleScientific("U",this[01;31m-[00m>term.U);
energyImproperRestraint.cc:94:    node[01;31m-[00m>addAttributeDoubleScientific("L",this[01;31m-[00m>term.L);
energyImproperRestraint.cc:95:    node[01;31m-[00m>addAttributeDoubleScientific("K",this[01;31m-[00m>term.K);
energyImproperRestraint.cc:96:    if ( this[01;31m-[00m>_AboveThreshold ) {
energyImproperRestraint.cc:98:	child[01;31m-[00m>addAttributeDoubleScientific("Phi",this[01;31m-[00m>_AboveThreshold_Phi );
energyImproperRestraint.cc:99:	child[01;31m-[00m>addAttributeDouble("PhiDeg",this[01;31m-[00m>_AboveThreshold_Phi/0.0174533,6,2 );
energyImproperRestraint.cc:101:	ss << endl << "This improper has the value("<<this[01;31m-[00m>_AboveThreshold_Phi/0.0174533<<")"
energyImproperRestraint.cc:102:	    << " outside of bounds ["<<this[01;31m-[00m>term.U/0.0174533<<","
energyImproperRestraint.cc:103:	    <<this[01;31m-[00m>term.L/0.0174533<<"]" << endl;
energyImproperRestraint.cc:104:	child[01;31m-[00m>setCharacters(ss.str());
energyImproperRestraint.cc:105:	node[01;31m-[00m>addChild(child);
energyImproperRestraint.cc:109:    xml[01;31m-[00m>addAttributeBool("calcForce",this[01;31m-[00m>_calcForce );
energyImproperRestraint.cc:110:    xml[01;31m-[00m>addAttributeBool("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian );
energyImproperRestraint.cc:111:    xml[01;31m-[00m>addAttributeBool("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian );
energyImproperRestraint.cc:113:    node[01;31m-[00m>addChild(xml);
energyImproperRestraint.cc:121:    this[01;31m-[00m>term.U = xml[01;31m-[00m>getAttributeDouble("U");
energyImproperRestraint.cc:122:    this[01;31m-[00m>term.L = xml[01;31m-[00m>getAttributeDouble("L");
energyImproperRestraint.cc:123:    this[01;31m-[00m>term.K = xml[01;31m-[00m>getAttributeDouble("K");
energyImproperRestraint.cc:124:    this[01;31m-[00m>term.I1 = xml[01;31m-[00m>getAttributeInt("I1");
energyImproperRestraint.cc:125:    this[01;31m-[00m>term.I2 = xml[01;31m-[00m>getAttributeInt("I2");
energyImproperRestraint.cc:126:    this[01;31m-[00m>term.I3 = xml[01;31m-[00m>getAttributeInt("I3");
energyImproperRestraint.cc:127:    this[01;31m-[00m>term.I4 = xml[01;31m-[00m>getAttributeInt("I4");
energyImproperRestraint.cc:128:    this[01;31m-[00m>_Atom1 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I1)[01;31m-[00m>_Atom;
energyImproperRestraint.cc:129:    this[01;31m-[00m>_Atom2 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I2)[01;31m-[00m>_Atom;
energyImproperRestraint.cc:130:    this[01;31m-[00m>_Atom3 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I3)[01;31m-[00m>_Atom;
energyImproperRestraint.cc:131:    this[01;31m-[00m>_Atom4 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I4)[01;31m-[00m>_Atom;
energyImproperRestraint.cc:178:    this[01;31m-[00m>_Terms.push_back(e);
energyImproperRestraint.cc:207:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyImproperRestraint.cc:210:#define	IMPROPER_RESTRAINT_SET_PARAMETER(x)	{x=iri[01;31m-[00m>term.x;}
energyImproperRestraint.cc:212:#define	IMPROPER_RESTRAINT_SET_POSITION(x,ii,of) {x=nvPosition[01;31m-[00m>element(ii+of);}
energyImproperRestraint.cc:221:	  m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyImproperRestraint.cc:225:	  m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyImproperRestraint.cc:231:    if ( this[01;31m-[00m>isEnabled() ) {
energyImproperRestraint.cc:238:	for ( vector<EnergyImproperRestraint>::iterator iri=this[01;31m-[00m>_Terms.begin();
energyImproperRestraint.cc:239:		    iri!=this[01;31m-[00m>_Terms.end(); iri++ ) {
energyImproperRestraint.cc:257:{_F(this[01;31m-[00m>lisp());
energyImproperRestraint.cc:258:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyImproperRestraint.cc:261:	LOG_ENERGY(BF("%s {")% this[01;31m-[00m>className());
energyImproperRestraint.cc:269:bool	hasForce = force[01;31m-[00m>notNil();
energyImproperRestraint.cc:270:bool	hasHessian = hessian[01;31m-[00m>notNil();
energyImproperRestraint.cc:271:bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
energyImproperRestraint.cc:277:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyImproperRestraint.cc:282:#define	IMPROPER_RESTRAINT_SET_PARAMETER(x)	{x = iri[01;31m-[00m>term.x;}
energyImproperRestraint.cc:284:#define	IMPROPER_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>element(ii+of);}
energyImproperRestraint.cc:288:#define	IMPROPER_RESTRAINT_ENERGY_ACCUMULATE(e) this[01;31m-[00m>_TotalEnergy += (e);
energyImproperRestraint.cc:296:    if ( this[01;31m-[00m>isEnabled() ) {
energyImproperRestraint.cc:304:	for ( i=0,iri =this[01;31m-[00m>_Terms.begin();
energyImproperRestraint.cc:305:		    iri!=this[01;31m-[00m>_Terms.end(); iri++,i++ ) {
energyImproperRestraint.cc:307:		if ( this[01;31m-[00m>_Debug_NumberOfImproperRestraintTermsToCalculate > 0 ) {
energyImproperRestraint.cc:308:		    if ( i>= this[01;31m-[00m>_Debug_NumberOfImproperRestraintTermsToCalculate ) {
energyImproperRestraint.cc:316:	       problem._Atom1 = iri[01;31m-[00m>_Atom1;
energyImproperRestraint.cc:317:	       problem._Atom2 = iri[01;31m-[00m>_Atom2;
energyImproperRestraint.cc:318:	       problem._Atom3 = iri[01;31m-[00m>_Atom3;
energyImproperRestraint.cc:319:	       problem._Atom4 = iri[01;31m-[00m>_Atom4;
energyImproperRestraint.cc:326:		iri[01;31m-[00m>_calcForce = calcForce;
energyImproperRestraint.cc:327:		iri[01;31m-[00m>_calcDiagonalHessian = calcDiagonalHessian;
energyImproperRestraint.cc:328:		iri[01;31m-[00m>_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyImproperRestraint.cc:330:		#define EVAL_SET(var,val)	{ iri[01;31m-[00m>eval.var=val;};
energyImproperRestraint.cc:334:	    if ( this[01;31m-[00m>_DebugEnergy ) 
energyImproperRestraint.cc:383:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyImproperRestraint.cc:384:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyImproperRestraint.cc:385:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyImproperRestraint.cc:386:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyImproperRestraint.cc:387:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyImproperRestraint.cc:388:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyImproperRestraint.cc:389:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx3>10000.0);
energyImproperRestraint.cc:390:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy3>10000.0);
energyImproperRestraint.cc:391:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz3>10000.0);
energyImproperRestraint.cc:392:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx4>10000.0);
energyImproperRestraint.cc:393:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy4>10000.0);
energyImproperRestraint.cc:394:		_lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz4>10000.0);
energyImproperRestraint.cc:398:    LOG_ENERGY(BF( "ImproperRestraint energy = %lf\n")% (double)(this[01;31m-[00m>_TotalEnergy) );
energyImproperRestraint.cc:399:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyImproperRestraint.cc:401:	LOG_ENERGY(BF("%s }\n")% this[01;31m-[00m>className());
energyImproperRestraint.cc:423://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyImproperRestraint.cc:428:#define	IMPROPER_RESTRAINT_SET_PARAMETER(x)	{x = iri[01;31m-[00m>term.x;}
energyImproperRestraint.cc:430:#define	IMPROPER_RESTRAINT_SET_POSITION(x,ii,of) {x = pos[01;31m-[00m>element(ii+of);}
energyImproperRestraint.cc:443:	if ( this[01;31m-[00m>isEnabled() ) {
energyImproperRestraint.cc:452:	    for ( i=0,iri =this[01;31m-[00m>_Terms.begin();
energyImproperRestraint.cc:453:			iri!=this[01;31m-[00m>_Terms.end(); iri++,i++ ) {
energyImproperRestraint.cc:473:    this[01;31m-[00m>_BeyondThresholdTerms.clear();
energyImproperRestraint.cc:478://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyImproperRestraint.cc:483:#define	IMPROPER_RESTRAINT_SET_PARAMETER(x)	{x = iri[01;31m-[00m>term.x;}
energyImproperRestraint.cc:485:#define	IMPROPER_RESTRAINT_SET_POSITION(x,ii,of) {x = pos[01;31m-[00m>element(ii+of);}
energyImproperRestraint.cc:498:	if ( this[01;31m-[00m>isEnabled() ) {
energyImproperRestraint.cc:507:	    for ( i=0,iri =this[01;31m-[00m>_Terms.begin();
energyImproperRestraint.cc:508:			iri!=this[01;31m-[00m>_Terms.end(); iri++,i++ ) {
energyImproperRestraint.cc:520:		    info << a1[01;31m-[00m>description() << " ";
energyImproperRestraint.cc:521:		    info << a2[01;31m-[00m>description() << " ";
energyImproperRestraint.cc:522:		    info << a3[01;31m-[00m>description() << " ";
energyImproperRestraint.cc:523:		    info << a4[01;31m-[00m>description() << " ";
energyImproperRestraint.cc:525:		    this[01;31m-[00m>_BeyondThresholdTerms.push_back(*iri);
energyImproperRestraint.cc:543:    class_<O_EnergyImproperRestraint>(e[01;31m-[00m>lisp())
energyImproperRestraint.cc:555:    this[01;31m-[00m>Base::initialize();
energyImproperRestraint.cc:556:    this[01;31m-[00m>setErrorThreshold(0.001);
energyImproperRestraint.cc:561:    this[01;31m-[00m>Base::archiveBase(node);
energyNonbond.cc:33:    node[01;31m-[00m>attribute("_Is14",this[01;31m-[00m>_Is14);
energyNonbond.cc:34:    node[01;31m-[00m>attribute("_A",this[01;31m-[00m>_A);
energyNonbond.cc:35:    node[01;31m-[00m>attribute("_C",this[01;31m-[00m>_C);
energyNonbond.cc:36:    node[01;31m-[00m>attribute("_Charge1",this[01;31m-[00m>_Charge1);
energyNonbond.cc:37:    node[01;31m-[00m>attribute("_Charge2",this[01;31m-[00m>_Charge2);
energyNonbond.cc:38:    node[01;31m-[00m>attribute("_RStar",this[01;31m-[00m>_RStar);
energyNonbond.cc:39:    node[01;31m-[00m>attribute("dQ1Q2",this[01;31m-[00m>term.dQ1Q2);
energyNonbond.cc:40:    node[01;31m-[00m>attribute("dA",this[01;31m-[00m>term.dA);
energyNonbond.cc:41:    node[01;31m-[00m>attribute("dC",this[01;31m-[00m>term.dC);
energyNonbond.cc:42:    node[01;31m-[00m>attribute("I1",this[01;31m-[00m>term.I1);
energyNonbond.cc:43:    node[01;31m-[00m>attribute("I2",this[01;31m-[00m>term.I2);
energyNonbond.cc:44:    node[01;31m-[00m>archiveObject("a1",this[01;31m-[00m>_Atom1);
energyNonbond.cc:45:    node[01;31m-[00m>archiveObject("a2",this[01;31m-[00m>_Atom2);
energyNonbond.cc:47:    node[01;31m-[00m>attributeIfDefined("calcForce",this[01;31m-[00m>_calcForce,this[01;31m-[00m>_calcForce);
energyNonbond.cc:48:    node[01;31m-[00m>attributeIfDefined("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian,this[01;31m-[00m>_calcDiagonalHessian);
energyNonbond.cc:49:    node[01;31m-[00m>attributeIfDefined("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian,this[01;31m-[00m>_calcOffDiagonalHessian);
energyNonbond.cc:66:{_F(forceField[01;31m-[00m>lisp());
energyNonbond.cc:72:    this[01;31m-[00m>_Is14 = is14;
energyNonbond.cc:73:    this[01;31m-[00m>_Atom1 = iea1[01;31m-[00m>_Atom;
energyNonbond.cc:74:    this[01;31m-[00m>_Atom2 = iea2[01;31m-[00m>_Atom;
energyNonbond.cc:75:    ffNonbond1 = forceField[01;31m-[00m>_Nonbonds[01;31m-[00m>findType(iea1[01;31m-[00m>_Atom[01;31m-[00m>getTypeString());
energyNonbond.cc:76:    ffNonbond2 = forceField[01;31m-[00m>_Nonbonds[01;31m-[00m>findType(iea2[01;31m-[00m>_Atom[01;31m-[00m>getTypeString());
energyNonbond.cc:78:    if ( ffNonbond1[01;31m-[00m>isNil() )
energyNonbond.cc:80://     	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown force field type(",iea1[01;31m-[00m>_Atom[01;31m-[00m>getTypeString().c_str(),") for non[01;31m-[00mbonded interaction"));
energyNonbond.cc:84:    if ( ffNonbond2[01;31m-[00m>isNil() )
energyNonbond.cc:86://     	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown force field type(",iea2[01;31m-[00m>_Atom[01;31m-[00m>getTypeString().c_str(),") for non[01;31m-[00mbonded interaction"));
energyNonbond.cc:90:	vdwScale = 1.0/2.0*nb[01;31m-[00m>getVdwScale();
energyNonbond.cc:91:	electrostaticScale = nb[01;31m-[00m>getElectrostaticScale()*1.0/1.2;
energyNonbond.cc:94:	vdwScale = nb[01;31m-[00m>getVdwScale();
energyNonbond.cc:95:	electrostaticScale = nb[01;31m-[00m>getElectrostaticScale();
energyNonbond.cc:101:	this[01;31m-[00m>_RStar = ffNonbond1[01;31m-[00m>_Radius+ffNonbond2[01;31m-[00m>_Radius;
energyNonbond.cc:102:	epsilonij = sqrt(ffNonbond1[01;31m-[00m>_Well*ffNonbond2[01;31m-[00m>_Well);
energyNonbond.cc:103:	this[01;31m-[00m>_A = epsilonij*pow(this[01;31m-[00m>_RStar,12.0);
energyNonbond.cc:104:	this[01;31m-[00m>_C = 2.0*epsilonij*pow(this[01;31m-[00m>_RStar,6.0);
energyNonbond.cc:105:	this[01;31m-[00m>term.dA = this[01;31m-[00m>_A*vdwScale;
energyNonbond.cc:106:	this[01;31m-[00m>term.dC = this[01;31m-[00m>_C*vdwScale;
energyNonbond.cc:110:	this[01;31m-[00m>_Charge1 = iea1[01;31m-[00m>_Atom[01;31m-[00m>getCharge();
energyNonbond.cc:111:	this[01;31m-[00m>_Charge2 = iea2[01;31m-[00m>_Atom[01;31m-[00m>getCharge();
energyNonbond.cc:112:	this[01;31m-[00m>term.dQ1Q2 = electrostaticScale*(this[01;31m-[00m>_Charge1*this[01;31m-[00m>_Charge2)/nb[01;31m-[00m>getDielectricConstant();
energyNonbond.cc:114:	LOG(BF( "Calc dQ1Q2 Dielectric constant = %lf")% (double)(nb[01;31m-[00m>getDielectricConstant()));
energyNonbond.cc:115:	LOG(BF( "Calc dQ1Q2 Charge1 = %lf")% (double)(this[01;31m-[00m>_Charge1));
energyNonbond.cc:116:	LOG(BF( "Calc dQ1Q2 Charge2 = %lf")% (double)(this[01;31m-[00m>_Charge2));
energyNonbond.cc:117:	LOG(BF( "dQ1Q2 = %lf")% (double)(this[01;31m-[00m>term.dQ1Q2));
energyNonbond.cc:119:    this[01;31m-[00m>term.I1 = iea1[01;31m-[00m>_CoordinateIndex;
energyNonbond.cc:120:    this[01;31m-[00m>term.I2 = iea2[01;31m-[00m>_CoordinateIndex;
energyNonbond.cc:127:    pos1 = this[01;31m-[00m>_Atom1[01;31m-[00m>getPosition();
energyNonbond.cc:128:    pos2 = this[01;31m-[00m>_Atom2[01;31m-[00m>getPosition();
energyNonbond.cc:129:    return calculateDistance(pos1,pos2,this[01;31m-[00m>lisp());
energyNonbond.cc:139:    node[01;31m-[00m>addAttributeString("atom1Name",this[01;31m-[00m>_Atom1[01;31m-[00m>getName());
energyNonbond.cc:140:    node[01;31m-[00m>addAttributeString("atom2Name",this[01;31m-[00m>_Atom2[01;31m-[00m>getName());
energyNonbond.cc:141:    node[01;31m-[00m>addAttributeInt("I1",this[01;31m-[00m>term.I1);
energyNonbond.cc:142:    node[01;31m-[00m>addAttributeInt("I2",this[01;31m-[00m>term.I2);
energyNonbond.cc:143:    node[01;31m-[00m>addAttributeBool("is14",this[01;31m-[00m>_Is14);
energyNonbond.cc:144:    node[01;31m-[00m>addAttributeString("atom1Type",this[01;31m-[00m>_Atom1[01;31m-[00m>getTypeString());
energyNonbond.cc:145:    node[01;31m-[00m>addAttributeString("atom2Type",this[01;31m-[00m>_Atom2[01;31m-[00m>getTypeString());
energyNonbond.cc:146:    node[01;31m-[00m>addAttributeDoubleScientific("RStar",this[01;31m-[00m>_RStar);
energyNonbond.cc:147:    node[01;31m-[00m>addAttributeDoubleScientific("A",this[01;31m-[00m>_A);
energyNonbond.cc:148:    node[01;31m-[00m>addAttributeDoubleScientific("C",this[01;31m-[00m>_C);
energyNonbond.cc:149:    node[01;31m-[00m>addAttributeDoubleScientific("Charge1",this[01;31m-[00m>_Charge1);
energyNonbond.cc:150:    node[01;31m-[00m>addAttributeDoubleScientific("Charge2",this[01;31m-[00m>_Charge2);
energyNonbond.cc:151://    vdiff = this[01;31m-[00m>_Atom1[01;31m-[00m>_Atom[01;31m-[00m>getPosition() [01;31m-[00m this[01;31m-[00m>_Atom2[01;31m-[00m>_Atom[01;31m-[00m>getPosition();
energyNonbond.cc:153://    node[01;31m-[00m>addAttributeDouble("_r",diff,5,2);
energyNonbond.cc:156:    xml[01;31m-[00m>addAttributeBool("calcForce",this[01;31m-[00m>_calcForce );
energyNonbond.cc:157:    xml[01;31m-[00m>addAttributeBool("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian );
energyNonbond.cc:158:    xml[01;31m-[00m>addAttributeBool("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian );
energyNonbond.cc:160:    node[01;31m-[00m>addChild(xml);
energyNonbond.cc:162:    node[01;31m-[00m>addAttributeDoubleScientific("dA",this[01;31m-[00m>term.dA);
energyNonbond.cc:163:    node[01;31m-[00m>addAttributeDoubleScientific("dC",this[01;31m-[00m>term.dC);
energyNonbond.cc:164:    node[01;31m-[00m>addAttributeDoubleScientific("dQ1Q2",this[01;31m-[00m>term.dQ1Q2);
energyNonbond.cc:174:    this[01;31m-[00m>term.dA = xml[01;31m-[00m>getAttributeDouble("dA");
energyNonbond.cc:175:    this[01;31m-[00m>term.dC = xml[01;31m-[00m>getAttributeDouble("dC");
energyNonbond.cc:176:    this[01;31m-[00m>term.dQ1Q2 = xml[01;31m-[00m>getAttributeDouble("dQ1Q2");
energyNonbond.cc:177:    this[01;31m-[00m>_RStar = xml[01;31m-[00m>getAttributeDouble("RStar");
energyNonbond.cc:178:    this[01;31m-[00m>_A = xml[01;31m-[00m>getAttributeDouble("A");
energyNonbond.cc:179:    this[01;31m-[00m>_C = xml[01;31m-[00m>getAttributeDouble("C");
energyNonbond.cc:180:    this[01;31m-[00m>_Charge1 = xml[01;31m-[00m>getAttributeDouble("Charge1");
energyNonbond.cc:181:    this[01;31m-[00m>_Charge2 = xml[01;31m-[00m>getAttributeDouble("Charge2");
energyNonbond.cc:182:    this[01;31m-[00m>term.I1 = xml[01;31m-[00m>getAttributeInt("I1");
energyNonbond.cc:183:    this[01;31m-[00m>term.I2 = xml[01;31m-[00m>getAttributeInt("I2");
energyNonbond.cc:184:    this[01;31m-[00m>_Is14 = xml[01;31m-[00m>getAttributeBool("is14");
energyNonbond.cc:185:    this[01;31m-[00m>_Atom1 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I1)[01;31m-[00m>_Atom;
energyNonbond.cc:186:    this[01;31m-[00m>_Atom2 = at[01;31m-[00m>findEnergyAtom(this[01;31m-[00m>term.I2)[01;31m-[00m>_Atom;
energyNonbond.cc:228:    this[01;31m-[00m>Base::zeroEnergy();
energyNonbond.cc:229:    this[01;31m-[00m>_EnergyElectrostatic = 0.0;
energyNonbond.cc:230:    this[01;31m-[00m>_EnergyVdw = 0.0;
energyNonbond.cc:234:{_F(this[01;31m-[00m>lisp());
energyNonbond.cc:236:    e = this[01;31m-[00m>getVdwEnergy();
energyNonbond.cc:237:    e += this[01;31m-[00m>getElectrostaticEnergy();
energyNonbond.cc:247:    for ( eni=this[01;31m-[00m>_Terms.begin();
energyNonbond.cc:248:	    eni!=this[01;31m-[00m>_Terms.end(); eni++ ) {
energyNonbond.cc:249:	as1 = atomLabel(eni[01;31m-[00m>_Atom1);
energyNonbond.cc:250:	as2 = atomLabel(eni[01;31m-[00m>_Atom2);
energyNonbond.cc:258:	if ( eni[01;31m-[00m>_Is14 ) {
energyNonbond.cc:259:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("TERM 4CALC14 %[01;31m-[00m9s [01;31m-[00m %[01;31m-[00m9s") %	str1.c_str() % str2.c_str() );
energyNonbond.cc:261:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("TERM 5NONBOND %[01;31m-[00m9s [01;31m-[00m %[01;31m-[00m9s") %	str1.c_str() % str2.c_str() );
energyNonbond.cc:269:{_F(this[01;31m-[00m>lisp());
energyNonbond.cc:285:    if ( displayIn[01;31m-[00m>notNil() )
energyNonbond.cc:288:	displayIn[01;31m-[00m>clear();
energyNonbond.cc:289:	color = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>(RGB_yellow );
energyNonbond.cc:290:	displayIn[01;31m-[00m>add(color);
energyNonbond.cc:292:    for ( eni=this[01;31m-[00m>_Terms.begin();
energyNonbond.cc:293:	    eni!=this[01;31m-[00m>_Terms.end(); eni++ )
energyNonbond.cc:295:	ia1 = eni[01;31m-[00m>term.I1;
energyNonbond.cc:296:	ia2 = eni[01;31m-[00m>term.I2;
energyNonbond.cc:297:	x1 = pos[01;31m-[00m>element(ia1+0);
energyNonbond.cc:298:	y1 = pos[01;31m-[00m>element(ia1+1);
energyNonbond.cc:299:	z1 = pos[01;31m-[00m>element(ia1+2);
energyNonbond.cc:300:	x2 = pos[01;31m-[00m>element(ia2+0);
energyNonbond.cc:301:	y2 = pos[01;31m-[00m>element(ia2+1);
energyNonbond.cc:302:	z2 = pos[01;31m-[00m>element(ia2+2);
energyNonbond.cc:303:	cutoff = eni[01;31m-[00m>_RStar*scaleSumOfVdwRadii;
energyNonbond.cc:305:	dx = x1[01;31m-[00mx2;
energyNonbond.cc:306:	dy = y1[01;31m-[00my2;
energyNonbond.cc:307:	dz = z1[01;31m-[00mz2;
energyNonbond.cc:312:	    LOG(BF("Atom1 = %s") % eni[01;31m-[00m>_Atom1[01;31m-[00m>description().c_str()  ); // vp0(("Atom1 = %s",eni[01;31m-[00m>_Atom1[01;31m-[00m>description().c_str() ));
energyNonbond.cc:313:	    LOG(BF("Atom2 = %s") % eni[01;31m-[00m>_Atom2[01;31m-[00m>description().c_str()  ); // vp0(("Atom2 = %s",eni[01;31m-[00m>_Atom2[01;31m-[00m>description().c_str() ));
energyNonbond.cc:319:		displayIn[01;31m-[00m>add(line);
energyNonbond.cc:341:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyNonbond.cc:344:TOSS(_lisp[01;31m-[00m>create<O_LispError>("Nonbond term isn't used when calculating setupHessianPreconditioner but it was called!!!"));
energyNonbond.cc:361:{_F(this[01;31m-[00m>lisp());
energyNonbond.cc:362:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyNonbond.cc:365:	LOG_ENERGY(BF("%s {\n")% this[01;31m-[00m>className());
energyNonbond.cc:373:bool	hasForce = force[01;31m-[00m>notNil();
energyNonbond.cc:374:bool	hasHessian = hessian[01;31m-[00m>notNil();
energyNonbond.cc:375:bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
energyNonbond.cc:381:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyNonbond.cc:387:#define	NONBOND_SET_PARAMETER(x)	{x=nbi[01;31m-[00m>term.x;}
energyNonbond.cc:389:#define	NONBOND_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyNonbond.cc:391:#define	NONBOND_EEEL_ENERGY_ACCUMULATE(e) {this[01;31m-[00m>_EnergyElectrostatic +=(e);}
energyNonbond.cc:393:#define	NONBOND_EVDW_ENERGY_ACCUMULATE(e) {this[01;31m-[00m>_EnergyVdw+=(e);}
energyNonbond.cc:405:    if ( this[01;31m-[00m>isEnabled() ) 
energyNonbond.cc:407:	vector<EnergyNonbond>::iterator firstElement = this[01;31m-[00m>_Terms.begin();
energyNonbond.cc:408:	int nonBondTerms = this[01;31m-[00m>_Terms.size();
energyNonbond.cc:421:		    if ( this[01;31m-[00m>_Debug_NumberOfNonbondTermsToCalculate > 0 ) {
energyNonbond.cc:422:			if ( i>= this[01;31m-[00m>_Debug_NumberOfNonbondTermsToCalculate ) {
energyNonbond.cc:429:		    nbi[01;31m-[00m>_calcForce = calcForce;
energyNonbond.cc:430:		    nbi[01;31m-[00m>_calcDiagonalHessian = calcDiagonalHessian;
energyNonbond.cc:431:		    nbi[01;31m-[00m>_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyNonbond.cc:433:		    #define	EVAL_SET(var,val)	{ nbi[01;31m-[00m>eval.var=val;};
energyNonbond.cc:438:		    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyNonbond.cc:439:		    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyNonbond.cc:440:		    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyNonbond.cc:441:		    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyNonbond.cc:442:		    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyNonbond.cc:443:		    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyNonbond.cc:445:		if ( this[01;31m-[00m>_DebugEnergy ) {
energyNonbond.cc:447:		    LOG_ENERGY(BF( "MEISTER nonbond %d dA %5.3lf\n")% (i+1) % (nbi[01;31m-[00m>term.dA) );
energyNonbond.cc:448:		    LOG_ENERGY(BF( "MEISTER nonbond %d dC %5.3lf\n")% (i+1) % (nbi[01;31m-[00m>term.dC) );
energyNonbond.cc:449:		    LOG_ENERGY(BF( "MEISTER nonbond %d dQ1Q2 %5.3lf\n")% (i+1) % (nbi[01;31m-[00m>term.dQ1Q2) );
energyNonbond.cc:475:    LOG_ENERGY(BF( "Nonbond energy vdw(%lf) electrostatic(%lf)\n")% (double)this[01;31m-[00m>_EnergyVdw % this[01;31m-[00m>_EnergyElectrostatic );
energyNonbond.cc:497://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyNonbond.cc:504:#define	NONBOND_SET_PARAMETER(x)	{x=nbi[01;31m-[00m>term.x;}
energyNonbond.cc:506:#define	NONBOND_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyNonbond.cc:520:	if ( this[01;31m-[00m>isEnabled() ) {
energyNonbond.cc:526:	    for ( i=0,nbi=this[01;31m-[00m>_Terms.begin();
energyNonbond.cc:527:			nbi!=this[01;31m-[00m>_Terms.end(); nbi++,i++ ) {
energyNonbond.cc:546:    this[01;31m-[00m>_BeyondThresholdTerms.clear();
energyNonbond.cc:551://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
energyNonbond.cc:556:#define	NONBOND_SET_PARAMETER(x)	{x=nbi[01;31m-[00m>term.x;}
energyNonbond.cc:558:#define	NONBOND_SET_POSITION(x,ii,of)	{x=pos[01;31m-[00m>element(ii+of);}
energyNonbond.cc:572:    if ( this[01;31m-[00m>isEnabled() ) {
energyNonbond.cc:578:	for ( i=0,nbi=this[01;31m-[00m>_Terms.begin();
energyNonbond.cc:579:		    nbi!=this[01;31m-[00m>_Terms.end(); nbi++,i++ ) 
energyNonbond.cc:582:	    if ( NonbondDistance < this[01;31m-[00m>_ErrorThreshold ) {
energyNonbond.cc:587://		info<< a1[01;31m-[00m>getAbsoluteIdPath() << " ";
energyNonbond.cc:588://		info<< a2[01;31m-[00m>getAbsoluteIdPath() << " ";
energyNonbond.cc:590:		info<<"threshold " << this[01;31m-[00m>_ErrorThreshold;
energyNonbond.cc:591:		info << a1[01;31m-[00m>getName() << " ";
energyNonbond.cc:592:		info << a2[01;31m-[00m>getName() << " ";
energyNonbond.cc:594:		this[01;31m-[00m>_BeyondThresholdTerms.push_back(*nbi);
energyNonbond.cc:611:    class_<O_EnergyNonbond>(e[01;31m-[00m>lisp())
energyNonbond.cc:623:    this[01;31m-[00m>Base::initialize();
energyNonbond.cc:624:    this[01;31m-[00m>setErrorThreshold(1.0);
energyNonbond.cc:625:    this[01;31m-[00m>setDielectricConstant(80.0);
energyNonbond.cc:626:    this[01;31m-[00m>setVdwScale(1.0);
energyNonbond.cc:627:    this[01;31m-[00m>setElectrostaticScale(1.0);
energyNonbond.cc:634:    this[01;31m-[00m>_Terms.push_back(term);
energyNonbond.cc:640:    this[01;31m-[00m>Base::archiveBase(node);
energyStretch.cc:28:    this[01;31m-[00m>_Atom1.reset();
energyStretch.cc:29:    this[01;31m-[00m>_Atom2.reset();
energyStretch.cc:41:    node[01;31m-[00m>attribute("kb",this[01;31m-[00m>term.kb);
energyStretch.cc:42:    node[01;31m-[00m>attribute("r0",this[01;31m-[00m>term.r0);
energyStretch.cc:43:    node[01;31m-[00m>attribute("I1",this[01;31m-[00m>term.I1);
energyStretch.cc:44:    node[01;31m-[00m>attribute("I2",this[01;31m-[00m>term.I2);
energyStretch.cc:45:    node[01;31m-[00m>archiveObject("a1",this[01;31m-[00m>_Atom1);
energyStretch.cc:46:    node[01;31m-[00m>archiveObject("a2",this[01;31m-[00m>_Atom2);
energyStretch.cc:48:    node[01;31m-[00m>attributeIfDefined("calcForce",this[01;31m-[00m>_calcForce,this[01;31m-[00m>_calcForce);
energyStretch.cc:49:    node[01;31m-[00m>attributeIfDefined("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian,this[01;31m-[00m>_calcDiagonalHessian);
energyStretch.cc:50:    node[01;31m-[00m>attributeIfDefined("calcOffDiagonalHessian",this[01;31m-[00m>_calcOffDiagonalHessian,this[01;31m-[00m>_calcOffDiagonalHessian);
energyStretch.cc:56:{_F(stretch[01;31m-[00m>lisp());
energyStretch.cc:57:    LOG(BF("Defining EnergyStretch with kb=%lf r0=%lf") % this[01;31m-[00m>term.kb % this[01;31m-[00m>term.r0  ); // vp0(( "Defining EnergyStretch with kb=%lf r0=%lf", this[01;31m-[00m>term.kb, this[01;31m-[00m>term.r0 ));
energyStretch.cc:58://    this[01;31m-[00m>_K3 = stretch[01;31m-[00m>_K3;
energyStretch.cc:59://    this[01;31m-[00m>_K4 = stretch[01;31m-[00m>_K4;
energyStretch.cc:60://    this[01;31m-[00m>_Bci = stretch[01;31m-[00m>_Bci;
energyStretch.cc:61:    this[01;31m-[00m>_Atom1 = ea1[01;31m-[00m>_Atom;
energyStretch.cc:62:    this[01;31m-[00m>_Atom2 = ea2[01;31m-[00m>_Atom;
energyStretch.cc:63:    LOG(BF(" Adding stretch between %s [01;31m-[00m %s")% this[01;31m-[00m>_Atom1[01;31m-[00m>description() % this[01;31m-[00m>_Atom2[01;31m-[00m>description() );
energyStretch.cc:64:    this[01;31m-[00m>term.I1 = ea1[01;31m-[00m>_CoordinateIndex;
energyStretch.cc:65:    this[01;31m-[00m>term.I2 = ea2[01;31m-[00m>_CoordinateIndex;
energyStretch.cc:66:    this[01;31m-[00m>term.kb = stretch[01;31m-[00m>_kb*scale;
energyStretch.cc:67:    this[01;31m-[00m>term.r0 = stretch[01;31m-[00m>_r0;
energyStretch.cc:77:    node[01;31m-[00m>addAttributeHex("address",(unsigned long)(this));
energyStretch.cc:78:    node[01;31m-[00m>addAttributeString("atom1Name",this[01;31m-[00m>_Atom1[01;31m-[00m>getName());
energyStretch.cc:79:    node[01;31m-[00m>addAttributeString("atom2Name",this[01;31m-[00m>_Atom2[01;31m-[00m>getName());
energyStretch.cc:80://    node[01;31m-[00m>addAttributeInt("idx1",this[01;31m-[00m>_Atom1[01;31m-[00m>_CoordinateIndex);
energyStretch.cc:81://    node[01;31m-[00m>addAttributeInt("idx2",this[01;31m-[00m>_Atom2[01;31m-[00m>_CoordinateIndex);
energyStretch.cc:82:    node[01;31m-[00m>addAttributeInt("I1",this[01;31m-[00m>term.I1);
energyStretch.cc:83:    node[01;31m-[00m>addAttributeInt("I2",this[01;31m-[00m>term.I2);
energyStretch.cc:84:    node[01;31m-[00m>addAttributeDoubleScientific("r0",this[01;31m-[00m>term.r0);
energyStretch.cc:85:    node[01;31m-[00m>addAttributeDoubleScientific("kb",this[01;31m-[00m>term.kb);
energyStretch.cc:88:    xml[01;31m-[00m>addAttributeBool("calcForce",this[01;31m-[00m>_calcForce );
energyStretch.cc:89:    xml[01;31m-[00m>addAttributeBool("calcDiagonalHessian",this[01;31m-[00m>_calcDiagonalHessian );
energyStretch.cc:90:    xml[01;31m-[00m>addAttributeBool("calcOffDiagonalHessian",
energyStretch.cc:91:				this[01;31m-[00m>_calcOffDiagonalHessian );
energyStretch.cc:97:    node[01;31m-[00m>addChild(xml);
energyStretch.cc:104:{_F(xml[01;31m-[00m>lisp());
energyStretch.cc:106:    i1 = xml[01;31m-[00m>getAttributeInt("idx1");
energyStretch.cc:107:    i2 = xml[01;31m-[00m>getAttributeInt("idx2");
energyStretch.cc:109:    this[01;31m-[00m>_Atom1 = atomTable[01;31m-[00m>findEnergyAtom(i1)[01;31m-[00m>_Atom;
energyStretch.cc:110:    this[01;31m-[00m>_Atom2 = atomTable[01;31m-[00m>findEnergyAtom(i2)[01;31m-[00m>_Atom;
energyStretch.cc:112:    this[01;31m-[00m>term.r0 = xml[01;31m-[00m>getAttributeDouble("r0");
energyStretch.cc:113:    this[01;31m-[00m>term.kb = xml[01;31m-[00m>getAttributeDouble("kb");
energyStretch.cc:114:    this[01;31m-[00m>term.I1 = xml[01;31m-[00m>getAttributeInt("I1");
energyStretch.cc:115:    this[01;31m-[00m>term.I2 = xml[01;31m-[00m>getAttributeInt("I2");
energyStretch.cc:123:    pos1 = this[01;31m-[00m>getAtom1()[01;31m-[00m>getPosition();
energyStretch.cc:124:    pos2 = this[01;31m-[00m>getAtom2()[01;31m-[00m>getPosition();
energyStretch.cc:182:#define	STRETCH_SET_PARAMETER(x)	{x = si[01;31m-[00m>term.x;}
energyStretch.cc:184:#define	STRETCH_SET_POSITION(x,ii,of)	{x = nvPosition[01;31m-[00m>getElement(ii+of);}
energyStretch.cc:191:	m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyStretch.cc:195:	m[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
energyStretch.cc:201:    if ( this[01;31m-[00m>isEnabled() ) {
energyStretch.cc:213://	stretchScale = this[01;31m-[00m>getScale();
energyStretch.cc:214:	for ( vector<EnergyStretch>::iterator si=this[01;31m-[00m>_Terms.begin();
energyStretch.cc:215:		    si!=this[01;31m-[00m>_Terms.end(); si++ ) {
energyStretch.cc:233:{ _F(this[01;31m-[00m>lisp());
energyStretch.cc:234:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyStretch.cc:237:	LOG_ENERGY(BF("%s {\n")% this[01;31m-[00m>className());
energyStretch.cc:245:bool	hasForce = force[01;31m-[00m>notNil();
energyStretch.cc:246:bool	hasHessian = hessian[01;31m-[00m>notNil();
energyStretch.cc:247:bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
energyStretch.cc:253:#define	STRETCH_SET_PARAMETER(x)	{x = si[01;31m-[00m>term.x;}
energyStretch.cc:255:#define	STRETCH_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>getElement(ii+of);}
energyStretch.cc:257:#define	STRETCH_ENERGY_ACCUMULATE(e) this[01;31m-[00m>_TotalEnergy += (e);
energyStretch.cc:265:    if ( this[01;31m-[00m>isEnabled() ) 
energyStretch.cc:273:	for ( i=0,si=this[01;31m-[00m>_Terms.begin();
energyStretch.cc:274:		    si!=this[01;31m-[00m>_Terms.end(); si++,i++ ) {
energyStretch.cc:276:		if ( this[01;31m-[00m>_Debug_NumberOfTermsToCalculate > 0 ) {
energyStretch.cc:277:		    if ( i>= this[01;31m-[00m>_Debug_NumberOfTermsToCalculate ) {
energyStretch.cc:287:		si[01;31m-[00m>_calcForce = calcForce;
energyStretch.cc:288:		si[01;31m-[00m>_calcDiagonalHessian = calcDiagonalHessian;
energyStretch.cc:289:		si[01;31m-[00m>_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyStretch.cc:291:		#define EVAL_SET(var,val) {si[01;31m-[00m>eval.var=val;}
energyStretch.cc:294:	    if ( this[01;31m-[00m>_DebugEnergy ) {
energyStretch.cc:319:	    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyStretch.cc:320:	    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyStretch.cc:321:	    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyStretch.cc:322:	    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyStretch.cc:323:	    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyStretch.cc:324:	    _lisp[01;31m-[00m>profiler().eventCounter(forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyStretch.cc:327:    if ( this[01;31m-[00m>_DebugEnergy ) 
energyStretch.cc:329:	LOG_ENERGY(BF("%s }")% this[01;31m-[00m>className());
energyStretch.cc:351:#define	STRETCH_SET_PARAMETER(x)	{x = si[01;31m-[00m>term.x;}
energyStretch.cc:353:#define	STRETCH_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>getElement(ii+of);}
energyStretch.cc:363:	if ( this[01;31m-[00m>isEnabled() ) {
energyStretch.cc:370://	    stretchScale = this[01;31m-[00m>getScale();
energyStretch.cc:372:	    for ( i=0,si=this[01;31m-[00m>_Terms.begin();
energyStretch.cc:373:			si!=this[01;31m-[00m>_Terms.end(); si++,i++ ) {
energyStretch.cc:401:    this[01;31m-[00m>_BeyondThresholdTerms.clear();
energyStretch.cc:407:#define	STRETCH_SET_PARAMETER(x)	{x = si[01;31m-[00m>term.x;}
energyStretch.cc:409:#define	STRETCH_SET_POSITION(x,ii,of)	{x = pos[01;31m-[00m>getElement(ii+of);}
energyStretch.cc:419:	if ( this[01;31m-[00m>isEnabled() ) {
energyStretch.cc:426://	    stretchScale = this[01;31m-[00m>getScale();
energyStretch.cc:428:	    for ( i=0,si=this[01;31m-[00m>_Terms.begin();
energyStretch.cc:429:			si!=this[01;31m-[00m>_Terms.end(); si++,i++ ) {
energyStretch.cc:434:		if ( fabs(StretchDeviation)/r0 > this[01;31m-[00m>_ErrorThreshold ) {
energyStretch.cc:440:		    info<<"threshold " << this[01;31m-[00m>_ErrorThreshold << " Atoms(";
energyStretch.cc:441:		    info << a1[01;31m-[00m>getName() << " ";
energyStretch.cc:442:		    info << a2[01;31m-[00m>getName() << ")";
energyStretch.cc:444:		    this[01;31m-[00m>_BeyondThresholdTerms.push_back(*si);
energyStretch.cc:460:    for ( esi=this[01;31m-[00m>_Terms.begin(); esi!=this[01;31m-[00m>_Terms.end(); esi++ ) {
energyStretch.cc:461:	as1 = atomLabel(esi[01;31m-[00m>_Atom1);
energyStretch.cc:462:	as2 = atomLabel(esi[01;31m-[00m>_Atom2);
energyStretch.cc:470:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("TERM 1BND %[01;31m-[00m9s [01;31m-[00m %[01;31m-[00m9s %8.2lf %8.2lf") 
energyStretch.cc:473:			    % esi[01;31m-[00m>term.kb
energyStretch.cc:474:			    % esi[01;31m-[00m>term.r0 );
energyStretch.cc:485:    class_<O_EnergyStretch>(e[01;31m-[00m>lisp())
energyStretch.cc:497:    this[01;31m-[00m>Base::initialize();
energyStretch.cc:498:    this[01;31m-[00m>setErrorThreshold(0.05);
energyStretch.cc:503:    this[01;31m-[00m>Base::archiveBase(node);
energyStretch.cc:510:    this[01;31m-[00m>_Terms.push_back(term);
entity.cc:21:    this[01;31m-[00m>Base::initialize();
entity.cc:37:{_F(this[01;31m-[00m>lisp());
entity.cc:38:    this[01;31m-[00m>Base::archiveBase(node);
entity.cc:43:{_F(this[01;31m-[00m>lisp());
entity.cc:44:    RPConstitution x = O_Constitution::nil(this[01;31m-[00m>lisp());
entity.cc:55:    class_<O_Entity>(this[01;31m-[00m>lisp())
environment.cc:32:	allowedSymbols.insert(lisp[01;31m-[00m>intern(*str));
environment.cc:34:    RPBinder binder = lisp[01;31m-[00m>create<O_Binder>();
environment.cc:35:    while ( args[01;31m-[00m>notNil() )
environment.cc:39:	if ( args[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Cons>() )
environment.cc:41:	    RPCons one = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
environment.cc:42:	    if ( !one[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
environment.cc:44:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You must provide a list of (symbol object) pairs [01;31m-[00m you gave: %s") % one[01;31m-[00m>__repr__()));
environment.cc:46:	    key = one[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
environment.cc:47:	    val = one[01;31m-[00m>ocadr();
environment.cc:48:	    if ( one[01;31m-[00m>cddr()[01;31m-[00m>notNil() )
environment.cc:50:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You must provide a list of (symbol object) pairs [01;31m-[00m you gave: %s") % one[01;31m-[00m>__repr__()));
environment.cc:52:	    args = args[01;31m-[00m>cdr();
environment.cc:53:	} else if ( args[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
environment.cc:55:	    key = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
environment.cc:56:	    args = args[01;31m-[00m>cdr();
environment.cc:57:	    val = args[01;31m-[00m>ocar();
environment.cc:58:	    args = args[01;31m-[00m>cdr();
environment.cc:62:	    ss << "instead I got the cons: " << args[01;31m-[00m>__repr__();
environment.cc:63:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
environment.cc:68:	    ss << "The symbol(" << key[01;31m-[00m>fullName() << ") is illegal here [01;31m-[00m expected one of(";
environment.cc:73:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
environment.cc:75:	binder[01;31m-[00m>extend(key,val);
environment.cc:87:{_F(this[01;31m-[00m>lisp());
environment.cc:89:    if ( node[01;31m-[00m>saving() )
environment.cc:90:    { _BLOCK_TRACEF(BF("Saving %d entries") % this[01;31m-[00m>_Bindings.size() );
environment.cc:92:	for ( oi=this[01;31m-[00m>_Bindings.begin(); oi!=this[01;31m-[00m>_Bindings.end(); oi++ )
environment.cc:93:	{ _BLOCK_TRACEF(BF("Archiving map entry with name(%s)") %oi[01;31m-[00m>first[01;31m-[00m>__repr__() );
environment.cc:94:	    node[01;31m-[00m>archiveObject(oi[01;31m-[00m>first[01;31m-[00m>fullName(),oi[01;31m-[00m>second);
environment.cc:98:        this[01;31m-[00m>_Bindings.clear();
environment.cc:102:	for ( ci=node[01;31m-[00m>begin_Children(); ci!=node[01;31m-[00m>end_Children(); ci++ )
environment.cc:104:	    object = node[01;31m-[00m>loadObjectDirectly(*ci);
environment.cc:106:	    key = (*ci)[01;31m-[00m>getUniqueIdCharactersIfMissingThrow();
environment.cc:107:	    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(key);
environment.cc:108:	    this[01;31m-[00m>_Bindings[sym] = object;
environment.cc:109:	    (*ci)[01;31m-[00m>setRecognized(true);
environment.cc:116:{_F(this[01;31m-[00m>lisp());
environment.cc:117:    RPRenderDisplayList dl = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
environment.cc:119:    for ( oi=this[01;31m-[00m>_Bindings.begin(); oi!=this[01;31m-[00m>_Bindings.end(); oi++ )
environment.cc:120:    { _BLOCK_TRACEF(BF("Trying to render entry with name(%s)") % oi[01;31m-[00m>first[01;31m-[00m>__repr__().c_str());
environment.cc:121:        if ( oi[01;31m-[00m>second[01;31m-[00m>canRender() )
environment.cc:123:	    RPRender part = oi[01;31m-[00m>second[01;31m-[00m>rendered(kargs);
environment.cc:124:	    part[01;31m-[00m>setName(oi[01;31m-[00m>first[01;31m-[00m>fullName());
environment.cc:125:	    dl[01;31m-[00m>add(part);
environment.cc:132:{_F(this[01;31m-[00m>lisp());
environment.cc:139:    for( O_Binder::iterator it=this[01;31m-[00m>_Bindings.begin(); it!=this[01;31m-[00m>_Bindings.end(); it++ )
environment.cc:141:	if ( !(it[01;31m-[00m>first[01;31m-[00m>isKeywordSymbol()) )
environment.cc:143:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("The binder should only contain keyword symbols as keys [01;31m-[00m it has the key(%s)") % it[01;31m-[00m>first[01;31m-[00m>fullName() ));
environment.cc:145:	if ( allowed.count(it[01;31m-[00m>first[01;31m-[00m>identifierName())!=1 )
environment.cc:147:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Illegal key(%s)") % it[01;31m-[00m>first[01;31m-[00m>fullName() ));
environment.cc:154:{_F(this[01;31m-[00m>lisp());
environment.cc:155:    for ( O_Binder::iterator it=other[01;31m-[00m>begin(); it!=other[01;31m-[00m>end(); it++ )
environment.cc:157:	this[01;31m-[00m>extend(it[01;31m-[00m>first,it[01;31m-[00m>second);
environment.cc:167:{_F(this[01;31m-[00m>lisp());
environment.cc:168:    O_Binder::iterator it = this[01;31m-[00m>_Bindings.find(sym);
environment.cc:169:    if ( it==this[01;31m-[00m>_Bindings.end() )
environment.cc:171:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("In update, could not find variable binding for symbol: "+sym[01;31m-[00m>fullName()));
environment.cc:173:    it[01;31m-[00m>second = val;
environment.cc:178:{_F(this[01;31m-[00m>lisp());
environment.cc:179:    this[01;31m-[00m>_Bindings[sym] = val;
environment.cc:184:{_F(this[01;31m-[00m>lisp());
environment.cc:185:    O_Binder::iterator it = this[01;31m-[00m>_Bindings.find(sym);
environment.cc:186:    if ( it==this[01;31m-[00m>_Bindings.end() )
environment.cc:188:	TOSS(_lisp[01;31m-[00m>error(BF("Could not find variable binding for %s") % sym[01;31m-[00m>__repr__() ));
environment.cc:190:    return it[01;31m-[00m>second;
environment.cc:195:{_F(this[01;31m-[00m>lisp());
environment.cc:196:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(symStr);
environment.cc:197:    return this[01;31m-[00m>lookup(sym);
environment.cc:205:    LOG(BF("Looking for symbol(%s)")%  sym[01;31m-[00m>fullName() );
environment.cc:206:    O_Binder::iterator it = this[01;31m-[00m>_Bindings.find(sym);
environment.cc:208:    if ( it == this[01;31m-[00m>_Bindings.end() )
environment.cc:210:	LOG(BF("Could not find symbol(%s)")% sym[01;31m-[00m>fullName() );
environment.cc:211:	LOG(BF("  In the binder which contains symbols: %s")% this[01;31m-[00m>allKeysAsString() );
environment.cc:219:{_F(this[01;31m-[00m>lisp());
environment.cc:220:    return this[01;31m-[00m>find(sym)!=this[01;31m-[00m>end();
environment.cc:225:{_F(this[01;31m-[00m>lisp());
environment.cc:226:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>findSymbol(str);
environment.cc:227:    if ( sym[01;31m-[00m>isNil() ) return false;
environment.cc:228:    return this[01;31m-[00m>contains(sym);
environment.cc:235:{_F(this[01;31m-[00m>lisp());
environment.cc:236:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>findSymbol(str);
environment.cc:237:    return this[01;31m-[00m>value(sym);
environment.cc:243:{_F(this[01;31m-[00m>lisp());
environment.cc:244:    if ( !this[01;31m-[00m>containsSymbolFromString(kw) )
environment.cc:248:    dest = this[01;31m-[00m>lookup(kw)[01;31m-[00m>as<O_Bool>()[01;31m-[00m>get();
environment.cc:253:{_F(this[01;31m-[00m>lisp());
environment.cc:254:    if ( !this[01;31m-[00m>containsSymbolFromString(kw) )
environment.cc:258:    dest = this[01;31m-[00m>lookup(kw)[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
environment.cc:263:{_F(this[01;31m-[00m>lisp());
environment.cc:264:    if ( !this[01;31m-[00m>containsSymbolFromString(kw) )
environment.cc:268:    dest = this[01;31m-[00m>lookup(kw)[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
environment.cc:275:    if ( !this[01;31m-[00m>containsSymbolFromString(kw) )
environment.cc:279:    return this[01;31m-[00m>lookup(kw)[01;31m-[00m>as<O_Bool>()[01;31m-[00m>get();
environment.cc:284:    if ( !this[01;31m-[00m>contains(sym) )
environment.cc:288:    return this[01;31m-[00m>lookup(sym)[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
environment.cc:294:    if ( !this[01;31m-[00m>containsSymbolFromString(kw) )
environment.cc:298:    return this[01;31m-[00m>lookup(kw)[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
environment.cc:304:    if ( !this[01;31m-[00m>containsSymbolFromString(kw) )
environment.cc:308:    return this[01;31m-[00m>lookup(kw)[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
environment.cc:316:    return this[01;31m-[00m>allKeysAsString();
environment.cc:325:    for ( O_Binder::const_iterator it=this[01;31m-[00m>_Bindings.begin(); it!=this[01;31m-[00m>_Bindings.end(); it++ )
environment.cc:327:	string one = it[01;31m-[00m>first[01;31m-[00m>fullName();
environment.cc:341:    RPStringSet result = O_StringSet::create(this[01;31m-[00m>lisp());
environment.cc:342:    for ( O_Binder::const_iterator it=this[01;31m-[00m>_Bindings.begin(); it!=this[01;31m-[00m>_Bindings.end(); it++ )
environment.cc:344:	result[01;31m-[00m>insert(it[01;31m-[00m>first[01;31m-[00m>currentName());
environment.cc:352:    RPCons first = O_Cons::create(this[01;31m-[00m>lisp());
environment.cc:354:    for ( O_Binder::const_iterator it=this[01;31m-[00m>_Bindings.begin(); it!=this[01;31m-[00m>_Bindings.end(); it++ )
environment.cc:356:	RPCons one = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(it[01;31m-[00m>first[01;31m-[00m>__repr__()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
environment.cc:357:	cur[01;31m-[00m>setCdr(one);
environment.cc:360:    return first[01;31m-[00m>cdr();
environment.cc:370:{_F(this[01;31m-[00m>lisp());
environment.cc:371:    return this[01;31m-[00m>_Bindings.find(sym);
environment.cc:375:{_F(this[01;31m-[00m>lisp());
environment.cc:376:    O_FormBinder::iterator it = this[01;31m-[00m>find(sym);
environment.cc:377:    if ( it == this[01;31m-[00m>end() )
environment.cc:379:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Could not update form(%s) because it was not defined") % sym[01;31m-[00m>__repr__() ));
environment.cc:381:    it[01;31m-[00m>second = obj;
environment.cc:385:{_F(this[01;31m-[00m>lisp());
environment.cc:386:    this[01;31m-[00m>_Bindings[sym] = obj;
environment.cc:390:{_F(this[01;31m-[00m>lisp());
environment.cc:391:    O_FormBinder::iterator it=this[01;31m-[00m>find(sym);
environment.cc:392:    if ( it==this[01;31m-[00m>end() )
environment.cc:394:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Could not find form(%s)") % sym[01;31m-[00m>__repr__() ));
environment.cc:396:    return it[01;31m-[00m>second;
environment.cc:430:    environ[01;31m-[00m>setParent(parent);
environment.cc:441:    this[01;31m-[00m>Base::initialize();
environment.cc:445:    this[01;31m-[00m>_Id = this[01;31m-[00m>lisp()[01;31m-[00m>nextEnvironmentId();
environment.cc:446:    this[01;31m-[00m>_Depth = 0; 
environment.cc:447:    this[01;31m-[00m>_ParentEnvironment = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Environment>();
environment.cc:448:    this[01;31m-[00m>_Forms = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_FormBinder>();
environment.cc:449:    this[01;31m-[00m>_Values = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Binder>();
environment.cc:454:{_F(this[01;31m-[00m>lisp());
environment.cc:455:    this[01;31m-[00m>_ParentEnvironment = environ;
environment.cc:456:    if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>isNil() )
environment.cc:458:	this[01;31m-[00m>_Depth = 0;
environment.cc:461:	this[01;31m-[00m>_Depth = this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>depth()+1;
environment.cc:467:    ASSERT_NOT_NULL(this[01;31m-[00m>_ParentEnvironment);
environment.cc:468:    return this[01;31m-[00m>_ParentEnvironment;
environment.cc:472:{_F(this[01;31m-[00m>lisp());
environment.cc:474:    ss << this[01;31m-[00m>className() << "#" << this[01;31m-[00m>_Id << " value bindings: " << this[01;31m-[00m>_Values[01;31m-[00m>summaryOfContents() << endl;
environment.cc:483:{_F(this[01;31m-[00m>lisp());
environment.cc:485:    ss <<this[01;31m-[00m>summaryOfContents();
environment.cc:486:    if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>notNil() )
environment.cc:488:	ss << this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>__repr__();
environment.cc:490:    ss << "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
environment.cc:502:{_F(this[01;31m-[00m>lisp());
environment.cc:503:    if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>isNil() )
environment.cc:505:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not get HeadSymbol"));
environment.cc:507:    return this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>getHeadSymbol();
environment.cc:514:    RPBinder top = this[01;31m-[00m>_Values;
environment.cc:515:    return top[01;31m-[00m>allKeysAsString();
environment.cc:521:    return this[01;31m-[00m>_Values[01;31m-[00m>allKeysAsCons();
environment.cc:527:{_F(this[01;31m-[00m>lisp());
environment.cc:534:{_F(this[01;31m-[00m>lisp());
environment.cc:535:    this[01;31m-[00m>_Code = code;
environment.cc:544:{_F(this[01;31m-[00m>lisp());
environment.cc:545:    return this[01;31m-[00m>_Code;
environment.cc:551:    ASSERT_NOT_NULL(this[01;31m-[00m>_ParentEnvironment);
environment.cc:552:    return this[01;31m-[00m>_Depth;
environment.cc:557:{_F(this[01;31m-[00m>lisp());
environment.cc:560:    this[01;31m-[00m>_Handlers.push_back(hh);
environment.cc:565:{_F(this[01;31m-[00m>lisp());
environment.cc:566:    for ( handlerIterator hi = this[01;31m-[00m>_Handlers.begin(); hi!=this[01;31m-[00m>_Handlers.end(); hi++ )
environment.cc:568:	if (cond[01;31m-[00m>isSubClassOf(hi[01;31m-[00m>getCondition()))
environment.cc:570:	    return hi[01;31m-[00m>getHandler();
environment.cc:573:    if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>isNil() )
environment.cc:575:	return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Executable>();
environment.cc:577:    return this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>lookupHandler(cond);
environment.cc:583:{_F(this[01;31m-[00m>lisp());
environment.cc:584:    LOG(BF("Looking for binding for symbol(%s)")% sym[01;31m-[00m>__repr__() );
environment.cc:585:    LOG(BF("The frame stack is %d deep") % this[01;31m-[00m>depth() );
environment.cc:586:    ASSERT_NOT_NULL(this[01;31m-[00m>_ParentEnvironment);
environment.cc:588:    RPBinder level = this[01;31m-[00m>_Values;
environment.cc:589:    fi = level[01;31m-[00m>find(sym);
environment.cc:590:    if ( fi==level[01;31m-[00m>end() )
environment.cc:592:	if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>isNil() )
environment.cc:598:	return this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>find(sym);
environment.cc:600:    LOG(BF(" Found binding %s")% fi[01;31m-[00m>second[01;31m-[00m>__repr__() );
environment.cc:606:{_F(this[01;31m-[00m>lisp());
environment.cc:607:    LOG(BF("Looking for binding for symbol(%s)")% sym[01;31m-[00m>__repr__() );
environment.cc:608:    RPBinder level = this[01;31m-[00m>_Values;
environment.cc:609:    O_Binder::iterator fi = level[01;31m-[00m>find(sym);
environment.cc:610:    if ( fi!= level[01;31m-[00m>end() ) 
environment.cc:612:	LOG(BF(" Found binding %s")% fi[01;31m-[00m>second[01;31m-[00m>__repr__() );
environment.cc:621:    O_Binder::iterator it = this[01;31m-[00m>findLocal(sym);
environment.cc:622:    if ( it == this[01;31m-[00m>end() )
environment.cc:624:	if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>isNil() ) return false;
environment.cc:625:	return this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>definedQ(sym);
environment.cc:638:{_F(this[01;31m-[00m>lisp());
environment.cc:639:    ASSERTF(!sym[01;31m-[00m>isDynamic(),BF("You tried to update an environment with the dynamic scope variable(%s)") % sym[01;31m-[00m>__repr__());
environment.cc:640:    O_Binder::iterator it = this[01;31m-[00m>findLocal(sym);
environment.cc:641:    if ( it == this[01;31m-[00m>end() )
environment.cc:643:	if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>isNil() )
environment.cc:645:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Could not update local symbol(%s) because it was not defined") % sym[01;31m-[00m>__repr__() ));
environment.cc:647:	this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>update(sym,obj);
environment.cc:650:    it[01;31m-[00m>second = obj;
environment.cc:657:    O_Binder::iterator it = this[01;31m-[00m>find(sym);
environment.cc:658:    if ( it == this[01;31m-[00m>end() )
environment.cc:660:	this[01;31m-[00m>extend(sym,obj);
environment.cc:663:	it[01;31m-[00m>second = obj;
environment.cc:673:{_F(this[01;31m-[00m>lisp());
environment.cc:674:    ASSERT(this[01;31m-[00m>lisp()[01;31m-[00m>isEnvironmentInitialized() );
environment.cc:675:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(symStr);
environment.cc:676:    return this[01;31m-[00m>lookup(sym);
environment.cc:682:{_F(this[01;31m-[00m>lisp());
environment.cc:683:    if ( sym[01;31m-[00m>isKeywordSymbol() || sym[01;31m-[00m>isAmpSymbol() ) return sym;
environment.cc:684:    if ( sym[01;31m-[00m>isDynamic() ) return sym[01;31m-[00m>dynamicValue();
environment.cc:685:    ASSERT(this[01;31m-[00m>lisp()[01;31m-[00m>isEnvironmentInitialized() );
environment.cc:686:    O_Binder::iterator it = this[01;31m-[00m>find(sym);
environment.cc:687:    if ( it == this[01;31m-[00m>end() )
environment.cc:689:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Could not find variable binding for symbol(%s)") % (sym[01;31m-[00m>__repr__()) ));
environment.cc:691:    return it[01;31m-[00m>second;
environment.cc:696:{_F(this[01;31m-[00m>lisp());
environment.cc:697:    this[01;31m-[00m>_Values[01;31m-[00m>extend(sym,obj);
environment.cc:701:{_F(this[01;31m-[00m>lisp());
environment.cc:702:    this[01;31m-[00m>_Forms[01;31m-[00m>extend(sym,form);
environment.cc:706:{_F(this[01;31m-[00m>lisp());
environment.cc:707:    O_FormBinder::iterator it = this[01;31m-[00m>_Forms[01;31m-[00m>find(sym);
environment.cc:708:    if ( it != this[01;31m-[00m>_Forms[01;31m-[00m>end() )
environment.cc:710:	return it[01;31m-[00m>second;
environment.cc:712:    ASSERT_NOT_NULL(this[01;31m-[00m>_ParentEnvironment);
environment.cc:713:    if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>isNil() )
environment.cc:715:	return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Executable>();
environment.cc:717:    return this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>lookupForm(sym);
environment.cc:722:{_F(this[01;31m-[00m>lisp());
environment.cc:723:    if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>isNil() )
environment.cc:725:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not get Receiver class"));
environment.cc:727:    return this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>getReceiverClass();
environment.cc:732:    if ( this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>isNil() )
environment.cc:734:	return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Executable>();
environment.cc:736:    return this[01;31m-[00m>_ParentEnvironment[01;31m-[00m>lookupHandler(cond);
environment.cc:752:    environ[01;31m-[00m>setParent(parent);
environment.cc:753:    environ[01;31m-[00m>setHeadSymbol(headSymbol);
environment.cc:764:    this[01;31m-[00m>Base::initialize();
environment.cc:769:    this[01;31m-[00m>_HeadSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Symbol>();
environment.cc:779:{_F(this[01;31m-[00m>lisp());
environment.cc:781:    ss << this[01;31m-[00m>className() << "#" << this[01;31m-[00m>_Id << " value bindings: " << this[01;31m-[00m>_Values[01;31m-[00m>summaryOfContents() << endl;
environment.cc:782:    ss << "Macro symbol: " << this[01;31m-[00m>_HeadSymbol[01;31m-[00m>__repr__() << endl;
environment.cc:788:{_F(this[01;31m-[00m>lisp());
environment.cc:789:    ASSERT_NOT_NULL(this[01;31m-[00m>_HeadSymbol);
environment.cc:790:    return this[01;31m-[00m>_HeadSymbol;
environment.cc:795:{_F(this[01;31m-[00m>lisp());
environment.cc:796:    this[01;31m-[00m>_HeadSymbol = sym;
environment.cc:835:    environ[01;31m-[00m>setParent(parent);
environment.cc:836:    environ[01;31m-[00m>setHeadSymbol(headSymbol);
environment.cc:847:    this[01;31m-[00m>Base::initialize();
environment.cc:852:    this[01;31m-[00m>_HeadSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Symbol>();
environment.cc:863:{_F(this[01;31m-[00m>lisp());
environment.cc:864:    this[01;31m-[00m>_HeadSymbol = sym;
environment.cc:869:{_F(this[01;31m-[00m>lisp());
environment.cc:871:    ss << this[01;31m-[00m>className() << "#" << this[01;31m-[00m>_Id << " value bindings: " << this[01;31m-[00m>_Values[01;31m-[00m>summaryOfContents() << endl;
environment.cc:872:    ss << "Procedure symbol: " << this[01;31m-[00m>_HeadSymbol[01;31m-[00m>__repr__() << endl;
environment.cc:877:{_F(this[01;31m-[00m>lisp());
environment.cc:878:    ASSERT_NOT_NULL(this[01;31m-[00m>_HeadSymbol);
environment.cc:879:    return this[01;31m-[00m>_HeadSymbol;
environment.cc:901:    environ[01;31m-[00m>setParent(parent);
environment.cc:902:    environ[01;31m-[00m>setHeadSymbol(lisp[01;31m-[00m>nil<O_Symbol>());
environment.cc:903:    environ[01;31m-[00m>setReceiverClass(lisp[01;31m-[00m>nil<O_MetaClass>());
environment.cc:910:    return O_MethodEnvironment::create(lisp[01;31m-[00m>nil<O_Symbol>(),lisp[01;31m-[00m>nil<O_MetaClass>(),parent,lisp);
environment.cc:920:    this[01;31m-[00m>Base::initialize();
environment.cc:925:    this[01;31m-[00m>_ReceiverClass = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_MetaClass>();
environment.cc:929:{_F(this[01;31m-[00m>lisp());
environment.cc:930:    ASSERT_NOT_NULL(this[01;31m-[00m>_ReceiverClass);
environment.cc:931:    return this[01;31m-[00m>_ReceiverClass;
environment.cc:936:{_F(this[01;31m-[00m>lisp());
environment.cc:937:    this[01;31m-[00m>_ReceiverClass = mc;
environment.cc:949:{_F(this[01;31m-[00m>lisp());
environment.cc:951:    ss << this[01;31m-[00m>className() << "#" << this[01;31m-[00m>_Id << " contents [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
environment.cc:952:    ss << "Method symbol: " << this[01;31m-[00m>_HeadSymbol[01;31m-[00m>__repr__() << endl;
environment.cc:953:    ss << "Receiver class: " << this[01;31m-[00m>_ReceiverClass[01;31m-[00m>__repr__() << endl;
environment.cc:955:    ss << this[01;31m-[00m>_Values[01;31m-[00m>summaryOfContents() << endl;
environment.cc:981:    environ[01;31m-[00m>setParent(parent);
environment.cc:992:    this[01;31m-[00m>Base::initialize();
environment.cc:1005:{_F(this[01;31m-[00m>lisp());
environment.cc:1007:    ss << this[01;31m-[00m>className() << "#" << this[01;31m-[00m>_Id << " value bindings: " << this[01;31m-[00m>_Values[01;31m-[00m>summaryOfContents() << endl;
environment.cc:1009:    for ( it=this[01;31m-[00m>_Handlers.begin(); it!=this[01;31m-[00m>_Handlers.end(); it++ )
environment.cc:1011:	ss << "Condition handler class: " << it[01;31m-[00m>getCondition()[01;31m-[00m>__repr__() << " code: [01;31m-[00minsert here[01;31m-[00m" << endl;
environmentDependent.cc:25:    this[01;31m-[00m>Base::initialize();
environmentDependent.cc:26://    this[01;31m-[00m>_WeakEnvironment = O_Lisp::nil(this[01;31m-[00m>lisp());
environmentDependent.cc:35://    this[01;31m-[00m>_WeakEnvironment = emr._WeakEnvironment;
environmentDependent.cc:46:{_F(this[01;31m-[00m>lisp());
environmentDependent.cc:51:    node[01;31m-[00m>needsFinalization();
environmentDependent.cc:55:{_F(this[01;31m-[00m>lisp());
environmentDependent.cc:56:    this[01;31m-[00m>archiveBase(node);
environmentDependent.cc:63:{_F(this[01;31m-[00m>lisp());
environmentDependent.cc:67:    archive = node[01;31m-[00m>getArchive();
environmentDependent.cc:68:    lisp = archive[01;31m-[00m>getEnvironment();
environmentDependent.cc:70:    LOG(BF("The environment@%X has been defined and environment[01;31m-[00m>notNil() = %d") % lisp.get() % lisp[01;31m-[00m>notNil() ); // vp0(("The environment@%X has been defined and environment[01;31m-[00m>notNil() = %d", lisp.get(), lisp[01;31m-[00m>notNil()));
environmentDependent.cc:72:    ASSERT(lisp[01;31m-[00m>notNil());
environmentDependent.cc:73://    this[01;31m-[00m>_WeakEnvironment = lisp;
environmentDependent.cc:79:{_F(this[01;31m-[00m>lisp());
environmentDependent.cc:80:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
environmentDependent.cc:81://    this[01;31m-[00m>_WeakEnvironment = env[01;31m-[00m>sharedThis<O_Lisp>();
environmentDependent.cc:86:{_F(this[01;31m-[00m>lisp());
environmentDependent.cc:88:    LOG(BF("The environment@%X has been defined and environment[01;31m-[00m>notNil() = %d") % env.get() % env[01;31m-[00m>notNil() ); // vp0(("The environment@%X has been defined and environment[01;31m-[00m>notNil() = %d", env.get(), env[01;31m-[00m>notNil()));
environmentDependent.cc:90:    if ( env[01;31m-[00m>isNil() )
environmentDependent.cc:92:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is a problem, the environment is nil!!!!!"));
environmentDependent.cc:96:    this[01;31m-[00m>_WeakEnvironment = env;
environmentDependent.cc:104:    class_<O_EnvironmentDependent>(this[01;31m-[00m>lisp())
evaluateEnergy.cc:21:    if ( this[01;31m-[00m>_CalculateStretchEnergy ) {
evaluateEnergy.cc:22:	for ( vector<EnergyStretch>::iterator si=this[01;31m-[00m>_StretchTerms.begin();
evaluateEnergy.cc:23:		    si!=this[01;31m-[00m>_StretchTerms.end(); si++ ) {
evaluateEnergy.cc:27:    if ( this[01;31m-[00m>_CalculateAngleEnergy ) {
evaluateEnergy.cc:28:	for ( vector<EnergyAngle>::iterator ai=this[01;31m-[00m>_AngleTerms.begin();
evaluateEnergy.cc:29:		    ai!=this[01;31m-[00m>_AngleTerms.end(); ai++ ) {
evaluateEnergy.cc:33:    if ( this[01;31m-[00m>_CalculateDihedralEnergy ) {
evaluateEnergy.cc:34:	for ( vector<EnergyDihedral>::iterator di=this[01;31m-[00m>_DihedralTerms.begin();
evaluateEnergy.cc:35:		    di!=this[01;31m-[00m>_DihedralTerms.end(); di++ ) {
evaluateEnergy.cc:39:    if ( this[01;31m-[00m>_CalculateImproperRestraintEnergy ) {
evaluateEnergy.cc:40:	for ( vector<AmberImproperRestraint>::iterator iri=this[01;31m-[00m>_ImproperRestraintTerms.begin();
evaluateEnergy.cc:41:		    iri!=this[01;31m-[00m>_ImproperRestraintTerms.end(); iri++ ) {
evaluateEnergy.cc:45:    if ( this[01;31m-[00m>_CalculateNonbondEnergy ) {
evaluateEnergy.cc:46:	for ( vector<AmberNonbond>::iterator iri=this[01;31m-[00m>_NonbondTerms.begin();
evaluateEnergy.cc:47:		    iri!=this[01;31m-[00m>_NonbondTerms.end(); iri++ ) {
evaluateEnergy.cc:51:    if ( this[01;31m-[00m>_CalculateChiralRestraintEnergy ) {
evaluateEnergy.cc:52:	for ( vector<AmberChiralRestraint>::iterator iri=this[01;31m-[00m>_ChiralRestraintTerms.begin();
evaluateEnergy.cc:53:		    iri!=this[01;31m-[00m>_ChiralRestraintTerms.end(); iri++ ) {
evaluator.cc:31:    if ( args[01;31m-[00m>cdr()[01;31m-[00m>notNil() )
evaluator.cc:33:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Expected only one argument"));
evaluator.cc:36:    RPObject earg = eval::evaluate(args[01;31m-[00m>ocar(),environ,lisp);
evaluator.cc:56:    LOG(BF( "defMacro raw args = %s") % args[01;31m-[00m>__repr__() );
evaluator.cc:57:    symbol = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:58:    RPCons argumentNames = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:59:    RPText docString = lisp[01;31m-[00m>nil<O_Text>();
evaluator.cc:61:    LOG(BF("Checking for docstring in remaining arguments: %s")%args[01;31m-[00m>ocaddr()[01;31m-[00m>__repr__());
evaluator.cc:62:    if ( args[01;31m-[00m>ocaddr()[01;31m-[00m>isAssignableTo<O_Text>() )
evaluator.cc:64:	docString = args[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Text>();
evaluator.cc:65:	form = args[01;31m-[00m>cdddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:66:	LOG(BF("Found docstring: %s") % docString[01;31m-[00m>__repr__());
evaluator.cc:67:	LOG(BF("Found form: %s") % form[01;31m-[00m>__repr__());
evaluator.cc:70:	form = args[01;31m-[00m>cddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:71:	LOG(BF("Found form: %s") % form[01;31m-[00m>__repr__());
evaluator.cc:73:    RPParsingCons code = O_ParsingCons::createWithDuplicateParsingInfo(lisp[01;31m-[00m>getSpecialForm_progn(),form,form,lisp);
evaluator.cc:74:    LOG(BF( "code = %s") % code[01;31m-[00m>__repr__() );
evaluator.cc:75:    LOG(BF("Closing over the environment[01;31m-[00m[01;31m-[00m>\n%s") % environment[01;31m-[00m>__repr__() );
evaluator.cc:76:    RPProcedure procedure = O_Procedure::create(symbol,argumentNames,docString,code,lisp[01;31m-[00m>globalEnvironment(),lisp);
evaluator.cc:77:    LOG(BF("procedure = %s") % procedure[01;31m-[00m>__repr__() );
evaluator.cc:78:    lisp[01;31m-[00m>defineMacro(symbol,procedure);
evaluator.cc:79:    return lisp[01;31m-[00m>nil<O_Cons>();
evaluator.cc:96:    RPCons assignments = args[01;31m-[00m>car<O_Cons>();
evaluator.cc:97:    RPCons body = args[01;31m-[00m>cdr();
evaluator.cc:99:    LOG(BF("Assignment part=%s") % assignments[01;31m-[00m>__repr__() );
evaluator.cc:100:    while ( cur[01;31m-[00m>notNil() )
evaluator.cc:104:	if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Cons>() )
evaluator.cc:106:	    RPCons assign = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
evaluator.cc:107:	    var = assign[01;31m-[00m>car<O_Symbol>();
evaluator.cc:108:	    RPObject val = assign[01;31m-[00m>ocadr();
evaluator.cc:109:	    LOG(BF("Extending environment with symbol(%s) value[01;31m-[00mpre[01;31m-[00mevaluation(%s)") % var[01;31m-[00m>__repr__() % val[01;31m-[00m>__repr__() );
evaluator.cc:111:	} else if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
evaluator.cc:113:	    var = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:114:	    result = lisp[01;31m-[00m>onil();
evaluator.cc:117:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Illegal object in let variable declaration: %s" ) % cur[01;31m-[00m>ocar()[01;31m-[00m>__repr__() ));
evaluator.cc:119:	LOG(BF("Extending environment with symbol(%s) value[01;31m-[00mpost[01;31m-[00mevaluation(%s)") % var[01;31m-[00m>__repr__() % result[01;31m-[00m>__repr__() );
evaluator.cc:120:	if ( var[01;31m-[00m>isDynamic() )
evaluator.cc:125:	    newEnvironment[01;31m-[00m>extend(var,result);
evaluator.cc:127:	cur = cur[01;31m-[00m>cdr();
evaluator.cc:129://    LOG(BF("Extended the environment [01;31m-[00m result [01;31m-[00m[01;31m-[00m>\n%s") % newEnvironment[01;31m-[00m>__repr__() );
evaluator.cc:130://    LOG(BF("Evaluating code in this new lexical environment: %s") % body[01;31m-[00m>__repr__() );
evaluator.cc:133:	// I'm going to have to handle return[01;31m-[00mfrom and stuff won't I?
evaluator.cc:152:    RPCons assignments = args[01;31m-[00m>car<O_Cons>();
evaluator.cc:153:    RPCons body = args[01;31m-[00m>cdr();
evaluator.cc:155:    LOG(BF("Assignment part=%s") % assignments[01;31m-[00m>__repr__() );
evaluator.cc:156:    while ( cur[01;31m-[00m>notNil() )
evaluator.cc:160:	if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Cons>() )
evaluator.cc:162:	    RPCons assign = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
evaluator.cc:163:	    var = assign[01;31m-[00m>car<O_Symbol>();
evaluator.cc:164:	    RPObject val = assign[01;31m-[00m>ocadr();
evaluator.cc:165:	    LOG(BF("Extending environment with symbol(%s) value[01;31m-[00mpre[01;31m-[00mevaluation(%s)") % var[01;31m-[00m>__repr__() % val[01;31m-[00m>__repr__() );
evaluator.cc:167:	} else if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
evaluator.cc:169:	    var = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:170:	    result = lisp[01;31m-[00m>onil();
evaluator.cc:173:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Illegal object in let variable declaration: %s" ) % cur[01;31m-[00m>ocar()[01;31m-[00m>__repr__() ));
evaluator.cc:175:	LOG(BF("Extending environment with symbol(%s) value[01;31m-[00mpost[01;31m-[00mevaluation(%s)") % var[01;31m-[00m>__repr__() % result[01;31m-[00m>__repr__() );
evaluator.cc:176:	if ( var[01;31m-[00m>isDynamic() )
evaluator.cc:181://	    newEnvironment[01;31m-[00m>extend(var,result);
evaluator.cc:183:	    newEnvironment[01;31m-[00m>extend(var,result);
evaluator.cc:187:	cur = cur[01;31m-[00m>cdr();
evaluator.cc:189:    LOG(BF("Extended the environment [01;31m-[00m result [01;31m-[00m[01;31m-[00m>\n%s") % newEnvironment[01;31m-[00m>__repr__() );
evaluator.cc:190:    LOG(BF("Evaluating code in this new lexical environment: %s") % body[01;31m-[00m>__repr__() );
evaluator.cc:193:	// I'm going to have to handle return[01;31m-[00mfrom and stuff won't I?
evaluator.cc:210:    LOG(BF("In prim_callAncestorMethod the environment is:\n%s") % environ[01;31m-[00m>__repr__() );
evaluator.cc:211:    RPSymbol formSymbol = environ[01;31m-[00m>getHeadSymbol();
evaluator.cc:213:    ASSERT(formSymbol[01;31m-[00m>notNil());
evaluator.cc:214:    RPMetaClass receiverClass = environ[01;31m-[00m>getReceiverClass();
evaluator.cc:216:    ASSERT(receiverClass[01;31m-[00m>notNil());
evaluator.cc:217:    RPMetaClass baseClass = receiverClass[01;31m-[00m>getInstanceBaseClass();
evaluator.cc:218:    LOG(BF("In prim_callAncestorMethod symbol(%s) receiverClass(%s) baseClass(%s)") % formSymbol[01;31m-[00m>__repr__() % receiverClass[01;31m-[00m>__repr__() % baseClass[01;31m-[00m>__repr__() );
evaluator.cc:219:    RPExecutable exec = lisp[01;31m-[00m>lookupMethod(formSymbol,baseClass,args[01;31m-[00m>ocar());
evaluator.cc:220:    if ( exec[01;31m-[00m>notNil() )
evaluator.cc:222:	LOG(BF("Found the method(%s) in the ancestor class(%s)") % formSymbol[01;31m-[00m>__repr__() % baseClass[01;31m-[00m>instanceClassName() );
evaluator.cc:223:	if ( args[01;31m-[00m>isNil() )
evaluator.cc:225:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must pass arguments"));
evaluator.cc:228:	RPObject result = exec[01;31m-[00m>evaluate(eargs,environ,lisp);
evaluator.cc:231:    return lisp[01;31m-[00m>onil();
evaluator.cc:247:    RPObject res = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:248:    if ( res[01;31m-[00m>isTrue() )
evaluator.cc:250:	return eval::evaluateListReturnLast(args[01;31m-[00m>cdr(),environment,lisp);
evaluator.cc:252:    return lisp[01;31m-[00m>onil();
evaluator.cc:264:    RPCandoObject obj = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp)[01;31m-[00m>as<O_CandoObject>();
evaluator.cc:265:    RPSymbol selector = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:266:    return obj[01;31m-[00m>getSlot(selector);
evaluator.cc:280:    return lisp[01;31m-[00m>onil();
evaluator.cc:295:    RPSymbol symbol = args[01;31m-[00m>car<O_Symbol>()[01;31m-[00m>asKeywordSymbol();
evaluator.cc:296:    RPCons argumentNames = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:298:    RPText docString = lisp[01;31m-[00m>nil<O_Text>();
evaluator.cc:299:    if ( args[01;31m-[00m>ocaddr()[01;31m-[00m>isAssignableTo<O_Text>() )
evaluator.cc:301:	docString = args[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Text>();
evaluator.cc:302:	form = args[01;31m-[00m>cdddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:305:	form = args[01;31m-[00m>cddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:307:    RPParsingCons code = O_ParsingCons::createWithDuplicateParsingInfo(lisp[01;31m-[00m>getSpecialForm_progn(),form,form,lisp);
evaluator.cc:308:    RPMethodEnvironment methodEnviron = environment[01;31m-[00m>as<O_MethodEnvironment>();
evaluator.cc:309:    methodEnviron[01;31m-[00m>setHeadSymbol(symbol);
evaluator.cc:310:    LOG(BF("Creating method(%s) with environment:\n%s") % symbol[01;31m-[00m>__repr__() % methodEnviron[01;31m-[00m>__repr__() );
evaluator.cc:318:    for ( ; clauses[01;31m-[00m>notNil(); clauses = clauses[01;31m-[00m>cdr() )
evaluator.cc:320:	if ( clauses[01;31m-[00m>car<O_Cons>()[01;31m-[00m>length() != 3 )
evaluator.cc:324:	    ss << "  instead you gave: " << clauses[01;31m-[00m>car<O_Cons>()[01;31m-[00m>__repr__() << endl;
evaluator.cc:325:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
evaluator.cc:328:	    RPCons clause = clauses[01;31m-[00m>car<O_Cons>();
evaluator.cc:329:	    RPSymbol conditionClassSymbol = clause[01;31m-[00m>car<O_Symbol>();
evaluator.cc:330:	    RPMetaClass conditionBase = lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(conditionClassSymbol)[01;31m-[00m>as<O_MetaClass>();
evaluator.cc:331:	    RPCons symbols = clause[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:332:	    RPCons code = clause[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:335:					    lisp[01;31m-[00m>nil<O_Text>(),
evaluator.cc:339:	    environ[01;31m-[00m>extendHandler(conditionBase,handler);
evaluator.cc:355:    RPCons expression = args[01;31m-[00m>car<O_Cons>();
evaluator.cc:356:    RPCons errorClauses = args[01;31m-[00m>cdr();
evaluator.cc:369:		result = lisp[01;31m-[00m>handle_handlerCase(condition,newEnviron);
evaluator.cc:372:		LOG(BF("Caught exception in handlerCase handler [01;31m-[00m this shouldn't ever happen"));
evaluator.cc:386:		result = lisp[01;31m-[00m>handle_handlerCase(condition,newEnviron);
evaluator.cc:401:    RPCandoObject cobj = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp)[01;31m-[00m>as<O_CandoObject>();
evaluator.cc:402:    RPSymbol varName = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:403:    LOG(BF("setf variable name(%s)")% varName[01;31m-[00m>currentName() );
evaluator.cc:404:    RPObject oval = eval::evaluate(args[01;31m-[00m>ocaddr(),environment,lisp);
evaluator.cc:405:    return cobj[01;31m-[00m>setSlot(varName,oval);
evaluator.cc:411:    RPCandoObject cobj = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp)[01;31m-[00m>as<O_CandoObject>();
evaluator.cc:413:    RPSymbol varName = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:415:    LOG(BF("getf variable name(%s)") % varName[01;31m-[00m>currentName().c_str() );
evaluator.cc:416:    RPObject oval = cobj[01;31m-[00m>getSlot(varName);
evaluator.cc:433:    LOG(BF("For invoke, args = |%s|" ) % args[01;31m-[00m>__repr__() );
evaluator.cc:435:    RPExecutable fn = eargs[01;31m-[00m>ocar()[01;31m-[00m>as<O_Executable>();
evaluator.cc:436:    RPCons argsCons = eargs[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:437:    LOG(BF(" argsCons = |%s|") % argsCons[01;31m-[00m>__repr__() );
evaluator.cc:455:    RPObject res = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:456:    if ( res[01;31m-[00m>isTrue() )
evaluator.cc:458:	return eval::evaluate(args[01;31m-[00m>ocadr(),environment,lisp);
evaluator.cc:460:    { if ( args[01;31m-[00m>cdr()[01;31m-[00m>cdr()[01;31m-[00m>notNil() )
evaluator.cc:462:	    return eval::evaluate(args[01;31m-[00m>ocaddr(),environment,lisp);
evaluator.cc:482:    RPObject res = evaluate(args[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:483:    if ( res[01;31m-[00m>isTrue() )
evaluator.cc:485:	return evaluateListReturnLast(args[01;31m-[00m>cdr(),environment,lisp);
evaluator.cc:503:    RPObject res = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:504:    if ( !res[01;31m-[00m>isTrue() )
evaluator.cc:506:	return eval::evaluateListReturnLast(args[01;31m-[00m>cdr(),environment,lisp);
evaluator.cc:521:    for ( ; args[01;31m-[00m>notNil(); args = args[01;31m-[00m>cdr() )
evaluator.cc:523:	RPCons condProgn = args[01;31m-[00m>car<O_Cons>();
evaluator.cc:524:	RPObject cond = eval::evaluate(condProgn[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:525:	if ( cond[01;31m-[00m>isTrue() )
evaluator.cc:527:	    RPCons code = condProgn[01;31m-[00m>cdr();
evaluator.cc:531:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Reached the end of a cond block and not one condition was true"));
evaluator.cc:547:    lisp[01;31m-[00m>setBreakFlag();
evaluator.cc:562:    lisp[01;31m-[00m>setContinueFlag();
evaluator.cc:584:    RPObject result = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:585:    if ( !result[01;31m-[00m>isAssignableTo<O_ConditionBase>() )
evaluator.cc:587:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You must provide an instance of a Condition to 'raise' [01;31m-[00m instead you passed: %s") % result[01;31m-[00m>__repr__()));
evaluator.cc:589:    RPConditionBase condition = result[01;31m-[00m>as<O_ConditionBase>();
evaluator.cc:590:    LOG(BF("Getting ready to throw Condition: %s") % condition[01;31m-[00m>__repr__() );
evaluator.cc:591:    if ( environment[01;31m-[00m>lookupHandler(condition[01;31m-[00m>_class())[01;31m-[00m>isNil() )
evaluator.cc:594:	lisp[01;31m-[00m>unhandledCondition(condition,environment);
evaluator.cc:596:    LOG(BF("Throwing the condition: %s") % condition[01;31m-[00m>__repr__() );
evaluator.cc:616:    ASSERTP(args[01;31m-[00m>cdr()[01;31m-[00m>isNil(),"You can provide only one argument [01;31m-[00m the name of a function");
evaluator.cc:617:    RPSymbol fnSymbol = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:618:    RPObject fn = environment[01;31m-[00m>lookupForm(fnSymbol);
evaluator.cc:639:    RPObject result = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:640:    lisp[01;31m-[00m>setReturnFlag();
evaluator.cc:641:    lisp[01;31m-[00m>clearContinueFlag();
evaluator.cc:642:    lisp[01;31m-[00m>clearBreakFlag();
evaluator.cc:682:    if ( lisp[01;31m-[00m>debugLog().isEnabled() )
evaluator.cc:700:    LOG(BF(" PrognLog args: %s") % args[01;31m-[00m>__repr__().c_str()  ); // vp0((" PrognLog args: %s", args[01;31m-[00m>__repr__().c_str() ));
evaluator.cc:702:    RPObject commentObj = args[01;31m-[00m>ocar();
evaluator.cc:703:    if ( lisp[01;31m-[00m>debugLog().isEnabled() )
evaluator.cc:705:	RPText comment = eval::evaluate(commentObj,environment,lisp)[01;31m-[00m>as<O_Text>();
evaluator.cc:706:	_StackTrace st(args[01;31m-[00m>getParsePosFileName().c_str(), "","CSC_BLOCK",args[01;31m-[00m>getParsePosLineNumber(),BF("%s")%comment[01;31m-[00m>get(),lisp);
evaluator.cc:707:	return eval::evaluateListReturnLast(args[01;31m-[00m>cdr(),environment,lisp);
evaluator.cc:710:	return eval::evaluateListReturnLast(args[01;31m-[00m>cdr(),environment,lisp);
evaluator.cc:725:    if ( lisp[01;31m-[00m>debugLog().isEnabled() )
evaluator.cc:727:        RPObject logCom = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:730:	ASSERT(comment[01;31m-[00m>notNil());
evaluator.cc:731:	LOG(BF(" comment[01;31m-[00m>size() = %d comment = |%s|")% comment[01;31m-[00m>size() % comment[01;31m-[00m>get() );
evaluator.cc:732:	lisp_debugLogWrite(lisp,args[01;31m-[00m>getParsePosFileName().c_str(),"[01;31m-[00mnofunc[01;31m-[00m",args[01;31m-[00m>getParsePosLineNumber(),BF("%s")%comment[01;31m-[00m>get());
evaluator.cc:733://        lisp[01;31m-[00m>debugLog().setDebugPrefix("CSC_LOG");
evaluator.cc:734://        lisp[01;31m-[00m>debugLog().setTraceFileLine(args[01;31m-[00m>getParsePosFileName().c_str(),args[01;31m-[00m>getParsePosLineNumber());
evaluator.cc:735://	lisp[01;31m-[00m>debugLog().log(comment[01;31m-[00m>get());
evaluator.cc:749:    RPObject res = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:750:    if ( res[01;31m-[00m>isFalse() )
evaluator.cc:753:	ss << "Assertion (" << args[01;31m-[00m>ocar()[01;31m-[00m>__repr__() << ") failed.  ";
evaluator.cc:754:        if ( args[01;31m-[00m>length() == 2 )
evaluator.cc:756:	    RPText msg = eval::evaluate(args[01;31m-[00m>ocadr(),environment,lisp)[01;31m-[00m>as<O_Text>();
evaluator.cc:757:	    ss << msg[01;31m-[00m>get();
evaluator.cc:759:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("%s:%d %s") % args[01;31m-[00m>getParsePosFileName() % args[01;31m-[00m>getParsePosLineNumber() % ss.str() ));
evaluator.cc:789:    if ( args[01;31m-[00m>length() < 1 )
evaluator.cc:791:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("while requires at least one arguments"));
evaluator.cc:794:        lisp[01;31m-[00m>clearExecutionFlags();
evaluator.cc:798:	    LOG(BF("Evaluating while test: %s") % args[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str()  ); // vp0(("Evaluating while test: %s",args[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ));
evaluator.cc:799:	    RPObject res = eval::evaluate(args[01;31m-[00m>ocar(),environment,lisp);
evaluator.cc:800:	    if ( !res[01;31m-[00m>isTrue() ) break;
evaluator.cc:803:	    LOG(BF("Evaluating body: %s") % args[01;31m-[00m>cdr()[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str()  ); // vp0(("Evaluating body: %s",args[01;31m-[00m>cdr()[01;31m-[00m>ocar()[01;31m-[00m>__repr__().c_str() ));
evaluator.cc:804:	    res = eval::evaluateListReturnLast(args[01;31m-[00m>cdr(),environment,lisp);
evaluator.cc:805:	    if ( lisp[01;31m-[00m>getExecutionFlags() )
evaluator.cc:807:		if ( lisp[01;31m-[00m>getBreakFlag() ) break;
evaluator.cc:808:		if ( lisp[01;31m-[00m>getReturnFlag() ) return res;
evaluator.cc:809:		if ( lisp[01;31m-[00m>getContinueFlag() )
evaluator.cc:811:		    lisp[01;31m-[00m>clearContinueFlag();
evaluator.cc:815:		if ( lisp[01;31m-[00m>getExitFlag() ) return O_Object::nil(lisp);
evaluator.cc:834:    if ( args[01;31m-[00m>length() < 3 )
evaluator.cc:836:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("foreach requires at least three arguments"));
evaluator.cc:838:    RPSymbol sym = args[01;31m-[00m>car<O_Symbol>();
evaluator.cc:839:    RPObject over  = eval::evaluate(args[01;31m-[00m>ocadr(),environment,lisp);
evaluator.cc:840:    LOG(BF("foreach over = %s") % over[01;31m-[00m>__repr__().c_str()  ); // vp0(("foreach over = %s", over[01;31m-[00m>__repr__().c_str() ));
evaluator.cc:841:    RPCons code = args[01;31m-[00m>cddr();
evaluator.cc:842:    LOG(BF("foreach code = %s") % code[01;31m-[00m>__repr__().c_str()  ); // vp0(("foreach code = %s", code[01;31m-[00m>__repr__().c_str() ));
evaluator.cc:846:    RPProcedureEnvironment newEnvironment = O_ProcedureEnvironment::create(lisp[01;31m-[00m>symbol(_sym_ClPackage_foreach),environment,lisp);
evaluator.cc:847:    newEnvironment[01;31m-[00m>extend(sym,lisp[01;31m-[00m>onil());
evaluator.cc:848:    if ( over[01;31m-[00m>notNil() )
evaluator.cc:850:	lisp[01;31m-[00m>clearExecutionFlags();
evaluator.cc:851:	if ( over[01;31m-[00m>isAssignableTo<O_Iterator>() )
evaluator.cc:855:	    it[01;31m-[00m>first();
evaluator.cc:856:	    for ( it[01;31m-[00m>first(); it[01;31m-[00m>notDone(); it[01;31m-[00m>next() )
evaluator.cc:858:		val = it[01;31m-[00m>currentObject();  // should use a copy here for some iterators
evaluator.cc:859:	    	newEnvironment[01;31m-[00m>update(sym,val);
evaluator.cc:861:		if ( lisp[01;31m-[00m>getExecutionFlags() )
evaluator.cc:863:		    if ( lisp[01;31m-[00m>getBreakFlag() ) break;
evaluator.cc:864:		    if ( lisp[01;31m-[00m>getReturnFlag() ) return res;
evaluator.cc:865:		    if ( lisp[01;31m-[00m>getContinueFlag() )
evaluator.cc:867:			lisp[01;31m-[00m>clearContinueFlag();
evaluator.cc:871:		    if ( lisp[01;31m-[00m>getExitFlag() ) return O_Object::nil(lisp);
evaluator.cc:874:	} else if ( over[01;31m-[00m>isOfClass<O_Range>() )
evaluator.cc:876:	    RPRange range = over[01;31m-[00m>as<O_Range>();
evaluator.cc:878:	    val = lisp[01;31m-[00m>create<O_Int>(range[01;31m-[00m>begin());
evaluator.cc:879:	    newEnvironment[01;31m-[00m>update(sym,val);
evaluator.cc:880:	    LOG(BF("Range = begin=%d, end=%d, step = %d") % range[01;31m-[00m>begin() % range[01;31m-[00m>end() % range[01;31m-[00m>step()  ); // vp0(("Range = begin=%d, end=%d, step = %d", range[01;31m-[00m>begin(), range[01;31m-[00m>end(), range[01;31m-[00m>step() ));
evaluator.cc:881:	    for ( int cur = range[01;31m-[00m>begin(); cur < range[01;31m-[00m>end(); cur += range[01;31m-[00m>step() )
evaluator.cc:884:		val = lisp[01;31m-[00m>create<O_Int>(cur);
evaluator.cc:885:	        newEnvironment[01;31m-[00m>update(sym,val);
evaluator.cc:887:		if ( lisp[01;31m-[00m>getExecutionFlags() )
evaluator.cc:889:		    if ( lisp[01;31m-[00m>getBreakFlag() ) break;
evaluator.cc:890:		    if ( lisp[01;31m-[00m>getReturnFlag() ) return res;
evaluator.cc:891:		    if ( lisp[01;31m-[00m>getContinueFlag() )
evaluator.cc:893:			lisp[01;31m-[00m>clearContinueFlag();
evaluator.cc:897:		    if ( lisp[01;31m-[00m>getExitFlag() ) return O_Object::nil(lisp);
evaluator.cc:900:	} else if ( over[01;31m-[00m>isAssignableTo<O_Cons>() )
evaluator.cc:903:	    for ( cur = list; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
evaluator.cc:905:		obj = cur[01;31m-[00m>ocar();
evaluator.cc:906:		newEnvironment[01;31m-[00m>update(sym,obj);
evaluator.cc:908:		if ( lisp[01;31m-[00m>getExecutionFlags() )
evaluator.cc:910:		    if ( lisp[01;31m-[00m>getBreakFlag() ) break;
evaluator.cc:911:		    if ( lisp[01;31m-[00m>getReturnFlag() ) return res;
evaluator.cc:912:		    if ( lisp[01;31m-[00m>getContinueFlag() )
evaluator.cc:914:			lisp[01;31m-[00m>clearContinueFlag();
evaluator.cc:918:		    if ( lisp[01;31m-[00m>getExitFlag() ) return O_Object::nil(lisp);
evaluator.cc:923:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal object of class("+over[01;31m-[00m>className()+") to loop over"));
evaluator.cc:926:    lisp[01;31m-[00m>clearBreakFlag();
evaluator.cc:927:    lisp[01;31m-[00m>clearContinueFlag();
evaluator.cc:945:    RPCons largs = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
evaluator.cc:948:    if ( args[01;31m-[00m>ocadr()[01;31m-[00m>isAssignableTo<O_Text>() )
evaluator.cc:950:	docString = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Text>();
evaluator.cc:951:	form = args[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:954:	form = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:956:    LOG(BF("lambda is closing over environment\n%s") % environment[01;31m-[00m>__repr__() );
evaluator.cc:957:    proc = O_Procedure::create(lisp[01;31m-[00m>predefinedSymbol(_sym_kw_lambda),largs,docString,form,environment,lisp);
evaluator.cc:972:    return args[01;31m-[00m>ocar();
evaluator.cc:986:    return args[01;31m-[00m>ocar();
evaluator.cc:992:    RPCons resultFirst = lisp[01;31m-[00m>create<O_Cons>();
evaluator.cc:995:    while ( cur[01;31m-[00m>notNil() )
evaluator.cc:997:	RPObject obj = cur[01;31m-[00m>ocar();
evaluator.cc:998:	LOG(BF("Examining object[%s] for backquoting")%obj[01;31m-[00m>__repr__() );
evaluator.cc:999:	if ( obj[01;31m-[00m>isAssignableTo<O_Cons>() )
evaluator.cc:1001:	    RPCons subArgs = obj[01;31m-[00m>as<O_Cons>();
evaluator.cc:1002:	    RPObject head = subArgs[01;31m-[00m>ocar();
evaluator.cc:1003:	    if ( head[01;31m-[00m>isAssignableTo<O_SpecialForm>() )
evaluator.cc:1005:		RPSpecialForm specialHead = head[01;31m-[00m>as<O_SpecialForm>();
evaluator.cc:1006:		if ( specialHead == lisp[01;31m-[00m>getSpecialForm_backQuote() )
evaluator.cc:1008:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Don't nest backquotes: %s")%subArgs[01;31m-[00m>__repr__()));
evaluator.cc:1009:		} else if ( specialHead == lisp[01;31m-[00m>getSpecialForm_comma() )
evaluator.cc:1011:		    RPObject evaluatedResult = evaluate( subArgs[01;31m-[00m>ocadr(), environment, lisp );
evaluator.cc:1012:		    RPCons one = lisp[01;31m-[00m>create<O_Cons>(evaluatedResult);
evaluator.cc:1013:		    tail[01;31m-[00m>setCdr(one);
evaluator.cc:1015:		} else if ( specialHead == lisp[01;31m-[00m>getSpecialForm_commaAt() )
evaluator.cc:1017:		    RPObject evaluatedResult = evaluate( subArgs[01;31m-[00m>ocadr(), environment, lisp );
evaluator.cc:1021:		    if ( evaluatedResult[01;31m-[00m>isAssignableTo<O_Cons>() )
evaluator.cc:1023:			RPCons evaluatedCons = evaluatedResult[01;31m-[00m>as<O_Cons>();
evaluator.cc:1024:			while ( evaluatedCons[01;31m-[00m>notNil() )
evaluator.cc:1026:			    RPCons one = lisp[01;31m-[00m>create<O_Cons>(evaluatedCons[01;31m-[00m>ocar());
evaluator.cc:1027:			    tail[01;31m-[00m>setCdr(one);
evaluator.cc:1029:			    evaluatedCons = evaluatedCons[01;31m-[00m>cdr();
evaluator.cc:1033:			TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Illegal ,@ expansion of a non[01;31m-[00mcons: %s") % evaluatedResult[01;31m-[00m>__repr__() ));
evaluator.cc:1038:		    RPCons one = lisp[01;31m-[00m>create<O_Cons>(backQuotedSubArgs);
evaluator.cc:1039:		    tail[01;31m-[00m>setCdr(one);
evaluator.cc:1045:		RPCons one = lisp[01;31m-[00m>create<O_Cons>(backQuotedSubArgs);
evaluator.cc:1046:		tail[01;31m-[00m>setCdr(one);
evaluator.cc:1051:	    LOG(BF("Backquoting simple object: %s") % obj[01;31m-[00m>__repr__() );
evaluator.cc:1052:	    RPCons one = lisp[01;31m-[00m>create<O_Cons>(obj);
evaluator.cc:1053:	    tail[01;31m-[00m>setCdr(one);
evaluator.cc:1056:	cur = cur[01;31m-[00m>cdr();
evaluator.cc:1058:    return resultFirst[01;31m-[00m>cdr();
evaluator.cc:1067:    LOG(BF("Expanding backQuote going in: %s") % args[01;31m-[00m>__repr__() );
evaluator.cc:1068:    RPCons expandArgs = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
evaluator.cc:1069:    if ( args[01;31m-[00m>cdr()[01;31m-[00m>notNil() )
evaluator.cc:1071:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There can be only one argument to backQuote"));
evaluator.cc:1074:    LOG(BF("Expanding backQuote result: %s") % result[01;31m-[00m>__repr__() );
evaluator.cc:1081:    return args[01;31m-[00m>ocar();
evaluator.cc:1088:    return args[01;31m-[00m>ocar();
evaluator.cc:1100:    ASSERTP(args[01;31m-[00m>cdr()[01;31m-[00m>notNil(),"You must provide 2 arguments");
evaluator.cc:1101:    ASSERT_eq(args[01;31m-[00m>length(),2);
evaluator.cc:1102:    RPObject destination = args[01;31m-[00m>ocar();
evaluator.cc:1103:    LOG(BF("SetValue arguments: %s") % args[01;31m-[00m>__repr__());
evaluator.cc:1104:    LOG( BF("About to check if destination with class(%s) is assignable to an O_Cons")%destination[01;31m-[00m>className() );
evaluator.cc:1107:	RPSymbol symbol = destination[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1108:        RPObject value = eval::evaluate(args[01;31m-[00m>ocadr(),environment,lisp);
evaluator.cc:1109://	lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(symbol,value);
evaluator.cc:1110:	symbol[01;31m-[00m>setDynamic(true);
evaluator.cc:1111:	symbol[01;31m-[00m>pushDynamicBinding(value);
evaluator.cc:1114:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You can only global symbols [01;31m-[00m you tried to global an object of class(%s) with the value(%s)")% destination[01;31m-[00m>className() % destination[01;31m-[00m>__repr__()));
evaluator.cc:1126:    ASSERTP(args[01;31m-[00m>cdr()[01;31m-[00m>notNil(),"You must provide 2 arguments");
evaluator.cc:1127:    ASSERT_eq(args[01;31m-[00m>length(),2);
evaluator.cc:1128:    RPEnvironment parentEnvironment = environment[01;31m-[00m>getParentEnvironment();
evaluator.cc:1129:    RPObject destination = args[01;31m-[00m>ocar();
evaluator.cc:1130:    LOG(BF("SetValue arguments: %s") % args[01;31m-[00m>__repr__());
evaluator.cc:1131:    LOG( BF("About to check if destination with class(%s) is assignable to an O_Cons")%destination[01;31m-[00m>className() );
evaluator.cc:1132:    if ( destination[01;31m-[00m>isAssignableTo<O_Symbol>() )
evaluator.cc:1135:	RPSymbol symbol = destination[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1136:        RPObject value = eval::evaluate(args[01;31m-[00m>ocadr(),environment,lisp);
evaluator.cc:1137:	parentEnvironment[01;31m-[00m>extend(symbol,value);
evaluator.cc:1138:	LOG(BF("Extended parent environment with symbol(%s) [01;31m-[00m value(%s)") % symbol[01;31m-[00m>__repr__() % value[01;31m-[00m>__repr__() );
evaluator.cc:1139:	LOG(BF("The environment is now [01;31m-[00m[01;31m-[00m>\n%s") % environment[01;31m-[00m>__repr__() );
evaluator.cc:1142:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You can only local symbols [01;31m-[00m you tried to local an object of class(%s) with the value(%s)")% destination[01;31m-[00m>className() % destination[01;31m-[00m>__repr__()));
evaluator.cc:1157:    ASSERTP(args[01;31m-[00m>cdr()[01;31m-[00m>notNil(),"You must provide 2 arguments");
evaluator.cc:1158:    ASSERT_eq(args[01;31m-[00m>length(),2);
evaluator.cc:1159:    RPObject destination = args[01;31m-[00m>ocar();
evaluator.cc:1160:    LOG(BF("SetValue arguments: %s") % args[01;31m-[00m>__repr__());
evaluator.cc:1161:    LOG( BF("About to check if destination with class(%s) is assignable to an O_Cons")%destination[01;31m-[00m>className() );
evaluator.cc:1162:    if ( destination[01;31m-[00m>isAssignableTo<O_Cons>() )
evaluator.cc:1168:	RPCons target = destination[01;31m-[00m>as<O_Cons>();
evaluator.cc:1169:	RPObject targetHead = target[01;31m-[00m>ocar();
evaluator.cc:1170:	if ( targetHead[01;31m-[00m>isAssignableTo<O_SpecialForm>() )
evaluator.cc:1172:	    RPSpecialForm sf = targetHead[01;31m-[00m>as<O_SpecialForm>();
evaluator.cc:1173:	    if ( sf == lisp[01;31m-[00m>getSpecialForm_slot() )
evaluator.cc:1176:		RPCandoObject object = eval::evaluate(target[01;31m-[00m>ocadr(),environment,lisp)[01;31m-[00m>as<O_CandoObject>();
evaluator.cc:1177:		RPSymbol selector = target[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1178:		RPObject value = eval::evaluate(args[01;31m-[00m>ocadr(),environment,lisp);
evaluator.cc:1179:		object[01;31m-[00m>setSlot(selector,value);
evaluator.cc:1184:    } else if ( destination[01;31m-[00m>isAssignableTo<O_Symbol>() )
evaluator.cc:1187:	RPSymbol symbol = destination[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1188:        RPObject value = eval::evaluate(args[01;31m-[00m>ocadr(),environment,lisp);
evaluator.cc:1189:	if ( symbol[01;31m-[00m>isDynamic() )
evaluator.cc:1191:	    symbol[01;31m-[00m>setDynamicValue(value);
evaluator.cc:1194:	    environment[01;31m-[00m>update(symbol,value);
evaluator.cc:1198:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You can only setq symbols or slots [01;31m-[00m you tried to setq an object of class(%s) with the value(%s)")% destination[01;31m-[00m>className() % destination[01;31m-[00m>__repr__()));
evaluator.cc:1219:    LOG(BF("defClass raw args = %s") % args[01;31m-[00m>__repr__().c_str()  ); // vp0(( "defClass raw args = %s", args[01;31m-[00m>__repr__().c_str() ));
evaluator.cc:1220:    RPSymbol className = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1221:    RPObject baseClassObject = eval::evaluate(args[01;31m-[00m>ocadr(),environment,lisp);
evaluator.cc:1222:    RPCons instanceVariableNames = args[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:1223:    RPCons methods = args[01;31m-[00m>cdddr();
evaluator.cc:1224:    RPCandoClass newClass = lisp[01;31m-[00m>defineCandoClass(className);
evaluator.cc:1225:    LOG(BF("created class = %s") % newClass[01;31m-[00m>name().c_str()  ); // vp0(("created class = %s", newClass[01;31m-[00m>name().c_str() ));
evaluator.cc:1229:    RPMetaClass baseClass = lisp[01;31m-[00m>classObject<O_CandoObject>();
evaluator.cc:1230:    if ( baseClassObject[01;31m-[00m>notNil() )
evaluator.cc:1232:        LOG(BF("baseClassObject class(%s) value(%s)") % baseClassObject[01;31m-[00m>className() % baseClassObject[01;31m-[00m>__repr__() );
evaluator.cc:1233:	if ( baseClassObject[01;31m-[00m>_class()[01;31m-[00m>isSubClassOf(lisp[01;31m-[00m>classFromClassId(O_MetaClass::static_classId())) )
evaluator.cc:1235:	    LOG(BF("The base class(%s) was supplied as a bare symbol") % baseClassObject[01;31m-[00m>__repr__() );
evaluator.cc:1236:	    baseClass = baseClassObject[01;31m-[00m>as<O_MetaClass>();
evaluator.cc:1239:    newClass[01;31m-[00m>setInstanceBaseClass(baseClass);
evaluator.cc:1240:    newClass[01;31m-[00m>setSupportsSlots(baseClass[01;31m-[00m>supportsSlots());
evaluator.cc:1241:    if ( baseClass[01;31m-[00m>isAssignableTo<O_CandoClass>() )
evaluator.cc:1243:	LOG(BF("The base class is: %s") % baseClass[01;31m-[00m>__repr__() );
evaluator.cc:1244:	RPCandoClass baseCandoClass = baseClass[01;31m-[00m>as<O_CandoClass>();
evaluator.cc:1245:	LOG(BF("Appending instance variables from base class: %s") % baseCandoClass[01;31m-[00m>slotNamesAsString() );
evaluator.cc:1246:	newClass[01;31m-[00m>appendInstanceVariablesFromCandoClass(baseCandoClass);
evaluator.cc:1247:	newClass[01;31m-[00m>setCoreObjectClass(baseCandoClass[01;31m-[00m>getCoreObjectClass());
evaluator.cc:1250:        newClass[01;31m-[00m>setCoreObjectClass(baseClass);
evaluator.cc:1252:    LOG(BF("Setting instance variables from list of symbols: %s")%instanceVariableNames[01;31m-[00m>__repr__() );
evaluator.cc:1253:    if ( baseClass[01;31m-[00m>supportsSlots() )
evaluator.cc:1255:	newClass[01;31m-[00m>appendInstanceVariablesFromListOfSymbols(instanceVariableNames);
evaluator.cc:1260:    LOG(BF("class instanceClassId=%d") % newClass[01;31m-[00m>getInstanceClassId()  ); // vp0(("class instanceClassId=%d", newClass[01;31m-[00m>getInstanceClassId() ));
evaluator.cc:1261:    while ( methods[01;31m-[00m>notNil() )
evaluator.cc:1264:	methodEnvironment[01;31m-[00m>setReceiverClass(newClass);
evaluator.cc:1265:	RPMethod method = eval::evaluate(methods[01;31m-[00m>ocar(),methodEnvironment,lisp)[01;31m-[00m>as<O_Method>();
evaluator.cc:1266:	RPSymbol methodKeyword = lisp[01;31m-[00m>internKeyword(method[01;31m-[00m>getName());
evaluator.cc:1267:	methodEnvironment[01;31m-[00m>setHeadSymbol(methodKeyword);
evaluator.cc:1268:	method[01;31m-[00m>setReceiverClass(newClass);
evaluator.cc:1269:	newClass[01;31m-[00m>addMethod(methodKeyword,method);
evaluator.cc:1270:	methods = methods[01;31m-[00m>cdr();
evaluator.cc:1272://    defNoWrap(className[01;31m-[00m>currentName(),&createAndInitializeCandoClassInstance,lisp);
evaluator.cc:1275:    func._Name = className[01;31m-[00m>get();
evaluator.cc:1277:    lisp[01;31m-[00m>executableEnvironment()[01;31m-[00m>addFunction(className[01;31m-[00m>get(),func._Functoid,lisp);
evaluator.cc:1278://    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "Defined CandoClass creator with name <%s>") % className[01;31m-[00m>get().c_str() );
evaluator.cc:1297:    LOG(BF("defMethod raw args = %s") % args[01;31m-[00m>__repr__().c_str()  ); // vp0(( "defMethod raw args = %s", args[01;31m-[00m>__repr__().c_str() ));
evaluator.cc:1298:    symbol = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1299:    RPObject classNameSymbolObject = args[01;31m-[00m>ocadr();
evaluator.cc:1300:    if ( !classNameSymbolObject[01;31m-[00m>isOfClass<O_Symbol>() )
evaluator.cc:1302:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a Class name as the second argument to defMethod"));
evaluator.cc:1304:    RPSymbol classNameSymbol = classNameSymbolObject[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1305:    RPMetaClass oclass = eval::evaluate(classNameSymbol,environment,lisp)[01;31m-[00m>as<O_MetaClass>();
evaluator.cc:1306:    if ( oclass[01;31m-[00m>isNil() )
evaluator.cc:1308:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown class: "+classNameSymbol[01;31m-[00m>currentName()));
evaluator.cc:1310:    LOG(BF("class = %s")% oclass[01;31m-[00m>name().c_str() );
evaluator.cc:1311:    RPCons argumentNames = args[01;31m-[00m>ocad2r()[01;31m-[00m>as<O_Cons>();
evaluator.cc:1314:    if ( args[01;31m-[00m>ocadddr()[01;31m-[00m>isAssignableTo<O_Text>() )
evaluator.cc:1316:	docString = args[01;31m-[00m>ocad3r()[01;31m-[00m>as<O_Text>();
evaluator.cc:1317:	form = args[01;31m-[00m>cddddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:1320:	form = args[01;31m-[00m>cdddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:1322:    RPParsingCons code = O_ParsingCons::createWithDuplicateParsingInfo(lisp[01;31m-[00m>getSpecialForm_progn(),form,form,lisp);
evaluator.cc:1323:    RPSymbol methodSymbol = lisp[01;31m-[00m>internKeyword(symbol[01;31m-[00m>name());
evaluator.cc:1324:    LOG(BF("defMethod docString(%s)") % docString[01;31m-[00m>__repr__() );
evaluator.cc:1325:    LOG(BF( "defMethod code = %s")% code[01;31m-[00m>__repr__() );
evaluator.cc:1326:    int instanceClassId = oclass[01;31m-[00m>getInstanceClassId();
evaluator.cc:1329:    oclass[01;31m-[00m>addMethod(methodSymbol,procedure);
evaluator.cc:1346:    LOG(BF( "defun raw args = %s") % args[01;31m-[00m>__repr__() );
evaluator.cc:1347:    symbol = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1348:    RPCons argumentNames = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:1351:    LOG(BF("Checking for docstring in remaining arguments: %s")%args[01;31m-[00m>ocaddr()[01;31m-[00m>__repr__());
evaluator.cc:1352:    if ( args[01;31m-[00m>ocaddr()[01;31m-[00m>isAssignableTo<O_Text>() )
evaluator.cc:1354:	docString = args[01;31m-[00m>ocaddr()[01;31m-[00m>as<O_Text>();
evaluator.cc:1355:	form = args[01;31m-[00m>cdddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:1356:	LOG(BF("Found docstring: %s") % docString[01;31m-[00m>__repr__());
evaluator.cc:1357:	LOG(BF("Found form: %s") % form[01;31m-[00m>__repr__());
evaluator.cc:1360:	form = args[01;31m-[00m>cddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:1361:	LOG(BF("Found form: %s") % form[01;31m-[00m>__repr__());
evaluator.cc:1363:    RPParsingCons code = O_ParsingCons::createWithDuplicateParsingInfo(lisp[01;31m-[00m>getSpecialForm_progn(),form,form,lisp);
evaluator.cc:1364:    LOG(BF( "code = %s") % code[01;31m-[00m>__repr__() );
evaluator.cc:1365:    LOG(BF("Closing over the environment[01;31m-[00m[01;31m-[00m>\n%s") % environment[01;31m-[00m>__repr__() );
evaluator.cc:1367:    LOG(BF("procedure = %s") % procedure[01;31m-[00m>__repr__() );
evaluator.cc:1368:    lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>extendForm(symbol,procedure);
evaluator.cc:1385:    RPCons functions = args[01;31m-[00m>car<O_Cons>();
evaluator.cc:1386:    RPCons body = args[01;31m-[00m>cdr();
evaluator.cc:1388:    LOG(BF("functions part=%s") % functions[01;31m-[00m>__repr__() );
evaluator.cc:1389:    RPText docString = lisp[01;31m-[00m>nil<O_Text>();
evaluator.cc:1390:    while ( cur[01;31m-[00m>notNil() )
evaluator.cc:1392:	RPCons oneDef = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
evaluator.cc:1393:	symbol = oneDef[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1394:	RPCons argumentNames = oneDef[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:1395:	RPParsingCons form = oneDef[01;31m-[00m>cddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:1396:	RPParsingCons code = O_ParsingCons::createWithDuplicateParsingInfo(lisp[01;31m-[00m>getSpecialForm_progn(),form,form,lisp);
evaluator.cc:1397:	LOG(BF( "code = %s") % code[01;31m-[00m>__repr__() );
evaluator.cc:1398:	LOG(BF("Closing over the environment[01;31m-[00m[01;31m-[00m>\n%s") % environment[01;31m-[00m>__repr__() );
evaluator.cc:1400:	LOG(BF("procedure = %s") % procedure[01;31m-[00m>__repr__() );
evaluator.cc:1401:	newEnvironment[01;31m-[00m>extendForm(symbol,procedure);
evaluator.cc:1402:	cur = cur[01;31m-[00m>cdr();
evaluator.cc:1422:    RPCons functions = args[01;31m-[00m>car<O_Cons>();
evaluator.cc:1423:    RPCons body = args[01;31m-[00m>cdr();
evaluator.cc:1425:    LOG(BF("functions part=%s") % functions[01;31m-[00m>__repr__() );
evaluator.cc:1426:    RPText docString = lisp[01;31m-[00m>nil<O_Text>();
evaluator.cc:1427:    while ( cur[01;31m-[00m>notNil() )
evaluator.cc:1430:	RPCons oneDef = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
evaluator.cc:1431:	symbol = oneDef[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1432:	RPCons argumentNames = oneDef[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
evaluator.cc:1433:	RPParsingCons form = oneDef[01;31m-[00m>cddr()[01;31m-[00m>as<O_ParsingCons>();
evaluator.cc:1434:	RPParsingCons code = O_ParsingCons::createWithDuplicateParsingInfo(lisp[01;31m-[00m>getSpecialForm_progn(),form,form,lisp);
evaluator.cc:1435:	LOG(BF( "code = %s") % code[01;31m-[00m>__repr__() );
evaluator.cc:1436:	LOG(BF("Closing over the environment[01;31m-[00m[01;31m-[00m>\n%s") % newEnvironment[01;31m-[00m>__repr__() );
evaluator.cc:1438:	LOG(BF("procedure = %s") % procedure[01;31m-[00m>__repr__() );
evaluator.cc:1439:	newEnvironment[01;31m-[00m>extendForm(symbol,procedure);
evaluator.cc:1440:	cur = cur[01;31m-[00m>cdr();
evaluator.cc:1450:    if ( form[01;31m-[00m>isAssignableTo<O_ParsingCons>() )
evaluator.cc:1452:	LOG(BF("\n%s|%d| __TRACE: head[%s:%s] args[%s]") % form[01;31m-[00m>getParsePosFileName() % form[01;31m-[00m>getParsePosLineNumber() % head[01;31m-[00m>className() % head[01;31m-[00m>__repr__() % evaluatedArgs[01;31m-[00m>__repr__() );
evaluator.cc:1455:	LOG(BF("\n%s|%d| __TRACE: head[%s:%s] args[%s]") %  __FILE__ % __LINE__ % head[01;31m-[00m>className() % head[01;31m-[00m>__repr__() % evaluatedArgs[01;31m-[00m>__repr__() );
evaluator.cc:1468:    if ( exp[01;31m-[00m>isNil() ) 
evaluator.cc:1470:	LOG(BF("Expression is nil [01;31m-[00m returning nil"));
evaluator.cc:1473:    if ( exp[01;31m-[00m>atomQ() )
evaluator.cc:1475:	LOG(BF("Evaluating atom: %s")% exp[01;31m-[00m>__repr__());
evaluator.cc:1476:	if ( exp[01;31m-[00m>symbolQ() )
evaluator.cc:1477:	{_BLOCK_TRACEF(BF("Evaluating symbol: %s")% exp[01;31m-[00m>__repr__() );
evaluator.cc:1478:	    RPSymbol sym = exp[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1479:	    RPObject val = environment[01;31m-[00m>lookup(sym);
evaluator.cc:1480:	    LOG(BF(" evaluated as: %s")% val[01;31m-[00m>__repr__() );
evaluator.cc:1485:	    LOG(BF(" Its the self returning object: %s")% exp[01;31m-[00m>__repr__() );
evaluator.cc:1488:	    if ( exp[01;31m-[00m>numberQ() || exp[01;31m-[00m>stringQ() || exp[01;31m-[00m>booleanQ() )
evaluator.cc:1492:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Cannot evaluate what should be an atomic expression(%s) of class(%s)") % exp[01;31m-[00m>__repr__() % exp[01;31m-[00m>className() ));
evaluator.cc:1495:    } else if (exp[01;31m-[00m>isAssignableTo<O_Cons>() )
evaluator.cc:1497:	LOG(BF("Evaluating cons[%s]") % exp[01;31m-[00m>__repr__() );
evaluator.cc:1498:	RPCons args = exp[01;31m-[00m>as<O_Cons>();
evaluator.cc:1501:	    RPObject head = args[01;31m-[00m>ocar();
evaluator.cc:1502:	    if ( head[01;31m-[00m>specialFormQ() )
evaluator.cc:1504:		RPSpecialForm specialForm = head[01;31m-[00m>as<O_SpecialForm>();
evaluator.cc:1505:		LOG(BF("Evaluating specialForm non[01;31m-[00matom: %s")% specialForm[01;31m-[00m>__repr__() );
evaluator.cc:1507:		traceEvaluateForm(args,head,args[01;31m-[00m>cdr(),lisp);
evaluator.cc:1509:		return specialForm[01;31m-[00m>evaluate(args[01;31m-[00m>cdr(),environment,lisp);
evaluator.cc:1514:	    RPCons evaluatedArgs = evaluateList(args[01;31m-[00m>cdr(),environment,lisp);
evaluator.cc:1521:	    if ( args[01;31m-[00m>hasParsePos() )
evaluator.cc:1525:		args[01;31m-[00m>getParsePos(lineNumber,column);
evaluator.cc:1526:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("%s:%s:%s %s [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m\n")% err.message() % args[01;31m-[00m>getParsePosFileName() % lineNumber % column ));
evaluator.cc:1529:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(err.message()));
evaluator.cc:1534:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Unknown object to evaluate: %s")%exp[01;31m-[00m>__repr__()));
evaluator.cc:1537:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Fell through"));
evaluator.cc:1544:    if ( head[01;31m-[00m>symbolQ() )
evaluator.cc:1546:	RPSymbol shead = head[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1555:	    exec = lisp[01;31m-[00m>lookupMacro(shead);
evaluator.cc:1556:	    if ( exec[01;31m-[00m>isNil() )
evaluator.cc:1558:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Could not find macro(%s)\n") % shead[01;31m-[00m>currentName() ));
evaluator.cc:1560:	    result = exec[01;31m-[00m>evaluate(args,newEnvironment,lisp)[01;31m-[00m>as<O_Cons>();
evaluator.cc:1564:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Illegal head for a macro[%s] class(%s) [01;31m-[00m it should be a symbol") % head[01;31m-[00m>__repr__() % head[01;31m-[00m>className() ));
evaluator.cc:1571:    if ( head[01;31m-[00m>symbolQ() )
evaluator.cc:1573:	RPSymbol shead = head[01;31m-[00m>as<O_Symbol>();
evaluator.cc:1581:	    RPObject receiver = lisp[01;31m-[00m>onil();
evaluator.cc:1582:	    if ( args[01;31m-[00m>notNil() )
evaluator.cc:1586:		receiver = args[01;31m-[00m>ocar();
evaluator.cc:1587:		LOG(BF("The potential receiver of the head is: %s")% receiver[01;31m-[00m>__repr__() );
evaluator.cc:1588:		RPMetaClass mc = receiver[01;31m-[00m>_class();
evaluator.cc:1589:		exec = lisp[01;31m-[00m>lookupMethod(shead,mc,receiver);
evaluator.cc:1590:		if ( exec[01;31m-[00m>notNil() )
evaluator.cc:1592:		    RPEnvironment formEnvironment = exec[01;31m-[00m>closedEnvironment(environment);
evaluator.cc:1593:		    LOG(BF("Evaluating method closedEnvironment=\n%s") % formEnvironment[01;31m-[00m>__repr__() );
evaluator.cc:1595:		    result = exec[01;31m-[00m>evaluate(args,evalEnviron,lisp);
evaluator.cc:1599:	    exec = environment[01;31m-[00m>lookupForm(shead);
evaluator.cc:1600:	    if ( exec[01;31m-[00m>isNil() )
evaluator.cc:1602:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Could not find form(%s)\n     [01;31m-[00m if its a method then its receiver class is: %s\n     [01;31m-[00m and its value is: %s") % shead[01;31m-[00m>currentName() % receiver[01;31m-[00m>className() % receiver[01;31m-[00m>__repr__() ));
evaluator.cc:1604:	    RPEnvironment formEnvironment = exec[01;31m-[00m>closedEnvironment(environment);
evaluator.cc:1606:	    result = exec[01;31m-[00m>evaluate(args,evalEnviron,lisp);
evaluator.cc:1609:    } else if ( head[01;31m-[00m>isAssignableTo<O_Executable>() )
evaluator.cc:1611:	RPExecutable exec = head[01;31m-[00m>as<O_Executable>();
evaluator.cc:1612:	LOG(BF("TRACE head is Executable[%s] arguments[%s]") % exec[01;31m-[00m>getSymbol()[01;31m-[00m>__repr__() % args[01;31m-[00m>__repr__() );
evaluator.cc:1617:	    RPEnvironment formEnvironment = exec[01;31m-[00m>closedEnvironment(environment);
evaluator.cc:1619:	    RPObject result = exec[01;31m-[00m>evaluate(args,evalEnviron,lisp);
evaluator.cc:1623:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Illegal head for a form[%s] class(%s) [01;31m-[00m it should be a symbol or executable") % head[01;31m-[00m>__repr__() % head[01;31m-[00m>className() ));
evaluator.cc:1631:    lisp[01;31m-[00m>clearExecutionFlags();
evaluator.cc:1632:    if ( args[01;31m-[00m>isNil() )
evaluator.cc:1634:        LOG(BF("Arguments before evaluateList: Nil [01;31m-[00m[01;31m-[00m[01;31m-[00m> returning Nil"));
evaluator.cc:1637:    LOG(BF("Arguments before evaluateList: %s")%args[01;31m-[00m>__repr__() );
evaluator.cc:1647:	for ( RPCons p=args; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() )
evaluator.cc:1649:	    inObj = p[01;31m-[00m>ocar();
evaluator.cc:1650:    	    LOG(BF("Pushing code onto the backTrace: <%s>")%p[01;31m-[00m>__repr__() );
evaluator.cc:1655:	    LOG(BF("After evaluation outObj = %s @ %X")% outObj[01;31m-[00m>__repr__() % (void*)(outObj.get()) );
evaluator.cc:1658:	    if ( firstCons[01;31m-[00m>isNil() )
evaluator.cc:1664:		curCons[01;31m-[00m>setCdr(outCons);
evaluator.cc:1667:	    if ( lisp[01;31m-[00m>getExecutionFlags() )
evaluator.cc:1669:		if ( lisp[01;31m-[00m>getReturnFlag() )
evaluator.cc:1673:		if ( lisp[01;31m-[00m>getBreakFlag() )
evaluator.cc:1677:		if ( lisp[01;31m-[00m>getContinueFlag() )
evaluator.cc:1681:		if ( lisp[01;31m-[00m>exit() )
evaluator.cc:1690:    while ( curCons[01;31m-[00m>notNil() )
evaluator.cc:1692:	RPObject zobj = curCons[01;31m-[00m>ocar();
evaluator.cc:1693:	LOG(BF("Argument after evaluateList in order: %s @ %X")% zobj[01;31m-[00m>__repr__() % (void*)(zobj.get()) );
evaluator.cc:1694:	curCons = curCons[01;31m-[00m>cdr();
evaluator.cc:1697:    LOG(BF("Arguments after evaluateList: %s")%firstCons[01;31m-[00m>__repr__() );
evaluator.cc:1703:    lisp[01;31m-[00m>clearExecutionFlags();
evaluator.cc:1705:    outObj = lisp[01;31m-[00m>nil<O_Object>();
evaluator.cc:1712:	for ( RPCons p=args; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() )
evaluator.cc:1714:	    inObj = p[01;31m-[00m>ocar();
evaluator.cc:1715:    	    LOG(BF("Pushing code onto the backTrace: <%s>")%p[01;31m-[00m>__repr__() );
evaluator.cc:1720:		if ( lisp[01;31m-[00m>getExecutionFlags() )
evaluator.cc:1722:		    if ( lisp[01;31m-[00m>getReturnFlag() )
evaluator.cc:1726:		    if ( lisp[01;31m-[00m>getBreakFlag() )
evaluator.cc:1730:		    if ( lisp[01;31m-[00m>getContinueFlag() )
evaluator.cc:1734:		    if ( lisp[01;31m-[00m>exit() )
evaluator.cc:1749:    lisp[01;31m-[00m>setSpecialForm_progn(lisp[01;31m-[00m>defineSpecialForm("progn",&special_progn));
evaluator.cc:1750:    lisp[01;31m-[00m>setSpecialForm_lambda(lisp[01;31m-[00m>defineSpecialForm("lambda",&special_lambda));
evaluator.cc:1751:    lisp[01;31m-[00m>setSpecialForm_slot(lisp[01;31m-[00m>defineSpecialForm("slot",&special_slot));
evaluator.cc:1752:    lisp[01;31m-[00m>setSpecialForm_quote(lisp[01;31m-[00m>defineSpecialForm("quote",&special_quote));
evaluator.cc:1753:    lisp[01;31m-[00m>setSpecialForm_function(lisp[01;31m-[00m>defineSpecialForm("function",&special_function));
evaluator.cc:1754:    lisp[01;31m-[00m>setSpecialForm_backQuote(lisp[01;31m-[00m>defineSpecialForm("backQuote",&special_backQuote));
evaluator.cc:1755:    lisp[01;31m-[00m>setSpecialForm_sharpQuote(lisp[01;31m-[00m>defineSpecialForm("sharpQuote",&special_sharpQuote));
evaluator.cc:1756:    lisp[01;31m-[00m>setSpecialForm_comma(lisp[01;31m-[00m>defineSpecialForm("comma",&special_comma));
evaluator.cc:1757:    lisp[01;31m-[00m>setSpecialForm_commaAt(lisp[01;31m-[00m>defineSpecialForm("commaAt",&special_commaAt));
evaluator.cc:1758:    lisp[01;31m-[00m>defineSpecialForm("then",&special_progn);
evaluator.cc:1759:    lisp[01;31m-[00m>defineSpecialForm("else",&special_progn);
evaluator.cc:1760:    lisp[01;31m-[00m>defineSpecialForm("invoke",&special_invoke);
evaluator.cc:1761:    lisp[01;31m-[00m>defineSpecialForm("if",&special_if);
evaluator.cc:1762:    lisp[01;31m-[00m>defineSpecialForm("ifTrue",&special_ifTrue);
evaluator.cc:1763:    lisp[01;31m-[00m>defineSpecialForm("ifFalse",&special_ifFalse);
evaluator.cc:1764:    lisp[01;31m-[00m>defineSpecialForm("cond",&special_cond);
evaluator.cc:1765:    lisp[01;31m-[00m>defineSpecialForm("break",&special_break);
evaluator.cc:1766:    lisp[01;31m-[00m>defineSpecialForm("continue",&special_continue);
evaluator.cc:1767:    lisp[01;31m-[00m>defineSpecialForm("raise",&special_raise);
evaluator.cc:1768:    lisp[01;31m-[00m>defineSpecialForm("return",&special_return);
evaluator.cc:1769:    lisp[01;31m-[00m>defineSpecialForm("prognDebug",&special_prognDebug);
evaluator.cc:1770:    lisp[01;31m-[00m>defineSpecialForm("prognLog",&special_prognLog);
evaluator.cc:1771:    lisp[01;31m-[00m>defineSpecialForm("log",&special_log);
evaluator.cc:1772:    lisp[01;31m-[00m>defineSpecialForm("assert",&special_assert);
evaluator.cc:1773:    lisp[01;31m-[00m>defineSpecialForm("while",&special_while);
evaluator.cc:1774:    lisp[01;31m-[00m>defineSpecialForm("foreach",&special_foreach);
evaluator.cc:1775:    lisp[01;31m-[00m>defineSpecialForm("setq",&special_setValue);	// change to setf later
evaluator.cc:1776:    lisp[01;31m-[00m>defineSpecialForm("defset",&special_local);
evaluator.cc:1777:    lisp[01;31m-[00m>defineSpecialForm("=",&special_setValue);
evaluator.cc:1778:    lisp[01;31m-[00m>defineSpecialForm("local",&special_local);
evaluator.cc:1779:    lisp[01;31m-[00m>defineSpecialForm(":=",&special_setValue);
evaluator.cc:1780:    lisp[01;31m-[00m>defineSpecialForm("global",&special_global);
evaluator.cc:1781:    lisp[01;31m-[00m>defineSpecialForm("defvar",&special_global);
evaluator.cc:1782:    lisp[01;31m-[00m>defineSpecialForm("defClass",&special_defClass);
evaluator.cc:1783:    lisp[01;31m-[00m>defineSpecialForm("defMethod",&special_defMethod);
evaluator.cc:1784:    lisp[01;31m-[00m>defineSpecialForm("defun",&special_defun);
evaluator.cc:1785:    lisp[01;31m-[00m>defineSpecialForm("setf",&special_setf);
evaluator.cc:1786:    lisp[01;31m-[00m>defineSpecialForm("getf",&special_getf);
evaluator.cc:1787:    lisp[01;31m-[00m>defineSpecialForm("when",&special_when);
evaluator.cc:1788:    lisp[01;31m-[00m>defineSpecialForm("eval",&special_eval);
evaluator.cc:1789:    lisp[01;31m-[00m>defineSpecialForm("method",&special_method);
evaluator.cc:1790:    lisp[01;31m-[00m>defineSpecialForm("handlerCase", &special_handlerCase );
evaluator.cc:1791:    lisp[01;31m-[00m>defineSpecialForm("let", &special_let);
evaluator.cc:1792:    lisp[01;31m-[00m>defineSpecialForm("flet", &special_flet);
evaluator.cc:1793:    lisp[01;31m-[00m>defineSpecialForm("labels", &special_labels);
evaluator.cc:1794:    lisp[01;31m-[00m>defineSpecialForm("let*", &special_letStar);
evaluator.cc:1795:    lisp[01;31m-[00m>defineSpecialForm("callAncestorMethod", &special_callAncestorMethod);
evaluator.cc:1796:    lisp[01;31m-[00m>defineMacro(lisp[01;31m-[00m>intern(ClPackage,"defMacro"), &macro_defMacro );
evaluator.cc:1797:    lisp[01;31m-[00m>defineMacro(lisp[01;31m-[00m>intern(ClPackage,"defmacro"), &macro_defMacro );
exceptions.cc:52:	this[01;31m-[00m>_Message = (BF("File: %s Function:%s LineNumber:%d\n%s") % sourceFile % functionName % lineNumber % fmt.str()).str();
exceptions.cc:57:	this[01;31m-[00m>_Message = (BF("File: %s Function:%s LineNumber:%d\n%s") % sourceFile % functionName % lineNumber % msg ).str();
exceptions.cc:62:	return this[01;31m-[00m>_Message;
exceptions.cc:69:	string mainLine = (BF("C++ Stack_level(%4d) source(%s:%d) %10s: %s") % stackLevel % this[01;31m-[00m>_sourceFilePath % this[01;31m-[00m>_lineNumber % this[01;31m-[00m>_structure % this[01;31m-[00m>_functionName).str();
exceptions.cc:70:	if ( this[01;31m-[00m>_message == NULL ) return mainLine;
exceptions.cc:71:	return (BF("%s\n message: %s") % mainLine % this[01;31m-[00m>_message).str();
exceptions.cc:83:    return this[01;31m-[00m>_Stack.size()==0;
exceptions.cc:88:    return this[01;31m-[00m>_Stack.size();
exceptions.cc:93:    return this[01;31m-[00m>_Stack.back();
exceptions.cc:98:    return this[01;31m-[00m>_Stack[i];
exceptions.cc:103:    this[01;31m-[00m>_Stack.push_back(e);
exceptions.cc:108:    this[01;31m-[00m>_Stack.pop_back();
exceptions.cc:120:	this[01;31m-[00m>_Stack.push_back(*it);
exceptions.cc:135://    ss << "THROWN AT: " << this[01;31m-[00m>getTraceFile() << ":" << this[01;31m-[00m>getTraceLine() << endl;
exceptions.cc:136:    ss << "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mSTACK TRACE[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
exceptions.cc:137:    for ( uint i=0; i<this[01;31m-[00m>_Stack.size(); i++ ) {
exceptions.cc:138:        e = &(this[01;31m-[00m>_Stack[i]);
exceptions.cc:139:	ss << e[01;31m-[00m>asStringAtStackLevel(i+1);
exceptions.cc:141://	ss << ")   "<< e[01;31m-[00m>structure<<"(" << e[01;31m-[00m>name;
exceptions.cc:142://		<< "    Line number: " << e[01;31m-[00m>lineNumber << endl;
exceptions.cc:143://	ss << "    Source file: " << e[01;31m-[00m>sourceFilePath  << endl;
exceptions.cc:161:    this[01;31m-[00m>_Enabled = true;
exceptions.cc:162:    this[01;31m-[00m>_OutStreamOpen = false;
exceptions.cc:163:    this[01;31m-[00m>DebugPositionCounter = 0;
exceptions.cc:164:    this[01;31m-[00m>DebugCallDepth = 0;
exceptions.cc:165:    this[01;31m-[00m>DebugLogAddBrackets = true;
exceptions.cc:166:    this[01;31m-[00m>DebugLogProcessRank = rank;
exceptions.cc:167:    this[01;31m-[00m>_SuppressMessages = false;
exceptions.cc:168://    this[01;31m-[00m>_CppCallStack.setTraceFileLine("[01;31m-[00m[01;31m-[00mDebugging off[01;31m-[00m[01;31m-[00m",0);
exceptions.cc:169:    this[01;31m-[00m>_DebugPrefix = "[01;31m-[00m[01;31m-[00mDebugging off[01;31m-[00m[01;31m-[00m";
exceptions.cc:170:    this[01;31m-[00m>_DebugFileNames.clear();
exceptions.cc:172:    fileName % this[01;31m-[00m>DebugLogProcessRank;
exceptions.cc:173:    this[01;31m-[00m>_LogFileName = fileName.str();
exceptions.cc:178:	printf("[01;31m-[00m[01;31m-[00m[01;31m-[00m Writing log to file: %s\n", this[01;31m-[00m>_LogFileName.c_str() );
exceptions.cc:179:	printf("[01;31m-[00m[01;31m-[00m[01;31m-[00m Writing log messages for source files listed in CANDO_DEBUG environment variable\n" );
exceptions.cc:180:	printf("[01;31m-[00m[01;31m-[00m[01;31m-[00m CANDO_DEBUG environment variable is: %s\n", cstr );
exceptions.cc:185:	this[01;31m-[00m>_DebugAll = false;
exceptions.cc:186:	this[01;31m-[00m>_DebugScript = false;
exceptions.cc:192:		this[01;31m-[00m>_DebugAll = true;
exceptions.cc:193:		printf("[01;31m-[00m[01;31m-[00m[01;31m-[00m Logging all c[01;31m-[00mcode source files\n");
exceptions.cc:197:		this[01;31m-[00m>_DebugScript = true;
exceptions.cc:198:		printf("[01;31m-[00m[01;31m-[00m[01;31m-[00m Logging all script source files\n");
exceptions.cc:202:		printf("[01;31m-[00m[01;31m-[00m[01;31m-[00m Turning off initial logging messages [01;31m-[00m use debugLogOn to turn them on\n");
exceptions.cc:203:		this[01;31m-[00m>setSuppressMessages(true);
exceptions.cc:206:	    this[01;31m-[00m>addDebugFileName(*fi);
exceptions.cc:210:        this[01;31m-[00m>_Enabled = false;
exceptions.cc:213:    this[01;31m-[00m>DebugLogAsXml = false;
exceptions.cc:214:    this[01;31m-[00m>_OutStream.open(this[01;31m-[00m>_LogFileName.c_str(),ios_base::out);
exceptions.cc:215:    this[01;31m-[00m>beginNode("DebugLog");
exceptions.cc:216:    this[01;31m-[00m>close();
exceptions.cc:222:    if ( !this[01;31m-[00m>_Enabled ) return;
exceptions.cc:224:    this[01;31m-[00m>_OutStream.open(this[01;31m-[00m>_LogFileName.c_str(),ios_base::app);
exceptions.cc:226:    this[01;31m-[00m>endNode("DebugLog");
exceptions.cc:227:    this[01;31m-[00m>_OutStream.close();
exceptions.cc:233:	return this[01;31m-[00m>_CppCallStack;
exceptions.cc:239:    this[01;31m-[00m>_DebugPrefix = s;
exceptions.cc:244:    return this[01;31m-[00m>_DebugPrefix;
exceptions.cc:251:    if ( !this[01;31m-[00m>_Enabled ) return false;
exceptions.cc:252:    if ( this[01;31m-[00m>debugAll() ) return true;
exceptions.cc:253:    if ( this[01;31m-[00m>debugScript() )
exceptions.cc:255:	if ( strncmp(this[01;31m-[00m>_DebugPrefix,"CSC", 3) == 0 ) return true;
exceptions.cc:257:    if ( this[01;31m-[00m>_DebugFileNames.count(fn)>0 ) return true;
exceptions.cc:258://    this[01;31m-[00m>write("failed_debugCheck[");
exceptions.cc:259://    this[01;31m-[00m>write(fn);
exceptions.cc:260://    this[01;31m-[00m>write("] ");
exceptions.cc:265:    if ( !this[01;31m-[00m>_Enabled ) return "[01;31m-[00m[01;31m-[00mnone[01;31m-[00m[01;31m-[00m";
exceptions.cc:268:    for ( fi=this[01;31m-[00m>_DebugFileNames.begin(); fi!=this[01;31m-[00m>_DebugFileNames.end(); fi++ )
exceptions.cc:280:    ss << "p"<<this[01;31m-[00m>DebugPositionCounter<<"p";
exceptions.cc:281:    this[01;31m-[00m>DebugPositionCounter++;
exceptions.cc:287:	if ( this[01;31m-[00m>DebugLogAsXml )
exceptions.cc:289:	    this[01;31m-[00m>writeRaw((BF("<%s>\n")%nodeName).str());
exceptions.cc:291:	    this[01;31m-[00m>writeRaw( (BF("%s%s%s\n") % DebugOpenLeft % nodeName % DebugOpenRight ).str());
exceptions.cc:298:    if ( this[01;31m-[00m>DebugLogAsXml )
exceptions.cc:301:	this[01;31m-[00m>writeRaw(stuff);
exceptions.cc:302:	if ( message!="") this[01;31m-[00m>writeTextCr(message);
exceptions.cc:306:	this[01;31m-[00m>writeRaw(stuff);
exceptions.cc:307:	this[01;31m-[00m>writeTextCr(message);
exceptions.cc:316:    if ( this[01;31m-[00m>DebugLogAsXml )
exceptions.cc:319:	this[01;31m-[00m>writeRaw(stuff);
exceptions.cc:323:	this[01;31m-[00m>writeRaw(stuff);
exceptions.cc:331:    if ( !this[01;31m-[00m>_Enabled ) return *this;
exceptions.cc:332:    if ( this[01;31m-[00m>_SuppressMessages ) return *this;
exceptions.cc:333:    this[01;31m-[00m>open();
exceptions.cc:334:    this[01;31m-[00m>_OutStream << data;
exceptions.cc:335:    this[01;31m-[00m>_OutStream.flush();
exceptions.cc:336:    this[01;31m-[00m>close();
exceptions.cc:343:    if ( !this[01;31m-[00m>_Enabled ) return *this;
exceptions.cc:344:    if ( this[01;31m-[00m>_SuppressMessages ) return *this;
exceptions.cc:345:    this[01;31m-[00m>open();
exceptions.cc:348:        if ( this[01;31m-[00m>DebugLogAsXml )
exceptions.cc:353:		this[01;31m-[00m>_OutStream << "&lt;";
exceptions.cc:356:		this[01;31m-[00m>_OutStream << "&gt;";
exceptions.cc:359:		this[01;31m-[00m>_OutStream << "&amp;";
exceptions.cc:362:		this[01;31m-[00m>_OutStream << "&apos;";
exceptions.cc:365:		this[01;31m-[00m>_OutStream << "&quot;";
exceptions.cc:368:		this[01;31m-[00m>_OutStream << *cp;
exceptions.cc:373:	    this[01;31m-[00m>_OutStream << *cp;
exceptions.cc:376://    this[01;31m-[00m>_OutStream << data;
exceptions.cc:377:    this[01;31m-[00m>_OutStream.flush();
exceptions.cc:378:    this[01;31m-[00m>close();
exceptions.cc:385:    this[01;31m-[00m>writeText(msg);
exceptions.cc:386:    this[01;31m-[00m>writeRaw("\n");
exceptions.cc:393:    if ( !this[01;31m-[00m>_Enabled ) return *this;
exceptions.cc:394:    if ( this[01;31m-[00m>_SuppressMessages ) return *this;
exceptions.cc:395:    this[01;31m-[00m>open();
exceptions.cc:396:    this[01;31m-[00m>_OutStream << i;
exceptions.cc:397:    this[01;31m-[00m>close();
exceptions.cc:403:    if ( !this[01;31m-[00m>_Enabled ) return *this;
exceptions.cc:404:    if ( this[01;31m-[00m>_SuppressMessages ) return *this;
exceptions.cc:405:    this[01;31m-[00m>open();
exceptions.cc:406:    this[01;31m-[00m>_OutStream << i;
exceptions.cc:407:    this[01;31m-[00m>close();
exceptions.cc:413:    if ( !this[01;31m-[00m>_Enabled ) return *this;
exceptions.cc:414:    if ( this[01;31m-[00m>_SuppressMessages ) return *this;
exceptions.cc:415:    this[01;31m-[00m>open();
exceptions.cc:416:    this[01;31m-[00m>_OutStream << endl;
exceptions.cc:417:    this[01;31m-[00m>close();
exceptions.cc:424:	if ( !this[01;31m-[00m>_Enabled ) return;
exceptions.cc:425:	if ( this[01;31m-[00m>_OutStreamOpen ) return;
exceptions.cc:428:	this[01;31m-[00m>_OutStream.open(this[01;31m-[00m>_LogFileName.c_str(),ios_base::app);
exceptions.cc:429:	if ( this[01;31m-[00m>_OutStream.fail() ) {
exceptions.cc:430:	    printf( "DEBUG LOG(())@%lX COULD NOT OPEN FILE(%s) FAILED!!!\n", (unsigned long)(this), this[01;31m-[00m>_LogFileName.c_str());
exceptions.cc:433:	this[01;31m-[00m>_OutStreamOpen = true;
exceptions.cc:441:    if ( !this[01;31m-[00m>_Enabled ) return;
exceptions.cc:443:    this[01;31m-[00m>_OutStream.close();
exceptions.cc:450:    if ( !this[01;31m-[00m>_Enabled ) return;
exceptions.cc:451:    this[01;31m-[00m>_OutStream.close();
exceptions.cc:463:    if ( !this[01;31m-[00m>_Enabled ) return false;
exceptions.cc:464:    if ( this[01;31m-[00m>getSuppressMessages() ) return false;
exceptions.cc:465:    if ( this[01;31m-[00m>debugAll() ) return true;
exceptions.cc:467:    while ( name >= fileName && !((*name == '\\') || (*name == '/'))) name[01;31m-[00m[01;31m-[00m;
exceptions.cc:469:    if ( !this[01;31m-[00m>recognizesDebugFileName(name) ) return false;
exceptions.cc:479:    this[01;31m-[00m>writeRaw((BF("<DebugMessages state=\"%s\"/>\n") % stateName ).str());
exceptions.cc:480:    this[01;31m-[00m>_SuppressMessages = s;
exceptions.cc:493:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not allocate a large enough internalPrintf buffer"));
exceptions.cc:500:{ // Dont use [01;31m-[00m[01;31m-[00m> _F(lisp);
exceptions.cc:503:    if ( !lisp[01;31m-[00m>debugLog().debugScript() )
exceptions.cc:507:	    if ( !lisp[01;31m-[00m>debugLog().cppCallStack().at(entryIndex[01;31m-[00m1).getWroteToLog() )
exceptions.cc:509:		_stackTraceEnter_WriteEntryToLog(entryIndex[01;31m-[00m1,lisp);
exceptions.cc:513:    e = &(lisp[01;31m-[00m>debugLog().cppCallStack().at(entryIndex));
exceptions.cc:514:    e[01;31m-[00m>setWroteToLog(true);
exceptions.cc:515:    if ( e[01;31m-[00m>message() == NULL )
exceptions.cc:517:	lisp[01;31m-[00m>debugLog().beginNode(e[01;31m-[00m>structure(),e[01;31m-[00m>sourceFilePath(),e[01;31m-[00m>functionName(),e[01;31m-[00m>lineNumber(),"");
exceptions.cc:519:	lisp[01;31m-[00m>debugLog().beginNode(e[01;31m-[00m>structure(),e[01;31m-[00m>sourceFilePath(),e[01;31m-[00m>functionName(),e[01;31m-[00m>lineNumber(),e[01;31m-[00m>message());
exceptions.cc:527:    e = &(lisp[01;31m-[00m>debugLog().cppCallStack().last());
exceptions.cc:528:    if (!lisp[01;31m-[00m>debugLog().isOn(e[01;31m-[00m>getSourceFilePath()) ) return;
exceptions.cc:529:    _stackTraceEnter_WriteEntryToLog(lisp[01;31m-[00m>debugLog().cppCallStack().size()[01;31m-[00m1,lisp);
exceptions.cc:534:    if ( lisp[01;31m-[00m>debugLog().cppCallStack().isEmpty() ) return;
exceptions.cc:535:    _StackEntry& e = (lisp[01;31m-[00m>debugLog().cppCallStack().last());
exceptions.cc:543:    _StackEntry& e = (lisp[01;31m-[00m>debugLog().cppCallStack().last());
exceptions.cc:545:    lisp[01;31m-[00m>debugLog().endNode(e.getStructure());
exceptions.cc:553:    ss = lisp[01;31m-[00m>debugLog().cppCallStack().asString();
exceptions.cc:554:    lisp[01;31m-[00m>debugLog().writeText(ss);
exceptions.cc:561:{_F(dict[01;31m-[00m>lisp());
exceptions.cc:562:    if ( dict[01;31m-[00m>size()== 0 ) return;
exceptions.cc:563:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unwanted arguments: "+dict[01;31m-[00m>allKeys() ));
exceptions.cc:594:    this[01;31m-[00m>_Message = msg;
exceptions.cc:595:    this[01;31m-[00m>saveCppStackTrace(lisp[01;31m-[00m>debugLog().cppCallStack());
exceptions.cc:600:    this[01;31m-[00m>_Message = f.str();
exceptions.cc:601:    this[01;31m-[00m>saveCppStackTrace(lisp[01;31m-[00m>debugLog().cppCallStack());
exceptions.cc:607:    ss << "A FatalError occured: " << this[01;31m-[00m>_Message << endl;
exceptions.cc:609:    ss << this[01;31m-[00m>_CppStackTrace.asString();
exceptions.cc:616:    this[01;31m-[00m>_Message = (BF("File(%s) Function(%s) LineNumber(%d)\n%s") % sourceFile % functionName % lineNumber % this[01;31m-[00m>_Message ).str();
exceptions.cc:621:    this[01;31m-[00m>_CppStackTrace.copyFromOther(copy);
executableNameSpace.cc:27:    if ( classId[01;31m-[00m>notNil() )
executableNameSpace.cc:29:	classId[01;31m-[00m>addMethod(sym,form);
executableNameSpace.cc:32:    this[01;31m-[00m>_Forms[sym.get()] = form;
executableNameSpace.cc:38: * in the classManager. If it isn't returned return O_Executable::nil(this[01;31m-[00m>lisp())
executableNameSpace.cc:42:    if ( receiverClass[01;31m-[00m>notNil() )
executableNameSpace.cc:44:	RPExecutable form = receiverClass[01;31m-[00m>getMethodOrNil(functionSymbol);
executableNameSpace.cc:45:	if ( form[01;31m-[00m>notNil() ) return form;
executableNameSpace.cc:47:    map<O_Symbol*,RPExecutable>::iterator fi = this[01;31m-[00m>_Forms.find(functionSymbol.get());
executableNameSpace.cc:48:    if ( fi!=this[01;31m-[00m>_Forms.end() )
executableNameSpace.cc:50:	return fi[01;31m-[00m>second;
executableNameSpace.cc:52:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find form for symbol: "+functionSymbol[01;31m-[00m>__repr__() ));
executableNameSpace.cc:56:{_F(this[01;31m-[00m>lisp());
executableNameSpace.cc:57:    RPMetaClass receiverClass = O_MetaClass::nil(this[01;31m-[00m>lisp());
executableNameSpace.cc:58:    if ( args[01;31m-[00m>notNil() )
executableNameSpace.cc:60:	receiverClass = args[01;31m-[00m>ocar()[01;31m-[00m>_class();
executableNameSpace.cc:62:    return this[01;31m-[00m>lookupFormWithReceiver(head,receiverClass);
executableNameSpace.cc:68:    if ( head[01;31m-[00m>classId() == O_Symbol::_classId() )
executableNameSpace.cc:71:	name = symbol[01;31m-[00m>get();
executableNameSpace.cc:72:	LOG(BF("Looking up method/function: %s") % symbol[01;31m-[00m>get().c_str() ); // vp0(("Looking up method/function: %s", symbol[01;31m-[00m>get().c_str()));
executableNameSpace.cc:73:        if ( !this[01;31m-[00m>_Methods.recognizesMethodName(symbol[01;31m-[00m>get()) )
executableNameSpace.cc:76:	    ss << "Undefined method/function with name: "+symbol[01;31m-[00m>get() << endl;
executableNameSpace.cc:77:	    if ( args[01;31m-[00m>length() == 0 )
executableNameSpace.cc:82:		ss << "   its receiver is of class: " << args[01;31m-[00m>ocar()[01;31m-[00m>getInstanceClassName();
executableNameSpace.cc:84:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
executableNameSpace.cc:86:	methodId = this[01;31m-[00m>_Methods.getMethodId(symbol[01;31m-[00m>get());
executableNameSpace.cc:90:	    // add support for pre[01;31m-[00mcompiled/pre[01;31m-[00mlooked up methodId
executableNameSpace.cc:93:	LOG(BF(" head = %s") % head[01;31m-[00m>__repr__().c_str()  ); // vp0((" head = %s", head[01;31m-[00m>__repr__().c_str() ));
executableNameSpace.cc:94:	LOG(BF(" args = %s") % args[01;31m-[00m>__repr__().c_str()  ); // vp0((" args = %s", args[01;31m-[00m>__repr__().c_str() ));
executableNameSpace.cc:100:	ss << "Expression head(" << head[01;31m-[00m>__repr__() << ") is not a symbol and it needs to be!" << endl;
executableNameSpace.cc:101:	ss << "    instead it is of class("<< head[01;31m-[00m>className() << ")" << endl;
executableNameSpace.cc:102:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
executableNameSpace.cc:106:    RPExecutable exec = O_Executable::nil(this[01;31m-[00m>lisp());
executableNameSpace.cc:107:    if ( args[01;31m-[00m>notNil() )
executableNameSpace.cc:110:	RPObject receiver = args[01;31m-[00m>ocar();
executableNameSpace.cc:114:	if ( receiver[01;31m-[00m>isOfClass<O_CandoObject>() )
executableNameSpace.cc:117:	    uclassId = receiver[01;31m-[00m>getInstanceClassId();
executableNameSpace.cc:126:	    uclassId = receiver[01;31m-[00m>classId();
executableNameSpace.cc:134:        exec = this[01;31m-[00m>_Methods.lookupMethod(methodId,uclassId,classManager,receiver);
executableNameSpace.cc:137:    if ( exec[01;31m-[00m>isNil() )
executableNameSpace.cc:139:	LOG(BF("exec[01;31m-[00m>isNil() == true") ); // vp0(("exec[01;31m-[00m>isNil() == true"));
executableNameSpace.cc:144:	exec = this[01;31m-[00m>_Methods.lookupMethod(methodId,uclassId,classManager,receiver);
executableNameSpace.cc:146:    if ( exec[01;31m-[00m>isNil() )
executableNameSpace.cc:151:	if ( args[01;31m-[00m>length() == 0 )
executableNameSpace.cc:156:	    RPObject rec = args[01;31m-[00m>ocar();
executableNameSpace.cc:157:	    uint classId = rec[01;31m-[00m>getInstanceClassId();
executableNameSpace.cc:158:	    if ( rec[01;31m-[00m>isNil() )
executableNameSpace.cc:167:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
exhaustiveSearch.cc:38:    this[01;31m-[00m>O_Search::archive(node);
exhaustiveSearch.cc:43:    this[01;31m-[00m>Base::initialize();
exhaustiveSearch.cc:44:    this[01;31m-[00m>_NumberOfProcesses = 1;
exhaustiveSearch.cc:45:    this[01;31m-[00m>_ProcessNumber = 0;
exhaustiveSearch.cc:46:    this[01;31m-[00m>_NumberOfConformationsPerSequence = 0;
exhaustiveSearch.cc:47:    this[01;31m-[00m>_UseRandomConformations = false;
exhaustiveSearch.cc:54:    this[01;31m-[00m>Base::setDefaultOptions();
exhaustiveSearch.cc:55:    this[01;31m-[00m>_NumberOfProcesses = 1;
exhaustiveSearch.cc:56:    this[01;31m-[00m>_ProcessNumber = 0;
exhaustiveSearch.cc:57:    this[01;31m-[00m>_NumberOfConformationsPerSequence = 0;
exhaustiveSearch.cc:58:    this[01;31m-[00m>_UseRandomConformations = false;
exhaustiveSearch.cc:63:    this[01;31m-[00m>setKeyedOptions(opts[01;31m-[00m>asKeyedArguments());
exhaustiveSearch.cc:67:{_F(this[01;31m-[00m>lisp());
exhaustiveSearch.cc:68:    this[01;31m-[00m>setDefaultOptions();
exhaustiveSearch.cc:69:    this[01;31m-[00m>Base::setKeyedOptions(kargs);
exhaustiveSearch.cc:70:    this[01;31m-[00m>_NumberOfConformationsPerSequence = kargs[01;31m-[00m>getIntAndRemoveOrDefault("NumberOfConformationsPerSequence",0);
exhaustiveSearch.cc:71:    this[01;31m-[00m>_NumberOfProcesses = kargs[01;31m-[00m>getIntAndRemoveOrDefault("NumberOfProcesses",1);
exhaustiveSearch.cc:72:    this[01;31m-[00m>_ProcessNumber = kargs[01;31m-[00m>getIntAndRemoveOrDefault("ProcessNumber",0);
exhaustiveSearch.cc:73:    this[01;31m-[00m>_UseRandomConformations = kargs[01;31m-[00m>getBoolAndRemoveOrDefault("UseRandomConformations",false);
exhaustiveSearch.cc:74:    kargs[01;31m-[00m>throwOnUnusedArguments(0);
exhaustiveSearch.cc:82:    search[01;31m-[00m>setBuilderScorer(kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_BuilderScorer>());
exhaustiveSearch.cc:83://    search[01;31m-[00m>setScorer(kargs[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_ScorerBase>());
exhaustiveSearch.cc:84:    search[01;31m-[00m>setHitList(kargs[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_HitList>());
exhaustiveSearch.cc:85:    RPCons options = kargs[01;31m-[00m>getAndRemoveOrDefault("options",O_Cons::nil(lisp))[01;31m-[00m>as<O_Cons>();
exhaustiveSearch.cc:86:    kargs[01;31m-[00m>throwOnUnusedArguments(3);
exhaustiveSearch.cc:87:    search[01;31m-[00m>setOptions(options);
exhaustiveSearch.cc:88:    search[01;31m-[00m>run();
exhaustiveSearch.cc:96:    uint sequenceIndex = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
exhaustiveSearch.cc:97:    search[01;31m-[00m>setBuilderScorer(kargs[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_BuilderScorer>());
exhaustiveSearch.cc:98://    search[01;31m-[00m>setScorer(kargs[01;31m-[00m>getPositionalArgument(2)[01;31m-[00m>as<O_ScorerBase>());
exhaustiveSearch.cc:99:    search[01;31m-[00m>setHitList(kargs[01;31m-[00m>getPositionalArgument(2)[01;31m-[00m>as<O_HitList>());
exhaustiveSearch.cc:100:    RPCons options = kargs[01;31m-[00m>getAndRemoveOrDefault("options",O_Cons::nil(lisp))[01;31m-[00m>as<O_Cons>();
exhaustiveSearch.cc:101:    kargs[01;31m-[00m>throwOnUnusedArguments(4);
exhaustiveSearch.cc:102:    search[01;31m-[00m>setOptions(options);
exhaustiveSearch.cc:104:    RPBuilderScorer builderScorer = search[01;31m-[00m>getBuilderScorer();
exhaustiveSearch.cc:105://    RPScorerBase scorer = search[01;31m-[00m>getScorer();
exhaustiveSearch.cc:106:    RPHitList hitList = search[01;31m-[00m>getHitList();
exhaustiveSearch.cc:107:    builderScorer[01;31m-[00m>firstOligomer();
exhaustiveSearch.cc:108:    builderScorer[01;31m-[00m>firstSequence();
exhaustiveSearch.cc:109:    builderScorer[01;31m-[00m>firstConformation();
exhaustiveSearch.cc:110:    hitList[01;31m-[00m>getData()[01;31m-[00m>set("builderScorer",builderScorer);
exhaustiveSearch.cc:112:    builderScorer[01;31m-[00m>gotoSequence(sequenceIndex);
exhaustiveSearch.cc:113:    if ( search[01;31m-[00m>getVerbose() ) _lisp[01;31m-[00m>print(BF("Searching sequence#%6lld") % sequenceIndex);
exhaustiveSearch.cc:115:    totalNumberOfBuilds += search[01;31m-[00m>searchCurrentSequence(statistics);
exhaustiveSearch.cc:123:    search[01;31m-[00m>setBuilderScorer(kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_BuilderScorer>());
exhaustiveSearch.cc:124://    search[01;31m-[00m>setScorer(kargs[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_ScorerBase>());
exhaustiveSearch.cc:125:    search[01;31m-[00m>setHitList(kargs[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_HitList>());
exhaustiveSearch.cc:126:    RPCons options = kargs[01;31m-[00m>getAndRemoveOrDefault("options",O_Cons::nil(lisp))[01;31m-[00m>as<O_Cons>();
exhaustiveSearch.cc:127:    kargs[01;31m-[00m>throwOnUnusedArguments(2);
exhaustiveSearch.cc:128:    search[01;31m-[00m>setOptions(options);
exhaustiveSearch.cc:129:    RPHitList hitList = search[01;31m-[00m>getHitList();
exhaustiveSearch.cc:130:    hitList[01;31m-[00m>getData()[01;31m-[00m>set("builderScorer",search[01;31m-[00m>getBuilderScorer());
exhaustiveSearch.cc:133:    totalNumberOfBuilds += search[01;31m-[00m>conformationalSearchWithMultipleHits( statistics );
exhaustiveSearch.cc:147:{_F(this[01;31m-[00m>lisp());
exhaustiveSearch.cc:148:    ASSERT_NOT_NULL(this[01;31m-[00m>_Builder);
exhaustiveSearch.cc:149:    ASSERT_NOT_NULL(this[01;31m-[00m>_Scorer);
exhaustiveSearch.cc:150:    ASSERT_NOT_NULL(this[01;31m-[00m>_HitList);
exhaustiveSearch.cc:151:    RPBuilder builder = this[01;31m-[00m>_Builder;
exhaustiveSearch.cc:152:    RPScorerBase scorer = this[01;31m-[00m>_Scorer;
exhaustiveSearch.cc:153:    RPHitList hitList = this[01;31m-[00m>_HitList;
exhaustiveSearch.cc:154:    builder[01;31m-[00m>firstOligomer();
exhaustiveSearch.cc:155:    builder[01;31m-[00m>firstSequence();
exhaustiveSearch.cc:156:    builder[01;31m-[00m>firstConformation();
exhaustiveSearch.cc:157:    hitList[01;31m-[00m>getData()[01;31m-[00m>set("builder",builder);
exhaustiveSearch.cc:159:    numberOfProcesses = this[01;31m-[00m>_NumberOfProcesses;
exhaustiveSearch.cc:161:    processNumber = this[01;31m-[00m>_ProcessNumber;
exhaustiveSearch.cc:164:    processNumber = MIN(processNumber,numberOfProcesses[01;31m-[00m1);
exhaustiveSearch.cc:165:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("numberOfProcesses = %6lld") % numberOfProcesses );
exhaustiveSearch.cc:166:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("processNumber     = %6lld") % processNumber);
exhaustiveSearch.cc:168:    LongLongInt	totalNumberOfSequences = builder[01;31m-[00m>numberOfSequences();
exhaustiveSearch.cc:169:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("There are %lld TOTAL sequences to search exhaustively") %totalNumberOfSequences);
exhaustiveSearch.cc:173:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is fewer than one sequence per process, reduce the number of processes"));
exhaustiveSearch.cc:175:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("This process will carry out %2.0lf%% of the searcher") % (sequenceStep/((double)(totalNumberOfSequences))*100.0));
exhaustiveSearch.cc:178:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Searching sequence#%6lld to %6lld") % sequenceIndexBegin% sequenceIndexEnd );
exhaustiveSearch.cc:180:    RPScorerStatistics statistics = O_ScorerStatistics::create(this[01;31m-[00m>lisp());
exhaustiveSearch.cc:184:        builder[01;31m-[00m>gotoSequence(sequenceIndex);
exhaustiveSearch.cc:185:	scorer[01;31m-[00m>oligomerChanged(builder);
exhaustiveSearch.cc:186:	scorer[01;31m-[00m>sequenceChanged(builder);
exhaustiveSearch.cc:187:        this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Searching sequence#%6lld") % sequenceIndex);
exhaustiveSearch.cc:188:	totalNumberOfBuilds += this[01;31m-[00m>searchCurrentSequence(statistics);
exhaustiveSearch.cc:190:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("\nBuild %lld TOTAL structures (oligomers*sequences*conformations)\n\n") % totalNumberOfBuilds );
exhaustiveSearch.cc:196:{_F(this[01;31m-[00m>lisp());
exhaustiveSearch.cc:197:    ASSERT_NOT_NULL(this[01;31m-[00m>_BuilderScorer);
exhaustiveSearch.cc:198:    ASSERT_NOT_NULL(this[01;31m-[00m>_HitList);
exhaustiveSearch.cc:199:    RPBuilderScorer builderScorer = this[01;31m-[00m>getBuilderScorer();
exhaustiveSearch.cc:200:    RPHitList hitList = this[01;31m-[00m>_HitList;
exhaustiveSearch.cc:201:    builderScorer[01;31m-[00m>firstOligomer();
exhaustiveSearch.cc:202:    builderScorer[01;31m-[00m>firstSequence();
exhaustiveSearch.cc:203:    builderScorer[01;31m-[00m>firstConformation();
exhaustiveSearch.cc:204:    hitList[01;31m-[00m>getData()[01;31m-[00m>set("builderScorer",builderScorer);
exhaustiveSearch.cc:205:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("There are %lld oligomers to search exhaustively") % builderScorer[01;31m-[00m>numberOfOligomers() );
exhaustiveSearch.cc:207:    for ( uint oligomerIndex = 0; oligomerIndex<builderScorer[01;31m-[00m>numberOfOligomers(); oligomerIndex++ )
exhaustiveSearch.cc:209:	builderScorer[01;31m-[00m>gotoOligomerIndexDontBuild(oligomerIndex);
exhaustiveSearch.cc:210:	LongLongInt	totalNumberOfSequences = builderScorer[01;31m-[00m>numberOfSequencesInCurrentOligomer();
exhaustiveSearch.cc:211:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Oligomer #%u has %lld sequences to search exhaustively") % oligomerIndex% totalNumberOfSequences);
exhaustiveSearch.cc:214:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Searching sequence#%6lld to %6lld") % sequenceIndexBegin % (sequenceIndexEnd[01;31m-[00m1) );
exhaustiveSearch.cc:216:	RPScorerStatistics statistics = O_ScorerStatistics::create(this[01;31m-[00m>lisp());
exhaustiveSearch.cc:220:	    builderScorer[01;31m-[00m>gotoSequence(sequenceIndex);
exhaustiveSearch.cc:221:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Searching sequence#%6lld") % sequenceIndex);
exhaustiveSearch.cc:222:	    totalNumberOfBuilds += this[01;31m-[00m>searchCurrentSequence(statistics);
exhaustiveSearch.cc:225:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("\nBuild %lld TOTAL structures (oligomers*sequences*conformations)\n\n") % totalNumberOfBuilds );
exhaustiveSearch.cc:231:{_F(this[01;31m-[00m>lisp());
exhaustiveSearch.cc:233:    RPBuilderScorer builderScorer = this[01;31m-[00m>getBuilderScorer();
exhaustiveSearch.cc:234:    RPHitList hitList = this[01;31m-[00m>getHitList();
exhaustiveSearch.cc:241:	bestBuilderState = O_BuilderState::create(this[01;31m-[00m>lisp());
exhaustiveSearch.cc:242:	bestScorerState = builderScorer[01;31m-[00m>createScorerState();
exhaustiveSearch.cc:243:	tempScorerState = builderScorer[01;31m-[00m>createScorerState();
exhaustiveSearch.cc:244:	builderScorer[01;31m-[00m>firstConformation();
exhaustiveSearch.cc:245:	if ( this[01;31m-[00m>_UseRandomConformations )
exhaustiveSearch.cc:247:	    if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearch.cc:249:		this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Building %d RANDOM conformations for each sequence") %this[01;31m-[00m>_NumberOfConformationsPerSequence );
exhaustiveSearch.cc:251:	    numberOfConformations = this[01;31m-[00m>_NumberOfConformationsPerSequence;
exhaustiveSearch.cc:254:	    numberOfConformations = builderScorer[01;31m-[00m>numberOfNecessaryConformationsInCurrentSequence();
exhaustiveSearch.cc:255:	    if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearch.cc:257:		this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Building every conformation for this sequence, thats %lld conformations") % numberOfConformations );
exhaustiveSearch.cc:263:    statistics[01;31m-[00m>reset();
exhaustiveSearch.cc:267:	    tempScorerState[01;31m-[00m>clear();
exhaustiveSearch.cc:269:	    builderScorer[01;31m-[00m>buildNecessaryUntransformedAtomPositionsAndEvaluateScorer(tempScorerState);
exhaustiveSearch.cc:270:	    if ( this[01;31m-[00m>getVerbosity()>1 )
exhaustiveSearch.cc:272:		this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("conf#%04u tempScorerState = %s") % confCount% tempScorerState[01;31m-[00m>summary().c_str() );
exhaustiveSearch.cc:274:	    statistics[01;31m-[00m>update(tempScorerState);
exhaustiveSearch.cc:275:    	    if ( hitList[01;31m-[00m>isAHit(tempScorerState) )
exhaustiveSearch.cc:278:		statistics[01;31m-[00m>registerHit(tempScorerState);
exhaustiveSearch.cc:279:		bestScorerState[01;31m-[00m>copyFromOtherState(tempScorerState);
exhaustiveSearch.cc:280:		builderScorer[01;31m-[00m>saveBuilderState(bestBuilderState);
exhaustiveSearch.cc:281:		LOG(BF("Added hit with bestScore=%lf") % bestScorerState[01;31m-[00m>getScore() ); // vp0(("Added hit with bestScore=%lf",bestScorerState[01;31m-[00m>getScore()));
exhaustiveSearch.cc:282:		RPScorerState hitScorerState = bestScorerState[01;31m-[00m>copy();
exhaustiveSearch.cc:284:		RPHit hit = hitList[01;31m-[00m>createHitWithStates(builderScorer, bestBuilderState,hitScorerState);
exhaustiveSearch.cc:285:		if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearch.cc:287:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Added a hit with score: %lf") % bestScorerState[01;31m-[00m>getScore() );
exhaustiveSearch.cc:288://		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % hitList[01;31m-[00m>__repr__().c_str() );
exhaustiveSearch.cc:294:	    if ( !this[01;31m-[00m>_UseRandomConformations )
exhaustiveSearch.cc:297:		conformationsRemain = builderScorer[01;31m-[00m>incrementConformation();
exhaustiveSearch.cc:301:		builderScorer[01;31m-[00m>randomizeConformation();
exhaustiveSearch.cc:307:		if ( this[01;31m-[00m>getVerbose() ) this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("  Done %8lld/%8lld conformations, bestScore = %s") %				confCount% numberOfConformations% bestScorerState[01;31m-[00m>summary().c_str());
exhaustiveSearch.cc:312:    if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearch.cc:314:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("  Done %8lld/%8lld conformations, bestScore = %s") % confCount % numberOfConformations % bestScorerState[01;31m-[00m>summary().c_str());
exhaustiveSearch.cc:315:        this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % statistics[01;31m-[00m>summary().c_str() );
exhaustiveSearch.cc:323:{_F(this[01;31m-[00m>lisp());
exhaustiveSearch.cc:325:    RPBuilderScorer builderScorer = this[01;31m-[00m>getBuilderScorer();
exhaustiveSearch.cc:326:    RPHitList hitList = this[01;31m-[00m>getHitList();
exhaustiveSearch.cc:333:	bestBuilderState = O_BuilderState::create(this[01;31m-[00m>lisp());
exhaustiveSearch.cc:334:	bestScorerState = builderScorer[01;31m-[00m>createScorerState();
exhaustiveSearch.cc:335:	tempScorerState = builderScorer[01;31m-[00m>createScorerState();
exhaustiveSearch.cc:336:	builderScorer[01;31m-[00m>firstConformation();
exhaustiveSearch.cc:337:	if ( this[01;31m-[00m>_UseRandomConformations )
exhaustiveSearch.cc:339:	    if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearch.cc:341:		this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Building %d RANDOM conformations for each sequence") % this[01;31m-[00m>_NumberOfConformationsPerSequence );
exhaustiveSearch.cc:343:	    numberOfConformations = this[01;31m-[00m>_NumberOfConformationsPerSequence;
exhaustiveSearch.cc:346:	    numberOfConformations = builderScorer[01;31m-[00m>numberOfNecessaryConformationsInCurrentSequence();
exhaustiveSearch.cc:347:	    if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearch.cc:349:		this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Building every conformation for this sequence, thats %lld conformations" ) %			numberOfConformations );
exhaustiveSearch.cc:355:    statistics[01;31m-[00m>reset();
exhaustiveSearch.cc:359:	    tempScorerState[01;31m-[00m>clear();
exhaustiveSearch.cc:361:	    builderScorer[01;31m-[00m>buildNecessaryUntransformedAtomPositionsAndEvaluateScorer(tempScorerState);
exhaustiveSearch.cc:362:	    if ( this[01;31m-[00m>getVerbosity()>1 )
exhaustiveSearch.cc:364:		this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("conf#%04u tempScorerState = %s") % confCount% tempScorerState[01;31m-[00m>summary().c_str() );
exhaustiveSearch.cc:366:	    statistics[01;31m-[00m>update(tempScorerState);
exhaustiveSearch.cc:367:	    if ( tempScorerState[01;31m-[00m>isBetterThan(bestScorerState) )
exhaustiveSearch.cc:370:		statistics[01;31m-[00m>registerHit(tempScorerState);
exhaustiveSearch.cc:371:		bestScorerState[01;31m-[00m>copyFromOtherState(tempScorerState);
exhaustiveSearch.cc:372:		builderScorer[01;31m-[00m>saveBuilderState(bestBuilderState);
exhaustiveSearch.cc:378:	    builderScorer[01;31m-[00m>advanceConformation(this[01;31m-[00m>_UseRandomConformations);
exhaustiveSearch.cc:382:		if ( this[01;31m-[00m>getVerbose() )
exhaustiveSearch.cc:384:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("  Done %8lld/%8lld conformations, bestScore = %s") % 
exhaustiveSearch.cc:385:				confCount % numberOfConformations % bestScorerState[01;31m-[00m>summary().c_str());
exhaustiveSearch.cc:391:    if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearch.cc:393:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("  Done %8lld/%8lld conformations, bestScore = %s")
exhaustiveSearch.cc:394:		    % confCount % numberOfConformations % bestScorerState[01;31m-[00m>summary());
exhaustiveSearch.cc:396:    if ( hitList[01;31m-[00m>isAHit(bestScorerState ) )
exhaustiveSearch.cc:398:	LOG(BF("Added hit with bestScore=%s") % bestScorerState[01;31m-[00m>summary().c_str() ); // vp0(("Added hit with bestScore=%s",bestScorerState[01;31m-[00m>summary().c_str()));
exhaustiveSearch.cc:399:	RPScorerState hitScorerState = bestScorerState[01;31m-[00m>copy();
exhaustiveSearch.cc:401:	builderScorer[01;31m-[00m>restoreState(bestBuilderState);
exhaustiveSearch.cc:402://        bestBuilderState[01;31m-[00m>getBuilder()[01;31m-[00m>buildInterestingUntransformedAtomPositions(); // TEST TEST TEST
exhaustiveSearch.cc:405:	RPHit hit = hitList[01;31m-[00m>createHitWithStates(builderScorer, bestBuilderState, hitScorerState );
exhaustiveSearch.cc:406:	if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearch.cc:408:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Added hit with score: %lf") % bestScorerState[01;31m-[00m>getScore() );
exhaustiveSearch.cc:409:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % hitList[01;31m-[00m>__repr__().c_str() );
exhaustiveSearch.cc:410:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % statistics[01;31m-[00m>summary().c_str() );
exhaustiveSearch.cc:422:	class_<O_ExhaustiveSearch>(this[01;31m-[00m>lisp())
exhaustiveSearch.cc:424:	defNoWrapPackage(MbbPackage,"exhaustiveSearch",&O_ExhaustiveSearch::prim_exhaustiveSearch,this[01;31m-[00m>lisp()); // ctor
exhaustiveSearch.cc:425:	defNoWrapPackage(MbbPackage,"exhaustiveSearchOneSequence",&O_ExhaustiveSearch::prim_exhaustiveSearchOneSequence,this[01;31m-[00m>lisp()); // ctor
exhaustiveSearch.cc:426:	defNoWrapPackage(MbbPackage,"exhaustiveSearchConformationsOfCurrentSequence",&O_ExhaustiveSearch::prim_exhaustiveSearchConformationsOfCurrentSequence,this[01;31m-[00m>lisp()); // ctor
exhaustiveSearchOneSequence.cc:38:    this[01;31m-[00m>O_Search::archive(node);
exhaustiveSearchOneSequence.cc:43:    this[01;31m-[00m>Base::initialize();
exhaustiveSearchOneSequence.cc:44:    this[01;31m-[00m>_NumberOfPartitions = 1;
exhaustiveSearchOneSequence.cc:45:    this[01;31m-[00m>_PartitionNumber = 0;
exhaustiveSearchOneSequence.cc:46:    this[01;31m-[00m>_NumberOfConformationsPerSequence = 0;
exhaustiveSearchOneSequence.cc:47:    this[01;31m-[00m>_UseRandomConformations = false;
exhaustiveSearchOneSequence.cc:54:    this[01;31m-[00m>Base::setDefaultOptions();
exhaustiveSearchOneSequence.cc:55:    this[01;31m-[00m>_NumberOfPartitions = 1;
exhaustiveSearchOneSequence.cc:56:    this[01;31m-[00m>_PartitionNumber = 0;
exhaustiveSearchOneSequence.cc:57:    this[01;31m-[00m>_NumberOfConformationsPerSequence = 0;
exhaustiveSearchOneSequence.cc:58:    this[01;31m-[00m>_UseRandomConformations = false;
exhaustiveSearchOneSequence.cc:63:    this[01;31m-[00m>setKeyedOptions(args[01;31m-[00m>asKeyedArguments());
exhaustiveSearchOneSequence.cc:67:{_F(this[01;31m-[00m>lisp());
exhaustiveSearchOneSequence.cc:68:    this[01;31m-[00m>setDefaultOptions();
exhaustiveSearchOneSequence.cc:69:    this[01;31m-[00m>Base::setKeyedOptions(kargs);
exhaustiveSearchOneSequence.cc:70:    this[01;31m-[00m>_NumberOfPartitions = kargs[01;31m-[00m>getIntAndRemoveOrDefault("NumberOfPartitions",1);
exhaustiveSearchOneSequence.cc:71:    this[01;31m-[00m>_PartitionNumber = kargs[01;31m-[00m>getIntAndRemoveOrDefault("PartitionNumber",0);
exhaustiveSearchOneSequence.cc:72:    this[01;31m-[00m>_UseRandomConformations = kargs[01;31m-[00m>getBoolAndRemoveOrDefault("UseRandomConformations",false);
exhaustiveSearchOneSequence.cc:73:    this[01;31m-[00m>_NumberOfConformationsPerSequence = kargs[01;31m-[00m>getIntAndRemoveOrDefault("NumberOfConformationsPerSequence",0);
exhaustiveSearchOneSequence.cc:74:    kargs[01;31m-[00m>throwOnUnusedArguments(0);
exhaustiveSearchOneSequence.cc:81:    this[01;31m-[00m>setBuilderScorer(kargs[01;31m-[00m>getAndRemove("builderScorer")[01;31m-[00m>as<O_BuilderScorer>());
exhaustiveSearchOneSequence.cc:82:    this[01;31m-[00m>setHitList(kargs[01;31m-[00m>getAndRemove("hitList")[01;31m-[00m>as<O_HitList>());
exhaustiveSearchOneSequence.cc:83:    RPCons options = kargs[01;31m-[00m>getAndRemoveOrDefault("options",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
exhaustiveSearchOneSequence.cc:84:    this[01;31m-[00m>setOptions(options);
exhaustiveSearchOneSequence.cc:85:    RPBuilderScorer bs = this[01;31m-[00m>getBuilderScorer();
exhaustiveSearchOneSequence.cc:86:    bs[01;31m-[00m>firstConformation();
exhaustiveSearchOneSequence.cc:87:    RPHitList hitList = this[01;31m-[00m>getHitList();
exhaustiveSearchOneSequence.cc:88:    hitList[01;31m-[00m>setBuilderScorer(bs);
exhaustiveSearchOneSequence.cc:90:    RPScorerStatistics statistics = O_ScorerStatistics::create(this[01;31m-[00m>lisp());
exhaustiveSearchOneSequence.cc:96:{_F(this[01;31m-[00m>lisp());
exhaustiveSearchOneSequence.cc:97:    RPScorerStatistics statistics = O_ScorerStatistics::create(this[01;31m-[00m>lisp());
exhaustiveSearchOneSequence.cc:98:    this[01;31m-[00m>_Statistics = statistics;
exhaustiveSearchOneSequence.cc:100:    RPBuilderScorer builderScorer = this[01;31m-[00m>getBuilderScorer();
exhaustiveSearchOneSequence.cc:101:    RPHitList hitList = this[01;31m-[00m>getHitList();
exhaustiveSearchOneSequence.cc:108:	bestBuilderState = O_BuilderState::create(this[01;31m-[00m>lisp());
exhaustiveSearchOneSequence.cc:109:	bestScorerState = builderScorer[01;31m-[00m>createScorerState();
exhaustiveSearchOneSequence.cc:110:	tempScorerState = builderScorer[01;31m-[00m>createScorerState();
exhaustiveSearchOneSequence.cc:111:	builderScorer[01;31m-[00m>firstConformation();
exhaustiveSearchOneSequence.cc:112:	if ( this[01;31m-[00m>_UseRandomConformations )
exhaustiveSearchOneSequence.cc:114:	    if ( this[01;31m-[00m>getVerbose() ) this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Building %d RANDOM conformations for each sequence") % this[01;31m-[00m>_NumberOfConformationsPerSequence );
exhaustiveSearchOneSequence.cc:115:	    numberOfConformations = this[01;31m-[00m>_NumberOfConformationsPerSequence;
exhaustiveSearchOneSequence.cc:118:	    numberOfConformations = builderScorer[01;31m-[00m>numberOfNecessaryConformationsInCurrentSequence();
exhaustiveSearchOneSequence.cc:119:	    if ( this[01;31m-[00m>getVerbose() ) this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Building every conformation for this "
exhaustiveSearchOneSequence.cc:125:    statistics[01;31m-[00m>reset();
exhaustiveSearchOneSequence.cc:129:	    tempScorerState[01;31m-[00m>clear();
exhaustiveSearchOneSequence.cc:131:	    builderScorer[01;31m-[00m>buildNecessaryUntransformedAtomPositionsAndEvaluateScorer(tempScorerState);
exhaustiveSearchOneSequence.cc:132:	    if ( this[01;31m-[00m>getVerbosity()>1 )
exhaustiveSearchOneSequence.cc:134:		this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("conf#%04u tempScorerState = %s") % confCount% tempScorerState[01;31m-[00m>summary().c_str() );
exhaustiveSearchOneSequence.cc:136:	    statistics[01;31m-[00m>update(tempScorerState);
exhaustiveSearchOneSequence.cc:137:    	    if ( hitList[01;31m-[00m>isAHit(tempScorerState) )
exhaustiveSearchOneSequence.cc:140:		statistics[01;31m-[00m>registerHit(tempScorerState);
exhaustiveSearchOneSequence.cc:141:		bestScorerState[01;31m-[00m>copyFromOtherState(tempScorerState);
exhaustiveSearchOneSequence.cc:142:		builderScorer[01;31m-[00m>saveBuilderState(bestBuilderState);
exhaustiveSearchOneSequence.cc:143:		LOG(BF("Added hit with bestScore=%lf") % bestScorerState[01;31m-[00m>getScore() ); // vp0(("Added hit with bestScore=%lf",bestScorerState[01;31m-[00m>getScore()));
exhaustiveSearchOneSequence.cc:144:		RPScorerState hitScorerState = bestScorerState[01;31m-[00m>copy();
exhaustiveSearchOneSequence.cc:146:		RPHit hit = hitList[01;31m-[00m>createHitWithStates(builderScorer, bestBuilderState,hitScorerState);
exhaustiveSearchOneSequence.cc:147:		if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearchOneSequence.cc:149:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Added a hit with score: %lf") % bestScorerState[01;31m-[00m>getScore() );
exhaustiveSearchOneSequence.cc:150://		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % hitList[01;31m-[00m>__repr__().c_str() );
exhaustiveSearchOneSequence.cc:156:	    if ( !this[01;31m-[00m>_UseRandomConformations )
exhaustiveSearchOneSequence.cc:159:		conformationsRemain = builderScorer[01;31m-[00m>incrementConformation();
exhaustiveSearchOneSequence.cc:163:		builderScorer[01;31m-[00m>randomizeConformation();
exhaustiveSearchOneSequence.cc:169:		if ( this[01;31m-[00m>getVerbose() ) this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("  Done %8lld/%8lld conformations, bestScore = %s") % 	confCount % numberOfConformations % bestScorerState[01;31m-[00m>summary().c_str());
exhaustiveSearchOneSequence.cc:174:    if ( this[01;31m-[00m>getVerbose() ) 
exhaustiveSearchOneSequence.cc:176:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("  Done %8lld/%8lld conformations, bestScore = %s") % confCount % numberOfConformations % bestScorerState[01;31m-[00m>summary().c_str());
exhaustiveSearchOneSequence.cc:177:        this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % statistics[01;31m-[00m>summary().c_str() );
exhaustiveSearchOneSequence.cc:179:    this[01;31m-[00m>_ConformationsBuilt = confCount;
exhaustiveSearchOneSequence.cc:192:	class_<O_ExhaustiveSearchOneSequence>(this[01;31m-[00m>lisp())
externalInterface.cc:33:    this[01;31m-[00m>Base::initialize();
externalInterface.cc:34:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
externalInterface.cc:35:    this[01;31m-[00m>_AtomNames = O_StringList::create(this[01;31m-[00m>lisp());
externalInterface.cc:36:    this[01;31m-[00m>_WeakConformationExplorer = O_ConformationExplorer::nil(this[01;31m-[00m>lisp());
externalInterface.cc:46:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
externalInterface.cc:47:    this[01;31m-[00m>_WeakConformationExplorer = kargs[01;31m-[00m>getAndRemove("conformationExplorer")[01;31m-[00m>as<O_ConformationExplorer>();
externalInterface.cc:48:    this[01;31m-[00m>_StageName = kargs[01;31m-[00m>getStringAndRemove("stageName");
externalInterface.cc:54:{_F(this[01;31m-[00m>lisp());
externalInterface.cc:56:if ( node[01;31m-[00m>saving() )
externalInterface.cc:58:    ASSERT_NOT_NULLP(this[01;31m-[00m>_WeakConformationExplorer,"WeakConformationExplorer is NULL");
externalInterface.cc:61:    node[01;31m-[00m>archiveWeakPointer("WeakConformationExplorer",this[01;31m-[00m>_WeakConformationExplorer);
externalInterface.cc:62:    node[01;31m-[00m>attribute("StageName",this[01;31m-[00m>_StageName);
externalInterface.cc:63:    node[01;31m-[00m>archiveString("ExternalScript",this[01;31m-[00m>_ExternalScript);
externalInterface.cc:64:    node[01;31m-[00m>archiveMap("ScriptSubstitutions",this[01;31m-[00m>_ScriptSubstitutions);
externalInterface.cc:65:    node[01;31m-[00m>archiveObject("Data",this[01;31m-[00m>_Data);
externalInterface.cc:66:    node[01;31m-[00m>attribute("Directory",this[01;31m-[00m>_Directory);
externalInterface.cc:67:    node[01;31m-[00m>attribute("FileNamePrefix",this[01;31m-[00m>_FileNamePrefix);
externalInterface.cc:68:    node[01;31m-[00m>archiveObject("AtomNames", this[01;31m-[00m>_AtomNames);
externalInterface.cc:69:    node[01;31m-[00m>archiveMap("AtomNamesToAtoms",this[01;31m-[00m>_AtomNamesToAtoms);
externalInterface.cc:74:{_F(this[01;31m-[00m>lisp());
externalInterface.cc:75:    this[01;31m-[00m>archiveBase(node);
externalInterface.cc:82:{_F(this[01;31m-[00m>lisp());
externalInterface.cc:85:    this[01;31m-[00m>_WeakConformationExplorer = explorer[01;31m-[00m>sharedThis<O_ConformationExplorer>();
externalInterface.cc:86:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakConformationExplorer);
externalInterface.cc:95:{_F(this[01;31m-[00m>lisp());
externalInterface.cc:99:    fnStream << this[01;31m-[00m>_Directory << "/";
externalInterface.cc:100:    fnStream << this[01;31m-[00m>_FileNamePrefix
externalInterface.cc:101:    	    << "_" << this[01;31m-[00m>externalInterfaceName() << "_"
externalInterface.cc:116:{_F(this[01;31m-[00m>lisp());
externalInterface.cc:120:    fnStream << this[01;31m-[00m>_Directory << "/";
externalInterface.cc:121:    fnStream << this[01;31m-[00m>_FileNamePrefix
externalInterface.cc:122:    	    << "_" << this[01;31m-[00m>externalInterfaceName() << "_"
externalInterface.cc:132:{_F(this[01;31m-[00m>lisp());
externalInterface.cc:137:    entry = stage[01;31m-[00m>getConformationExplorerEntry();
externalInterface.cc:138:    explorer = stage[01;31m-[00m>getConformationExplorer();
externalInterface.cc:139:    index = explorer[01;31m-[00m>getEntryIndex(entry);
externalInterface.cc:140:    stageName = stage[01;31m-[00m>getStageName();
externalInterface.cc:142:    return this[01;31m-[00m>_assembleFileName(index,stageName,ext);
externalInterface.cc:146:{_F(this[01;31m-[00m>lisp());
externalInterface.cc:151:    entry = stage[01;31m-[00m>getConformationExplorerEntry();
externalInterface.cc:152:    explorer = stage[01;31m-[00m>getConformationExplorer();
externalInterface.cc:153:    index = explorer[01;31m-[00m>getEntryIndex(entry);
externalInterface.cc:154:    stageName = stage[01;31m-[00m>getStageName();
externalInterface.cc:156:    return this[01;31m-[00m>_assembleFilePath(index,stageName,ext);
externalInterface.cc:161:{_F(this[01;31m-[00m>lisp());
externalInterface.cc:170:    fileName = this[01;31m-[00m>assembleFileName(entryStage,this[01;31m-[00m>summaryFileExtension());
externalInterface.cc:172:    explorer = entryStage[01;31m-[00m>getConformationExplorer();
externalInterface.cc:194:	    if ( this[01;31m-[00m>_AtomNamesToAtoms.contains(atomName) )
externalInterface.cc:196:		atom = this[01;31m-[00m>_AtomNamesToAtoms.get(atomName);
externalInterface.cc:197:	        entryStage[01;31m-[00m>setCoordinateForAtom(atom,pos);
externalInterface.cc:200:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("In summary file: "+fileName.string()+" did not recognize atom named: "+atomName));
externalInterface.cc:207:	    entryStage[01;31m-[00m>setEnergyKCal(hartrees*627.5095);
externalInterface.cc:210:    if ( numCoordsRead != explorer[01;31m-[00m>numberOfAllAtoms() )
externalInterface.cc:212:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Not enough coordinates"));
externalInterface.cc:223:	class_<O_ExternalInterface>(this[01;31m-[00m>lisp())
externalObject.cc:22:    class_<O_ExternalObjectManager>(env[01;31m-[00m>lisp())
externalObject.cc:26:{_F(this[01;31m-[00m>lisp());
externalObject.cc:27:    this[01;31m-[00m>_ExternalPointersToObjects.clear();
externalObject.cc:33:    LOG(BF("Registering external ptr@%p to correspond to object(%s)") % ptr % obj[01;31m-[00m>__repr__() );
externalObject.cc:34:    this[01;31m-[00m>_ExternalPointersToObjects[ptr] = obj;
externalObject.cc:38:{_F(this[01;31m-[00m>lisp());
externalObject.cc:39:    return this[01;31m-[00m>_ExternalPointersToObjects.count(ptr)>0;
externalObject.cc:44:    if ( !this[01;31m-[00m>recognizesExternal(ptr) )
externalObject.cc:46:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("The external pointer@%p is not recognized") % ptr ));
externalObject.cc:48:    if ( this[01;31m-[00m>_ExternalPointersToObjects[ptr].use_count() == 0 )
externalObject.cc:50:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Object for external ptr@p was deleted") % ptr ));
externalObject.cc:52:    return this[01;31m-[00m>_ExternalPointersToObjects[ptr].lock();
externalObject.cc:62:    class_<O_ExternalObject>(e[01;31m-[00m>lisp())
externalObject.cc:81:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
externalObject.cc:87:    this[01;31m-[00m>Base::initialize();
externalObject.cc:92:    this[01;31m-[00m>Base::archiveBase(node);
extractFragment.cc:32:    this[01;31m-[00m>Base::initialize();
extractFragment.cc:33:    this[01;31m-[00m>_WeakFragment = O_Fragment::nil(this[01;31m-[00m>lisp());
extractFragment.cc:37:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:38:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
extractFragment.cc:39:    this[01;31m-[00m>_WeakFragment = args[01;31m-[00m>getAndRemove("fragment")[01;31m-[00m>as<O_Fragment>();
extractFragment.cc:40:    ASSERT_NOT_NULLP(this[01;31m-[00m>_WeakFragment,"ExtractFragmentBase _WeakFragment is NULL");
extractFragment.cc:41:    ASSERTP(this[01;31m-[00m>getFragment()[01;31m-[00m>notNil(),"ExtractFragmentBase _WeakFragment is nil");
extractFragment.cc:47:    ss << this[01;31m-[00m>className() << "@" << this << "[ ";
extractFragment.cc:48:    if (this[01;31m-[00m>isNil() ) 
extractFragment.cc:53:    if ( this[01;31m-[00m>_WeakFragment.use_count() == 0 )
extractFragment.cc:56:    } else if ( this[01;31m-[00m>_WeakFragment.lock()[01;31m-[00m>isNil() )
extractFragment.cc:60:	ss << "_WeakFragment=fragment(" << this[01;31m-[00m>_WeakFragment.lock()[01;31m-[00m>getName()<<")";
extractFragment.cc:67:    this[01;31m-[00m>Base::archiveBase(node);
extractFragment.cc:68:    node[01;31m-[00m>archiveWeakPointer("fragment",this[01;31m-[00m>_WeakFragment);
extractFragment.cc:73:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:74:    if ( this[01;31m-[00m>_WeakFragment.use_count() == 0 )
extractFragment.cc:76:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The _WeakFragment is nil for ExtractFragmentBase"));
extractFragment.cc:78:    return this[01;31m-[00m>_WeakFragment.lock();
extractFragment.cc:90:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:98:    fragment = this[01;31m-[00m>getFragment();
extractFragment.cc:99:    focusResidue = focusMonomer[01;31m-[00m>getTemporaryResidue();
extractFragment.cc:100:    for ( ai = fragment[01;31m-[00m>begin_AtomNames(); ai!=fragment[01;31m-[00m>end_AtomNames(); ai++ )
extractFragment.cc:102:        if ( !focusResidue[01;31m-[00m>hasAtomWithName(*ai) )
extractFragment.cc:104:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find atom named("+*ai+") in residue: "
extractFragment.cc:105:	    			+focusResidue[01;31m-[00m>description()));
extractFragment.cc:107:        atom = focusResidue[01;31m-[00m>atomWithName(*ai);
extractFragment.cc:110:    if ( !extractScaffold[01;31m-[00m>atomsInFocusMonomerAreAllInAtomSet(focusMonomer,
extractFragment.cc:122:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:130:    LOG(BF("structureList contains %d entries") % structureList[01;31m-[00m>numberOfEntries()  ); // vp0(("structureList contains %d entries",structureList[01;31m-[00m>numberOfEntries() ));
extractFragment.cc:131:    uniqueStructures = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SuperposableConformationCollection>();
extractFragment.cc:132:    uniqueStructures[01;31m-[00m>setMatter(structureList[01;31m-[00m>getMatter());
extractFragment.cc:133:    fragment = this[01;31m-[00m>getFragment();
extractFragment.cc:135:    ASSERT(focusMonomer[01;31m-[00m>notNil());
extractFragment.cc:136:    res = focusMonomer[01;31m-[00m>getTemporaryResidue();
extractFragment.cc:137:    for ( ai=fragment[01;31m-[00m>begin_AtomNames();ai!=fragment[01;31m-[00m>end_AtomNames(); ai++ )
extractFragment.cc:139:        if ( !res[01;31m-[00m>hasAtomWithName(*ai) )
extractFragment.cc:141:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find atom named("+*ai+") in residue: "
extractFragment.cc:142:	    			+res[01;31m-[00m>description()));
extractFragment.cc:144:        atom = res[01;31m-[00m>atomWithName(*ai);
extractFragment.cc:145:	uniqueStructures[01;31m-[00m>addSuperposeAtom(atom);
extractFragment.cc:149:    RPFrameBase curFrame = this[01;31m-[00m>getFrame();
extractFragment.cc:151:    ASSERT(curFrame[01;31m-[00m>notNil());
extractFragment.cc:152:    boundFrame = curFrame[01;31m-[00m>getBoundFrame(focusMonomer);
extractFragment.cc:154:    ASSERT(boundFrame[01;31m-[00m>notNil());
extractFragment.cc:155:    boundFrame[01;31m-[00m>addYourAtomsToSuperposeAtoms(uniqueStructures);
extractFragment.cc:156:    uniqueStructures[01;31m-[00m>addConformationExplorerSelectedStageConformations(structureList);
extractFragment.cc:157:    LOG(BF("uniqueStructures contains %d entries") % uniqueStructures[01;31m-[00m>numberOfEntries()  ); // vp0(("uniqueStructures contains %d entries",uniqueStructures[01;31m-[00m>numberOfEntries() ));
extractFragment.cc:171:    this[01;31m-[00m>Base::initialize();
extractFragment.cc:172:    this[01;31m-[00m>_WeakFrame = O_Frame::nil(this[01;31m-[00m>lisp());
extractFragment.cc:176:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:177:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
extractFragment.cc:178:    this[01;31m-[00m>_WeakFrame = args[01;31m-[00m>getAndRemove("frame")[01;31m-[00m>as<O_Frame>();
extractFragment.cc:182:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:183:    this[01;31m-[00m>Base::archiveBase(node);
extractFragment.cc:184:    node[01;31m-[00m>archiveWeakPointer("frame",this[01;31m-[00m>_WeakFrame);
extractFragment.cc:190:    ss << this[01;31m-[00m>className() << "@" << this << "[ ";
extractFragment.cc:191:    if (this[01;31m-[00m>isNil() ) 
extractFragment.cc:196:    if ( this[01;31m-[00m>_WeakFragment.use_count() == 0 )
extractFragment.cc:199:    } else if ( this[01;31m-[00m>_WeakFragment.lock()[01;31m-[00m>isNil() )
extractFragment.cc:203:	ss << "_WeakFragment=fragment(" << this[01;31m-[00m>_WeakFragment.lock()[01;31m-[00m>getName();
extractFragment.cc:205:    if ( this[01;31m-[00m>_WeakFrame.use_count() == 0 )
extractFragment.cc:208:    } else if ( this[01;31m-[00m>_WeakFrame.lock()[01;31m-[00m>isNil() )
extractFragment.cc:212:	ss << "_WeakFrame=frame(" << this[01;31m-[00m>_WeakFrame.lock()[01;31m-[00m>getName();
extractFragment.cc:219:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:220:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakFrame);
extractFragment.cc:221:    RPFrame f = this[01;31m-[00m>_WeakFrame.lock();
extractFragment.cc:241:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:242:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
extractFragment.cc:243:    this[01;31m-[00m>_WeakExtractScaffold = args[01;31m-[00m>getAndRemove("scaffold")[01;31m-[00m>as<O_ExtractScaffold>();
extractFragment.cc:247:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:248:    this[01;31m-[00m>Base::archiveBase(node);
extractFragment.cc:249:    node[01;31m-[00m>archiveWeakPointer("scaffold",this[01;31m-[00m>_WeakExtractScaffold);
extractFragment.cc:255:    ss << this[01;31m-[00m>className() << "@" << this << "[ ";
extractFragment.cc:256:    if (this[01;31m-[00m>isNil() ) 
extractFragment.cc:261:    if ( this[01;31m-[00m>_WeakFragment.use_count() == 0 )
extractFragment.cc:264:    } else if ( this[01;31m-[00m>_WeakFragment.lock()[01;31m-[00m>isNil() )
extractFragment.cc:268:	ss << "_WeakFragment=fragment(" << this[01;31m-[00m>_WeakFragment.lock()[01;31m-[00m>getName();
extractFragment.cc:270:    if ( this[01;31m-[00m>_WeakExtractScaffold.use_count() == 0 )
extractFragment.cc:273:    } else if ( this[01;31m-[00m>_WeakExtractScaffold.lock()[01;31m-[00m>isNil() )
extractFragment.cc:277:	ss << "_WeakExtractScaffold=scaffold(" << this[01;31m-[00m>_WeakExtractScaffold.lock()[01;31m-[00m>getAnchor()[01;31m-[00m>description();
extractFragment.cc:286:{_F(this[01;31m-[00m>lisp());
extractFragment.cc:289:    extractScaffold = this[01;31m-[00m>getExtractScaffold();
extractFragment.cc:290:    anchor = extractScaffold[01;31m-[00m>getAnchor();
extractFragment.cc:303:    class_<O_ExtractFragmentBase>(this[01;31m-[00m>lisp())
extractFragment.cc:327:    class_<O_ExtractFragment>(this[01;31m-[00m>lisp())
extractFragment.cc:351:    class_<O_ExtractCoreFragment>(this[01;31m-[00m>lisp())
extractFrame.cc:24:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:30:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:31:    this[01;31m-[00m>O_ExtractFrameBase::archiveBase(node);
extractFrame.cc:32:    node[01;31m-[00m>attribute( "alias", this[01;31m-[00m>_Alias);
extractFrame.cc:33:    node[01;31m-[00m>attribute( "plugName", this[01;31m-[00m>_PlugName );
extractFrame.cc:34://    node[01;31m-[00m>archiveWeakPointer( "recognizer", this[01;31m-[00m>_WeakRecognizer);
extractFrame.cc:35://    node[01;31m-[00m>attribute( "containsAtom", this[01;31m-[00m>_ContainsAtom);
extractFrame.cc:43:    ss << "_Alias(" << this[01;31m-[00m>_Alias<< ") ";
extractFrame.cc:44:    ss << "_PlugName(" << this[01;31m-[00m>_PlugName << ") ";
extractFrame.cc:50:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:51:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Depreciated, you should use FrameFinisher aliases [01;31m-[00m[01;31m-[00m> getAlias"));
extractFrame.cc:55:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:56:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Depreciated, you should use FrameFinisher aliases [01;31m-[00m[01;31m-[00m> getAlias_const"));
extractFrame.cc:60:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:61:    this[01;31m-[00m>_Alias = alias;
extractFrame.cc:68:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:69:    if ( !mon[01;31m-[00m>hasCouplingWithPlugName(this[01;31m-[00m>_PlugName) )
extractFrame.cc:71:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Could not find plug("+this[01;31m-[00m>_PlugName+") for monomer("+mon[01;31m-[00m>getName()+")",mon[01;31m-[00m>description()));
extractFrame.cc:74:    coupling = mon[01;31m-[00m>getCouplingWithPlugName(this[01;31m-[00m>_PlugName);
extractFrame.cc:76:    neighborMonomer = coupling[01;31m-[00m>getOtherSideMonomer(mon);
extractFrame.cc:78:    neighborTopology = neighborMonomer[01;31m-[00m>getTopology();
extractFrame.cc:80:    if ( neighborTopology[01;31m-[00m>hasExtractScaffoldWithIncompleteFrameWithAlias(this[01;31m-[00m>_Alias) )
extractFrame.cc:82:	extractNeighborScaffold = neighborTopology[01;31m-[00m>getExtractScaffold();
extractFrame.cc:87:	ss << this[01;31m-[00m>_Alias.c_str() << ") in neighbor " << endl;
extractFrame.cc:88:	ss << "neighborMonomer = " << neighborMonomer[01;31m-[00m>description() << endl;
extractFrame.cc:89:	ss << "neighborTopology = " << neighborTopology[01;31m-[00m>description() << endl;
extractFrame.cc:90:	RPConstitution neighborConstitution = neighborTopology[01;31m-[00m>getConstitution();
extractFrame.cc:91:	ss << "neighborConstitution = " << neighborConstitution[01;31m-[00m>description() << endl;
extractFrame.cc:93:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(ss.str() ));
extractFrame.cc:97:    extractFrame = extractNeighborScaffold[01;31m-[00m>getExtractIncompleteFrameWithAlias(this[01;31m-[00m>_Alias);
extractFrame.cc:98:    RPBoundFrame boundFrame = extractFrame[01;31m-[00m>getFrame()[01;31m-[00m>getBoundFrame(neighborMonomer);
extractFrame.cc:100:    string containsAtomName = this[01;31m-[00m>getContainsAtom();
extractFrame.cc:101:    if ( !boundFrame[01;31m-[00m>containsAtomWithName(containsAtomName) )
extractFrame.cc:103:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("BoundFrame("+boundFrame[01;31m-[00m>description()+") does not contain atom with name("+containsAtomName+")", boundFrame[01;31m-[00m>description()));
extractFrame.cc:126:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:127:    this[01;31m-[00m>Base::oldLispInitialize(args,lisp);
extractFrame.cc:128:    this[01;31m-[00m>_Alias = args[01;31m-[00m>getStringAndRemove("alias");
extractFrame.cc:129:    this[01;31m-[00m>_PlugName = args[01;31m-[00m>getStringAndRemove("plugName");
extractFrame.cc:131:    this[01;31m-[00m>_ContainsAtom = args[01;31m-[00m>getStringAndRemove("containsAtom");
extractFrame.cc:132:    RPFrameRecognizer recog = args[01;31m-[00m>getAndRemove("recognizer")[01;31m-[00m>as<O_FrameRecognizer>();
extractFrame.cc:133:    this[01;31m-[00m>_WeakRecognizer = recog;
extractFrame.cc:140:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:141:    LOG(BF("_Alias=%s") % this[01;31m-[00m>_Alias.c_str()  ); // vp0(("_Alias=%s",this[01;31m-[00m>_Alias.c_str() ));
extractFrame.cc:142:    return this[01;31m-[00m>_Alias;
extractFrame.cc:146:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:147:    LOG(BF("_Alias=%s") % this[01;31m-[00m>_Alias.c_str()  ); // vp0(("_Alias=%s",this[01;31m-[00m>_Alias.c_str() ));
extractFrame.cc:148:    return this[01;31m-[00m>_Alias;
extractFrame.cc:153:    this[01;31m-[00m>_WeakFrame = O_Frame::nil(this[01;31m-[00m>lisp());
extractFrame.cc:157:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:158:    this[01;31m-[00m>Base::oldLispInitialize(args,lisp);
extractFrame.cc:159:    this[01;31m-[00m>_WeakFrame = args[01;31m-[00m>getAndRemove("frame")[01;31m-[00m>as<O_Frame>();
extractFrame.cc:163:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:164:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakFrame);
extractFrame.cc:165:    RPFrame frame = this[01;31m-[00m>getFrame();
extractFrame.cc:166:    return frame[01;31m-[00m>getName();
extractFrame.cc:173:    if ( this[01;31m-[00m>_WeakFrame.use_count() == 0 ) return false;
extractFrame.cc:174:    return ( this[01;31m-[00m>_WeakFrame.lock()[01;31m-[00m>notNil());
extractFrame.cc:181:    if ( this[01;31m-[00m>hasFrame() )
extractFrame.cc:183:	frame = this[01;31m-[00m>getFrame();
extractFrame.cc:184:	name = frame[01;31m-[00m>getName();
extractFrame.cc:196:    frame = this[01;31m-[00m>getFrame_const();
extractFrame.cc:197:    name = frame[01;31m-[00m>getName_const();
extractFrame.cc:205:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:206:    this[01;31m-[00m>O_ExtractFrameBase::archiveBase(node);
extractFrame.cc:207:    node[01;31m-[00m>archiveWeakPointer("frame",this[01;31m-[00m>_WeakFrame);
extractFrame.cc:211:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:214:    frame = this[01;31m-[00m>getFrame();
extractFrame.cc:215:    return frame[01;31m-[00m>getBoundFrame(mon);
extractFrame.cc:229:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:231:   boundFrame= this[01;31m-[00m>getBoundFrame(mon);
extractFrame.cc:233:   aOrigin = boundFrame[01;31m-[00m>get_oAtom();
extractFrame.cc:234:   aX = boundFrame[01;31m-[00m>get_pAtom();
extractFrame.cc:235:   aXY = boundFrame[01;31m-[00m>get_qAtom();
extractFrame.cc:236:   Vector3 vOrigin = aOrigin[01;31m-[00m>getPosition();
extractFrame.cc:237:   Vector3 vX = aX[01;31m-[00m>getPosition().sub(vOrigin);
extractFrame.cc:238:   Vector3 vXY = aXY[01;31m-[00m>getPosition().sub(vOrigin);
extractFrame.cc:240:   res = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateSystem>();
extractFrame.cc:241:   res[01;31m-[00m>defineForVectorsOriginXDirXYPlane(vOrigin,vX,vXY);
extractFrame.cc:251:    ss << this[01;31m-[00m>className() << "(";
extractFrame.cc:252:    ss << this[01;31m-[00m>getFrameName_const() << ") ";
extractFrame.cc:258:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:259:    this[01;31m-[00m>O_ExtractInternalFrameBase::archiveBase(node);
extractFrame.cc:266:    this[01;31m-[00m>Base::oldLispInitialize(kargs,lisp);
extractFrame.cc:267:    this[01;31m-[00m>_Alias = kargs[01;31m-[00m>getStringAndRemove("alias");
extractFrame.cc:268:    this[01;31m-[00m>_PlugName = kargs[01;31m-[00m>getStringAndRemove("plugName");
extractFrame.cc:273:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:274:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Depreciated, you should use IncompleteFrame aliases [01;31m-[00m[01;31m-[00m> getAlias"));
extractFrame.cc:278:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:279:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Depreciated, you should use IncompleteFrame aliases [01;31m-[00m[01;31m-[00m> getAlias_const"));
extractFrame.cc:285:    ss << this[01;31m-[00m>className() << "(";
extractFrame.cc:286:    ss << this[01;31m-[00m>getAlias_const() << ") ";
extractFrame.cc:291:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:292:    this[01;31m-[00m>O_ExtractInternalFrameBase::archiveBase(node);
extractFrame.cc:293:    node[01;31m-[00m>attribute("alias",this[01;31m-[00m>_Alias);
extractFrame.cc:294:    node[01;31m-[00m>attribute("plugName",this[01;31m-[00m>_PlugName);
extractFrame.cc:306:    this[01;31m-[00m>Base::oldLispInitialize(kargs,lisp);
extractFrame.cc:307:    this[01;31m-[00m>_PlugName = kargs[01;31m-[00m>getStringAndRemove("plugName");
extractFrame.cc:316:    ss << this[01;31m-[00m>className() << "("<< mutableThis[01;31m-[00m>generateAlias() << ")";
extractFrame.cc:321:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:322:    this[01;31m-[00m>O_ExtractInternalFrameBase::archiveBase(node);
extractFrame.cc:323:    node[01;31m-[00m>attribute("plugName",this[01;31m-[00m>_PlugName);
extractFrame.cc:328:    string recogName = recognizer[01;31m-[00m>getGroupName();
extractFrame.cc:335:    string plugName = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_String>()[01;31m-[00m>get();
extractFrame.cc:336:    RPFrameRecognizer recognizer = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_FrameRecognizer>();
extractFrame.cc:337:    return lisp[01;31m-[00m>create<O_String>(O_FrameFinisher::createAlias(lisp,plugName,recognizer));
extractFrame.cc:342:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:343:    RPFrame frame = this[01;31m-[00m>getFrame();
extractFrame.cc:344:    ASSERTP(frame[01;31m-[00m>isOfClass<O_RecognizedFrame>(),"All FrameFinishers must contain a RecognizedFrame");
extractFrame.cc:345:    return O_FrameFinisher::createAlias(this[01;31m-[00m>lisp(),this[01;31m-[00m>_PlugName,frame[01;31m-[00m>as<O_RecognizedFrame>()[01;31m-[00m>getFrameRecognizer());
extractFrame.cc:350:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:351:    RPExtractFrameFinisher e = RP_Create<O_ExtractFrameFinisher>(this[01;31m-[00m>lisp());
extractFrame.cc:352:    e[01;31m-[00m>setPlugName(this[01;31m-[00m>_PlugName);
extractFrame.cc:353:    e[01;31m-[00m>setAlias(this[01;31m-[00m>generateAlias());
extractFrame.cc:358:{_F(this[01;31m-[00m>lisp());
extractFrame.cc:359:    RPExtractIncompleteFrame e = RP_Create<O_ExtractIncompleteFrame>(this[01;31m-[00m>lisp());
extractFrame.cc:360:    e[01;31m-[00m>setAlias(this[01;31m-[00m>generateAlias());
extractFrame.cc:361:    e[01;31m-[00m>setFrame(this[01;31m-[00m>getFrame());
extractFrame.cc:398:    class_<O_ExtractFrameBase>(this[01;31m-[00m>lisp())
extractFrame.cc:417:    class_<O_ExtractFrameFinisher>(this[01;31m-[00m>lisp())
extractFrame.cc:445:    class_<O_ExtractInternalFrameBase>(this[01;31m-[00m>lisp())
extractFrame.cc:464:    class_<O_ExtractCompleteFrame>(this[01;31m-[00m>lisp())
extractFrame.cc:488:    class_<O_ExtractIncompleteFrame>(this[01;31m-[00m>lisp())
extractFrame.cc:510:    class_<O_FrameFinisher>(this[01;31m-[00m>lisp())
extractFrame.cc:512:    defNoWrapPackage(MbbPackage,"FrameFinisher_createAlias",&prim_FrameFinisher_createAlias,this[01;31m-[00m>lisp());
extractScaffold.cc:18:    ss << "Could not find context: "<<this[01;31m-[00m>_Context[01;31m-[00m>getKey();
extractScaffold.cc:36:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:37:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
extractScaffold.cc:38:    this[01;31m-[00m>_Anchor = args[01;31m-[00m>getAndRemoveOrDefault("anchor",O_Anchor::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Anchor>();
extractScaffold.cc:45:    one = args[01;31m-[00m>getAndRemoveOrDefault("frameFinishers",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
extractScaffold.cc:46:    this[01;31m-[00m>_ExtractFrameFinishers.fillFromCons(one);
extractScaffold.cc:51:    one = args[01;31m-[00m>getAndRemoveOrDefault("completeFrames",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
extractScaffold.cc:52:    this[01;31m-[00m>_ExtractCompleteFrames.fillFromCons(one);
extractScaffold.cc:57:    one = args[01;31m-[00m>getAndRemoveOrDefault("incompleteFrames",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
extractScaffold.cc:58:    this[01;31m-[00m>_ExtractIncompleteFrames.fillFromCons(one);
extractScaffold.cc:63:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:64:    this[01;31m-[00m>_ExtractCompleteFrames.fillFromCons(c);
extractScaffold.cc:68:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:69:    this[01;31m-[00m>_ExtractIncompleteFrames.fillFromCons(c);
extractScaffold.cc:73:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:74:    this[01;31m-[00m>_ExtractFrameFinishers.fillFromCons(c);
extractScaffold.cc:82:    if ( this[01;31m-[00m>_Anchor.use_count() == 0 )
extractScaffold.cc:84:	ss << "this[01;31m-[00m>_Anchor(UNDEFINED) ";
extractScaffold.cc:87:        ss << this[01;31m-[00m>_Anchor[01;31m-[00m>description() << " ";
extractScaffold.cc:89:    for ( List<O_ExtractFrameFinisher>::const_iterator oi=this[01;31m-[00m>_ExtractFrameFinishers.const_begin();
extractScaffold.cc:90:    		oi!=this[01;31m-[00m>_ExtractFrameFinishers.const_end(); oi++ )
extractScaffold.cc:92:	ss << (*oi)[01;31m-[00m>description() << " ";
extractScaffold.cc:94:    for ( List<O_ExtractCompleteFrame>::const_iterator ci=this[01;31m-[00m>_ExtractCompleteFrames.const_begin();
extractScaffold.cc:95:    		ci!=this[01;31m-[00m>_ExtractCompleteFrames.const_end(); ci++ )
extractScaffold.cc:97:	ss << (*ci)[01;31m-[00m>description() << " ";
extractScaffold.cc:99:    for ( List<O_ExtractIncompleteFrame>::const_iterator ii=this[01;31m-[00m>_ExtractIncompleteFrames.const_begin();
extractScaffold.cc:100:    		ii!=this[01;31m-[00m>_ExtractIncompleteFrames.const_end(); ii++ )
extractScaffold.cc:102:	ss << (*ii)[01;31m-[00m>description() << " ";
extractScaffold.cc:110:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:111:    node[01;31m-[00m>archiveObject("anchor",this[01;31m-[00m>_Anchor);
extractScaffold.cc:112:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_ExtractFrameFinishers);
extractScaffold.cc:113:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_ExtractCompleteFrames);
extractScaffold.cc:114:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_ExtractIncompleteFrames);
extractScaffold.cc:118:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:121:    for ( eifi=this[01;31m-[00m>begin_ExtractCompleteFrames();
extractScaffold.cc:122:    		eifi!=this[01;31m-[00m>end_ExtractCompleteFrames(); eifi++ )
extractScaffold.cc:124:	LOG(BF("Looking at(%s)") % (*eifi)[01;31m-[00m>getFrame()[01;31m-[00m>getName().c_str()  ); // vp0(( "Looking at(%s)", (*eifi)[01;31m-[00m>getFrame()[01;31m-[00m>getName().c_str() ));
extractScaffold.cc:125:        if ((*eifi)[01;31m-[00m>getFrame()[01;31m-[00m>getName() == name ) 
extractScaffold.cc:127:	    LOG(BF("Matched desired frame [01;31m-[00m returning") ); // vp0(("Matched desired frame [01;31m-[00m returning"));
extractScaffold.cc:137:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:140:    for ( eifi=this[01;31m-[00m>begin_ExtractIncompleteFrames();
extractScaffold.cc:141:    		eifi!=this[01;31m-[00m>end_ExtractIncompleteFrames(); eifi++ )
extractScaffold.cc:143:	LOG(BF("Looking at(%s)") % (*eifi)[01;31m-[00m>getFrame()[01;31m-[00m>getName().c_str()  ); // vp0(( "Looking at(%s)", (*eifi)[01;31m-[00m>getFrame()[01;31m-[00m>getName().c_str() ));
extractScaffold.cc:144:        if ((*eifi)[01;31m-[00m>getAlias() == alias ) 
extractScaffold.cc:146:	    LOG(BF("Matched desired frame [01;31m-[00m returning") ); // vp0(("Matched desired frame [01;31m-[00m returning"));
extractScaffold.cc:156:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:158:    for ( eifi=this[01;31m-[00m>begin_ExtractIncompleteFrames();
extractScaffold.cc:159:    		eifi!=this[01;31m-[00m>end_ExtractIncompleteFrames(); eifi++ )
extractScaffold.cc:161:        if ((*eifi)[01;31m-[00m>getAlias() == alias ) return *eifi;
extractScaffold.cc:163:    return O_ExtractIncompleteFrame::nil(this[01;31m-[00m>lisp());
extractScaffold.cc:168:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:170:    for ( eifi=this[01;31m-[00m>begin_ExtractIncompleteFrames();
extractScaffold.cc:171:    		eifi!=this[01;31m-[00m>end_ExtractIncompleteFrames(); eifi++ )
extractScaffold.cc:173:        if ((*eifi)[01;31m-[00m>getFrame()[01;31m-[00m>getName() == name ) return *eifi;
extractScaffold.cc:175:    return O_ExtractIncompleteFrame::nil(this[01;31m-[00m>lisp());
extractScaffold.cc:181:{_F(this[01;31m-[00m>lisp());
extractScaffold.cc:184:    for ( ffi=this[01;31m-[00m>begin_ExtractFrameFinishers();
extractScaffold.cc:185:    		ffi!=this[01;31m-[00m>end_ExtractFrameFinishers(); ffi++ )
extractScaffold.cc:187:        boundFrame = (*ffi)[01;31m-[00m>getBoundFrame(focusMonomer);
extractScaffold.cc:188:	if ( !boundFrame[01;31m-[00m>allAtomsInFocusMonomerAreInAtomSet(focusMonomer,
extractScaffold.cc:196:    for ( cfi=this[01;31m-[00m>begin_ExtractCompleteFrames();
extractScaffold.cc:197:    		cfi!=this[01;31m-[00m>end_ExtractCompleteFrames(); cfi++ )
extractScaffold.cc:199:        boundFrame = (*cfi)[01;31m-[00m>getBoundFrame(focusMonomer);
extractScaffold.cc:200:	if ( !boundFrame[01;31m-[00m>allAtomsInFocusMonomerAreInAtomSet(focusMonomer,
extractScaffold.cc:208:    for ( ifi=this[01;31m-[00m>begin_ExtractIncompleteFrames();
extractScaffold.cc:209:    		ifi!=this[01;31m-[00m>end_ExtractIncompleteFrames(); ifi++ )
extractScaffold.cc:211:        boundFrame = (*ifi)[01;31m-[00m>getBoundFrame(focusMonomer);
extractScaffold.cc:212:	if ( !boundFrame[01;31m-[00m>allAtomsInFocusMonomerAreInAtomSet(focusMonomer,
extractScaffold.cc:230:    class_<O_ExtractScaffold>(this[01;31m-[00m>lisp())
ffAngleDb.cc:35:    node[01;31m-[00m>attribute("type1",this[01;31m-[00m>_Type1);
ffAngleDb.cc:36:    node[01;31m-[00m>attribute("type2",this[01;31m-[00m>_Type2);
ffAngleDb.cc:37:    node[01;31m-[00m>attribute("type3",this[01;31m-[00m>_Type3);
ffAngleDb.cc:38:    node[01;31m-[00m>attribute("angRad", this[01;31m-[00m>_AngRad);
ffAngleDb.cc:39:    node[01;31m-[00m>attribute("k2",this[01;31m-[00m>_K2);
ffAngleDb.cc:45:    this[01;31m-[00m>O_FFBaseDb::archive(node);
ffAngleDb.cc:46:    node[01;31m-[00m>attribute("angleFunction",this[01;31m-[00m>_AngleFunction);
ffAngleDb.cc:47:    node[01;31m-[00m>archiveObjectVector("angles","Angles",this[01;31m-[00m>_Terms );
ffAngleDb.cc:48:    node[01;31m-[00m>archiveMap<O_FFAngle>("map",this[01;31m-[00m>_Lookup );
ffAngleDb.cc:49:    node[01;31m-[00m>archiveMap("zConstants",this[01;31m-[00m>_ZConstants);
ffAngleDb.cc:50:    node[01;31m-[00m>archiveMap("cConstants",this[01;31m-[00m>_CConstants);
ffAngleDb.cc:58:    node = O_QDomNode::create(this[01;31m-[00m>lisp(),XmlTag_FFAngle());
ffAngleDb.cc:59:    node[01;31m-[00m>addAttributeString("Type1",this[01;31m-[00m>_Type1 );
ffAngleDb.cc:60:    node[01;31m-[00m>addAttributeString("Type2",this[01;31m-[00m>_Type2 );
ffAngleDb.cc:61:    node[01;31m-[00m>addAttributeString("Type3",this[01;31m-[00m>_Type3 );
ffAngleDb.cc:62:    node[01;31m-[00m>addAttributeDoubleScientific("AngRad",this[01;31m-[00m>_AngRad);
ffAngleDb.cc:63:    node[01;31m-[00m>addAttributeDoubleScientific("K2",this[01;31m-[00m>_K2);
ffAngleDb.cc:69:    this[01;31m-[00m>_Type1 = node[01;31m-[00m>getAttributeString("Type1");
ffAngleDb.cc:70:    this[01;31m-[00m>_Type2 = node[01;31m-[00m>getAttributeString("Type2");
ffAngleDb.cc:71:    this[01;31m-[00m>_Type3 = node[01;31m-[00m>getAttributeString("Type3");
ffAngleDb.cc:72:    this[01;31m-[00m>_AngRad = node[01;31m-[00m>getAttributeDouble("AngRad");
ffAngleDb.cc:73:    this[01;31m-[00m>_K2 = node[01;31m-[00m>getAttributeDouble("K2");
ffAngleDb.cc:82:    this[01;31m-[00m>Base::initialize();
ffAngleDb.cc:83:    this[01;31m-[00m>_Terms.clear();
ffAngleDb.cc:84:    this[01;31m-[00m>_Lookup.clear();
ffAngleDb.cc:85:    this[01;31m-[00m>_ZConstants.clear();
ffAngleDb.cc:86:    this[01;31m-[00m>_CConstants.clear();
ffAngleDb.cc:97:#define angleKey(t1,t2,t3) t1+"[01;31m-[00m"+t2+"[01;31m-[00m"+t3
ffAngleDb.cc:102:    this[01;31m-[00m>_Terms.push_back(ang);
ffAngleDb.cc:103:    key = angleKey(ang[01;31m-[00m>_Type1,ang[01;31m-[00m>_Type2,ang[01;31m-[00m>_Type3);
ffAngleDb.cc:104:    this[01;31m-[00m>_Lookup.set(key,ang);
ffAngleDb.cc:105:    key = angleKey(ang[01;31m-[00m>_Type3,ang[01;31m-[00m>_Type2,ang[01;31m-[00m>_Type1);
ffAngleDb.cc:106:    this[01;31m-[00m>_Lookup.set(key,ang);
ffAngleDb.cc:111:{ _F(this[01;31m-[00m>lisp());
ffAngleDb.cc:115:    t1 = a1[01;31m-[00m>getTypeString();
ffAngleDb.cc:116:    t2 = a2[01;31m-[00m>getTypeString();
ffAngleDb.cc:117:    t3 = a3[01;31m-[00m>getTypeString();
ffAngleDb.cc:119:    if ( this[01;31m-[00m>_Lookup.count(key) != 0 ) {
ffAngleDb.cc:120:        return this[01;31m-[00m>_Lookup.get(key);
ffAngleDb.cc:123:    if ( this[01;31m-[00m>_Lookup.count(key) != 0 ) {
ffAngleDb.cc:124:        return this[01;31m-[00m>_Lookup.get(key);
ffAngleDb.cc:131:    match = this[01;31m-[00m>estimateTerm(a1,a2,a3);
ffAngleDb.cc:142:    if ( this[01;31m-[00m>_Lookup.count(key) != 0 ) {
ffAngleDb.cc:146:    if ( this[01;31m-[00m>_Lookup.count(key) != 0 ) {
ffAngleDb.cc:156:    ss << "PARAMETER_PROBLEM Can't find angle term for ("<<t1<<")[01;31m-[00m("<<t2<<")[01;31m-[00m("<<t3<<")";
ffAngleDb.cc:157:    ss << " atoms("<<a1[01;31m-[00m>description()<<") [01;31m-[00m (" << a2[01;31m-[00m>description()<<")";
ffAngleDb.cc:159:    //TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
ffAngleDb.cc:167:    this[01;31m-[00m>Base::initialize();
ffAngleDb.cc:168:    this[01;31m-[00m>_Type1 = "";
ffAngleDb.cc:169:    this[01;31m-[00m>_Type2 = "";
ffAngleDb.cc:170:    this[01;31m-[00m>_Type3 = "";
ffAngleDb.cc:171:    this[01;31m-[00m>_AngRad = 0.0;
ffAngleDb.cc:172:    this[01;31m-[00m>_K2 = 0.0;
ffAngleDb.cc:173://    this[01;31m-[00m>_K3 = 0.0;
ffAngleDb.cc:174://    this[01;31m-[00m>_K4 = 0.0;
ffAngleDb.cc:175://    this[01;31m-[00m>_Ub_k = 0.0;
ffAngleDb.cc:176://    this[01;31m-[00m>_Ub_len = 0.0;
ffAngleDb.cc:181:/*! Estimate the angle term according to Wang et al. J. Comput. Chem 25, 1157[01;31m-[00m1174 (2004) */
ffAngleDb.cc:183:{_F(this[01;31m-[00m>lisp());
ffAngleDb.cc:192:    ASSERT_NOT_NULL(this[01;31m-[00m>_ForceField);
ffAngleDb.cc:193:    ff = this[01;31m-[00m>_ForceField.lock();
ffAngleDb.cc:195:    t1 = a1[01;31m-[00m>getTypeString();
ffAngleDb.cc:196:    t2 = a2[01;31m-[00m>getTypeString();
ffAngleDb.cc:197:    t3 = a3[01;31m-[00m>getTypeString();
ffAngleDb.cc:202:    angle = O_FFAngle::nil(this[01;31m-[00m>lisp());
ffAngleDb.cc:204:    ff_121 = ff[01;31m-[00m>_Angles[01;31m-[00m>findTerm(a1,a2,a1);
ffAngleDb.cc:205:    ff_323 = ff[01;31m-[00m>_Angles[01;31m-[00m>findTerm(a3,a2,a3);
ffAngleDb.cc:207:    if ( ff_121[01;31m-[00m>isNil() ) goto GUESS;
ffAngleDb.cc:209:    if ( ff_323[01;31m-[00m>isNil() ) goto GUESS;
ffAngleDb.cc:211:    angRad = (ff_121[01;31m-[00m>_AngRad + ff_323[01;31m-[00m>_AngRad)/2.0;
ffAngleDb.cc:212:    element1 = a1[01;31m-[00m>getElement();
ffAngleDb.cc:213:    element2 = a2[01;31m-[00m>getElement();
ffAngleDb.cc:214:    element3 = a3[01;31m-[00m>getElement();
ffAngleDb.cc:216:    if ( ff[01;31m-[00m>_Angles[01;31m-[00m>_ZConstants.count(element1) == 0 ) goto GUESS;
ffAngleDb.cc:218:    if ( ff[01;31m-[00m>_Angles[01;31m-[00m>_CConstants.count(element2) == 0 ) goto GUESS;
ffAngleDb.cc:220:    if ( ff[01;31m-[00m>_Angles[01;31m-[00m>_ZConstants.count(element3) == 0 ) goto GUESS;
ffAngleDb.cc:222:    z1 = ff[01;31m-[00m>_Angles[01;31m-[00m>_ZConstants.get(element1)[01;31m-[00m>get();
ffAngleDb.cc:223:    c2 = ff[01;31m-[00m>_Angles[01;31m-[00m>_CConstants.get(element2)[01;31m-[00m>get();
ffAngleDb.cc:224:    z3 = ff[01;31m-[00m>_Angles[01;31m-[00m>_ZConstants.get(element3)[01;31m-[00m>get();
ffAngleDb.cc:225:    r12 = ff[01;31m-[00m>_Stretches[01;31m-[00m>findTerm(a1,a2);
ffAngleDb.cc:226:    r32 = ff[01;31m-[00m>_Stretches[01;31m-[00m>findTerm(a3,a2);
ffAngleDb.cc:228:    if ( r12[01;31m-[00m>isNil() ) goto GUESS;
ffAngleDb.cc:230:    if ( r32[01;31m-[00m>isNil() ) goto GUESS;
ffAngleDb.cc:232:    d = (r12[01;31m-[00m>_r0[01;31m-[00mr32[01;31m-[00m>_r0)/(r12[01;31m-[00m>_r0+r32[01;31m-[00m>_r0);
ffAngleDb.cc:234:    k = 143.9*z1*c2*z3*(1.0/((r12[01;31m-[00m>_r0+r32[01;31m-[00m>_r0)*(angRad*angRad)))*exp([01;31m-[00m2.0*d);
ffAngleDb.cc:235:    angle = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_FFAngle>();
ffAngleDb.cc:236:    angle[01;31m-[00m>_Level = estimated;
ffAngleDb.cc:237:    angle[01;31m-[00m>_Type1 = t1;
ffAngleDb.cc:238:    angle[01;31m-[00m>_Type2 = t2;
ffAngleDb.cc:239:    angle[01;31m-[00m>_Type3 = t3;
ffAngleDb.cc:240:    angle[01;31m-[00m>_AngRad = angRad;
ffAngleDb.cc:241:    angle[01;31m-[00m>_K2 = k;
ffAngleDb.cc:244:    angle = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_FFAngle>();
ffAngleDb.cc:245:    angle[01;31m-[00m>_Level = rough;
ffAngleDb.cc:246:    angle[01;31m-[00m>_Type1 = t1;
ffAngleDb.cc:247:    angle[01;31m-[00m>_Type2 = t2;
ffAngleDb.cc:248:    angle[01;31m-[00m>_Type3 = t3;
ffAngleDb.cc:249:    if ( a2[01;31m-[00m>getHybridization() == hybridization_sp3 ) {
ffAngleDb.cc:250:	angle[01;31m-[00m>_AngRad = 109.5*0.0174533;
ffAngleDb.cc:251:    } else if ( a2[01;31m-[00m>getHybridization() == hybridization_sp2 ) {
ffAngleDb.cc:252:	angle[01;31m-[00m>_AngRad = 120.0*0.0174533;
ffAngleDb.cc:253:    } else if ( a2[01;31m-[00m>getHybridization() == hybridization_sp ) {
ffAngleDb.cc:254:	angle[01;31m-[00m>_AngRad = 180.0*0.0174533;
ffAngleDb.cc:256:	LOG(BF("Unknown hybridization(%s) for: %s") % a2[01;31m-[00m>getHybridization().c_str() % a2[01;31m-[00m>description().c_str() ); // vp0(("Unknown hybridization(%s) for: %s",a2[01;31m-[00m>getHybridization().c_str(),a2[01;31m-[00m>description().c_str()));
ffAngleDb.cc:257:	angle[01;31m-[00m>_AngRad = 109.5*0.0174533;
ffAngleDb.cc:260:    if ( a1[01;31m-[00m>getElement() == element_H && a3[01;31m-[00m>getElement() == element_H ) {
ffAngleDb.cc:261:	angle[01;31m-[00m>_K2 = 32.5;
ffAngleDb.cc:262:    } else if ( a1[01;31m-[00m>getElement() == element_H || a3[01;31m-[00m>getElement() == element_H ) {
ffAngleDb.cc:263:	angle[01;31m-[00m>_K2 = 50.0;
ffAngleDb.cc:265:	angle[01;31m-[00m>_K2 = 70.0;
ffAngleDb.cc:274:    desc << this[01;31m-[00m>O_FFParameter::levelDescription();
ffAngleDb.cc:275:    desc << " angle between types "<<this[01;31m-[00m>_Type1<< " "
ffAngleDb.cc:276:		<< this[01;31m-[00m>_Type2 << " "
ffAngleDb.cc:277:		<< this[01;31m-[00m>_Type3;
ffBaseDb.cc:29:    switch ( this[01;31m-[00m>_Level ) {
ffBaseDb.cc:45:	{ "", [01;31m-[00m1 }
ffBaseDb.cc:50:    node[01;31m-[00m>attributeEnum( "level", this[01;31m-[00m>_Level, paramLevelEnum );
ffBaseDb.cc:56:    node[01;31m-[00m>archiveWeakPointer( "forceField", this[01;31m-[00m>_ForceField );
ffBaseDb.cc:61:    this[01;31m-[00m>archiveBase(node);
ffBaseDb.cc:65:{_F(this[01;31m-[00m>lisp());
ffBaseDb.cc:67:    this[01;31m-[00m>_ForceField = ff;
ffBaseDb.cc:75:    class_<O_FFParameter>(this[01;31m-[00m>lisp())
ffBaseDb.cc:95:    class_<O_FFBaseDb>(this[01;31m-[00m>lisp())
ffItorDb.cc:26:    this[01;31m-[00m>Base::initialize();
ffItorDb.cc:28:    this[01;31m-[00m>_T1 = "";
ffItorDb.cc:29:    this[01;31m-[00m>_T2 = "";
ffItorDb.cc:30:    this[01;31m-[00m>_T3 = "";
ffItorDb.cc:31:    this[01;31m-[00m>_T4 = "";
ffItorDb.cc:32:    for ( i=0; i<6; i++ ) this[01;31m-[00m>_Vs[i] = 0.0;
ffItorDb.cc:33:    for ( i=0; i<6; i++ ) this[01;31m-[00m>_PhaseRads[i] = 0.0;
ffItorDb.cc:38:    node[01;31m-[00m>attribute( "type1", this[01;31m-[00m>_T1 );
ffItorDb.cc:39:    node[01;31m-[00m>attribute( "type2", this[01;31m-[00m>_T2 );
ffItorDb.cc:40:    node[01;31m-[00m>attribute( "type3", this[01;31m-[00m>_T3 );
ffItorDb.cc:41:    node[01;31m-[00m>attribute( "type4", this[01;31m-[00m>_T4 );
ffItorDb.cc:42:    node[01;31m-[00m>attributeIfNotDefault ( "v1", this[01;31m-[00m>_Vs[0], 0.0 );
ffItorDb.cc:43:    node[01;31m-[00m>attributeIfNotDefault ( "v2", this[01;31m-[00m>_Vs[1], 0.0 );
ffItorDb.cc:44:    node[01;31m-[00m>attributeIfNotDefault ( "v3", this[01;31m-[00m>_Vs[2], 0.0 );
ffItorDb.cc:45:    node[01;31m-[00m>attributeIfNotDefault ( "v4", this[01;31m-[00m>_Vs[3], 0.0 );
ffItorDb.cc:46:    node[01;31m-[00m>attributeIfNotDefault ( "v5", this[01;31m-[00m>_Vs[4], 0.0 );
ffItorDb.cc:47:    node[01;31m-[00m>attributeIfNotDefault ( "v6", this[01;31m-[00m>_Vs[5], 0.0 );
ffItorDb.cc:48:    node[01;31m-[00m>attributeIfNotDefault ( "ph1", this[01;31m-[00m>_PhaseRads[0], 0.0 );
ffItorDb.cc:49:    node[01;31m-[00m>attributeIfNotDefault ( "ph2", this[01;31m-[00m>_PhaseRads[1], 0.0 );
ffItorDb.cc:50:    node[01;31m-[00m>attributeIfNotDefault ( "ph3", this[01;31m-[00m>_PhaseRads[2], 0.0 );
ffItorDb.cc:51:    node[01;31m-[00m>attributeIfNotDefault ( "ph4", this[01;31m-[00m>_PhaseRads[3], 0.0 );
ffItorDb.cc:52:    node[01;31m-[00m>attributeIfNotDefault ( "ph5", this[01;31m-[00m>_PhaseRads[4], 0.0 );
ffItorDb.cc:53:    node[01;31m-[00m>attributeIfNotDefault ( "ph6", this[01;31m-[00m>_PhaseRads[5], 0.0 );
ffItorDb.cc:58:    this[01;31m-[00m>O_FFBaseDb::archive(node);
ffItorDb.cc:59:    node[01;31m-[00m>archiveObjectVector<O_FFItor>("ptors","Itors",this[01;31m-[00m>_Terms );
ffItorDb.cc:60:    node[01;31m-[00m>archiveMap<O_FFItor>("map",this[01;31m-[00m>_Lookup );
ffItorDb.cc:67:    node = O_QDomNode::create(this[01;31m-[00m>lisp(),XmlTag_FFItor());
ffItorDb.cc:68:    node[01;31m-[00m>addAttributeString("Type1",this[01;31m-[00m>_T1);
ffItorDb.cc:69:    node[01;31m-[00m>addAttributeString("Type2",this[01;31m-[00m>_T2);
ffItorDb.cc:70:    node[01;31m-[00m>addAttributeString("Type3",this[01;31m-[00m>_T3);
ffItorDb.cc:71:    node[01;31m-[00m>addAttributeString("Type4",this[01;31m-[00m>_T4);
ffItorDb.cc:73:	if ( this[01;31m-[00m>_Vs[i]==0.0 ) continue;
ffItorDb.cc:74:	child = O_QDomNode::create(this[01;31m-[00m>lisp(),"VTerm");
ffItorDb.cc:75:	child[01;31m-[00m>addAttributeInt("Mult",i+1);
ffItorDb.cc:76:	child[01;31m-[00m>addAttributeDoubleScientific("V",this[01;31m-[00m>_Vs[i]);
ffItorDb.cc:77:	child[01;31m-[00m>addAttributeDoubleScientific("PhaseRad",this[01;31m-[00m>_PhaseRads[i]);
ffItorDb.cc:78:	node[01;31m-[00m>addChild(child);
ffItorDb.cc:87:    this[01;31m-[00m>_T1 = node[01;31m-[00m>getAttributeString("Type1");
ffItorDb.cc:88:    this[01;31m-[00m>_T2 = node[01;31m-[00m>getAttributeString("Type2");
ffItorDb.cc:89:    this[01;31m-[00m>_T3 = node[01;31m-[00m>getAttributeString("Type3");
ffItorDb.cc:90:    this[01;31m-[00m>_T4 = node[01;31m-[00m>getAttributeString("Type4");
ffItorDb.cc:92:	this[01;31m-[00m>_Vs[i] = 0.0;
ffItorDb.cc:93:	this[01;31m-[00m>_PhaseRads[i] = 0.0;
ffItorDb.cc:95:    for ( ci=node[01;31m-[00m>begin_Children(); ci!=node[01;31m-[00m>end_Children(); ci++ ) {
ffItorDb.cc:96:	if ( (*ci)[01;31m-[00m>isNamed("VTerm") ) {
ffItorDb.cc:97:	    int multIndex = (*ci)[01;31m-[00m>getAttributeInt("Mult")[01;31m-[00m1;
ffItorDb.cc:98:	    v = (*ci)[01;31m-[00m>getAttributeDouble("V");
ffItorDb.cc:99:	    phaseRad = (*ci)[01;31m-[00m>getAttributeDouble("PhaseRad");
ffItorDb.cc:101:	    this[01;31m-[00m>_Vs[multIndex] = v;
ffItorDb.cc:102:	    this[01;31m-[00m>_PhaseRads[multIndex] = phaseRad;
ffItorDb.cc:117:    LOG(BF("terms has space for %d terms") % (sizeof(this[01;31m-[00m>terms)/sizeof(this[01;31m-[00m>terms[0])) ); // vp0(( "terms has space for %d terms", sizeof(this[01;31m-[00m>terms)/sizeof(this[01;31m-[00m>terms[0])));
ffItorDb.cc:119:	LOG(BF("Setting termOrder[%d]@%d to %lf") % (i) % (db[01;31m-[00m>termOrder[i]) % (*it ) ); // vp0(( "Setting termOrder[%d]@%d to %lf", i, db[01;31m-[00m>termOrder[i], *it ));
ffItorDb.cc:120:	this[01;31m-[00m>terms[db[01;31m-[00m>termOrder[i]]=*it;
ffItorDb.cc:133:    this[01;31m-[00m>termOrder.clear();
ffItorDb.cc:148:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown itor term: ", *si ));
ffItorDb.cc:150:	LOG(BF("Setting termOrder element %d to %d") % (this[01;31m-[00m>termOrder.size()) % (idx ) ); // vp0(( "Setting termOrder element %d to %d", this[01;31m-[00m>termOrder.size(), idx ));
ffItorDb.cc:151: 	this[01;31m-[00m>termOrder.push_back(idx);
ffItorDb.cc:162:    this[01;31m-[00m>_T1 = t1;
ffItorDb.cc:163:    this[01;31m-[00m>_T2 = t2;
ffItorDb.cc:164:    this[01;31m-[00m>_T3 = t3;
ffItorDb.cc:165:    this[01;31m-[00m>_T4 = t4;
ffItorDb.cc:171:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal index for getV"));
ffItorDb.cc:173:    return this[01;31m-[00m>_Vs[idx[01;31m-[00m1];
ffItorDb.cc:179:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal index for setV"));
ffItorDb.cc:181:    this[01;31m-[00m>_Vs[idx[01;31m-[00m1] = val;
ffItorDb.cc:188:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal index for getPhaseRad"));
ffItorDb.cc:190:    return this[01;31m-[00m>_PhaseRads[idx[01;31m-[00m1];
ffItorDb.cc:196:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal index for setPhaseRad"));
ffItorDb.cc:198:    this[01;31m-[00m>_PhaseRads[idx[01;31m-[00m1] = val;
ffItorDb.cc:206:        if ( itor[01;31m-[00m>_Vs[i] != 0.0 ) {
ffItorDb.cc:207:            this[01;31m-[00m>_Vs[i] = itor[01;31m-[00m>_Vs[i];
ffItorDb.cc:208:            this[01;31m-[00m>_PhaseRads[i] = itor[01;31m-[00m>_PhaseRads[i];
ffItorDb.cc:213:#define keyString(t1,t2,t3,t4) (t1+"[01;31m-[00m"+t2+"[01;31m-[00m"+t3+"[01;31m-[00m"+t4)
ffItorDb.cc:227:    if (this[01;31m-[00m>hasExactTerm(itor[01;31m-[00m>_T1,itor[01;31m-[00m>_T2,itor[01;31m-[00m>_T3,itor[01;31m-[00m>_T4) ){
ffItorDb.cc:228:        itorOld = this[01;31m-[00m>findExactTerm(itor[01;31m-[00m>_T1,itor[01;31m-[00m>_T2,itor[01;31m-[00m>_T3,itor[01;31m-[00m>_T4);
ffItorDb.cc:229:        itorOld[01;31m-[00m>mergeWith(itor);
ffItorDb.cc:231:        this[01;31m-[00m>_Terms.push_back(itor);
ffItorDb.cc:232:        key = keyString(itor[01;31m-[00m>_T1,itor[01;31m-[00m>_T2,itor[01;31m-[00m>_T3,itor[01;31m-[00m>_T4);
ffItorDb.cc:234:	if ( itor[01;31m-[00m>_T3=="c" && itor[01;31m-[00m>_T4=="o" ) {
ffItorDb.cc:238:        this[01;31m-[00m>_Lookup.set(key,itor);
ffItorDb.cc:247:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) return true;
ffItorDb.cc:256:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) {
ffItorDb.cc:257:        return this[01;31m-[00m>_Lookup.get(key);
ffItorDb.cc:259:    itor = O_FFItor::nil(this[01;31m-[00m>lisp());
ffItorDb.cc:264:{_F(this[01;31m-[00m>lisp());
ffItorDb.cc:268:    if ( this[01;31m-[00m>_Lookup.count(key4)!=0 ) {
ffItorDb.cc:269:        itor = this[01;31m-[00m>_Lookup.get(key4);
ffItorDb.cc:275:    if ( this[01;31m-[00m>_Lookup.count(key3)!=0 ) {
ffItorDb.cc:276:        itor = this[01;31m-[00m>_Lookup.get(key3);
ffItorDb.cc:281:    if ( this[01;31m-[00m>_Lookup.count(key2)!=0 ) {
ffItorDb.cc:282:        itor = this[01;31m-[00m>_Lookup.get(key2);
ffItorDb.cc:287:    if ( this[01;31m-[00m>_Lookup.count(key1)!=0 ) {
ffItorDb.cc:288:        itor = this[01;31m-[00m>_Lookup.get(key1);
ffItorDb.cc:292:    itor = O_FFItor::nil(this[01;31m-[00m>lisp());
ffItorDb.cc:296:	LOG(BF("FFITorDb::findBestTerm for types %s[01;31m-[00m%s[01;31m-[00m%s[01;31m-[00m%s") % t1.c_str() % t2.c_str() % t3.c_str() % t4.c_str()  ); // vp0(( "FFITorDb::findBestTerm for types %s[01;31m-[00m%s[01;31m-[00m%s[01;31m-[00m%s", t1.c_str(), t2.c_str(), t3.c_str(), t4.c_str() ));
ffItorDb.cc:297:	if ( itor[01;31m-[00m>notNil() )
ffItorDb.cc:306:	        for ( map<string,RPFFItor>::iterator ii=this[01;31m-[00m>_Lookup.begin();
ffItorDb.cc:307:				ii!=this[01;31m-[00m>_Lookup.end();ii++ ) {
ffItorDb.cc:308:		    LOG(BF("Entry key=%s") % ii[01;31m-[00m>first.c_str()  ); // vp0(( "Entry key=%s", ii[01;31m-[00m>first.c_str() ));
ffItorDb.cc:322:    itor = this[01;31m-[00m>findBestTerm(t1,t2,t3,t4);
ffItorDb.cc:323:    return itor[01;31m-[00m>notNil();
ffItorDb.cc:330:    ss << "Can't find itor term for ("<<t1<<")[01;31m-[00m("<<t2<<")[01;31m-[00m("<<t3<<")[01;31m-[00m("<<t4<<")";
ffItorDb.cc:331:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
ffItorDb.cc:339:    desc << this[01;31m-[00m>O_FFParameter::levelDescription();
ffItorDb.cc:340:    desc << " itor between types "<<this[01;31m-[00m>_T1<< " "
ffItorDb.cc:341:		<< this[01;31m-[00m>_T2 << " "
ffItorDb.cc:342:		<< this[01;31m-[00m>_T3 << " "
ffItorDb.cc:343:		<< this[01;31m-[00m>_T4;
ffNonbondDb.cc:31:    class_<O_FFNonbondCrossTermTable>(e[01;31m-[00m>lisp())
ffNonbondDb.cc:41:{_F(this[01;31m-[00m>lisp());
ffNonbondDb.cc:42:    uint numberOfTypes = db[01;31m-[00m>numberOfTypes();
ffNonbondDb.cc:43:    this[01;31m-[00m>_NumberOfTypes = numberOfTypes;
ffNonbondDb.cc:51:	    RPFFNonbond ffNonbond1 = db[01;31m-[00m>getFFNonbondUsingTypeIndex(it1);
ffNonbondDb.cc:52:	    RPFFNonbond ffNonbond2 = db[01;31m-[00m>getFFNonbondUsingTypeIndex(it2);
ffNonbondDb.cc:53:	    term._RStar = ffNonbond1[01;31m-[00m>_Radius + ffNonbond2[01;31m-[00m>_Radius;
ffNonbondDb.cc:54:	    double epsilonij = sqrt(ffNonbond1[01;31m-[00m>_Well*ffNonbond2[01;31m-[00m>_Well);
ffNonbondDb.cc:57:	    this[01;31m-[00m>_CrossTerms.push_back(term);
ffNonbondDb.cc:63:{_F(this[01;31m-[00m>lisp());
ffNonbondDb.cc:64:    ASSERT_lt(typeIndex,this[01;31m-[00m>_NumberOfTypes);
ffNonbondDb.cc:65:    return typeIndex*this[01;31m-[00m>_NumberOfTypes;
ffNonbondDb.cc:69:{_F(this[01;31m-[00m>lisp());
ffNonbondDb.cc:70:    ASSERT_lt(type1,this[01;31m-[00m>_NumberOfTypes);
ffNonbondDb.cc:71:    ASSERT_lt(type2,this[01;31m-[00m>_NumberOfTypes);
ffNonbondDb.cc:72:    uint idx = type1*this[01;31m-[00m>_NumberOfTypes + type2;
ffNonbondDb.cc:73:    ASSERT_lt(idx,this[01;31m-[00m>_CrossTerms.size());
ffNonbondDb.cc:74:    return this[01;31m-[00m>_CrossTerms[idx];
ffNonbondDb.cc:79:    ASSERT_lt(idx,this[01;31m-[00m>_CrossTerms.size());
ffNonbondDb.cc:80:    return this[01;31m-[00m>_CrossTerms[idx];
ffNonbondDb.cc:85:    ASSERT_lt(type1,this[01;31m-[00m>_NumberOfTypes);
ffNonbondDb.cc:86:    ASSERT_lt(type2,this[01;31m-[00m>_NumberOfTypes);
ffNonbondDb.cc:87:    uint idx = type1*this[01;31m-[00m>_NumberOfTypes + type2;
ffNonbondDb.cc:99:    class_<O_FFNonbond>(e[01;31m-[00m>lisp())
ffNonbondDb.cc:111:    class_<O_FFNonbondDb>(e[01;31m-[00m>lisp())
ffNonbondDb.cc:128:    this[01;31m-[00m>Base::initialize();
ffNonbondDb.cc:129:    this[01;31m-[00m>_Terms.clear();
ffNonbondDb.cc:130:    this[01;31m-[00m>_Lookup.clear();
ffNonbondDb.cc:131:    this[01;31m-[00m>_EleDielectricValue = 0.0;
ffNonbondDb.cc:132:    this[01;31m-[00m>_EleBuffer = 0.0;
ffNonbondDb.cc:133:    this[01;31m-[00m>_EleScale14 = 0.0;
ffNonbondDb.cc:134:    this[01;31m-[00m>_EleChargeFcn = "";
ffNonbondDb.cc:135:    this[01;31m-[00m>_VdwScale14 = 0.0;
ffNonbondDb.cc:136:    this[01;31m-[00m>_VdwScaleBufferA = 0.0;
ffNonbondDb.cc:137:    this[01;31m-[00m>_VdwScaleBufferB = 0.0;
ffNonbondDb.cc:138:    this[01;31m-[00m>_EleDielectricCode = edConstant;
ffNonbondDb.cc:139:    this[01;31m-[00m>_VdwMixRadius = vmrAverage;
ffNonbondDb.cc:140:    this[01;31m-[00m>_VdwMixWell = vmwAverage;
ffNonbondDb.cc:147:	{ "", [01;31m-[00m1 }
ffNonbondDb.cc:151:{_F(this[01;31m-[00m>lisp());
ffNonbondDb.cc:152:    node[01;31m-[00m>attribute("type",this[01;31m-[00m>_Type );
ffNonbondDb.cc:153:    node[01;31m-[00m>attribute("radius",this[01;31m-[00m>_Radius);
ffNonbondDb.cc:154:    node[01;31m-[00m>attribute("well",this[01;31m-[00m>_Well);
ffNonbondDb.cc:155:    node[01;31m-[00m>attributeIfNotDefault("apol",this[01;31m-[00m>_Apol,0.0);
ffNonbondDb.cc:156:    node[01;31m-[00m>attributeIfNotDefault("neff",this[01;31m-[00m>_Neff,0.0);
ffNonbondDb.cc:157:    node[01;31m-[00m>attribute("mass",this[01;31m-[00m>_Mass);
ffNonbondDb.cc:158:    node[01;31m-[00m>attributeIfNotDefault("pol",this[01;31m-[00m>_Polarizability,0.0);
ffNonbondDb.cc:159:    node[01;31m-[00m>attributeIfNotDefault("initCharge",this[01;31m-[00m>_InitialCharge,0.0);
ffNonbondDb.cc:160:    node[01;31m-[00m>attributeIfNotDefault("fcadj",this[01;31m-[00m>_Fcadj,0.0);
ffNonbondDb.cc:161:    node[01;31m-[00m>attributeIfNotDefault("pbci",this[01;31m-[00m>_Pbci,0.0);
ffNonbondDb.cc:162:    node[01;31m-[00m>attributeEnum("da",this[01;31m-[00m>_DonorAcceptor,daEnum );
ffNonbondDb.cc:168: { "", [01;31m-[00m1 }
ffNonbondDb.cc:175: { "", [01;31m-[00m1 }
ffNonbondDb.cc:181: { "", [01;31m-[00m1 }
ffNonbondDb.cc:185:{_F(this[01;31m-[00m>lisp());
ffNonbondDb.cc:186:    this[01;31m-[00m>O_FFBaseDb::archive(node);
ffNonbondDb.cc:187:    node[01;31m-[00m>attributeIfNotDefault("eleDielectricValue", this[01;31m-[00m>_EleDielectricValue, 0.0);
ffNonbondDb.cc:188:    node[01;31m-[00m>attributeIfNotDefault("eleBuffer", this[01;31m-[00m>_EleBuffer, 0.0);
ffNonbondDb.cc:189:    node[01;31m-[00m>attributeIfNotDefault("eleScale14", this[01;31m-[00m>_EleScale14, 0.0);
ffNonbondDb.cc:190:    node[01;31m-[00m>attributeIfNotDefault<string>("eleChargeFcn", this[01;31m-[00m>_EleChargeFcn, "");
ffNonbondDb.cc:191:    node[01;31m-[00m>attributeIfNotDefault("vdwScale14", this[01;31m-[00m>_VdwScale14, 0.0);
ffNonbondDb.cc:192:    node[01;31m-[00m>attributeIfNotDefault("vdwScaleBufferA", this[01;31m-[00m>_VdwScaleBufferA, 0.0);
ffNonbondDb.cc:193:    node[01;31m-[00m>attributeIfNotDefault("vdwScaleBufferB", this[01;31m-[00m>_VdwScaleBufferB, 0.0);
ffNonbondDb.cc:194:    node[01;31m-[00m>archiveObjectVector("nonbonds","Nonbonds",this[01;31m-[00m>_Terms );
ffNonbondDb.cc:195:    node[01;31m-[00m>archiveMapKeyStringValuePOD("map",this[01;31m-[00m>_Lookup );
ffNonbondDb.cc:196:    node[01;31m-[00m>attributeEnum( "eleDielectricCode", this[01;31m-[00m>_EleDielectricCode, dielectricEnum );
ffNonbondDb.cc:197:    node[01;31m-[00m>attributeEnum( "vdwMixRadius", this[01;31m-[00m>_VdwMixRadius, vmrEnum );
ffNonbondDb.cc:198:    node[01;31m-[00m>attributeEnum( "vdwMixWell", this[01;31m-[00m>_VdwMixWell, vmwEnum );
ffNonbondDb.cc:205:    if ( this[01;31m-[00m>_Lookup.count(nb[01;31m-[00m>_Type)!= 0 ) {
ffNonbondDb.cc:206:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Adding nonbonded( %s ) to database but it's already there") % nb[01;31m-[00m>_Type ));
ffNonbondDb.cc:208:    uint index = this[01;31m-[00m>_Terms.size();
ffNonbondDb.cc:209:    this[01;31m-[00m>_Terms.push_back(nb);
ffNonbondDb.cc:210:    this[01;31m-[00m>_Lookup[nb[01;31m-[00m>_Type] = index;
ffNonbondDb.cc:215:    if ( this[01;31m-[00m>_Lookup.count(type) != 0 ) return true;
ffNonbondDb.cc:221:    if ( this[01;31m-[00m>_Lookup.count(type) != 0 ) 
ffNonbondDb.cc:223:	uint index = this[01;31m-[00m>_Lookup[type];
ffNonbondDb.cc:224:        return this[01;31m-[00m>_Terms[index];
ffNonbondDb.cc:226:    return O_FFNonbond::nil(this[01;31m-[00m>lisp());
ffNonbondDb.cc:231:    if ( this[01;31m-[00m>_Lookup.count(type) != 0 ) 
ffNonbondDb.cc:233:	uint index = this[01;31m-[00m>_Lookup[type];
ffNonbondDb.cc:241:    uint ti = this[01;31m-[00m>findTypeIndex(type);
ffNonbondDb.cc:244:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown type("+type+")"));
ffNonbondDb.cc:250:    if ( this[01;31m-[00m>_Lookup.count(type) != 0 ) 
ffNonbondDb.cc:252:	uint index = this[01;31m-[00m>_Lookup[type]*this[01;31m-[00m>_Terms.size();
ffNonbondDb.cc:260:    ASSERT_lt(typeIdx,this[01;31m-[00m>_Terms.size());
ffNonbondDb.cc:261:    return this[01;31m-[00m>_Terms[typeIdx];
ffNonbondDb.cc:267:{_F(this[01;31m-[00m>lisp());
ffNonbondDb.cc:268:    return this[01;31m-[00m>_Terms.size();
ffNonbondDb.cc:276:    this[01;31m-[00m>Base::initialize();
ffNonbondDb.cc:277:    this[01;31m-[00m>_Type = "";
ffNonbondDb.cc:278:    this[01;31m-[00m>_Radius = 0.0;
ffNonbondDb.cc:279:    this[01;31m-[00m>_Well = 0.0;
ffNonbondDb.cc:280:    this[01;31m-[00m>_Apol = 0.0;
ffNonbondDb.cc:281:    this[01;31m-[00m>_Neff = 0.0;
ffNonbondDb.cc:282:    this[01;31m-[00m>_Mass = 0.0;
ffNonbondDb.cc:283:    this[01;31m-[00m>_Polarizability = 0.0;
ffNonbondDb.cc:284:    this[01;31m-[00m>_DonorAcceptor = daNeither;
ffNonbondDb.cc:285:    this[01;31m-[00m>_InitialCharge = 0.0;
ffNonbondDb.cc:286:    this[01;31m-[00m>_Fcadj = 0.0;
ffNonbondDb.cc:287:    this[01;31m-[00m>_Pbci = 0.0;
ffNonbondDb.cc:296:    node[01;31m-[00m>addAttributeString("type",this[01;31m-[00m>_Type);
ffNonbondDb.cc:297:    node[01;31m-[00m>addAttributeDoubleScientific("Radius",this[01;31m-[00m>_Radius);
ffNonbondDb.cc:298:    node[01;31m-[00m>addAttributeDoubleScientific("Well",this[01;31m-[00m>_Well);
ffNonbondDb.cc:304:    this[01;31m-[00m>_Type = node[01;31m-[00m>getAttributeString("type");
ffNonbondDb.cc:305:    this[01;31m-[00m>_Radius = node[01;31m-[00m>getAttributeDouble("Radius");
ffNonbondDb.cc:306:    this[01;31m-[00m>_Well = node[01;31m-[00m>getAttributeDouble("Well");
ffNonbondDb.cc:314:    desc << this[01;31m-[00m>O_FFParameter::levelDescription();
ffNonbondDb.cc:315:    desc << " nonbond type "<<this[01;31m-[00m>_Type;
ffPtorDb.cc:28:    node[01;31m-[00m>attribute( "type1", this[01;31m-[00m>_T1 );
ffPtorDb.cc:29:    node[01;31m-[00m>attribute( "type2", this[01;31m-[00m>_T2 );
ffPtorDb.cc:30:    node[01;31m-[00m>attribute( "type3", this[01;31m-[00m>_T3 );
ffPtorDb.cc:31:    node[01;31m-[00m>attribute( "type4", this[01;31m-[00m>_T4 );
ffPtorDb.cc:32:    node[01;31m-[00m>attributeIfDefined ( "v1", this[01;31m-[00m>_Vs[0], this[01;31m-[00m>_HasTerm[0] );
ffPtorDb.cc:33:    node[01;31m-[00m>attributeIfDefined ( "v2", this[01;31m-[00m>_Vs[1], this[01;31m-[00m>_HasTerm[1] );
ffPtorDb.cc:34:    node[01;31m-[00m>attributeIfDefined ( "v3", this[01;31m-[00m>_Vs[2], this[01;31m-[00m>_HasTerm[2] );
ffPtorDb.cc:35:    node[01;31m-[00m>attributeIfDefined ( "v4", this[01;31m-[00m>_Vs[3], this[01;31m-[00m>_HasTerm[3] );
ffPtorDb.cc:36:    node[01;31m-[00m>attributeIfDefined ( "v5", this[01;31m-[00m>_Vs[4], this[01;31m-[00m>_HasTerm[4] );
ffPtorDb.cc:37:    node[01;31m-[00m>attributeIfDefined ( "v6", this[01;31m-[00m>_Vs[5], this[01;31m-[00m>_HasTerm[5] );
ffPtorDb.cc:38:    node[01;31m-[00m>attributeIfDefined ( "ph1", this[01;31m-[00m>_PhaseRads[0], this[01;31m-[00m>_HasTerm[0] );
ffPtorDb.cc:39:    node[01;31m-[00m>attributeIfDefined ( "ph2", this[01;31m-[00m>_PhaseRads[1], this[01;31m-[00m>_HasTerm[1] );
ffPtorDb.cc:40:    node[01;31m-[00m>attributeIfDefined ( "ph3", this[01;31m-[00m>_PhaseRads[2], this[01;31m-[00m>_HasTerm[2] );
ffPtorDb.cc:41:    node[01;31m-[00m>attributeIfDefined ( "ph4", this[01;31m-[00m>_PhaseRads[3], this[01;31m-[00m>_HasTerm[3] );
ffPtorDb.cc:42:    node[01;31m-[00m>attributeIfDefined ( "ph5", this[01;31m-[00m>_PhaseRads[4], this[01;31m-[00m>_HasTerm[4] );
ffPtorDb.cc:43:    node[01;31m-[00m>attributeIfDefined ( "ph6", this[01;31m-[00m>_PhaseRads[5], this[01;31m-[00m>_HasTerm[5] );
ffPtorDb.cc:49:    this[01;31m-[00m>O_FFBaseDb::archive(node);
ffPtorDb.cc:50:    node[01;31m-[00m>archiveObjectVector<O_FFPtor>("ptors","Ptors",this[01;31m-[00m>_Terms );
ffPtorDb.cc:51:    node[01;31m-[00m>archiveMap<O_FFPtor>("map",this[01;31m-[00m>_Lookup );
ffPtorDb.cc:59:    this[01;31m-[00m>Base::initialize();
ffPtorDb.cc:60:    this[01;31m-[00m>_Lookup.clear();
ffPtorDb.cc:61:    this[01;31m-[00m>_Terms.clear();
ffPtorDb.cc:72:    ss << "Can't find ptor term for ("<<t1<<")[01;31m-[00m("<<t2<<")[01;31m-[00m("<<t3<<")[01;31m-[00m("<<t4<<")";
ffPtorDb.cc:73:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
ffPtorDb.cc:79:    this[01;31m-[00m>Base::initialize();
ffPtorDb.cc:81:    this[01;31m-[00m>_T1 = "";
ffPtorDb.cc:82:    this[01;31m-[00m>_T2 = "";
ffPtorDb.cc:83:    this[01;31m-[00m>_T3 = "";
ffPtorDb.cc:84:    this[01;31m-[00m>_T4 = "";
ffPtorDb.cc:85:    for ( i=0; i<6; i++ ) this[01;31m-[00m>_HasTerm[i] = false;
ffPtorDb.cc:86:    for ( i=0; i<6; i++ ) this[01;31m-[00m>_Vs[i] = 0.0;
ffPtorDb.cc:87:    for ( i=0; i<6; i++ ) this[01;31m-[00m>_PhaseRads[i] = 0.0;
ffPtorDb.cc:94:    this[01;31m-[00m>_T1 = t1;
ffPtorDb.cc:95:    this[01;31m-[00m>_T2 = t2;
ffPtorDb.cc:96:    this[01;31m-[00m>_T3 = t3;
ffPtorDb.cc:97:    this[01;31m-[00m>_T4 = t4;
ffPtorDb.cc:103:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal index for hasTerm"));
ffPtorDb.cc:105:    return this[01;31m-[00m>_HasTerm[idx[01;31m-[00m1];
ffPtorDb.cc:110:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal index for getV"));
ffPtorDb.cc:112:    return this[01;31m-[00m>_Vs[idx[01;31m-[00m1];
ffPtorDb.cc:118:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal index for setV"));
ffPtorDb.cc:120:    this[01;31m-[00m>_HasTerm[idx[01;31m-[00m1] = true;
ffPtorDb.cc:121:    this[01;31m-[00m>_Vs[idx[01;31m-[00m1] = val;
ffPtorDb.cc:128:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal index for getPhaseRad"));
ffPtorDb.cc:130:    return this[01;31m-[00m>_PhaseRads[idx[01;31m-[00m1];
ffPtorDb.cc:136:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal index for setPhaseRad"));
ffPtorDb.cc:138:    this[01;31m-[00m>_PhaseRads[idx[01;31m-[00m1] = val;
ffPtorDb.cc:146:	if ( ptor[01;31m-[00m>_HasTerm[i] ) {
ffPtorDb.cc:147:            this[01;31m-[00m>_HasTerm[i] = ptor[01;31m-[00m>_HasTerm[i];
ffPtorDb.cc:148:            this[01;31m-[00m>_Vs[i] = ptor[01;31m-[00m>_Vs[i];
ffPtorDb.cc:149:            this[01;31m-[00m>_PhaseRads[i] = ptor[01;31m-[00m>_PhaseRads[i];
ffPtorDb.cc:154:#define keyString(t1,t2,t3,t4) (t1+"[01;31m-[00m"+t2+"[01;31m-[00m"+t3+"[01;31m-[00m"+t4)
ffPtorDb.cc:160:    if (this[01;31m-[00m>hasExactTerm(ptor[01;31m-[00m>_T1,ptor[01;31m-[00m>_T2,ptor[01;31m-[00m>_T3,ptor[01;31m-[00m>_T4) ){
ffPtorDb.cc:161:        ptorOld = this[01;31m-[00m>findExactTerm(ptor[01;31m-[00m>_T1,ptor[01;31m-[00m>_T2,ptor[01;31m-[00m>_T3,ptor[01;31m-[00m>_T4);
ffPtorDb.cc:162:        ptorOld[01;31m-[00m>mergeWith(ptor);
ffPtorDb.cc:164:        this[01;31m-[00m>_Terms.push_back(ptor);
ffPtorDb.cc:165:        key = keyString(ptor[01;31m-[00m>_T1,ptor[01;31m-[00m>_T2,ptor[01;31m-[00m>_T3,ptor[01;31m-[00m>_T4);
ffPtorDb.cc:166:        this[01;31m-[00m>_Lookup.set(key,ptor);
ffPtorDb.cc:167:        key = keyString(ptor[01;31m-[00m>_T4,ptor[01;31m-[00m>_T3,ptor[01;31m-[00m>_T2,ptor[01;31m-[00m>_T1);
ffPtorDb.cc:168:        this[01;31m-[00m>_Lookup.set(key,ptor);
ffPtorDb.cc:177:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) return true;
ffPtorDb.cc:179:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) return true;
ffPtorDb.cc:188:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) {
ffPtorDb.cc:189:        return this[01;31m-[00m>_Lookup.get(key);
ffPtorDb.cc:192:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) {
ffPtorDb.cc:193:        return this[01;31m-[00m>_Lookup.get(key);
ffPtorDb.cc:195:    ptor = O_FFPtor::nil(this[01;31m-[00m>lisp());
ffPtorDb.cc:204:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) {
ffPtorDb.cc:205:        return this[01;31m-[00m>_Lookup.get(key);
ffPtorDb.cc:208:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) {
ffPtorDb.cc:209:        return this[01;31m-[00m>_Lookup.get(key);
ffPtorDb.cc:213:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) {
ffPtorDb.cc:214:        return this[01;31m-[00m>_Lookup.get(key);
ffPtorDb.cc:217:    if ( this[01;31m-[00m>_Lookup.count(key)!=0 ) {
ffPtorDb.cc:218:        return this[01;31m-[00m>_Lookup.get(key);
ffPtorDb.cc:220:    ptor = O_FFPtor::nil(this[01;31m-[00m>lisp());
ffPtorDb.cc:229:    ptor = this[01;31m-[00m>findBestTerm(t1,t2,t3,t4);
ffPtorDb.cc:230:    return ptor[01;31m-[00m>notNil();
ffPtorDb.cc:238:    desc << this[01;31m-[00m>O_FFParameter::levelDescription();
ffPtorDb.cc:239:    desc << " ptor between types "<<this[01;31m-[00m>_T1<< " "
ffPtorDb.cc:240:		<< this[01;31m-[00m>_T2 << " "
ffPtorDb.cc:241:		<< this[01;31m-[00m>_T3 << " "
ffPtorDb.cc:242:		<< this[01;31m-[00m>_T4;
ffStretchDb.cc:38:    node[01;31m-[00m>addAttributeString("ti",this[01;31m-[00m>_ti);
ffStretchDb.cc:39:    node[01;31m-[00m>addAttributeString("tj",this[01;31m-[00m>_tj);
ffStretchDb.cc:40:    node[01;31m-[00m>addAttributeDoubleScientific("rij",this[01;31m-[00m>_rij);
ffStretchDb.cc:41:    node[01;31m-[00m>addAttributeDoubleScientific("lnKij",this[01;31m-[00m>_lnKij);
ffStretchDb.cc:48:    this[01;31m-[00m>_ti = node[01;31m-[00m>getAttributeString("ti");
ffStretchDb.cc:49:    this[01;31m-[00m>_tj = node[01;31m-[00m>getAttributeString("tj");
ffStretchDb.cc:50:    this[01;31m-[00m>_rij = node[01;31m-[00m>getAttributeDouble("rij");
ffStretchDb.cc:51:    this[01;31m-[00m>_lnKij = node[01;31m-[00m>getAttributeDouble("lnKij");
ffStretchDb.cc:59:    this[01;31m-[00m>Base::initialize();
ffStretchDb.cc:60:    this[01;31m-[00m>clearEstimateStretch();
ffStretchDb.cc:61:    this[01;31m-[00m>_Lookup.clear();
ffStretchDb.cc:62:    this[01;31m-[00m>_Terms.clear();
ffStretchDb.cc:69:#define stretchKey(t1,t2) t1+"[01;31m-[00m"+t2
ffStretchDb.cc:74:    this[01;31m-[00m>_Terms.push_back(term);
ffStretchDb.cc:75:    key = stretchKey(term[01;31m-[00m>_Type1,term[01;31m-[00m>_Type2);        // forwards
ffStretchDb.cc:76:    this[01;31m-[00m>_Lookup.set(key,term);
ffStretchDb.cc:77:    key = stretchKey(term[01;31m-[00m>_Type2,term[01;31m-[00m>_Type1);        // backwards
ffStretchDb.cc:78:    this[01;31m-[00m>_Lookup.set(key,term);
ffStretchDb.cc:83:{_F(this[01;31m-[00m>lisp());
ffStretchDb.cc:88:    t1 = a1[01;31m-[00m>getTypeString();
ffStretchDb.cc:89:    t2 = a2[01;31m-[00m>getTypeString();
ffStretchDb.cc:90:    LOG(BF("Looking for stretch between types (%s)[01;31m-[00m(%s)") % t1.c_str() % t2.c_str() ); // vp0(( "Looking for stretch between types (%s)[01;31m-[00m(%s)",t1.c_str(),t2.c_str()));
ffStretchDb.cc:92:    if ( this[01;31m-[00m>_Lookup.count(key) != 0 ) {
ffStretchDb.cc:93:        return this[01;31m-[00m>_Lookup.get(key);
ffStretchDb.cc:96:    if ( this[01;31m-[00m>_Lookup.count(key) != 0 ) {
ffStretchDb.cc:97:        return this[01;31m-[00m>_Lookup.get(key);
ffStretchDb.cc:101:    ss << "PARAMETER_PROBLEM Can't find stretch term for types(" << t1 << ")[01;31m-[00m("<<t2<<")";
ffStretchDb.cc:102:    ss << " atoms("<<a1[01;31m-[00m>description()<<") [01;31m-[00m (" << a2[01;31m-[00m>description()<<")";
ffStretchDb.cc:103:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
ffStretchDb.cc:105:    match = O_FFStretch::nil(this[01;31m-[00m>lisp());
ffStretchDb.cc:116:    if ( this[01;31m-[00m>_Lookup.count(key) != 0 ) {
ffStretchDb.cc:120:    if ( this[01;31m-[00m>_Lookup.count(key) != 0 ) {
ffStretchDb.cc:130:    ss << "Can't find stretch term for types(" << t1 << ")[01;31m-[00m("<<t2<<")";
ffStretchDb.cc:131:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
ffStretchDb.cc:139:    this[01;31m-[00m>_EstimateStretch.clear();
ffStretchDb.cc:152:    tt = es._ti+"[01;31m-[00m"+es._tj;
ffStretchDb.cc:153:    this[01;31m-[00m>_EstimateStretch[tt] = es;
ffStretchDb.cc:166:    tt = ti+"[01;31m-[00m"+tj;
ffStretchDb.cc:167:    this[01;31m-[00m>_addEstimateStretch(es);
ffStretchDb.cc:174:    node[01;31m-[00m>attribute( "type1", this[01;31m-[00m>_Type1 );
ffStretchDb.cc:175:    node[01;31m-[00m>attribute( "type2", this[01;31m-[00m>_Type2 );
ffStretchDb.cc:176:    node[01;31m-[00m>attribute( "r0", this[01;31m-[00m>_r0 );
ffStretchDb.cc:177:    node[01;31m-[00m>attribute( "kb", this[01;31m-[00m>_kb );
ffStretchDb.cc:183:    this[01;31m-[00m>O_FFBaseDb::archive(node);
ffStretchDb.cc:184:    node[01;31m-[00m>archiveObjectVector<O_FFStretch>("stretches","Stretches",this[01;31m-[00m>_Terms );
ffStretchDb.cc:185:    node[01;31m-[00m>archiveMap<O_FFStretch>("map",this[01;31m-[00m>_Lookup );
ffStretchDb.cc:194:    this[01;31m-[00m>Base::initialize();
ffStretchDb.cc:195:    this[01;31m-[00m>_Type1 = "";
ffStretchDb.cc:196:    this[01;31m-[00m>_Type2 = "";
ffStretchDb.cc:197:    this[01;31m-[00m>_r0 = 10.0;
ffStretchDb.cc:198:    this[01;31m-[00m>_kb = 0.0;
ffStretchDb.cc:199://    this[01;31m-[00m>_K3 = 0.0;
ffStretchDb.cc:200://    this[01;31m-[00m>_K4 = 0.0;
ffStretchDb.cc:201://    this[01;31m-[00m>_Bci = 0.0;
ffStretchDb.cc:208:    desc << this[01;31m-[00m>O_FFParameter::levelDescription();
ffStretchDb.cc:209:    desc << " stretch between types "<<this[01;31m-[00m>_Type1<< " "
ffStretchDb.cc:210:		<< this[01;31m-[00m>_Type2;
ffTypesDb.cc:30:    this[01;31m-[00m>Base::initialize();
ffTypesDb.cc:31:    this[01;31m-[00m>_TypeAssignmentRules.clear();
ffTypesDb.cc:37:{ _F(this[01;31m-[00m>lisp());
ffTypesDb.cc:58:        LOG(BF("atom name: %s") % atom[01;31m-[00m>getName().c_str() ); // vp0(( "atom name: %s", atom[01;31m-[00m>getName().c_str()));
ffTypesDb.cc:59:        LOG(BF("Assigning type for atom: %s") % atom[01;31m-[00m>description().c_str()  ); // vp0(( "Assigning type for atom: %s", atom[01;31m-[00m>description().c_str() ));
ffTypesDb.cc:61:	    for ( it=this[01;31m-[00m>_TypeAssignmentRules.begin();
ffTypesDb.cc:62:		    it!=this[01;31m-[00m>_TypeAssignmentRules.end(); it++ ) 
ffTypesDb.cc:63:	    {_BLOCK_TRACEF(BF("Testing rule code(%s)") % (*it)[01;31m-[00m>getCode().c_str() );
ffTypesDb.cc:64:		LOG(BF("as xml: %s") % ((*it)[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("as xml: %s", (*it)[01;31m-[00m>asXmlString().c_str() ));
ffTypesDb.cc:65:		if ( (*it)[01;31m-[00m>matches(atom) ) 
ffTypesDb.cc:80:    this[01;31m-[00m>O_FFBaseDb::archive(node);
ffTypesDb.cc:81:    node[01;31m-[00m>archiveObjectVector<chemInfo::O_ChemInfo>("typeRules","List", this[01;31m-[00m>_TypeAssignmentRules);
ffTypesDb.cc:87:    ASSERT_lessThan(index,this[01;31m-[00m>_TypeAssignmentRules.size());
ffTypesDb.cc:88:    return this[01;31m-[00m>_TypeAssignmentRules[index];
ffTypesDb.cc:98:    class_<O_FFTypesDb>(this[01;31m-[00m>lisp())
ffVdwDb.cc:22:    node[01;31m-[00m>attribute("type1",this[01;31m-[00m>_T1);
ffVdwDb.cc:23:    node[01;31m-[00m>attribute("type2",this[01;31m-[00m>_T2);
ffVdwDb.cc:24:    node[01;31m-[00m>attribute("R",this[01;31m-[00m>_R);
ffVdwDb.cc:25:    node[01;31m-[00m>attribute("Eps",this[01;31m-[00m>_Eps);
ffVdwDb.cc:26:    node[01;31m-[00m>attribute("M",this[01;31m-[00m>_M);
ffVdwDb.cc:27:    node[01;31m-[00m>attribute("N",this[01;31m-[00m>_N);
ffVdwDb.cc:28:    node[01;31m-[00m>attribute("Edep",this[01;31m-[00m>_Edep);
ffVdwDb.cc:34:    this[01;31m-[00m>O_FFBaseDb::archive(node);
ffVdwDb.cc:35:    node[01;31m-[00m>archiveObjectVector("Vdw","Vdw",this[01;31m-[00m>_Terms);
fileSystem.cc:31:{_F(rpath[01;31m-[00m>lisp());
fileSystem.cc:32:    bf::path p(rpath[01;31m-[00m>getPath());
fileSystem.cc:36:    first = O_Cons::create(O_Object::nil(rpath[01;31m-[00m>lisp()),O_Cons::nil(rpath[01;31m-[00m>lisp()),rpath[01;31m-[00m>lisp());
fileSystem.cc:41:	string name = itr[01;31m-[00m>path().file_string();
fileSystem.cc:46:            tail[01;31m-[00m>setCdr(O_Cons::create(rpath[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(name),O_Cons::nil(rpath[01;31m-[00m>lisp()),rpath[01;31m-[00m>lisp()));
fileSystem.cc:47:	    tail = tail[01;31m-[00m>cdr();
fileSystem.cc:53:    return first[01;31m-[00m>cdr();
fileSystem.cc:58:    bf::path p(rpath[01;31m-[00m>getPath());
fileSystem.cc:62:    first = O_Cons::create(O_Object::nil(rpath[01;31m-[00m>lisp()),O_Cons::nil(rpath[01;31m-[00m>lisp()),rpath[01;31m-[00m>lisp());
fileSystem.cc:69:	    string pathName = itr[01;31m-[00m>path().file_string();
fileSystem.cc:70:	    string fileName = itr[01;31m-[00m>path().filename();
fileSystem.cc:75:		tail[01;31m-[00m>setCdr(O_Cons::create(rpath[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(pathName),O_Cons::nil(rpath[01;31m-[00m>lisp()),rpath[01;31m-[00m>lisp()));
fileSystem.cc:76:		tail = tail[01;31m-[00m>cdr();
fileSystem.cc:84:	TOSS(lisp[01;31m-[00m>create<O_LispError>(BF("Could not iterate over directory")));
fileSystem.cc:87:    return first[01;31m-[00m>cdr();
fileSystem.cc:94:    return bf::rename(rpath1[01;31m-[00m>getPath(),rpath2[01;31m-[00m>getPath());
fileSystem.cc:99:    return bf::remove(rpath[01;31m-[00m>getPath());
fileSystem.cc:104:    return bf::remove_all(rpath[01;31m-[00m>getPath());
fileSystem.cc:110:    return bf::create_directory(rpath[01;31m-[00m>getPath());
fileSystem.cc:117:    class_<O_Path>(lisp[01;31m-[00m>lisp())
fileSystem.cc:125:    defInPackage(ClPackage,"directory",&directory, lisp[01;31m-[00m>lisp());
fileSystem.cc:126:    defInPackage(ClPackage,"directoryFileNameRegex",&directoryFileNameRegex, lisp[01;31m-[00m>lisp());
fileSystem.cc:127:    defInPackage(ClPackage,"remove",&remove, lisp[01;31m-[00m>lisp());
fileSystem.cc:128:    defInPackage(ClPackage,"rename",&rename, lisp[01;31m-[00m>lisp());
fileSystem.cc:129:    defInPackage(ClPackage,"removeAll",&removeAll, lisp[01;31m-[00m>lisp());
fileSystem.cc:130:    defInPackage(ClPackage,"createDirectory",&createDirectory, lisp[01;31m-[00m>lisp());
fileSystem.cc:136:    this[01;31m-[00m>Base::initialize();
fileSystem.cc:149:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_Path>(args,environ);
fileSystem.cc:153:	this[01;31m-[00m>setPath(sp);
fileSystem.cc:155:    return lisp[01;31m-[00m>onil();
fileSystem.cc:169:	this[01;31m-[00m>_Path = path;
fileSystem.cc:174:{_F(this[01;31m-[00m>lisp());
fileSystem.cc:176:    this[01;31m-[00m>_Path = p;
fileSystem.cc:180:{_F(this[01;31m-[00m>lisp());
fileSystem.cc:181:    return this[01;31m-[00m>_Path.file_string();
fileSystem.cc:185:{_F(this[01;31m-[00m>lisp());
fileSystem.cc:186:    return this[01;31m-[00m>_Path.stem();
fileSystem.cc:190:{_F(this[01;31m-[00m>lisp());
fileSystem.cc:191:    return this[01;31m-[00m>_Path.extension();
fileSystem.cc:198:    return boost::filesystem::exists(this[01;31m-[00m>_Path);
fileSystem.cc:204:	di[01;31m-[00m>setPath(path);
fileSystem.cc:212:    class_<O_DirectoryIterator>(lisp[01;31m-[00m>lisp())
fileSystem.cc:219:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_DirectoryIterator>(args,environ);
fileSystem.cc:221:    if ( path[01;31m-[00m>isNil() )
fileSystem.cc:223:	TOSS(lisp[01;31m-[00m>create<O_LispError>("You must specify the path"));
fileSystem.cc:225:    this[01;31m-[00m>setPath(path);
fileSystem.cc:226:    this[01;31m-[00m>first();
fileSystem.cc:227:    return lisp[01;31m-[00m>onil();
fileSystem.cc:233:	this[01;31m-[00m>_CurrentIterator = NULL;
fileSystem.cc:241:	this[01;31m-[00m>_Path = p;
fileSystem.cc:246:    ASSERT_NOT_NULL(this[01;31m-[00m>_Path);
fileSystem.cc:247:    ASSERT(this[01;31m-[00m>_Path[01;31m-[00m>notNil());
fileSystem.cc:248:    if ( this[01;31m-[00m>_CurrentIterator != NULL )
fileSystem.cc:250:	delete (this[01;31m-[00m>_CurrentIterator);
fileSystem.cc:254:    this[01;31m-[00m>_CurrentIterator = new boost::filesystem::directory_iterator(this[01;31m-[00m>_Path[01;31m-[00m>getPath());
fileSystem.cc:257:	TOSS(_lisp[01;31m-[00m>error(BF("%s") % err.what() ));
fileSystem.cc:264:	this[01;31m-[00m>setupCurrentIterator();
fileSystem.cc:269:	ASSERTF(this[01;31m-[00m>_CurrentIterator != NULL, BF("The _CurrentIterator is NULL [01;31m-[00m it shouldn't be") );
fileSystem.cc:270:	(*(this[01;31m-[00m>_CurrentIterator))++;
fileSystem.cc:275:	ASSERTF(this[01;31m-[00m>_CurrentIterator != NULL, BF("The _CurrentIterator is NULL [01;31m-[00m it shouldn't be") );
fileSystem.cc:276:	return ( *(this[01;31m-[00m>_CurrentIterator) == this[01;31m-[00m>_EndIterator );
fileSystem.cc:281:	ASSERTF(this[01;31m-[00m>_CurrentIterator != NULL, BF("The _CurrentIterator is NULL [01;31m-[00m it shouldn't be") );
fileSystem.cc:282:	if ( this[01;31m-[00m>isDone() )
fileSystem.cc:284:	    LOG(BF("The directory iteratory is done [01;31m-[00m returning nil"));
fileSystem.cc:285:	    return _lisp[01;31m-[00m>nil<O_DirectoryEntry>();
fileSystem.cc:288:	RPDirectoryEntry de = _lisp[01;31m-[00m>create<O_DirectoryEntry>();
fileSystem.cc:289:	de[01;31m-[00m>setEntry(**(this[01;31m-[00m>_CurrentIterator));
fileSystem.cc:295:	if ( this[01;31m-[00m>_CurrentIterator != NULL )
fileSystem.cc:297:	    delete this[01;31m-[00m>_CurrentIterator;
fileSystem.cc:320:	di[01;31m-[00m>setPath(path);
fileSystem.cc:328:    class_<O_RecursiveDirectoryIterator>(lisp[01;31m-[00m>lisp())
fileSystem.cc:335:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_RecursiveDirectoryIterator>(args,environ);
fileSystem.cc:337:    if ( path[01;31m-[00m>isNil() )
fileSystem.cc:339:	TOSS(lisp[01;31m-[00m>create<O_LispError>("You must specify the path"));
fileSystem.cc:341:    this[01;31m-[00m>setPath(path);
fileSystem.cc:342:    this[01;31m-[00m>first();
fileSystem.cc:343:    return lisp[01;31m-[00m>onil();
fileSystem.cc:349:	this[01;31m-[00m>_CurrentIterator = NULL;
fileSystem.cc:350:	this[01;31m-[00m>_EnterHidden = false;
fileSystem.cc:358:	this[01;31m-[00m>_Path = p;
fileSystem.cc:363:    ASSERT_NOT_NULL(this[01;31m-[00m>_Path);
fileSystem.cc:364:    ASSERT(this[01;31m-[00m>_Path[01;31m-[00m>notNil());
fileSystem.cc:365:    if ( this[01;31m-[00m>_CurrentIterator != NULL )
fileSystem.cc:367:	delete (this[01;31m-[00m>_CurrentIterator);
fileSystem.cc:371:	this[01;31m-[00m>_CurrentIterator = new boost::filesystem::recursive_directory_iterator(this[01;31m-[00m>_Path[01;31m-[00m>getPath());
fileSystem.cc:374:	TOSS(_lisp[01;31m-[00m>error(BF("%s") % err.what() ));
fileSystem.cc:381:	this[01;31m-[00m>setupCurrentIterator();
fileSystem.cc:386:	ASSERTF(this[01;31m-[00m>_CurrentIterator != NULL, BF("The _CurrentIterator is NULL [01;31m-[00m it shouldn't be") );
fileSystem.cc:387:	(*(this[01;31m-[00m>_CurrentIterator))++;
fileSystem.cc:392:	ASSERTF(this[01;31m-[00m>_CurrentIterator != NULL, BF("The _CurrentIterator is NULL [01;31m-[00m it shouldn't be") );
fileSystem.cc:393:	return ( *(this[01;31m-[00m>_CurrentIterator) == this[01;31m-[00m>_EndIterator );
fileSystem.cc:398:	ASSERTF(this[01;31m-[00m>_CurrentIterator != NULL, BF("The _CurrentIterator is NULL [01;31m-[00m it shouldn't be") );
fileSystem.cc:399:	if ( this[01;31m-[00m>isDone() )
fileSystem.cc:401:	    LOG(BF("The directory iteratory is done [01;31m-[00m returning nil"));
fileSystem.cc:402:	    return _lisp[01;31m-[00m>nil<O_DirectoryEntry>();
fileSystem.cc:405:	RPDirectoryEntry de = _lisp[01;31m-[00m>create<O_DirectoryEntry>();
fileSystem.cc:406:	de[01;31m-[00m>setEntry(**(this[01;31m-[00m>_CurrentIterator));
fileSystem.cc:412:	if ( this[01;31m-[00m>_CurrentIterator != NULL )
fileSystem.cc:414:	    delete this[01;31m-[00m>_CurrentIterator;
fileSystem.cc:438:    class_<O_DirectoryEntry>(lisp[01;31m-[00m>lisp())
fileSystem.cc:452:	if ( this[01;31m-[00m>_Entry != NULL )
fileSystem.cc:454:	    delete this[01;31m-[00m>_Entry;
fileSystem.cc:459:	this[01;31m-[00m>_Entry = new boost::filesystem::directory_entry(p,s,ss);
fileSystem.cc:464:	RPFileStatus fs = _lisp[01;31m-[00m>create<O_FileStatus>();
fileSystem.cc:465:	fs[01;31m-[00m>setFileStatus(this[01;31m-[00m>_Entry[01;31m-[00m>status());
fileSystem.cc:471:	RPFileStatus fs = _lisp[01;31m-[00m>create<O_FileStatus>();
fileSystem.cc:472:	fs[01;31m-[00m>setFileStatus(this[01;31m-[00m>_Entry[01;31m-[00m>symlink_status());
fileSystem.cc:478:	RPPath path = _lisp[01;31m-[00m>create<O_Path>();
fileSystem.cc:479:	path[01;31m-[00m>setPath(this[01;31m-[00m>_Entry[01;31m-[00m>path());
fileSystem.cc:485:    if ( this[01;31m-[00m>_Entry!=NULL) delete this[01;31m-[00m>_Entry;
fileSystem.cc:491:    class_<O_FileStatus>(lisp[01;31m-[00m>lisp())
fileSystem.cc:507:	this[01;31m-[00m>_FileStatus = fs;
fileSystem.cc:512:	return boost::filesystem::exists(this[01;31m-[00m>_FileStatus);
fileSystem.cc:516:	return boost::filesystem::is_regular_file(this[01;31m-[00m>_FileStatus);
fileSystem.cc:520:	return boost::filesystem::is_directory(this[01;31m-[00m>_FileStatus);
fileSystem.cc:524:	return boost::filesystem::is_symlink(this[01;31m-[00m>_FileStatus);
fileSystem.cc:528:	return boost::filesystem::is_other(this[01;31m-[00m>_FileStatus);
forceField.cc:35:    node[01;31m-[00m>archiveMapIfDefined("k",this[01;31m-[00m>db);
forceField.cc:41:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("subclass must implement"));
forceField.cc:50:    this[01;31m-[00m>Base::initialize();
forceField.cc:52:    this[01;31m-[00m>_Info = O_InfoDb::create(this[01;31m-[00m>lisp());
forceField.cc:54:    this[01;31m-[00m>_Types = O_FFTypesDb::create(this[01;31m-[00m>lisp());
forceField.cc:56:    this[01;31m-[00m>_Stretches = O_FFStretchDb::create(this[01;31m-[00m>lisp());
forceField.cc:58:    this[01;31m-[00m>_Angles = O_FFAngleDb::create(this[01;31m-[00m>lisp());
forceField.cc:60:    this[01;31m-[00m>_Itors = O_FFItorDb::create(this[01;31m-[00m>lisp());
forceField.cc:62:    this[01;31m-[00m>_Ptors = O_FFPtorDb::create(this[01;31m-[00m>lisp());
forceField.cc:64:    this[01;31m-[00m>_Nonbonds = O_FFNonbondDb::create(this[01;31m-[00m>lisp());
forceField.cc:66:    this[01;31m-[00m>_Vdws = O_FFVdwDb::create(this[01;31m-[00m>lisp());
forceField.cc:72:    node[01;31m-[00m>attribute("title",this[01;31m-[00m>_Title);
forceField.cc:73:    node[01;31m-[00m>attribute("ref",this[01;31m-[00m>_Ref);
forceField.cc:74:    node[01;31m-[00m>archiveVectorStrings( "bondDistinctions", this[01;31m-[00m>_SingleBondMultiBondDistinctions );
forceField.cc:75:    node[01;31m-[00m>archiveObject( "_Info", this[01;31m-[00m>_Info );
forceField.cc:76:    node[01;31m-[00m>archiveObject( "_Types", this[01;31m-[00m>_Types );
forceField.cc:77:    node[01;31m-[00m>archiveObject( "_Stretches", this[01;31m-[00m>_Stretches );
forceField.cc:78:    node[01;31m-[00m>archiveObject( "_Angles", this[01;31m-[00m>_Angles );
forceField.cc:79:    node[01;31m-[00m>archiveObject( "_Itors", this[01;31m-[00m>_Itors );
forceField.cc:80:    node[01;31m-[00m>archiveObject( "_Ptors", this[01;31m-[00m>_Ptors );
forceField.cc:81:    node[01;31m-[00m>archiveObject( "_Nonbonds", this[01;31m-[00m>_Nonbonds );
forceField.cc:82:    node[01;31m-[00m>archiveObject( "_Vdws", this[01;31m-[00m>_Vdws );
forceField.cc:88:{_F(this[01;31m-[00m>lisp());
forceField.cc:90:    xml = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_XmlSaveArchive>();
forceField.cc:91:    xml[01;31m-[00m>put("forceField",this[01;31m-[00m>sharedThis<O_ForceField>());
forceField.cc:92:    xml[01;31m-[00m>saveAs(fileName);
forceField.cc:97:{_F(this[01;31m-[00m>lisp());
forceField.cc:99:    types = this[01;31m-[00m>getTypes();
forceField.cc:100:    types[01;31m-[00m>assignTypes(matter);
forceField.cc:107:    this[01;31m-[00m>_Title = title;
forceField.cc:112:    this[01;31m-[00m>_Info = Info;
forceField.cc:116:{_F(this[01;31m-[00m>lisp());
forceField.cc:117:    this[01;31m-[00m>_Types = Types;
forceField.cc:118:    this[01;31m-[00m>_Types[01;31m-[00m>setForceField(this[01;31m-[00m>sharedThis<O_ForceField>());
forceField.cc:123:{_F(this[01;31m-[00m>lisp());
forceField.cc:124:    this[01;31m-[00m>_Stretches = Stretches;
forceField.cc:125:    this[01;31m-[00m>_Stretches[01;31m-[00m>setForceField(this[01;31m-[00m>sharedThis<O_ForceField>());
forceField.cc:128:{_F(this[01;31m-[00m>lisp());
forceField.cc:129:    this[01;31m-[00m>_Angles = Angles;
forceField.cc:130:    this[01;31m-[00m>_Angles[01;31m-[00m>setForceField(this[01;31m-[00m>sharedThis<O_ForceField>());
forceField.cc:133:{_F(this[01;31m-[00m>lisp());
forceField.cc:134:    this[01;31m-[00m>_Itors = Itors;
forceField.cc:135:    this[01;31m-[00m>_Itors[01;31m-[00m>setForceField(this[01;31m-[00m>sharedThis<O_ForceField>());
forceField.cc:138:{_F(this[01;31m-[00m>lisp());
forceField.cc:139:    this[01;31m-[00m>_Ptors = Ptors;
forceField.cc:140:    this[01;31m-[00m>_Ptors[01;31m-[00m>setForceField(this[01;31m-[00m>sharedThis<O_ForceField>());
forceField.cc:143:{_F(this[01;31m-[00m>lisp());
forceField.cc:144:    this[01;31m-[00m>_Nonbonds = Nonbonds;
forceField.cc:145:    this[01;31m-[00m>_Nonbonds[01;31m-[00m>setForceField(this[01;31m-[00m>sharedThis<O_ForceField>());
forceField.cc:148:{_F(this[01;31m-[00m>lisp());
forceField.cc:149:    this[01;31m-[00m>_Vdws = Vdws;
forceField.cc:150:    this[01;31m-[00m>_Vdws[01;31m-[00m>setForceField(this[01;31m-[00m>sharedThis<O_ForceField>());
forceField.cc:166:    class_<O_ForceField>(this[01;31m-[00m>lisp())
foundation.cc:72:	return lisp[01;31m-[00m>symbol(symId);
foundation.cc:78:	RPSymbolToEnumConverter converter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(predefSymId))[01;31m-[00m>as<O_SymbolToEnumConverter>();
foundation.cc:79:	return converter[01;31m-[00m>enumIndexForSymbol(symbol[01;31m-[00m>as<O_Symbol>());
foundation.cc:85:    RPSymbolToEnumConverter converter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(predefSymId))[01;31m-[00m>as<O_SymbolToEnumConverter>();
foundation.cc:86:    return converter[01;31m-[00m>symbolForEnumIndex(enumVal);
foundation.cc:92:    lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>extend(sym,obj);
foundation.cc:97:    conv[01;31m-[00m>addSymbolEnumPair(lisp[01;31m-[00m>internKeyword(name),archiveName,value);
foundation.cc:105:	return lisp[01;31m-[00m>isGlobalInitializationAllowed();
foundation.cc:110:	lisp[01;31m-[00m>debugLog().beginNode("LOG",functionName,fileName,lineNumber,fmt.str());
foundation.cc:111:	lisp[01;31m-[00m>debugLog().endNode("LOG");
foundation.cc:117:	lisp[01;31m-[00m>debugLog().beginNode("EXCEPTION",file,fn,line,message);
foundation.cc:118:	lisp[01;31m-[00m>debugLog().endNode("EXCEPTION");
foundation.cc:146:    lisp[01;31m-[00m>print(BF("> ") );
foundation.cc:147:    lisp[01;31m-[00m>printvFlush();
foundation.cc:155:    os[01;31m-[00m>open(fileName.c_str());
foundation.cc:156:    ASSERTP(!os[01;31m-[00m>fail(), "Could not open file named: "+fileName+" for output");
foundation.cc:157:    lisp[01;31m-[00m>setOutputStream(os);
foundation.cc:162:    lisp[01;31m-[00m>outputStream() << outputBuffer;
foundation.cc:167:    lisp[01;31m-[00m>outputStream() << outputChar;
foundation.cc:173:    lisp[01;31m-[00m>outputStream().flush();
foundation.cc:180:    lisp[01;31m-[00m>printfPrefixStack().push_back(prefix);
foundation.cc:187:    lisp[01;31m-[00m>printfPrefixStack().pop_back();
foundation.cc:196:	lisp[01;31m-[00m>printvWrite((*si).c_str());
foundation.cc:215:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not malloc buffer for printv"));
foundation.cc:219:		n = vsnprintf( outBuffer, outBufferSize[01;31m-[00m1, fmt, arg_ptr );
foundation.cc:221:		if ( n>[01;31m-[00m1 && n<outBufferSize ) break;
foundation.cc:230:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not realloc printv buffer"));
foundation.cc:248:		lisp[01;31m-[00m>printvWriteChar(*cp);
foundation.cc:250:	    lisp[01;31m-[00m>printvFlush();
foundation.cc:258:	lisp[01;31m-[00m>print(BF("%s")%str);
foundation.cc:264:    lisp[01;31m-[00m>print(BF("%s") %str.c_str());
foundation.cc:320:    return str.substr( startpos, endpos[01;31m-[00mstartpos+1 );
foundation.cc:368:    // Find first "non[01;31m-[00mdelimiter".
foundation.cc:372:        tokens.push_back(str.substr(lastPos, pos [01;31m-[00m lastPos));
foundation.cc:375:        // Find next "non[01;31m-[00mdelimiter"
foundation.cc:400://    LOG(BF("foundation.cc::tokenize[01;31m-[00m[01;31m-[00m Entered") ); // vp0(( "foundation.cc::tokenize[01;31m-[00m[01;31m-[00m Entered" ));
foundation.cc:403:    // Find first "non[01;31m-[00mdelimiter".
foundation.cc:407:        tokens.push(str.substr(lastPos, pos [01;31m-[00m lastPos));
foundation.cc:410:        // Find next "non[01;31m-[00mdelimiter"
foundation.cc:464:    HARD_ASSERT(this[01;31m-[00m>parts.size()>0);
foundation.cc:465:    this[01;31m-[00m>parts.pop_back();
foundation.cc:472:    if ( this[01;31m-[00m>parts.size() > 0 )
foundation.cc:474:	ss << this[01;31m-[00m>parts[0];
foundation.cc:476:    for (uint i=1;i<this[01;31m-[00m>parts.size();i++){
foundation.cc:478:	ss<<this[01;31m-[00m>parts[i];
foundation.cc:490:	lisp[01;31m-[00m>print(BF("Debug information was being written when classes have not yet been initialized"));
foundation.cc:491:	lisp[01;31m-[00m>print(BF("This should never happen."));
foundation.cc:492:	lisp[01;31m-[00m>print(BF( "Run with the debugger and use the following commands:" ));
foundation.cc:493:	lisp[01;31m-[00m>print(BF( "l foundation.cc:1" ));
foundation.cc:494:	lisp[01;31m-[00m>print(BF( "search throwIfClassesNotInitialized" ));
foundation.cc:495:	lisp[01;31m-[00m>print(BF( "[01;31m-[00m[01;31m-[00m> set a breakpoint in the if block" ));
foundation.cc:496:	lisp[01;31m-[00m>print(BF( "Then backtrace to find the offending initialization routine." ));
foundation.cc:536:	    exposedOne = it[01;31m-[00m>exposeYourself(exposeCando,exposePython);
fragment.cc:25:{_F(this[01;31m-[00m>lisp());
fragment.cc:26:    node[01;31m-[00m>archiveWeakPointer("constitution",this[01;31m-[00m>_WeakConstitution);
fragment.cc:27:    if ( node[01;31m-[00m>loading() )
fragment.cc:30:	ss = node[01;31m-[00m>getDataAsStringSet();
fragment.cc:31:	this[01;31m-[00m>_FragmentNames= ss;
fragment.cc:34:        ASSERT_NOT_NULL(this[01;31m-[00m>_FragmentNames);
fragment.cc:35:    	node[01;31m-[00m>setCharacters(this[01;31m-[00m>_FragmentNames[01;31m-[00m>asString());
fragment.cc:41:{_F(this[01;31m-[00m>lisp());
fragment.cc:48:    con = this[01;31m-[00m>getConstitution();
fragment.cc:50:    res = con[01;31m-[00m>getResidue();
fragment.cc:54:    allAtoms = res[01;31m-[00m>getAtomNamesAsStringSet();
fragment.cc:56:    for ( fn = this[01;31m-[00m>_FragmentNames[01;31m-[00m>begin();
fragment.cc:57:    		fn != this[01;31m-[00m>_FragmentNames[01;31m-[00m>end(); fn++ )
fragment.cc:60:       frag = con[01;31m-[00m>getFragmentWithName(*fn);
fragment.cc:61:       subSetAtoms = allAtoms[01;31m-[00m>relativeComplement(frag[01;31m-[00m>getAtomNames());
fragment.cc:82:    this[01;31m-[00m>Base::initialize();
fragment.cc:83:    this[01;31m-[00m>_AtomsNotInFragments = O_AtomsNotInFragments::nil(this[01;31m-[00m>lisp());
fragment.cc:97:{_F(this[01;31m-[00m>lisp());
fragment.cc:98:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
fragment.cc:99:    this[01;31m-[00m>_Name = args[01;31m-[00m>getStringAndRemove("name");
fragment.cc:100:    this[01;31m-[00m>_AtomNames = O_StringSet::create(this[01;31m-[00m>lisp());
fragment.cc:101:    RPCons l = args[01;31m-[00m>getAndRemove("atoms")[01;31m-[00m>as<O_Cons>();
fragment.cc:102:    this[01;31m-[00m>_AtomNames[01;31m-[00m>insertConsStrings(l);
fragment.cc:114:{ _F(this[01;31m-[00m>lisp());
fragment.cc:115:    node[01;31m-[00m>archiveObjectIfDefined("rest",this[01;31m-[00m>_AtomsNotInFragments);
fragment.cc:117:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
fragment.cc:119:    if ( node[01;31m-[00m>loading() )
fragment.cc:121:	if ( node[01;31m-[00m>hasAttribute("name") )
fragment.cc:123:	    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
fragment.cc:126:	    node[01;31m-[00m>attribute("_key",this[01;31m-[00m>_Name);
fragment.cc:130:	node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
fragment.cc:134:    if ( node[01;31m-[00m>loading() )
fragment.cc:138:	ss = node[01;31m-[00m>getDataAsStringSet();
fragment.cc:139:	this[01;31m-[00m>_AtomNames = ss;
fragment.cc:143:        ASSERT_NOT_NULL(this[01;31m-[00m>_AtomNames);
fragment.cc:144:    	node[01;31m-[00m>setCharacters(this[01;31m-[00m>_AtomNames[01;31m-[00m>asString());
fragment.cc:147:    node[01;31m-[00m>needsFinalization();
fragment.cc:152:    if ( this[01;31m-[00m>_AtomsNotInFragments[01;31m-[00m>notNil() )
fragment.cc:154:        this[01;31m-[00m>_AtomNames = this[01;31m-[00m>_AtomsNotInFragments[01;31m-[00m>asStringSet();
fragment.cc:155:	this[01;31m-[00m>_AtomsNotInFragments = O_AtomsNotInFragments::nil(this[01;31m-[00m>lisp());
fragment.cc:168:    node[01;31m-[00m>attribute( "frameName",this[01;31m-[00m>_FrameName );
fragment.cc:169:    node[01;31m-[00m>archiveWeakPointerIfNotNil( "fragment", this[01;31m-[00m>_WeakFragment );
fragment.cc:170:    if ( node[01;31m-[00m>loading() )
fragment.cc:172:        this[01;31m-[00m>_TemporaryWeakConstitution = O_Constitution::nil(this[01;31m-[00m>lisp());
fragment.cc:173:	this[01;31m-[00m>_TemporaryFragmentName == "";
fragment.cc:174:	node[01;31m-[00m>archiveWeakPointerNotNil("constitution",this[01;31m-[00m>_TemporaryWeakConstitution );
fragment.cc:175:	node[01;31m-[00m>attributeIfNotDefault<string>("fragmentName",this[01;31m-[00m>_TemporaryFragmentName, "");
fragment.cc:176:	node[01;31m-[00m>needsFinalization();
fragment.cc:183:{ _F(this[01;31m-[00m>lisp());
fragment.cc:184:	if ( this[01;31m-[00m>_TemporaryWeakConstitution.lock()[01;31m-[00m>notNil() )
fragment.cc:186:	    if ( this[01;31m-[00m>_TemporaryFragmentName == "" )
fragment.cc:188:		TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>("You must provide both a 'Constitution' and "
fragment.cc:193:	    if ( this[01;31m-[00m>_TemporaryFragmentName != "" )
fragment.cc:195:		TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>("You must provide both a 'Constitution' along "
fragment.cc:202:    ASSERT_NOT_NULL(this[01;31m-[00m>_TemporaryWeakConstitution);
fragment.cc:203:    RPConstitution con = this[01;31m-[00m>_TemporaryWeakConstitution.lock();
fragment.cc:204:    if ( !con[01;31m-[00m>recognizesFragmentName(this[01;31m-[00m>_TemporaryFragmentName) )
fragment.cc:206:	this[01;31m-[00m>_WeakFragment = con[01;31m-[00m>getFragment(this[01;31m-[00m>_TemporaryFragmentName);
fragment.cc:209:        TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>("Could not find fragmentName("
fragment.cc:210:			+this[01;31m-[00m>_TemporaryFragmentName+") in Constitution",node));
fragment.cc:220:    class_<O_AtomsNotInFragments>(this[01;31m-[00m>lisp());
fragment.cc:238:    class_<O_Fragment>(this[01;31m-[00m>lisp())
fragmentCoordinates.cc:36:    this[01;31m-[00m>Base::initialize();
fragmentCoordinates.cc:37:    this[01;31m-[00m>_FirstVirtualAtomNameIndex = UndefinedUnsignedInt;
fragmentCoordinates.cc:41:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:42:    node[01;31m-[00m>archiveVectorStrings("atomNames",this[01;31m-[00m>_AtomNames);
fragmentCoordinates.cc:43:    node[01;31m-[00m>archiveList("coordinates",this[01;31m-[00m>_Coordinates);
fragmentCoordinates.cc:44:    node[01;31m-[00m>archiveObject("frame",this[01;31m-[00m>_Frame);
fragmentCoordinates.cc:45:    node[01;31m-[00m>attributeIfNotDefault("firstVirtualAtomNameIndex",this[01;31m-[00m>_FirstVirtualAtomNameIndex,UndefinedUnsignedInt);
fragmentCoordinates.cc:46:    node[01;31m-[00m>attribute("fragmentName",this[01;31m-[00m>_FragmentName);
fragmentCoordinates.cc:48:    if ( !node[01;31m-[00m>loading() )
fragmentCoordinates.cc:51:	s = this[01;31m-[00m>_DebugMessages.str();
fragmentCoordinates.cc:52:	node[01;31m-[00m>archiveString("DebugMessage",s);
fragmentCoordinates.cc:56:	node[01;31m-[00m>archiveString("DebugMessage",s);
fragmentCoordinates.cc:57:	this[01;31m-[00m>_DebugMessages.str(s);
fragmentCoordinates.cc:64:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:65:    return (this[01;31m-[00m>_Frame[01;31m-[00m>isAssignableTo<O_Anchor>());
fragmentCoordinates.cc:69:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:70:    ASSERT_lessThan(i,this[01;31m-[00m>_Coordinates.size());
fragmentCoordinates.cc:71:    return this[01;31m-[00m>_Coordinates[i];
fragmentCoordinates.cc:77:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:78:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
fragmentCoordinates.cc:80:    for ( List<O_CoordinateArray>::iterator it=this[01;31m-[00m>_Coordinates.begin();
fragmentCoordinates.cc:81:    		it!=this[01;31m-[00m>_Coordinates.end(); it++ )
fragmentCoordinates.cc:83:	RPCons one = O_Cons::create(*it,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
fragmentCoordinates.cc:84:	cur[01;31m-[00m>setCdr(one);
fragmentCoordinates.cc:87:    return first[01;31m-[00m>cdr();
fragmentCoordinates.cc:92:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:93:    this[01;31m-[00m>_Coordinates.clear();
fragmentCoordinates.cc:97:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:98:    this[01;31m-[00m>_Coordinates.push_back(coord);
fragmentCoordinates.cc:106:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:119:    this[01;31m-[00m>_DebugMessages.str("");
fragmentCoordinates.cc:121:    this[01;31m-[00m>_FragmentName = extractFragment[01;31m-[00m>getFragment()[01;31m-[00m>getName();
fragmentCoordinates.cc:122:    focusResidue = focusMonomer[01;31m-[00m>getTemporaryResidue();
fragmentCoordinates.cc:123:    fragment = extractFragment[01;31m-[00m>getFragment();
fragmentCoordinates.cc:124:    this[01;31m-[00m>setFrame(extractFragment[01;31m-[00m>getFrame());
fragmentCoordinates.cc:125:    for ( atomi=fragment[01;31m-[00m>begin_AtomNames();
fragmentCoordinates.cc:126:			atomi!=fragment[01;31m-[00m>end_AtomNames(); atomi++ )
fragmentCoordinates.cc:128:        this[01;31m-[00m>_AtomNames.push_back(*atomi);
fragmentCoordinates.cc:130:    agg = downcast<O_Aggregate>(structureList[01;31m-[00m>getMatter());
fragmentCoordinates.cc:131:    for ( ei = structureList[01;31m-[00m>begin_Entries();
fragmentCoordinates.cc:132:    		ei!=structureList[01;31m-[00m>end_Entries(); ei++ )
fragmentCoordinates.cc:136:    	(*ei)[01;31m-[00m>writeCoordinatesToMatter(matter);
fragmentCoordinates.cc:139:            frameCoordSys = extractFragment[01;31m-[00m>getFrame()[01;31m-[00m>getCoordinateSystem(focusMonomer);
fragmentCoordinates.cc:146:	    frameCoordSys = O_CoordinateSystem::create(this[01;31m-[00m>lisp()); // canonical
fragmentCoordinates.cc:148:        index = this[01;31m-[00m>_Coordinates.size();
fragmentCoordinates.cc:150:        this[01;31m-[00m>_DebugMessages << "O_FragmentCoordinates::defineFromConformationCollection for index: "<<index<<endl;
fragmentCoordinates.cc:151:	this[01;31m-[00m>_DebugMessages << "  Extracting fragment: "<<extractFragment[01;31m-[00m>getFragment()[01;31m-[00m>getName()<<endl;
fragmentCoordinates.cc:152:	this[01;31m-[00m>_DebugMessages << "  Extracting with respect to coordinate system:"<<endl;
fragmentCoordinates.cc:153:	this[01;31m-[00m>_DebugMessages << frameCoordSys[01;31m-[00m>asString() <<endl;
fragmentCoordinates.cc:154:	this[01;31m-[00m>_DebugMessages << "  calculated from anchor: " << endl;
fragmentCoordinates.cc:155:	this[01;31m-[00m>_DebugMessages << extractFragment[01;31m-[00m>getFrame()[01;31m-[00m>debugAsString(focusMonomer) << endl;
fragmentCoordinates.cc:157:        fragmentCoordArray = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>();
fragmentCoordinates.cc:158:        for ( atomi=fragment[01;31m-[00m>begin_AtomNames();
fragmentCoordinates.cc:159:			atomi!=fragment[01;31m-[00m>end_AtomNames(); atomi++ )
fragmentCoordinates.cc:161:	    if ( !focusResidue[01;31m-[00m>hasAtomWithName(*atomi) )
fragmentCoordinates.cc:163:	        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find atom with name("+*atomi+") in residue: "+focusResidue[01;31m-[00m>description()));
fragmentCoordinates.cc:165:	    atom = focusResidue[01;31m-[00m>atomWithName(*atomi);
fragmentCoordinates.cc:167:        this[01;31m-[00m>_DebugMessages << "                           Atom: " << atom[01;31m-[00m>getName() << endl;
fragmentCoordinates.cc:168:        this[01;31m-[00m>_DebugMessages << "      position before transform: " << atom[01;31m-[00m>getPosition().asString() << endl;
fragmentCoordinates.cc:170:	    pos = frameCoordSys[01;31m-[00m>vectorRelativeToYou(atom[01;31m-[00m>getPosition());
fragmentCoordinates.cc:172:        this[01;31m-[00m>_DebugMessages << "       position after transform: " << pos.asString() << endl;
fragmentCoordinates.cc:174:	    fragmentCoordArray[01;31m-[00m>appendElement(pos);
fragmentCoordinates.cc:176:        this[01;31m-[00m>_Coordinates.append(fragmentCoordArray);
fragmentCoordinates.cc:177:	maximumNumberOfConformations[01;31m-[00m[01;31m-[00m;
fragmentCoordinates.cc:184:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:187:    for ( it=this[01;31m-[00m>begin_AllAtomNames();
fragmentCoordinates.cc:188:    		it!=this[01;31m-[00m>end_AllAtomNames(); it++, atomIdx++ )
fragmentCoordinates.cc:192:	    RPCoordinateArray coords = this[01;31m-[00m>_Coordinates[idx];
fragmentCoordinates.cc:193:	    return coords[01;31m-[00m>value_getElement(atomIdx);
fragmentCoordinates.cc:196:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find atom with name("+name+")"));
fragmentCoordinates.cc:200:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:203:    for ( it=this[01;31m-[00m>begin_AllAtomNames();
fragmentCoordinates.cc:204:    		it!=this[01;31m-[00m>end_AllAtomNames(); it++ )
fragmentCoordinates.cc:219:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:220:    ASSERT_greaterThan(this[01;31m-[00m>_AtomNames.size(),0);
fragmentCoordinates.cc:224:    if ( this[01;31m-[00m>recognizesAtomName(name) )
fragmentCoordinates.cc:230:    if ( this[01;31m-[00m>_FirstVirtualAtomNameIndex == UndefinedUnsignedInt )
fragmentCoordinates.cc:232:	this[01;31m-[00m>_FirstVirtualAtomNameIndex = this[01;31m-[00m>_AtomNames.size();
fragmentCoordinates.cc:234:    this[01;31m-[00m>_AtomNames.push_back(name);
fragmentCoordinates.cc:235:    uint virtualAtomIndex = this[01;31m-[00m>_AtomNames.size()[01;31m-[00m1;
fragmentCoordinates.cc:237:    it = O_IterateFragmentCoordinateEntries::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>sharedThis<O_FragmentCoordinates>());
fragmentCoordinates.cc:238:    it[01;31m-[00m>first();
fragmentCoordinates.cc:239:    while ( !it[01;31m-[00m>isDone() )
fragmentCoordinates.cc:242:	Vector3 pos = code[01;31m-[00m>calculatePosition(it);
fragmentCoordinates.cc:244:	array = this[01;31m-[00m>_Coordinates.get(it[01;31m-[00m>getIndex() );
fragmentCoordinates.cc:246:	array[01;31m-[00m>push_back(pos);
fragmentCoordinates.cc:247:	LOG(BF("After atom position added coordinate array size=%d") % array[01;31m-[00m>size() ); // vp0(( "After atom position added coordinate array size=%d", array[01;31m-[00m>size()));
fragmentCoordinates.cc:248:	if ( array[01;31m-[00m>size() != this[01;31m-[00m>_AtomNames.size() )
fragmentCoordinates.cc:250:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("One of the virtual atom coordinates have gotten out of sync with the AtomNames of FragmentCoordinates"));
fragmentCoordinates.cc:252:	it[01;31m-[00m>next();
fragmentCoordinates.cc:264:    it[01;31m-[00m>setFragmentCoordinates(fragCoords);
fragmentCoordinates.cc:270:    this[01;31m-[00m>Base::initialize();
fragmentCoordinates.cc:271:    this[01;31m-[00m>_FragmentCoordinates = O_FragmentCoordinates::nil(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:278:    ASSERT_NOT_NULL(this[01;31m-[00m>_FragmentCoordinates);
fragmentCoordinates.cc:279:    return this[01;31m-[00m>_Index >= this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays();
fragmentCoordinates.cc:284:    return this[01;31m-[00m>sharedThis<O_IterateFragmentCoordinateEntries>();
fragmentCoordinates.cc:289:    return this[01;31m-[00m>_FragmentCoordinates;
fragmentCoordinates.cc:294:{_F(this[01;31m-[00m>lisp());
fragmentCoordinates.cc:295:    RPFragmentCoordinates fc = this[01;31m-[00m>_FragmentCoordinates;
fragmentCoordinates.cc:296:    Vector3 vec = fc[01;31m-[00m>getPositionForAtomWithNameAndConformationIndex(name,this[01;31m-[00m>_Index);
fragmentCoordinates.cc:305:    class_<O_FragmentCoordinates>(this[01;31m-[00m>lisp())
fragmentCoordinates.cc:345:    class_<O_IterateFragmentCoordinateEntries>(this[01;31m-[00m>lisp())
fragmentHolder.cc:26:#define VAR(name) #name << "(" << this[01;31m-[00m>name << ")" << endl;
fragmentHolder.cc:30:    this[01;31m-[00m>_InterestingAtom = false;
fragmentHolder.cc:37:    		% this[01;31m-[00m>_FragmentCoordinateAtomOffset
fragmentHolder.cc:38:    		% this[01;31m-[00m>_Atom[01;31m-[00m>getName() 
fragmentHolder.cc:39:		% this[01;31m-[00m>_InterestingAtom
fragmentHolder.cc:40:		% this[01;31m-[00m>_Pos.asString()
fragmentHolder.cc:41://		% this[01;31m-[00m>_ScoreTransformedPos.asString() 
fragmentHolder.cc:46:{_F(oligomerBuilder[01;31m-[00m>lisp());
fragmentHolder.cc:47:    FragmentHolder& fragmentHolder = oligomerBuilder[01;31m-[00m>_AllFragmentHolders[fragmentHolderIndex];
fragmentHolder.cc:49:    RPRenderDisplayList dl = O_RenderDisplayList::create(oligomerBuilder[01;31m-[00m>lisp());
fragmentHolder.cc:50:    dl[01;31m-[00m>add(oligomerBuilder[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("yellow"));
fragmentHolder.cc:52:    ss << "Monomer("<< scaffoldHolder._Monomer[01;31m-[00m>getId()<<") ";
fragmentHolder.cc:53:    ss << "   Fragment(" << fragmentHolder._FragmentCoordinates[01;31m-[00m>getFragmentName() <<") "<< endl;
fragmentHolder.cc:54:    ss << "   MonomerCoordinates: " << scaffoldHolder._MonomerCoordinates[01;31m-[00m>getComment() << endl;
fragmentHolder.cc:55:    ss << "   MonomerContext: " << scaffoldHolder._Monomer[01;31m-[00m>getSpecificMonomerContext()[01;31m-[00m>getKey() << endl;
fragmentHolder.cc:56:    dl[01;31m-[00m>add(O_GrInformation::create(ss.str(),oligomerBuilder[01;31m-[00m>lisp()));
fragmentHolder.cc:59:	Vector3& pos = oligomerBuilder[01;31m-[00m>_AllAtomHolders[i]._Pos;
fragmentHolder.cc:60:	dl[01;31m-[00m>add(O_GrSphere::create(pos,0.2,oligomerBuilder[01;31m-[00m>lisp()));
fragmentHolder.cc:62:    FrameHolder& fh = oligomerBuilder[01;31m-[00m>_FrameHolders[fragmentHolder._FrameHolderIndex];
fragmentHolder.cc:63:    RPCoordinateSystem coords = O_CoordinateSystem::create(oligomerBuilder[01;31m-[00m>lisp());
fragmentHolder.cc:64:    coords[01;31m-[00m>defineCanonical();
fragmentHolder.cc:65:    coords[01;31m-[00m>transformWithMatrix(oligomerBuilder[01;31m-[00m>_FrameHolders[fragmentHolder._FrameHolderIndex].frameTransform());
fragmentHolder.cc:66:    dl[01;31m-[00m>add(coords[01;31m-[00m>rendered(O_KeyedArguments::nil(oligomerBuilder[01;31m-[00m>lisp())));
fragmentHolder.cc:72:    this[01;31m-[00m>_WeakLisp = lisp;
fragmentHolder.cc:73:    this[01;31m-[00m>_LockToScaffoldConformation = false;
fragmentHolder.cc:74:    this[01;31m-[00m>_localFragmentConformationIndex = 0;
fragmentHolder.cc:75:    this[01;31m-[00m>_ManipulateMask = 0;
fragmentHolder.cc:76:    this[01;31m-[00m>_SaveBuildSerialNumber = UndefinedUnsignedInt;
fragmentHolder.cc:82:    if ( this[01;31m-[00m>_WeakLisp.use_count() == 0 )
fragmentHolder.cc:86:    return this[01;31m-[00m>_WeakLisp.lock();
fragmentHolder.cc:109:{_F(this[01;31m-[00m>lisp());
fragmentHolder.cc:117:    this[01;31m-[00m>_FragmentCoordinates = fragCoordinates;
fragmentHolder.cc:118:    this[01;31m-[00m>_localFragmentConformationIndex = 0;
fragmentHolder.cc:119:    this[01;31m-[00m>_ScaffoldHolderPtr = &scaffoldHolder;
fragmentHolder.cc:122:    LOG(BF("initializing fragment coordinates for monomer: %s") % monomer[01;31m-[00m>description().c_str()  ); // vp0(("initializing fragment coordinates for monomer: %s",monomer[01;31m-[00m>description().c_str() ));
fragmentHolder.cc:123:    frame = fragCoordinates[01;31m-[00m>getFrame();
fragmentHolder.cc:124:    if ( frame[01;31m-[00m>isAssignableTo<O_Anchor>() )
fragmentHolder.cc:128:	this[01;31m-[00m>_LockToScaffoldConformation = true;
fragmentHolder.cc:134:	iFrame = scaffoldHolder.getFrameHolderIndex(frame[01;31m-[00m>getName());
fragmentHolder.cc:135:	this[01;31m-[00m>_LockToScaffoldConformation = false;
fragmentHolder.cc:137:    this[01;31m-[00m>_FrameHolderIndex = iFrame;
fragmentHolder.cc:144:    residue = scaffoldHolder._Monomer[01;31m-[00m>getTemporaryResidue();
fragmentHolder.cc:146:    this[01;31m-[00m>_AllAtomIndicesBegin = oligomerBuilder[01;31m-[00m>_AllAtomHolders.size();
fragmentHolder.cc:147:    this[01;31m-[00m>_FragmentBuildInterestingAtomIndicesBeginIndex = oligomerBuilder[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices.size();
fragmentHolder.cc:151:	for ( ai=fragCoordinates[01;31m-[00m>begin_AllAtomNames(), offset=0;
fragmentHolder.cc:152:		    ai!=fragCoordinates[01;31m-[00m>end_AllAtomNames(); ai++, offset++ )
fragmentHolder.cc:155:	    atom = residue[01;31m-[00m>atomWithName(*ai);
fragmentHolder.cc:159:	    LOG(BF("Setting OligomerBuilder(%s) for atom(%s)") % oligomerBuilder[01;31m-[00m>__repr__() % atom[01;31m-[00m>__repr__() );
fragmentHolder.cc:160:	    atom[01;31m-[00m>setOligomerBuilder(oligomerBuilder);
fragmentHolder.cc:161:	    atom[01;31m-[00m>setAtomHolderIndex(oligomerBuilder[01;31m-[00m>_AllAtomHolders.size());
fragmentHolder.cc:165:	    if ( interestingAtomIndexer[01;31m-[00m>containsAtomName(*ai) )
fragmentHolder.cc:168:		LOG(BF("Adding interesting atom to scaffoldHolder@%X for " "monomer sequence number: %d") % &scaffoldHolder % monomer[01;31m-[00m>getSequenceNumber()  ); // vp0(("Adding interesting atom to scaffoldHolder@%X for " "monomer sequence number: %d",&scaffoldHolder,monomer[01;31m-[00m>getSequenceNumber() ));
fragmentHolder.cc:169:		uint allAtomHolderIndex = oligomerBuilder[01;31m-[00m>_AllAtomHolders.size();
fragmentHolder.cc:170:		LOG(BF("oligomerBuilder[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices[%d] = %d") % oligomerBuilder[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices.size() % allAtomHolderIndex ); // vp0(( "oligomerBuilder[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices[%d] = %d", oligomerBuilder[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices.size(),allAtomHolderIndex));
fragmentHolder.cc:171:		oligomerBuilder[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices.push_back(allAtomHolderIndex);
fragmentHolder.cc:173:					+ interestingAtomIndexer[01;31m-[00m>indexForAtomName(*ai);
fragmentHolder.cc:174:		ASSERT_lt(interestingAtomIndex,oligomerBuilder[01;31m-[00m>_InterestingAtomHolderIndices.size());
fragmentHolder.cc:175:		oligomerBuilder[01;31m-[00m>_InterestingAtomHolderIndices[interestingAtomIndex] = allAtomHolderIndex;
fragmentHolder.cc:184:	    oligomerBuilder[01;31m-[00m>_AllAtomHolders.push_back(atomHolder);
fragmentHolder.cc:187:    this[01;31m-[00m>_AllAtomIndicesEnd = oligomerBuilder[01;31m-[00m>_AllAtomHolders.size();
fragmentHolder.cc:188:    this[01;31m-[00m>_FragmentBuildInterestingAtomIndicesEndIndex = oligomerBuilder[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices.size();
fragmentHolder.cc:199:    ss << "[conf("<<this[01;31m-[00m>_localFragmentConformationIndex<<")";
fragmentHolder.cc:200:    ss << " " << this[01;31m-[00m>_ScaffoldHolderPtr[01;31m-[00m>_Monomer[01;31m-[00m>description();
fragmentHolder.cc:209:{_F(this[01;31m-[00m>lisp());
fragmentHolder.cc:215:LOG(BF("Building %d atomHolders") % (indicesEnd[01;31m-[00mindicesBegin)  ); // vp0(("Building %d atomHolders",indicesEnd[01;31m-[00mindicesBegin ));
fragmentHolder.cc:218:    ASSERT_lessThan(this[01;31m-[00m>_FrameHolderIndex,oligomerBuilder[01;31m-[00m>_FrameHolders.size());
fragmentHolder.cc:219:    frameTransform = oligomerBuilder[01;31m-[00m>_FrameHolders[this[01;31m-[00m>_FrameHolderIndex]._Transform;
fragmentHolder.cc:227:	if ( this[01;31m-[00m>_UseScaffoldConformation )
fragmentHolder.cc:229:	    iConformation = this[01;31m-[00m>_ScaffoldHolderPtr[01;31m-[00m>_ScaffoldListIndex;
fragmentHolder.cc:232:	    iConformation = this[01;31m-[00m>_FragmentConformationIndex;
fragmentHolder.cc:235:	LOG(BF("this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays()=%d") % this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays() ); // vp0(("this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays()=%d",this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays()));
fragmentHolder.cc:236:	ASSERT_lessThan(iConformation,this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays());
fragmentHolder.cc:237:	fragmentCoordinateArray = this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>getCoordinateArray(iConformation);
fragmentHolder.cc:239:	dbPos = fragmentCoordinateArray[01;31m-[00m>getElement(atomHolderPtr[01;31m-[00m>_FragmentCoordinateAtomOffset);
fragmentHolder.cc:249:{_F(this[01;31m-[00m>lisp());
fragmentHolder.cc:256:    indicesBegin = this[01;31m-[00m>_FragmentBuildInterestingAtomIndicesBeginIndex;
fragmentHolder.cc:257:    indicesEnd = this[01;31m-[00m>_FragmentBuildInterestingAtomIndicesEndIndex;
fragmentHolder.cc:258:    LOG(BF("Building %d atomHolders") % (indicesEnd[01;31m-[00mindicesBegin)  ); // vp0(("Building %d atomHolders",indicesEnd[01;31m-[00mindicesBegin ));
fragmentHolder.cc:261:    ASSERT_lessThan(this[01;31m-[00m>_FrameHolderIndex,ob[01;31m-[00m>_FrameHolders.size());
fragmentHolder.cc:262:    frameTransform = ob[01;31m-[00m>_FrameHolders[this[01;31m-[00m>_FrameHolderIndex].frameTransform();
fragmentHolder.cc:265:	intAtomIndex = ob[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices[ai];
fragmentHolder.cc:266:	iConformation = this[01;31m-[00m>_localFragmentConformationIndex;
fragmentHolder.cc:268:	LOG(BF("this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays()=%d") % this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays() ); // vp0(("this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays()=%d",this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays()));
fragmentHolder.cc:269:	ASSERT_lessThan(iConformation,this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays());
fragmentHolder.cc:270:	fragmentCoordinateArray = this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>getCoordinateArray(iConformation);
fragmentHolder.cc:271:	atomHolderPtr = &(ob[01;31m-[00m>_AllAtomHolders[intAtomIndex]);
fragmentHolder.cc:272:	dbPos = fragmentCoordinateArray[01;31m-[00m>getElement(atomHolderPtr[01;31m-[00m>_FragmentCoordinateAtomOffset);
fragmentHolder.cc:273:	atomHolderPtr[01;31m-[00m>_Pos = frameTransform*dbPos;
fragmentHolder.cc:279:{_F(this[01;31m-[00m>lisp());
fragmentHolder.cc:286:    indicesBegin = this[01;31m-[00m>_AllAtomIndicesBegin;
fragmentHolder.cc:287:    indicesEnd = this[01;31m-[00m>_AllAtomIndicesEnd;
fragmentHolder.cc:288:    LOG(BF("Building FragmentHolder for fragment: %s") % this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>getFragmentName().c_str() ); // vp0(("Building FragmentHolder for fragment: %s",this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>getFragmentName().c_str()));
fragmentHolder.cc:289:    LOG(BF("Building %d atomHolders") % (indicesEnd[01;31m-[00mindicesBegin)  ); // vp0(("Building %d atomHolders",indicesEnd[01;31m-[00mindicesBegin ));
fragmentHolder.cc:292:    ASSERT_lessThan(this[01;31m-[00m>_FrameHolderIndex,ob[01;31m-[00m>_FrameHolders.size());
fragmentHolder.cc:298:    if ( !ob[01;31m-[00m>_FrameHolders[this[01;31m-[00m>_FrameHolderIndex].hasBeenBuilt(ob) ) return false;
fragmentHolder.cc:299:    this[01;31m-[00m>_SaveBuildSerialNumber = ob[01;31m-[00m>_BuildSerialNumber;
fragmentHolder.cc:300:    frameTransform = ob[01;31m-[00m>_FrameHolders[this[01;31m-[00m>_FrameHolderIndex].frameTransform();
fragmentHolder.cc:304:        iConformation = this[01;31m-[00m>_localFragmentConformationIndex;
fragmentHolder.cc:306:	LOG(BF("this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays()=%d") % this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays() ); // vp0(("this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays()=%d",this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays()));
fragmentHolder.cc:307:	ASSERT_lessThan(iConformation,this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays());
fragmentHolder.cc:308:	fragmentCoordinateArray = this[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>getCoordinateArray(iConformation);
fragmentHolder.cc:309:	atomHolderPtr = &(ob[01;31m-[00m>_AllAtomHolders[i]);
fragmentHolder.cc:310:	dbPos = fragmentCoordinateArray[01;31m-[00m>getElement(atomHolderPtr[01;31m-[00m>_FragmentCoordinateAtomOffset);
fragmentHolder.cc:312:	atomHolderPtr[01;31m-[00m>_Pos = frameTransform*dbPos;
fragmentHolder.cc:313:	LOG(BF("transformed atomHolderPtr[01;31m-[00m>_Pos = %s") % atomHolderPtr[01;31m-[00m>_Pos.asString().c_str()  ); // vp0(("transformed atomHolderPtr[01;31m-[00m>_Pos = %s", atomHolderPtr[01;31m-[00m>_Pos.asString().c_str() ));
fragmentHolder.cc:320:    return this[01;31m-[00m>_SaveBuildSerialNumber == ob[01;31m-[00m>_BuildSerialNumber;
fragmentHolder.cc:328:    for ( uint i=0; i<ob[01;31m-[00m>_AllAtomHolders.size(); i++ )
fragmentHolder.cc:330:	ob[01;31m-[00m>_AllAtomHolders[i]._Atom[01;31m-[00m>setPosition(ss[01;31m-[00m>scoreTransform()*(ob[01;31m-[00m>_AllAtomHolders[i]._Pos));
fragmentHolder.cc:337:    for ( uint i=0; i<ob[01;31m-[00m>_AllAtomHolders.size(); i++ )
fragmentHolder.cc:339:	ob[01;31m-[00m>_AllAtomHolders[i]._Pos = ob[01;31m-[00m>_AllAtomHolders[i]._Atom[01;31m-[00m>getPosition();
frame.cc:23:{_F(this[01;31m-[00m>lisp());
frame.cc:38:with the x[01;31m-[00maxis on \sa{nameOfXAtom} and xy[01;31m-[00mplane on \sa{nameOfXYAtom}.
frame.cc:44:{_F(this[01;31m-[00m>lisp());
frame.cc:45:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
frame.cc:46:    this[01;31m-[00m>_FrameName = args[01;31m-[00m>getStringAndRemove("name");
frame.cc:54:    ss << "( " << this[01;31m-[00m>className() << "@" << this << " " << this[01;31m-[00m>_FrameName << ")";
frame.cc:60:{_F(this[01;31m-[00m>lisp());
frame.cc:61:    this[01;31m-[00m>Base::archiveBase(node);
frame.cc:63:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_FrameName);
frame.cc:65:    if ( node[01;31m-[00m>loading() )
frame.cc:67:	if ( node[01;31m-[00m>hasAttribute("name") )
frame.cc:69:	    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_FrameName);
frame.cc:72:	    node[01;31m-[00m>attribute("_key",this[01;31m-[00m>_FrameName);
frame.cc:76:	node[01;31m-[00m>attribute("name",this[01;31m-[00m>_FrameName);
frame.cc:128:with the x[01;31m-[00maxis on \sa{nameOfXAtom} and xy[01;31m-[00mplane on \sa{nameOfXYAtom}.
frame.cc:134:{_F(this[01;31m-[00m>lisp());
frame.cc:135:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
frame.cc:136:    this[01;31m-[00m>_OriginAtomName = args[01;31m-[00m>getStringAndRemove("origin");
frame.cc:137:    this[01;31m-[00m>_XAtomName = args[01;31m-[00m>getStringAndRemove("xAtom");
frame.cc:138:    this[01;31m-[00m>_XYAtomName = args[01;31m-[00m>getStringAndRemove("xyAtom");
frame.cc:142:{_F(this[01;31m-[00m>lisp());
frame.cc:143:    this[01;31m-[00m>Base::archiveBase(node);
frame.cc:144:    node[01;31m-[00m>attribute("origin",this[01;31m-[00m>_OriginAtomName);
frame.cc:145:    node[01;31m-[00m>attribute("xAtom",this[01;31m-[00m>_XAtomName);
frame.cc:146:    node[01;31m-[00m>attribute("xyAtom",this[01;31m-[00m>_XYAtomName);
frame.cc:150:{_F(this[01;31m-[00m>lisp());
frame.cc:151:    if ( !mon[01;31m-[00m>hasTemporaryResidue() )
frame.cc:153:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not have a residue",mon[01;31m-[00m>description()));
frame.cc:155:    RPResidue res = mon[01;31m-[00m>getTemporaryResidue();
frame.cc:156:    if ( !res[01;31m-[00m>hasAtomWithName(this[01;31m-[00m>_OriginAtomName) )
frame.cc:158:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not contain atom with name("+this[01;31m-[00m>_OriginAtomName+")",mon[01;31m-[00m>description()));
frame.cc:160:    if ( !res[01;31m-[00m>hasAtomWithName(this[01;31m-[00m>_XAtomName) )
frame.cc:162:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not contain atom with name("+this[01;31m-[00m>_XAtomName+")",mon[01;31m-[00m>description()));
frame.cc:164:    if ( !res[01;31m-[00m>hasAtomWithName(this[01;31m-[00m>_XYAtomName) )
frame.cc:166:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not contain atom with name("+this[01;31m-[00m>_XYAtomName+")",mon[01;31m-[00m>description()));
frame.cc:168:    RPAtom originAtom = res[01;31m-[00m>atomWithName(this[01;31m-[00m>_OriginAtomName);
frame.cc:169:    RPAtom xAtom = res[01;31m-[00m>atomWithName(this[01;31m-[00m>_XAtomName);
frame.cc:170:    RPAtom xyAtom = res[01;31m-[00m>atomWithName(this[01;31m-[00m>_XYAtomName);
frame.cc:172:    RPAtomBoundFrame bound = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_AtomBoundFrame>();
frame.cc:173:    bound[01;31m-[00m>set_oAtom(originAtom);
frame.cc:174:    bound[01;31m-[00m>set_pAtom(xAtom);
frame.cc:175:    bound[01;31m-[00m>set_qAtom(xyAtom);
frame.cc:181:    return "O_ExplicitFrame origin atom: "+this[01;31m-[00m>_OriginAtomName;
frame.cc:185:{_F(this[01;31m-[00m>lisp());
frame.cc:187:   boundFrame= this[01;31m-[00m>getBoundFrame(mon);
frame.cc:188:   return boundFrame[01;31m-[00m>getCoordinateSystem();
frame.cc:213:{_F(this[01;31m-[00m>lisp());
frame.cc:214:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
frame.cc:215:    this[01;31m-[00m>_OriginAtomName = args[01;31m-[00m>getStringAndRemove("origin");
frame.cc:219:{_F(this[01;31m-[00m>lisp());
frame.cc:220:    this[01;31m-[00m>Base::archiveBase(node);
frame.cc:221:    node[01;31m-[00m>attribute("origin",this[01;31m-[00m>_OriginAtomName);
frame.cc:225:{_F(this[01;31m-[00m>lisp());
frame.cc:226:    if ( !mon[01;31m-[00m>hasTemporaryResidue() )
frame.cc:228:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not have a residue",mon[01;31m-[00m>description()));
frame.cc:230:    RPResidue res = mon[01;31m-[00m>getTemporaryResidue();
frame.cc:231:    if ( !res[01;31m-[00m>hasAtomWithName(this[01;31m-[00m>_OriginAtomName) )
frame.cc:233:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not contain atom with name("+this[01;31m-[00m>_OriginAtomName+")",mon[01;31m-[00m>description()));
frame.cc:235:    RPAtom originAtom = res[01;31m-[00m>atomWithName(this[01;31m-[00m>_OriginAtomName);
frame.cc:236:    RPAtomBoundFrame bound = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_AtomBoundFrame>();
frame.cc:237:    bound[01;31m-[00m>set_oAtom(originAtom);
frame.cc:238:    bound[01;31m-[00m>set_pAtom(O_Atom::nil(this[01;31m-[00m>lisp()));
frame.cc:239:    bound[01;31m-[00m>set_qAtom(O_Atom::nil(this[01;31m-[00m>lisp()));
frame.cc:245:    return "O_OneAtomFrame origin atom: "+this[01;31m-[00m>_OriginAtomName;
frame.cc:249:{_F(this[01;31m-[00m>lisp());
frame.cc:251:   boundFrame= this[01;31m-[00m>getBoundFrame(mon);
frame.cc:252:   return boundFrame[01;31m-[00m>getCoordinateSystem();
frame.cc:274:with the x[01;31m-[00maxis on \sa{nameOfXAtom}.
frame.cc:280:{_F(this[01;31m-[00m>lisp());
frame.cc:281:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
frame.cc:282:    this[01;31m-[00m>_OriginAtomName = args[01;31m-[00m>getStringAndRemove("origin");
frame.cc:283:    this[01;31m-[00m>_XAtomName = args[01;31m-[00m>getStringAndRemove("xAtom");
frame.cc:287:{_F(this[01;31m-[00m>lisp());
frame.cc:288:    this[01;31m-[00m>Base::archiveBase(node);
frame.cc:289:    node[01;31m-[00m>attribute("origin",this[01;31m-[00m>_OriginAtomName);
frame.cc:290:    node[01;31m-[00m>attribute("xAtom",this[01;31m-[00m>_XAtomName);
frame.cc:294:{_F(this[01;31m-[00m>lisp());
frame.cc:295:    if ( !mon[01;31m-[00m>hasTemporaryResidue() )
frame.cc:297:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not have a residue",mon[01;31m-[00m>description()));
frame.cc:299:    RPResidue res = mon[01;31m-[00m>getTemporaryResidue();
frame.cc:300:    if ( !res[01;31m-[00m>hasAtomWithName(this[01;31m-[00m>_OriginAtomName) )
frame.cc:302:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not contain atom with name("+this[01;31m-[00m>_OriginAtomName+")",mon[01;31m-[00m>description()));
frame.cc:304:    if ( !res[01;31m-[00m>hasAtomWithName(this[01;31m-[00m>_XAtomName) )
frame.cc:306:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not contain atom with name("+this[01;31m-[00m>_XAtomName+")",mon[01;31m-[00m>description()));
frame.cc:308:    RPAtom originAtom = res[01;31m-[00m>atomWithName(this[01;31m-[00m>_OriginAtomName);
frame.cc:309:    RPAtom xAtom = res[01;31m-[00m>atomWithName(this[01;31m-[00m>_XAtomName);
frame.cc:311:    RPAtomBoundFrame bound = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_AtomBoundFrame>();
frame.cc:312:    bound[01;31m-[00m>set_oAtom(originAtom);
frame.cc:313:    bound[01;31m-[00m>set_pAtom(xAtom);
frame.cc:314:    bound[01;31m-[00m>set_qAtom(O_Atom::nil(this[01;31m-[00m>lisp()));
frame.cc:320:    return "O_TwoAtomFrame origin atom: "+this[01;31m-[00m>_OriginAtomName;
frame.cc:324:{_F(this[01;31m-[00m>lisp());
frame.cc:326:   boundFrame= this[01;31m-[00m>getBoundFrame(mon);
frame.cc:327:   return boundFrame[01;31m-[00m>getCoordinateSystem();
frame.cc:360:{_F(this[01;31m-[00m>lisp());
frame.cc:361:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
frame.cc:362:    this[01;31m-[00m>_OriginAtomName = args[01;31m-[00m>getStringAndRemove("origin");
frame.cc:363:    string recognizerName = args[01;31m-[00m>getStringAndRemove("recognizerName");
frame.cc:364:    this[01;31m-[00m>_Recognizer = O_BuilderDatabaseReference::create(this[01;31m-[00m>lisp(),env[01;31m-[00m>getBuilderDatabase(),"FrameRecognizer="+recognizerName);
frame.cc:369:{_F(this[01;31m-[00m>lisp());
frame.cc:370:    this[01;31m-[00m>Base::archiveBase(node);
frame.cc:371:    node[01;31m-[00m>attribute("origin",this[01;31m-[00m>_OriginAtomName);
frame.cc:372:    node[01;31m-[00m>archiveObject("recognizer",this[01;31m-[00m>_Recognizer);
frame.cc:378:    ASSERT_NOT_NULL(this[01;31m-[00m>_Recognizer);
frame.cc:379:    ASSERT(this[01;31m-[00m>_Recognizer[01;31m-[00m>notNil());
frame.cc:380:    return this[01;31m-[00m>_Recognizer[01;31m-[00m>get<O_FrameRecognizer>();
frame.cc:384:{_F(this[01;31m-[00m>lisp());
frame.cc:386:    recog = this[01;31m-[00m>getFrameRecognizer();
frame.cc:387:    if ( !mon[01;31m-[00m>hasTemporaryResidue() )
frame.cc:389:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not have a residue",mon[01;31m-[00m>description()));
frame.cc:391:    RPResidue res = mon[01;31m-[00m>getTemporaryResidue();
frame.cc:392:    if ( !res[01;31m-[00m>hasAtomWithName(this[01;31m-[00m>_OriginAtomName) )
frame.cc:394:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer("+mon[01;31m-[00m>description()+") does not contain atom with name("+this[01;31m-[00m>_OriginAtomName+")",mon[01;31m-[00m>description()));
frame.cc:396:    RPAtom atom = res[01;31m-[00m>atomWithName(this[01;31m-[00m>_OriginAtomName);
frame.cc:397:    if ( !recog[01;31m-[00m>recognizes(atom) )
frame.cc:400:	ss << (BF("Monomer(%s) does not recognize frame(%s) with origin atom name(%s)")%mon[01;31m-[00m>description()%recog[01;31m-[00m>description()%this[01;31m-[00m>_OriginAtomName).str() << endl;
frame.cc:401:	ss << (BF("The recognizer pattern is: %s")%recog[01;31m-[00m>getSmarts() ) << endl;
frame.cc:402:	ss << (BF("The depth of the recognizer pattern is: %s")%recog[01;31m-[00m>depth() ) << endl;
frame.cc:403:	ss << (BF("The atom environment is: %s")%atom[01;31m-[00m>localSpanningTree(recog[01;31m-[00m>depth())[01;31m-[00m>__repr__() ).str() << endl;
frame.cc:404:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>(ss.str()));
frame.cc:406:    LOG(BF("FrameRecognizer(%s) recognized atom(%s)") % recog[01;31m-[00m>getRecognizerName().c_str() % atom[01;31m-[00m>description().c_str()  ); // vp0(( "FrameRecognizer(%s) recognized atom(%s)", recog[01;31m-[00m>getRecognizerName().c_str(), atom[01;31m-[00m>description().c_str() ));
frame.cc:407:    RPBoundFrame bound = recog[01;31m-[00m>getMatch()[01;31m-[00m>boundFrame();
frame.cc:414:    return "O_Frame origin atom: "+this[01;31m-[00m>_OriginAtomName;
frame.cc:418:{_F(this[01;31m-[00m>lisp());
frame.cc:420:   boundFrame= this[01;31m-[00m>getBoundFrame(mon);
frame.cc:421:   return boundFrame[01;31m-[00m>getCoordinateSystem();
frame.cc:439:{_F(this[01;31m-[00m>lisp());
frame.cc:440:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
frame.cc:445:{_F(this[01;31m-[00m>lisp());
frame.cc:446:    this[01;31m-[00m>Base::archiveBase(node);
frame.cc:454:    class_<O_FrameBase>(this[01;31m-[00m>lisp())
frame.cc:480:    class_<O_Frame>(this[01;31m-[00m>lisp())
frame.cc:512:    class_<O_ExplicitFrame>(this[01;31m-[00m>lisp())
frame.cc:536:    class_<O_OneAtomFrame>(this[01;31m-[00m>lisp())
frame.cc:565:    class_<O_TwoAtomFrame>(this[01;31m-[00m>lisp())
frame.cc:593:    class_<O_RecognizedFrame>(this[01;31m-[00m>lisp())
frame.cc:616:    class_<O_IncompleteFrame>(this[01;31m-[00m>lisp())
frameRecognizer.cc:14:    this[01;31m-[00m>_GroupName = "";
frameRecognizer.cc:18:{_F(this[01;31m-[00m>lisp());
frameRecognizer.cc:19:    this[01;31m-[00m>_Smarts = osm;
frameRecognizer.cc:20:    this[01;31m-[00m>_ChemInfo = chemInfo::O_ChemInfo::create(this[01;31m-[00m>lisp());
frameRecognizer.cc:21:    this[01;31m-[00m>_ChemInfo [01;31m-[00m>compileSmarts(this[01;31m-[00m>_Smarts);
frameRecognizer.cc:22:    if ( !this[01;31m-[00m>_ChemInfo[01;31m-[00m>compileSucceeded() )
frameRecognizer.cc:24:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Error compiling ChemInfo: %s") % this[01;31m-[00m>_ChemInfo));
frameRecognizer.cc:27:    LOG(BF("ChemInfo code = %s") % this[01;31m-[00m>_ChemInfo[01;31m-[00m>asXmlString().c_str()  ); // vp0(("ChemInfo code = %s",this[01;31m-[00m>_ChemInfo[01;31m-[00m>asXmlString().c_str() ));
frameRecognizer.cc:34:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
frameRecognizer.cc:36:    if ( node[01;31m-[00m>loading() )
frameRecognizer.cc:38:	if ( node[01;31m-[00m>hasAttribute("name") )
frameRecognizer.cc:40:	    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
frameRecognizer.cc:43:	    node[01;31m-[00m>attribute("_key",this[01;31m-[00m>_Name);
frameRecognizer.cc:47:	node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
frameRecognizer.cc:50:    node[01;31m-[00m>attribute("smarts",this[01;31m-[00m>_Smarts);
frameRecognizer.cc:51:    node[01;31m-[00m>attributeIfNotDefault<string>("groupName",this[01;31m-[00m>_GroupName,"");
frameRecognizer.cc:53:    if ( node[01;31m-[00m>loading() )
frameRecognizer.cc:57:            this[01;31m-[00m>compileSmarts(this[01;31m-[00m>_Smarts);
frameRecognizer.cc:60:	    TOSS(_lisp[01;31m-[00m>create<O_ArchiveError>(BF("Could not parse Smarts code for %s %s")% this[01;31m-[00m>_Smarts % err.message(), node ));
frameRecognizer.cc:68:{_F(this[01;31m-[00m>lisp());
frameRecognizer.cc:69:    ASSERT_NOT_NULL(this[01;31m-[00m>_ChemInfo);
frameRecognizer.cc:70:    ASSERT(this[01;31m-[00m>_ChemInfo[01;31m-[00m>compileSucceeded());
frameRecognizer.cc:71:    return this[01;31m-[00m>_ChemInfo[01;31m-[00m>matches(o);
frameRecognizer.cc:76:{_F(this[01;31m-[00m>lisp());
frameRecognizer.cc:77:    return this[01;31m-[00m>_ChemInfo[01;31m-[00m>getMatch();
frameRecognizer.cc:84:    this[01;31m-[00m>_Name = fn;
frameRecognizer.cc:88:{_F(this[01;31m-[00m>lisp());
frameRecognizer.cc:89:    ASSERT_NOT_NULL(this[01;31m-[00m>_ChemInfo);
frameRecognizer.cc:90:    return this[01;31m-[00m>_ChemInfo[01;31m-[00m>depth();
frameRecognizer.cc:96:    return this[01;31m-[00m>_Name;
frameRecognizer.cc:101:    this[01;31m-[00m>_GroupName = fn;
frameRecognizer.cc:106:    if ( this[01;31m-[00m>_GroupName == "" )
frameRecognizer.cc:107:	return this[01;31m-[00m>_Name;
frameRecognizer.cc:108:    return this[01;31m-[00m>_GroupName;
frameRecognizer.cc:116:    ss << "FrameRecognizer("<<this[01;31m-[00m>_Name<<"/GroupName("<<this[01;31m-[00m>_GroupName<<")";
frameRecognizer.cc:124:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
frameRecognizer.cc:125:    this[01;31m-[00m>_Name = dict[01;31m-[00m>getStringAndRemove("name");
frameRecognizer.cc:126:    this[01;31m-[00m>_Smarts = dict[01;31m-[00m>getStringAndRemove("smarts");
frameRecognizer.cc:127:    this[01;31m-[00m>_GroupName = dict[01;31m-[00m>getStringAndRemoveOrDefault("groupName","");
frameRecognizer.cc:128:    this[01;31m-[00m>_ChemInfo = O_ChemInfo::create(this[01;31m-[00m>lisp());
frameRecognizer.cc:129:    this[01;31m-[00m>_ChemInfo[01;31m-[00m>compileSmarts(this[01;31m-[00m>_Smarts);
frameRecognizer.cc:130:    if ( !this[01;31m-[00m>_ChemInfo[01;31m-[00m>compileSucceeded() )
frameRecognizer.cc:132:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(this[01;31m-[00m>_ChemInfo[01;31m-[00m>compilerMessage()));
frameRecognizer.cc:142:    class_<O_FrameRecognizer>(this[01;31m-[00m>lisp())
frameTransform.cc:21:	this[01;31m-[00m>Base::initialize();
frameTransform.cc:22:	this[01;31m-[00m>_OffsetOfTransform = [01;31m-[00m1;
frameTransform.cc:26:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:27:    this[01;31m-[00m>_TransformName = tn;
frameTransform.cc:28:    this[01;31m-[00m>_InternalFrameName = fn;
frameTransform.cc:33:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:34:    node[01;31m-[00m>attribute("transformName",this[01;31m-[00m>_TransformName);
frameTransform.cc:35:    node[01;31m-[00m>attribute("frameName",this[01;31m-[00m>_InternalFrameName);
frameTransform.cc:36:    node[01;31m-[00m>attribute<unsigned int>("matrixIdx",this[01;31m-[00m>_OffsetOfTransform );
frameTransform.cc:41:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:42:    this[01;31m-[00m>O_FrameTransformBase::archiveBase(node);
frameTransform.cc:43://    node[01;31m-[00m>archivePlainObject("transform","Matrix",this[01;31m-[00m>_FromCanonicalTransform);
frameTransform.cc:44://    LOG(BF("After serializing matrix got: %s") % (this[01;31m-[00m>_FromCanonicalTransform.asString().c_str() ) ); // vp0(("After serializing matrix got: %s",this[01;31m-[00m>_FromCanonicalTransform.asString().c_str() ));
frameTransform.cc:51:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:52:    this[01;31m-[00m>O_FrameTransform::archiveBase(node);
frameTransform.cc:53:    node[01;31m-[00m>attribute("plug",this[01;31m-[00m>_PlugName);
frameTransform.cc:54://    node[01;31m-[00m>archiveObject("extractFinishFrame",this[01;31m-[00m>_ExtractFinishFrame);
frameTransform.cc:66:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:71:    transformName = ff[01;31m-[00m>getAlias();
frameTransform.cc:73:    boundFrame = ff[01;31m-[00m>getBoundFrame(mon);
frameTransform.cc:75:    frameCoord = boundFrame[01;31m-[00m>getCoordinateSystem();
frameTransform.cc:77:    Matrix transform = anchor[01;31m-[00m>matrixForTransformTo(frameCoord);
frameTransform.cc:86:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:90:    string transformName = ff[01;31m-[00m>getAlias();
frameTransform.cc:91:    string frameName = ff[01;31m-[00m>getInternalFrameName();
frameTransform.cc:93:    this[01;31m-[00m>setTransformAndFrameName(transformName,frameName);
frameTransform.cc:106:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:107:    this[01;31m-[00m>_PlugName = ff[01;31m-[00m>getPlugName();
frameTransform.cc:108:    string transformName = ff[01;31m-[00m>getAlias();
frameTransform.cc:110:    this[01;31m-[00m>setTransformAndFrameName(transformName,transformName);
frameTransform.cc:112://    this[01;31m-[00m>O_FrameTransform::defineFromExtractFrame(ff,anchor,mon);
frameTransform.cc:119:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:120:    this[01;31m-[00m>O_FrameTransform::archiveBase(node);
frameTransform.cc:127:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:128:    string transformName = ff[01;31m-[00m>getAlias();
frameTransform.cc:129:    string frameName = ff[01;31m-[00m>getInternalFrameName();
frameTransform.cc:131:    this[01;31m-[00m>setTransformAndFrameName(transformName,frameName);
frameTransform.cc:132://    this[01;31m-[00m>O_FrameTransform::defineFromExtractFrame(ff,anchor,mon);
frameTransform.cc:138:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:139:    this[01;31m-[00m>O_FrameTransformBase::archiveBase(node);
frameTransform.cc:147:{_F(this[01;31m-[00m>lisp());
frameTransform.cc:148:    this[01;31m-[00m>setTransformAndFrameName(ff[01;31m-[00m>getAlias(),ff[01;31m-[00m>getInternalFrameName());
fs.cc:21:    this[01;31m-[00m>Base::initialize();
fs.cc:33:{_F(this[01;31m-[00m>lisp());
fs.cc:34:    string sp = keyed[01;31m-[00m>getStringAndRemoveOrDefault("path","");
fs.cc:37:	this[01;31m-[00m>setPath(sp);
fs.cc:51:{_F(this[01;31m-[00m>lisp());
fs.cc:53:    this[01;31m-[00m>_Path = p;
fs.cc:57:{_F(this[01;31m-[00m>lisp());
fs.cc:58:    return this[01;31m-[00m>_Path.file_string();
fs.cc:62:{_F(this[01;31m-[00m>lisp());
fs.cc:63:    return this[01;31m-[00m>_Path.stem();
fs.cc:67:{_F(this[01;31m-[00m>lisp());
fs.cc:68:    return this[01;31m-[00m>_Path.extension();
fs.cc:75:    return boost::filesystem::exists(this[01;31m-[00m>_Path);
fs.cc:79:{_F(rpath[01;31m-[00m>lisp());
fs.cc:80:    bf::path p(rpath[01;31m-[00m>getPath());
fs.cc:83:    list = O_Cons::create(this[01;31m-[00m>env(),O_Object::nil(this[01;31m-[00m>env()),O_Cons::nil(this[01;31m-[00m>env()));
fs.cc:88:        tail[01;31m-[00m>setCdr(O_Cons::create(this[01;31m-[00m>env(),O_String::create(itr[01;31m-[00m>path().file_string()),O_Cons::nil(this[01;31m-[00m>env())));
fs.cc:89:	tail = tail[01;31m-[00m>cdr();
fs.cc:91:    return list[01;31m-[00m>cdr();
fs.cc:96:{_F(rpath1[01;31m-[00m>lisp());
fs.cc:97:    return bf::rename(rpath1[01;31m-[00m>getPath(),rpath2[01;31m-[00m>getPath());
fs.cc:101:{_F(rpath[01;31m-[00m>lisp());
fs.cc:102:    return bf::remove(rpath[01;31m-[00m>getPath());
fs.cc:106:{_F(rpath[01;31m-[00m>lisp());
fs.cc:107:    return bf::remove_all(rpath[01;31m-[00m>getPath());
fs.cc:112:{_F(rpath[01;31m-[00m>lisp());
fs.cc:113:    return bf::create_directory(rpath[01;31m-[00m>getPath());
fs.cc:123:	class_<O_Path>(ClPackage,this[01;31m-[00m>env())
gamessInterface.cc:29:	void close() { this[01;31m-[00m>_Fin.close(); };
gamessInterface.cc:30:	bool fail() { return this[01;31m-[00m>_Fin.fail(); };
gamessInterface.cc:31:	bool eof() { return this[01;31m-[00m>_Fin.eof(); };
gamessInterface.cc:32:	void ignoreSpaces(bool b) { this[01;31m-[00m>_IgnoreSpaces = b; };
gamessInterface.cc:38:    RPLisp lisp() { return this[01;31m-[00m>_WeakLisp.lock();};
gamessInterface.cc:39:    GamessArchiveReader(RPLisp lisp) { this[01;31m-[00m>_WeakLisp = lisp;};
gamessInterface.cc:44:    this[01;31m-[00m>_Fin.exceptions(ios::goodbit);
gamessInterface.cc:45:    this[01;31m-[00m>_Fin.open(fileName.c_str(),ios::in);
gamessInterface.cc:46:    this[01;31m-[00m>_IgnoreSpaces = false;
gamessInterface.cc:50:{_F(this[01;31m-[00m>lisp());
gamessInterface.cc:53:    while ( !this[01;31m-[00m>_Fin.eof() && (c = this[01;31m-[00m>_Fin.get()) != symbol  )
gamessInterface.cc:57:	    if ( !(this[01;31m-[00m>_IgnoreSpaces&& c==' ') )
gamessInterface.cc:67:{_F(this[01;31m-[00m>lisp());
gamessInterface.cc:72:        if ( this[01;31m-[00m>eof() ) break;
gamessInterface.cc:73:        line = this[01;31m-[00m>readToSymbol(lineDelimiter);
gamessInterface.cc:76:    } while (!this[01;31m-[00m>eof());
gamessInterface.cc:82:{_F(this[01;31m-[00m>lisp());
gamessInterface.cc:83:    return this[01;31m-[00m>readToSymbol('\n');
gamessInterface.cc:97:    this[01;31m-[00m>open(fileName);
gamessInterface.cc:98:    if ( this[01;31m-[00m>fail() )
gamessInterface.cc:107:	    line = this[01;31m-[00m>readLine();
gamessInterface.cc:114:		    this[01;31m-[00m>ignoreSpaces(true);
gamessInterface.cc:117:		    string header = this[01;31m-[00m>readBlankLineTerminatedString('\\');
gamessInterface.cc:118:		    if ( this[01;31m-[00m>eof() ) break;
gamessInterface.cc:119:		    string job = this[01;31m-[00m>readBlankLineTerminatedString('\\');
gamessInterface.cc:120:		    if ( this[01;31m-[00m>eof() ) break;
gamessInterface.cc:121:		    string title = this[01;31m-[00m>readBlankLineTerminatedString('\\');
gamessInterface.cc:122:		    if ( this[01;31m-[00m>eof() ) break;
gamessInterface.cc:123:		    string chargeSpin = this[01;31m-[00m>readToSymbol('\\');
gamessInterface.cc:124:		    if ( this[01;31m-[00m>eof() ) break;
gamessInterface.cc:129:			line = this[01;31m-[00m>readToSymbol('\\');
gamessInterface.cc:131:			if ( this[01;31m-[00m>eof() ) break;
gamessInterface.cc:140:			coords[01;31m-[00m>setElement(atomIndex,v);
gamessInterface.cc:143:		    while ( !this[01;31m-[00m>eof() );
gamessInterface.cc:144:		    if ( this[01;31m-[00m>eof() ) break;
gamessInterface.cc:148:			line = this[01;31m-[00m>readToSymbol('\\');
gamessInterface.cc:149:			if ( this[01;31m-[00m>eof() ) break;
gamessInterface.cc:159:			data[01;31m-[00m>setString(varName,value);
gamessInterface.cc:160:		    } while ( !this[01;31m-[00m>eof() );
gamessInterface.cc:161:		    if ( this[01;31m-[00m>eof() ) break;
gamessInterface.cc:164:	} while (!this[01;31m-[00m>eof() && !done );
gamessInterface.cc:166:	if ( this[01;31m-[00m>eof() )
gamessInterface.cc:172:    this[01;31m-[00m>close();
gamessInterface.cc:190:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
gamessInterface.cc:195:    this[01;31m-[00m>Base::initialize();
gamessInterface.cc:201:{_F(this[01;31m-[00m>lisp());
gamessInterface.cc:202:    this[01;31m-[00m>O_ExternalInterface::archiveBase(node);
gamessInterface.cc:209:{_F(this[01;31m-[00m>lisp());
gamessInterface.cc:213:    this[01;31m-[00m>O_ExternalInterface::setConformationExplorer(explorer);
gamessInterface.cc:215:    for ( ai=explorer[01;31m-[00m>begin_AllAtoms(); ai!=explorer[01;31m-[00m>end_AllAtoms(); ai++ )
gamessInterface.cc:218:	atomName << (*ai)[01;31m-[00m>getElement() << atomIndex;
gamessInterface.cc:219:	this[01;31m-[00m>_AtomNames[01;31m-[00m>append(atomName.str());
gamessInterface.cc:220:	this[01;31m-[00m>_AtomNamesToAtoms.set(atomName.str(),*ai);
gamessInterface.cc:227:{_F(this[01;31m-[00m>lisp());
gamessInterface.cc:237:    explorer = stage[01;31m-[00m>getConformationExplorer();
gamessInterface.cc:238:    totalCharge = explorer[01;31m-[00m>getMatter()[01;31m-[00m>totalNetResidueCharge();
gamessInterface.cc:240:    coords = stage[01;31m-[00m>getFinalCoordinates();
gamessInterface.cc:241:    ic = coords[01;31m-[00m>begin();
gamessInterface.cc:242:    in = this[01;31m-[00m>_AtomNames[01;31m-[00m>begin();
gamessInterface.cc:243:    for ( ai=explorer[01;31m-[00m>begin_AllAtoms(); ai!=explorer[01;31m-[00m>end_AllAtoms(); ai++)
gamessInterface.cc:246:	Vector3 pos = (*ai)[01;31m-[00m>getPosition();
gamessInterface.cc:247:	int atomicNumber = (*ai)[01;31m-[00m>getAtomicNumber();
gamessInterface.cc:262:{_F(this[01;31m-[00m>lisp());
gamessInterface.cc:263:    return this[01;31m-[00m>parseSummaryFileForFinalConformationAndEnergy(entryStage);
gamessInterface.cc:276:    class_<O_GamessInterface>(this[01;31m-[00m>lisp())
gaussianInterface.cc:28:	void close() { this[01;31m-[00m>_Fin.close(); };
gaussianInterface.cc:29:	bool fail() { return this[01;31m-[00m>_Fin.fail(); };
gaussianInterface.cc:30:	bool eof() { return this[01;31m-[00m>_Fin.eof(); };
gaussianInterface.cc:31:	void ignoreSpaces(bool b) { this[01;31m-[00m>_IgnoreSpaces = b; };
gaussianInterface.cc:37:    GaussianArchiveReader(RPLisp lisp) { this[01;31m-[00m>_WeakLisp = lisp;};
gaussianInterface.cc:38:    RPLisp lisp() { return this[01;31m-[00m>_WeakLisp.lock();};
gaussianInterface.cc:43://    this[01;31m-[00m>_Fin = fileName.open(ios::in);
gaussianInterface.cc:45:    this[01;31m-[00m>_Fin.exceptions(ios::goodbit);
gaussianInterface.cc:48:    this[01;31m-[00m>_Fin.open(fileName.string().c_str(),ios::in);
gaussianInterface.cc:49:    this[01;31m-[00m>_IgnoreSpaces = false;
gaussianInterface.cc:53:{_F(this[01;31m-[00m>lisp());
gaussianInterface.cc:56:    while ( !this[01;31m-[00m>_Fin.eof() && (c = this[01;31m-[00m>_Fin.get()) != symbol  )
gaussianInterface.cc:60:	    if ( !(this[01;31m-[00m>_IgnoreSpaces&& c==' ') )
gaussianInterface.cc:70:{_F(this[01;31m-[00m>lisp());
gaussianInterface.cc:75:        if ( this[01;31m-[00m>eof() ) break;
gaussianInterface.cc:76:        line = this[01;31m-[00m>readToSymbol(lineDelimiter);
gaussianInterface.cc:79:    } while (!this[01;31m-[00m>eof());
gaussianInterface.cc:85:{_F(this[01;31m-[00m>lisp());
gaussianInterface.cc:86:    return this[01;31m-[00m>readToSymbol('\n');
gaussianInterface.cc:92:{_F(this[01;31m-[00m>lisp());
gaussianInterface.cc:102:    this[01;31m-[00m>open(fileName);
gaussianInterface.cc:103:    if ( this[01;31m-[00m>fail() )
gaussianInterface.cc:113:	    line = this[01;31m-[00m>readLine();
gaussianInterface.cc:120:		    this[01;31m-[00m>ignoreSpaces(true);
gaussianInterface.cc:123:		    string header = this[01;31m-[00m>readBlankLineTerminatedString('\\');
gaussianInterface.cc:124:		    if ( this[01;31m-[00m>eof() ) break;
gaussianInterface.cc:125:		    string job = this[01;31m-[00m>readBlankLineTerminatedString('\\');
gaussianInterface.cc:126:		    if ( this[01;31m-[00m>eof() ) break;
gaussianInterface.cc:127:		    string title = this[01;31m-[00m>readBlankLineTerminatedString('\\');
gaussianInterface.cc:128:		    if ( this[01;31m-[00m>eof() ) break;
gaussianInterface.cc:129:		    string chargeSpin = this[01;31m-[00m>readToSymbol('\\');
gaussianInterface.cc:130:		    if ( this[01;31m-[00m>eof() ) break;
gaussianInterface.cc:135:			line = this[01;31m-[00m>readToSymbol('\\');
gaussianInterface.cc:137:			if ( this[01;31m-[00m>eof() ) break;
gaussianInterface.cc:146:			coords[01;31m-[00m>setElement(atomIndex,v);
gaussianInterface.cc:149:		    while ( !this[01;31m-[00m>eof() );
gaussianInterface.cc:150:		    if ( this[01;31m-[00m>eof() ) break;
gaussianInterface.cc:154:			line = this[01;31m-[00m>readToSymbol('\\');
gaussianInterface.cc:155:			if ( this[01;31m-[00m>eof() ) break;
gaussianInterface.cc:165:			data[01;31m-[00m>setString(varName,value);
gaussianInterface.cc:166:		    } while ( !this[01;31m-[00m>eof() );
gaussianInterface.cc:167:		    if ( this[01;31m-[00m>eof() ) break;
gaussianInterface.cc:193:	    } else if ( line.find(" [01;31m-[00m[01;31m-[00m Stationary point") != string::npos )
gaussianInterface.cc:197:	} while (!this[01;31m-[00m>eof() && !done );
gaussianInterface.cc:199:	if ( this[01;31m-[00m>eof() )
gaussianInterface.cc:208:    data[01;31m-[00m>setTextBlock(varName,value);
gaussianInterface.cc:209:    this[01;31m-[00m>close();
gaussianInterface.cc:221:    this[01;31m-[00m>Base::initialize();
gaussianInterface.cc:222:    this[01;31m-[00m>_GaussianAtomNames = O_StringList::create(this[01;31m-[00m>lisp());
gaussianInterface.cc:230:{_F(this[01;31m-[00m>lisp());
gaussianInterface.cc:231:    this[01;31m-[00m>O_ExternalInterface::archiveBase(node);
gaussianInterface.cc:238:{_F(this[01;31m-[00m>lisp());
gaussianInterface.cc:242:    this[01;31m-[00m>O_ExternalInterface::setConformationExplorer(explorer);
gaussianInterface.cc:244:    for ( ai=explorer[01;31m-[00m>begin_AllAtoms(); ai!=explorer[01;31m-[00m>end_AllAtoms(); ai++ )
gaussianInterface.cc:247:	atomName << (*ai)[01;31m-[00m>getElement() << atomIndex;
gaussianInterface.cc:248:	this[01;31m-[00m>_GaussianAtomNames[01;31m-[00m>append(atomName.str());
gaussianInterface.cc:249:	this[01;31m-[00m>_GaussianAtomNamesToAtoms.set(atomName.str(),*ai);
gaussianInterface.cc:256:{_F(this[01;31m-[00m>lisp());
gaussianInterface.cc:267:    explorer = stage[01;31m-[00m>getConformationExplorer();
gaussianInterface.cc:268:    totalCharge = explorer[01;31m-[00m>getMatter()[01;31m-[00m>totalNetResidueCharge();
gaussianInterface.cc:270:    coords = stage[01;31m-[00m>getFinalCoordinates();
gaussianInterface.cc:271:    ic = coords[01;31m-[00m>begin();
gaussianInterface.cc:272:    in = this[01;31m-[00m>_GaussianAtomNames[01;31m-[00m>begin();
gaussianInterface.cc:274:    for ( ai=explorer[01;31m-[00m>begin_AllAtoms(); ai!=explorer[01;31m-[00m>end_AllAtoms(); ai++)
gaussianInterface.cc:277:	Vector3 pos = (*ai)[01;31m-[00m>getPosition();
gaussianInterface.cc:291:{_F(this[01;31m-[00m>lisp());
gaussianInterface.cc:304:    fileName = this[01;31m-[00m>assembleFileName(entryStage,this[01;31m-[00m>resultFileExtension());
gaussianInterface.cc:306:    coords = entryStage[01;31m-[00m>getFinalCoordinates();
gaussianInterface.cc:307:    arch.parseFile(fileName, coords, entryStage[01;31m-[00m>getData(), success, this[01;31m-[00m>_ErrorMessages );
gaussianInterface.cc:308:    if (entryStage[01;31m-[00m>getData()[01;31m-[00m>contains("Gaussian_HF") )
gaussianInterface.cc:310:        string energyString = entryStage[01;31m-[00m>getData()[01;31m-[00m>getString("Gaussian_HF");
gaussianInterface.cc:312:        entryStage[01;31m-[00m>setEnergyKCal(hartrees*627.509); // Hartrees in kCal/mole
gaussianInterface.cc:315:        entryStage[01;31m-[00m>setEnergyKCal(0.0);
gaussianInterface.cc:328:    class_<O_GaussianInterface>(this[01;31m-[00m>lisp())
groupPart.cc:19:    this[01;31m-[00m>Base::initialize();
groupPart.cc:24:    node[01;31m-[00m>attribute("groupName",this[01;31m-[00m>_GroupName);
groupPart.cc:25:    node[01;31m-[00m>attribute("partName",this[01;31m-[00m>_PartName);
groupPart.cc:31:    this[01;31m-[00m>Base::oldLispInitialize(keyed,env);
groupPart.cc:32:    this[01;31m-[00m>_GroupName = keyed[01;31m-[00m>getStringAndRemove("group");
groupPart.cc:33:    this[01;31m-[00m>_PartName = keyed[01;31m-[00m>getStringAndRemove("part");
groupPart.cc:45:	class_<O_GroupPart>(this[01;31m-[00m>lisp())
hierarchy.cc:39:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
hierarchy.cc:45:    this[01;31m-[00m>Base::initialize();
hierarchy.cc:50:    this[01;31m-[00m>Base::archiveBase(node);
hierarchy.cc:57:{_F(this[01;31m-[00m>lisp());
hierarchy.cc:58:    if ( tag[01;31m-[00m>isA(parent) )
hierarchy.cc:60:	TOSS(_lisp[01;31m-[00m>create<O_LispError>((boost::format("%s is already a %s") % tag[01;31m-[00m>__repr__() % parent[01;31m-[00m>__repr__() ).str()));
hierarchy.cc:62:    if ( parent[01;31m-[00m>isA(tag) )
hierarchy.cc:64:	TOSS(_lisp[01;31m-[00m>create<O_LispError>((boost::format("Circular ancestry: %s is already a %s")% parent[01;31m-[00m>__repr__() % tag[01;31m-[00m>__repr__() ).str()));
hierarchy.cc:66:    this[01;31m-[00m>addParent(tag,parent);
hierarchy.cc:67:    RPObjectSet descendants = this[01;31m-[00m>descendants(parent);
hierarchy.cc:68:    this[01;31m-[00m>addAncestor(tag,parent);
hierarchy.cc:69:    this[01;31m-[00m>addDescendant(parent,tag);
hierarchy.cc:70:    descendants = this[01;31m-[00m>descendants(tag);
hierarchy.cc:71:    RPObjectSet ancestors = this[01;31m-[00m>ancestors(tag);
hierarchy.cc:72:    this[01;31m-[00m>eachOfYouAddAllAncestors(descendants,ancestors);
hierarchy.cc:73:    descendants = this[01;31m-[00m>descendants(parent);
hierarchy.cc:74:    ancestors = this[01;31m-[00m>ancestors(parent);
hierarchy.cc:75:    this[01;31m-[00m>eachOfYouAddAllDescendants(ancestors,descendants);
hierarchy.cc:80:{_F(this[01;31m-[00m>lisp());
hierarchy.cc:81:    O_Hierarchy::iterator it = this[01;31m-[00m>_Parents.find(tag);
hierarchy.cc:82:    if ( it == this[01;31m-[00m>_Parents.end() ) return O_ObjectSet::nil(this[01;31m-[00m>lisp());
hierarchy.cc:83:    return it[01;31m-[00m>second;
hierarchy.cc:87:{_F(this[01;31m-[00m>lisp());
hierarchy.cc:88:    O_Hierarchy::iterator it = this[01;31m-[00m>_Descendants.find(tag);
hierarchy.cc:89:    if ( it == this[01;31m-[00m>_Descendants.end() ) return O_ObjectSet::nil(this[01;31m-[00m>lisp());
hierarchy.cc:90:    return it[01;31m-[00m>second;
hierarchy.cc:94:{_F(this[01;31m-[00m>lisp());
hierarchy.cc:95:    O_Hierarchy::iterator it = this[01;31m-[00m>_Ancestors.find(tag);
hierarchy.cc:96:    if ( it == this[01;31m-[00m>_Ancestors.end() ) return O_ObjectSet::nil(this[01;31m-[00m>lisp());
hierarchy.cc:97:    return it[01;31m-[00m>second;
hierarchy.cc:105:    O_Hierarchy::iterator iti = this[01;31m-[00m>_Descendants.find(ancestor);
hierarchy.cc:106:    if ( iti == this[01;31m-[00m>_Descendants.end() ) return false;
hierarchy.cc:107:    if ( iti[01;31m-[00m>second[01;31m-[00m>contains(tag) ) return true;
hierarchy.cc:114:{_F(this[01;31m-[00m>lisp());
hierarchy.cc:115:    O_Hierarchy::iterator it = this[01;31m-[00m>_Parents.find(tag);
hierarchy.cc:116:    if ( it == this[01;31m-[00m>_Parents.end() )
hierarchy.cc:118:	RPObjectSet os = O_ObjectSet::create(this[01;31m-[00m>lisp());
hierarchy.cc:119:	os[01;31m-[00m>insert(parent);
hierarchy.cc:120:	this[01;31m-[00m>_Parents[tag] = os;
hierarchy.cc:123:    it[01;31m-[00m>second[01;31m-[00m>insert(parent);
hierarchy.cc:128:{_F(this[01;31m-[00m>lisp());
hierarchy.cc:129:    O_Hierarchy::iterator it = this[01;31m-[00m>_Ancestors.find(tag);
hierarchy.cc:130:    if ( it == this[01;31m-[00m>_Ancestors.end() )
hierarchy.cc:132:	RPObjectSet os = O_ObjectSet::create(this[01;31m-[00m>lisp());
hierarchy.cc:133:	os[01;31m-[00m>insert(ancestor);
hierarchy.cc:134:	this[01;31m-[00m>_Ancestors[tag] = os;
hierarchy.cc:137:    it[01;31m-[00m>second[01;31m-[00m>insert(ancestor);
hierarchy.cc:141:{_F(this[01;31m-[00m>lisp());
hierarchy.cc:142:    O_Hierarchy::iterator it = this[01;31m-[00m>_Descendants.find(tag);
hierarchy.cc:143:    if ( it == this[01;31m-[00m>_Descendants.end() )
hierarchy.cc:145:	RPObjectSet os = O_ObjectSet::create(this[01;31m-[00m>lisp());
hierarchy.cc:146:	os[01;31m-[00m>insert(descendant);
hierarchy.cc:147:	this[01;31m-[00m>_Descendants[tag] = os;
hierarchy.cc:150:    it[01;31m-[00m>second[01;31m-[00m>insert(descendant);
hierarchy.cc:155:{_F(this[01;31m-[00m>lisp());
hierarchy.cc:157:    for ( it=tagSet[01;31m-[00m>begin(); it!=tagSet[01;31m-[00m>end(); it++ )
hierarchy.cc:159:	RPObjectSet tagAncestors = this[01;31m-[00m>_Ancestors[*it];
hierarchy.cc:160:	tagAncestors[01;31m-[00m>setUnion(ancestors);
hierarchy.cc:167:{_F(this[01;31m-[00m>lisp());
hierarchy.cc:169:    for ( it=tagSet[01;31m-[00m>begin(); it!=tagSet[01;31m-[00m>end(); it++ )
hierarchy.cc:171:	RPObjectSet tagDescendants = this[01;31m-[00m>_Descendants[*it];
hierarchy.cc:172:	tagDescendants[01;31m-[00m>setUnion(descendants);
hits.cc:48:    this[01;31m-[00m>Base::initialize();
hits.cc:49:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
hits.cc:50:    this[01;31m-[00m>_ScorerStageList = O_ScorerStageList::nil(this[01;31m-[00m>lisp());
hits.cc:51://    this[01;31m-[00m>_HitGraphics = O_RenderDisplayList::nil(this[01;31m-[00m>lisp());
hits.cc:52:    this[01;31m-[00m>_BuilderState = O_BuilderState::nil(this[01;31m-[00m>lisp());
hits.cc:53:    this[01;31m-[00m>_ScorerState = O_ScorerState::nil(this[01;31m-[00m>lisp());
hits.cc:54:    this[01;31m-[00m>_TimesSeen = 1;
hits.cc:66:    h[01;31m-[00m>setHitList(hl);
hits.cc:72:    node[01;31m-[00m>archiveWeakPointer("hitList",this[01;31m-[00m>_WeakHitList);
hits.cc:73:    node[01;31m-[00m>attribute("score",this[01;31m-[00m>_Score);
hits.cc:74:    node[01;31m-[00m>attributeIfNotDefault<uint>("timesSeen",this[01;31m-[00m>_TimesSeen,1);
hits.cc:75:    node[01;31m-[00m>archiveObject("builderState",this[01;31m-[00m>_BuilderState);
hits.cc:76:    node[01;31m-[00m>archiveObject("scorerState",this[01;31m-[00m>_ScorerState);
hits.cc:77://    node[01;31m-[00m>archiveObject("hitGraphics",this[01;31m-[00m>_HitGraphics);
hits.cc:78:    node[01;31m-[00m>archiveObject("data",this[01;31m-[00m>_Data);
hits.cc:79:    node[01;31m-[00m>archiveObjectIfDefined("scorerStageList",this[01;31m-[00m>_ScorerStageList);
hits.cc:84:{_F(this[01;31m-[00m>lisp());
hits.cc:85:    if ( !this[01;31m-[00m>_BuilderState[01;31m-[00m>matchesOligomerAndSequenceAndConformation(other[01;31m-[00m>getBuilderState()) ) 
hits.cc:95:{_F(this[01;31m-[00m>lisp());
hits.cc:96:    if ( !this[01;31m-[00m>_BuilderState[01;31m-[00m>matchesOligomerAndSequence(other[01;31m-[00m>getBuilderState()) ) 
hits.cc:106:{_F(this[01;31m-[00m>lisp());
hits.cc:107:    ASSERT_NOT_NULL(this[01;31m-[00m>_ScorerStageList);
hits.cc:108:    if ( this[01;31m-[00m>_ScorerStageList[01;31m-[00m>isNil() )
hits.cc:110:	this[01;31m-[00m>_ScorerStageList = O_ScorerStageList::create(this[01;31m-[00m>lisp());
hits.cc:112:    return this[01;31m-[00m>_ScorerStageList;
hits.cc:116:{_F(this[01;31m-[00m>lisp());
hits.cc:117:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakHitList);
hits.cc:118:    return this[01;31m-[00m>_WeakHitList.lock();
hits.cc:123:{_F(this[01;31m-[00m>lisp());
hits.cc:125:    ss << "hit(score:"<<this[01;31m-[00m>_Score<<" changeCounters(" << this[01;31m-[00m>_BuilderState[01;31m-[00m>changeCountersAsString() << "))  ";
hits.cc:132:    this[01;31m-[00m>_HitGraphics = dl;
hits.cc:139:{_F(this[01;31m-[00m>lisp());
hits.cc:140:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
hits.cc:141:    dl[01;31m-[00m>setName("hitRendered");
hits.cc:142:    RPBuilderScorer bs = this[01;31m-[00m>getHitList()[01;31m-[00m>getBuilderScorer();
hits.cc:143:    bs[01;31m-[00m>restoreState(this[01;31m-[00m>_BuilderState);
hits.cc:144:    bs[01;31m-[00m>buildAllUntransformedAtomPositions(); // build all atom positions for rendering
hits.cc:145:    bs[01;31m-[00m>writeScoreTransformedCoordinatesToBuiltMolecule(this[01;31m-[00m>getScorerState());
hits.cc:146:    RPMolecule mol = bs[01;31m-[00m>getBuiltMolecule();
hits.cc:147:    ASSERT_NOT_NULL(this[01;31m-[00m>_ScorerState);
hits.cc:148:    RPRender molRender = mol[01;31m-[00m>rendered(opts);
hits.cc:149:    molRender[01;31m-[00m>setName("molecule");
hits.cc:150:    dl[01;31m-[00m>add(molRender);
hits.cc:152:    fmt % this[01;31m-[00m>getScore() % this[01;31m-[00m>getTimesSeen();
hits.cc:153:    RPGrInformation info = O_GrInformation::create(fmt.str(),this[01;31m-[00m>lisp());
hits.cc:154:    dl[01;31m-[00m>add(info);
hits.cc:156:	// Render the hit graphics [01;31m-[00m I should get rid of hit graphics
hits.cc:160:	RPRenderDisplayList render = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
hits.cc:161:	render[01;31m-[00m>setName("savedHitGraphics");
hits.cc:162:	render[01;31m-[00m>add(this[01;31m-[00m>_HitGraphics);
hits.cc:163:	dl[01;31m-[00m>add(render);
hits.cc:169:	RPRenderDisplayList render = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
hits.cc:170:	render[01;31m-[00m>setName("hitGraphics");
hits.cc:171:        RPRenderDisplayList hitGraphics = bs[01;31m-[00m>getRenderForScore(this[01;31m-[00m>_ScorerState);
hits.cc:172:	render[01;31m-[00m>add(hitGraphics);
hits.cc:173:	dl[01;31m-[00m>add(render);
hits.cc:175:    dl[01;31m-[00m>add(this[01;31m-[00m>data()[01;31m-[00m>rendered(opts));
hits.cc:176:    if ( this[01;31m-[00m>_ScorerStageList[01;31m-[00m>notNil() )
hits.cc:178:	if ( this[01;31m-[00m>_ScorerStageList[01;31m-[00m>canRender() )
hits.cc:180:	    dl[01;31m-[00m>add(this[01;31m-[00m>_ScorerStageList[01;31m-[00m>rendered(opts));
hits.cc:195:    return this[01;31m-[00m>_Score;
hits.cc:202:Set the score value of the hit.  Only use this method on hits that haven't been added yet to a HitList [01;31m-[00m once the hit is in a HitList changing the score will mess up the ordering in the HitList.
hits.cc:207:    this[01;31m-[00m>_Score = score;
hits.cc:212:{_F(this[01;31m-[00m>lisp());
hits.cc:213:    if ( this[01;31m-[00m>_BuilderState[01;31m-[00m>matchesOligomerAndSequence(otherHit[01;31m-[00m>getBuilderState()))  return true;
hits.cc:230:    return this[01;31m-[00m>_Data; 
hits.cc:241:{_F(this[01;31m-[00m>lisp());
hits.cc:242:    RPHitList hl = this[01;31m-[00m>getHitList();
hits.cc:243:    RPBuilderScorer builderScorer = hl[01;31m-[00m>getBuilderScorer();
hits.cc:244:    RPBuilderState builderState = this[01;31m-[00m>getBuilderState();
hits.cc:245:    builderScorer[01;31m-[00m>restoreState(builderState);
hits.cc:246:    builderScorer[01;31m-[00m>buildAllUntransformedAtomPositions();
hits.cc:247:    builderScorer[01;31m-[00m>writeScoreTransformedCoordinatesToBuiltMolecule(this[01;31m-[00m>getScorerState());
hits.cc:248:    return builderScorer[01;31m-[00m>getBuiltMolecule();
hits.cc:260:{_F(this[01;31m-[00m>lisp());
hits.cc:261:    RPHitList hl = this[01;31m-[00m>getHitList();
hits.cc:262:    RPBuilderScorer builderScorer = hl[01;31m-[00m>getBuilderScorer();
hits.cc:263:    RPBuilderState builderState = this[01;31m-[00m>getBuilderState();
hits.cc:264:    builderScorer[01;31m-[00m>restoreState(builderState);
hits.cc:271:{_F(this[01;31m-[00m>lisp());
hits.cc:272:    return this[01;31m-[00m>_BuilderState;
hits.cc:277:{_F(this[01;31m-[00m>lisp());
hits.cc:278:    return this[01;31m-[00m>_ScorerState;
hits.cc:282:{_F(this[01;31m-[00m>lisp());
hits.cc:283:    this[01;31m-[00m>_ScorerState = state;
hits.cc:287:{_F(this[01;31m-[00m>lisp());
hits.cc:288:    this[01;31m-[00m>_BuilderState = state;
hits.cc:293:    this[01;31m-[00m>_TimesSeen++;
hits.cc:304:{_F(this[01;31m-[00m>lisp());
hits.cc:305:    RPScorerBase scorer= this[01;31m-[00m>getData()[01;31m-[00m>get("scorer")[01;31m-[00m>as<O_ScorerBase>();
hits.cc:312:{_F(this[01;31m-[00m>lisp());
hits.cc:313:    RPScorerBase scorer = this[01;31m-[00m>_getScorer();
hits.cc:314:    RPBuilder builder = this[01;31m-[00m>getBuilder();
hits.cc:315:    scorer[01;31m-[00m>builderChanged(builder);
hits.cc:321:{_F(this[01;31m-[00m>lisp());
hits.cc:322:    RPBuilderState state = this[01;31m-[00m>getData()[01;31m-[00m>get("builderState")[01;31m-[00m>as<O_BuilderState>();
hits.cc:323:    RPBuilder builder = state[01;31m-[00m>getBuilder();
hits.cc:324:    state[01;31m-[00m>applyToBuilder(builder);
hits.cc:339:    uint maxHits = kargs[01;31m-[00m>getIntAndRemoveOrDefault("maxHits",100);
hits.cc:340:    RPBuilderDatabase bdb = kargs[01;31m-[00m>getAndRemoveOrDefault("optionalDatabase",O_BuilderDatabase::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_BuilderDatabase>();
hits.cc:341:    RPBuilderScorer bs = kargs[01;31m-[00m>getAndRemoveOrDefault("builderScorer",O_BuilderScorer::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_BuilderScorer>();
hits.cc:342:    this[01;31m-[00m>setBuilderScorer(bs);
hits.cc:343:    this[01;31m-[00m>setMaxEntries(maxHits);
hits.cc:344:    this[01;31m-[00m>setOptionalBuilderDatabase(bdb);
hits.cc:359:    this[01;31m-[00m>Base::initialize();
hits.cc:360:    this[01;31m-[00m>_SearchStatistics = O_SearchStatistics::create(this[01;31m-[00m>lisp());
hits.cc:361:    this[01;31m-[00m>_SearchStatistics[01;31m-[00m>setReportFrequency(1000);
hits.cc:362:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
hits.cc:363:    this[01;31m-[00m>_Hits.clear();
hits.cc:364:    this[01;31m-[00m>_AvoidDuplicateScores = false;
hits.cc:365:    this[01;31m-[00m>_OptionalBuilderDatabase = O_BuilderDatabase::nil(this[01;31m-[00m>lisp());
hits.cc:366:    this[01;31m-[00m>_BuilderScorer = O_BuilderScorer::nil(this[01;31m-[00m>lisp());
hits.cc:367:    this[01;31m-[00m>_AllowMultipleHitsWithTheSameSequence = false;
hits.cc:376:{_F(this[01;31m-[00m>lisp());
hits.cc:378:    this[01;31m-[00m>_AllowMultipleHitsWithTheSameSequence = ig;
hits.cc:382:{_F(this[01;31m-[00m>lisp());
hits.cc:384:    	% this[01;31m-[00m>_AllowMultipleHitsWithTheSameSequence );
hits.cc:385:    return this[01;31m-[00m>_AllowMultipleHitsWithTheSameSequence;
hits.cc:392:{_F(this[01;31m-[00m>lisp());
hits.cc:394:    h = O_Hit::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>sharedThis<O_HitList>());
hits.cc:399:{_F(this[01;31m-[00m>lisp());
hits.cc:400:    this[01;31m-[00m>_OptionalBuilderDatabase = bdb;
hits.cc:405:{_F(this[01;31m-[00m>lisp());
hits.cc:406:    RPCons entries = O_Cons::nil(this[01;31m-[00m>lisp());
hits.cc:408:    for ( hit=this[01;31m-[00m>end()[01;31m-[00m1; hit>=this[01;31m-[00m>begin(); hit[01;31m-[00m[01;31m-[00m )
hits.cc:410:	entries = O_Cons::create(*hit,entries,this[01;31m-[00m>lisp());
hits.cc:417:    ASSERT_NOT_NULL(this[01;31m-[00m>_OptionalBuilderDatabase);
hits.cc:418:    return this[01;31m-[00m>_OptionalBuilderDatabase;
hits.cc:423:{_F(this[01;31m-[00m>lisp());
hits.cc:424:    RPHitList copy = RP_Create<O_HitList>(this[01;31m-[00m>lisp());
hits.cc:425:    copy[01;31m-[00m>setAllowMultipleHitsWithTheSameSequence(this[01;31m-[00m>getAllowMultipleHitsWithTheSameSequence());
hits.cc:426:    copy[01;31m-[00m>setMaxEntries(this[01;31m-[00m>_MaxEntries);
hits.cc:427:    copy[01;31m-[00m>setOptionalBuilderDatabase(this[01;31m-[00m>getOptionalBuilderDatabase());
hits.cc:428:    copy[01;31m-[00m>setBuilderScorer(this[01;31m-[00m>_BuilderScorer);
hits.cc:436:{_F(this[01;31m-[00m>lisp());
hits.cc:439:    ASSERT(builderScorer[01;31m-[00m>notNil());
hits.cc:440:    ASSERT(this[01;31m-[00m>_BuilderScorer[01;31m-[00m>notNil());
hits.cc:441:    if ( this[01;31m-[00m>_BuilderScorer != builderScorer )
hits.cc:443:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("The other builderScorer(%s) does not match this[01;31m-[00m>_BuilderScorer(%s)") % builderScorer[01;31m-[00m>description() % this[01;31m-[00m>_BuilderScorer[01;31m-[00m>description() ));
hits.cc:445:    ASSERTP(this[01;31m-[00m>_BuilderScorer == builderScorer, "The builderScorer does not match mine" );
hits.cc:446:    builderScorer[01;31m-[00m>throwIfScorerStateOutOfSync(scorerState);
hits.cc:452://    builderState[01;31m-[00m>getBuilder()[01;31m-[00m>buildInterestingUntransformedAtomPositions(); // test
hits.cc:455:    RPBuilderState hitBuilderState = builderState[01;31m-[00m>copy();
hits.cc:456:    hitBuilderState[01;31m-[00m>setComment(hitBuilderState[01;31m-[00m>changeCountersAsString());
hits.cc:457:    LOG(BF("creating hit for builderState %s with score: %lf")% hitBuilderState[01;31m-[00m>changeCountersAsString() % scorerState[01;31m-[00m>getScore() );
hits.cc:458:    if ( !hitBuilderState[01;31m-[00m>matchesBuilder(builderScorer[01;31m-[00m>getBuilder()) )
hits.cc:460:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("When coming into createHitWithStates the Builder must be in the same state as the BuilderState but it wasn't"));
hits.cc:462:    RPScorerState hitScorerState = scorerState[01;31m-[00m>copy();
hits.cc:463://    hitBuilderState[01;31m-[00m>setScorerState(hitScorerState);
hits.cc:464:    RPHit hit = this[01;31m-[00m>createHit();
hits.cc:465:    hit[01;31m-[00m>setScore(hitScorerState[01;31m-[00m>getScore());
hits.cc:466:    hit[01;31m-[00m>setBuilderState(hitBuilderState);
hits.cc:467:    hit[01;31m-[00m>setScorerState(hitScorerState);
hits.cc:468://    RPRenderDisplayList hitGraphics = builderScorer[01;31m-[00m>getRenderForScore(hitScorerState);
hits.cc:469://    hit[01;31m-[00m>setHitGraphics(hitGraphics);
hits.cc:470:    this[01;31m-[00m>addHit(hit);
hits.cc:479:    node[01;31m-[00m>archiveObjectIfDefined("optionalBuilderDatabase",this[01;31m-[00m>_OptionalBuilderDatabase);
hits.cc:480:    if ( node[01;31m-[00m>loading() )
hits.cc:482:	if ( this[01;31m-[00m>_OptionalBuilderDatabase[01;31m-[00m>notNil() )
hits.cc:486:	    RPLisp lisp = node[01;31m-[00m>getArchive()[01;31m-[00m>lisp();
hits.cc:487:	    ASSERTP(lisp[01;31m-[00m>notNil(),"Default Environment is nil");
hits.cc:488:	    lisp[01;31m-[00m>setBuilderDatabase(this[01;31m-[00m>_OptionalBuilderDatabase);
hits.cc:489:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Loaded HitList with OptionalBuilderDatabase [01;31m-[00m> replaced system BuilderDatabase"));
hits.cc:492:    node[01;31m-[00m>attribute("maxEntries",this[01;31m-[00m>_MaxEntries );
hits.cc:493:    node[01;31m-[00m>attribute("avoidDuplicateScores",this[01;31m-[00m>_AvoidDuplicateScores );
hits.cc:494:    node[01;31m-[00m>archiveList("hits",this[01;31m-[00m>_Hits);
hits.cc:495:    node[01;31m-[00m>archiveObject("data",this[01;31m-[00m>_Data);
hits.cc:496:    node[01;31m-[00m>archiveObject("searchStatistics",this[01;31m-[00m>_SearchStatistics);
hits.cc:497:    node[01;31m-[00m>archiveObject("builderScorer",this[01;31m-[00m>_BuilderScorer);
hits.cc:498:    node[01;31m-[00m>attribute("AllowMultipleHitsWithTheSameSequence",this[01;31m-[00m>_AllowMultipleHitsWithTheSameSequence);
hits.cc:507:{_F(this[01;31m-[00m>lisp());
hits.cc:509:    for ( hi = this[01;31m-[00m>begin(); hi != this[01;31m-[00m>end(); hi++ )
hits.cc:511:	if ( score <= (*hi)[01;31m-[00m>getScore() )
hits.cc:529:{_F(this[01;31m-[00m>lisp());
hits.cc:530:    return this[01;31m-[00m>_Hits.size();
hits.cc:542:{_F(this[01;31m-[00m>lisp());
hits.cc:543:    if ( this[01;31m-[00m>isNil() )
hits.cc:545:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("HitList is nil"));
hits.cc:547:    this[01;31m-[00m>_SearchStatistics[01;31m-[00m>incrementBuilds();
hits.cc:548:    if ( state[01;31m-[00m>getReject() )
hits.cc:550:	this[01;31m-[00m>_SearchStatistics[01;31m-[00m>incrementRejects();
hits.cc:552:    if ( !state[01;31m-[00m>isScoreSet() ) return false;
hits.cc:553:    if ( state[01;31m-[00m>getReject() ) return false;
hits.cc:554:    double score = state[01;31m-[00m>getScore();
hits.cc:556:    LOG(BF("Checking if something is a hit,score(%lf)  hitList=%s") % score % this[01;31m-[00m>__repr__().c_str()  ); // vp0(("Checking if something is a hit,score(%lf)  hitList=%s",score,this[01;31m-[00m>__repr__().c_str() ));
hits.cc:557:    if ( this[01;31m-[00m>_Hits.size() == 0 )
hits.cc:560:	this[01;31m-[00m>_SearchStatistics[01;31m-[00m>incrementHits();
hits.cc:563:    if ( score > this[01;31m-[00m>_Hits[this[01;31m-[00m>_Hits.size()[01;31m-[00m1][01;31m-[00m>getScore())
hits.cc:565:	if ( this[01;31m-[00m>_Hits.size() >= this[01;31m-[00m>_MaxEntries )
hits.cc:567:	    double worstScore = this[01;31m-[00m>_Hits[this[01;31m-[00m>_Hits.size()[01;31m-[00m1][01;31m-[00m>getScore();
hits.cc:572:    hi = this[01;31m-[00m>_hitInsertPosition(score);
hits.cc:573:    if ( hi == this[01;31m-[00m>begin() )
hits.cc:576:	this[01;31m-[00m>_SearchStatistics[01;31m-[00m>incrementHits();
hits.cc:579:    if ( this[01;31m-[00m>_AvoidDuplicateScores )
hits.cc:581:	if ( hi != this[01;31m-[00m>end() && (*hi)[01;31m-[00m>getScore() == score )
hits.cc:583:	    LOG(BF("Return false because we already have a hit with that score,arg score(%lf),hit score(%lf)") % score % (*hi)[01;31m-[00m>getScore() ); // vp0(("Return false because we already have a hit with that score,arg score(%lf),hit score(%lf)",score,(*hi)[01;31m-[00m>getScore()));
hits.cc:588:    this[01;31m-[00m>_SearchStatistics[01;31m-[00m>incrementHits();
hits.cc:596:{_F(this[01;31m-[00m>lisp());
hits.cc:597:    ASSERT(this[01;31m-[00m>_Hits.size() > 2);
hits.cc:598:    this[01;31m-[00m>_Hits.pop_back();
hits.cc:606:{_F(this[01;31m-[00m>lisp());
hits.cc:609:    hi = this[01;31m-[00m>_hitInsertPosition(hit[01;31m-[00m>getScore());
hits.cc:610:    if ( this[01;31m-[00m>_Hits.size() > 0 )
hits.cc:614:	LOG(BF("hi == this[01;31m-[00m>end() = %d") % (hi == this[01;31m-[00m>end())  ); // vp0(("hi == this[01;31m-[00m>end() = %d",hi == this[01;31m-[00m>end() ));
hits.cc:615:	if ( hi == this[01;31m-[00m>end() )
hits.cc:617:	    if ( this[01;31m-[00m>_Hits.size() >= this[01;31m-[00m>_MaxEntries ) goto DONE;
hits.cc:622:    if ( this[01;31m-[00m>_Hits.size() == 0 )  // only element of list
hits.cc:624:	this[01;31m-[00m>_Hits.push_back(hit);
hits.cc:627:        this[01;31m-[00m>_Hits.insert(hi,hit);
hits.cc:629:    if ( this[01;31m-[00m>_Hits.size() >= this[01;31m-[00m>_MaxEntries )
hits.cc:631:	this[01;31m-[00m>_dropLastEntry();
hits.cc:634:    hit[01;31m-[00m>setHitList(this[01;31m-[00m>sharedThis<O_HitList>());
hits.cc:640:{_F(this[01;31m-[00m>lisp());
hits.cc:641:    LOG(BF("AllowMultipleHitsWithTheSameSequence = %d") % this[01;31m-[00m>_AllowMultipleHitsWithTheSameSequence );
hits.cc:643:    for ( hi = this[01;31m-[00m>begin(); hi != this[01;31m-[00m>end(); hi++ )
hits.cc:645:	if ( this[01;31m-[00m>_AllowMultipleHitsWithTheSameSequence )
hits.cc:647:	    if ( (*hi)[01;31m-[00m>matchesOligomerAndSequenceAndConformation(hit) ) return hi;
hits.cc:650:	    if ( (*hi)[01;31m-[00m>matchesOligomerAndSequence(hit) ) return hi;
hits.cc:653:    return this[01;31m-[00m>end();
hits.cc:664:{_F(this[01;31m-[00m>lisp());
hits.cc:665:    O_HitList::iterator existingHit = this[01;31m-[00m>findEquivalentHit(hit);
hits.cc:668:    if ( existingHit == this[01;31m-[00m>_Hits.end() )
hits.cc:670:	this[01;31m-[00m>primitiveAddHit(hit);
hits.cc:677:    if ( hit[01;31m-[00m>getScore() < (*existingHit)[01;31m-[00m>getScore() )
hits.cc:683:	hit[01;31m-[00m>setTimesSeen(1+(*existingHit)[01;31m-[00m>getTimesSeen());
hits.cc:685:	this[01;31m-[00m>_Hits.erase(existingHit);
hits.cc:687:	this[01;31m-[00m>primitiveAddHit(hit);
hits.cc:694:	(*existingHit)[01;31m-[00m>setTimesSeen(1+(*existingHit)[01;31m-[00m>getTimesSeen());
hits.cc:709:    for ( hi = other[01;31m-[00m>begin(); hi!=other[01;31m-[00m>end(); hi++ )
hits.cc:711:	RPScorerState state = (*hi)[01;31m-[00m>getScorerState();
hits.cc:712:	if ( this[01;31m-[00m>isAHit(state) )
hits.cc:714:	    this[01;31m-[00m>addHit(*hi);
hits.cc:727:{_F(this[01;31m-[00m>lisp());
hits.cc:728:    if ( i < this[01;31m-[00m>_Hits.size() )
hits.cc:730:	return this[01;31m-[00m>_Hits[i];
hits.cc:732:    return O_Hit::nil(this[01;31m-[00m>lisp());
hits.cc:736:{_F(this[01;31m-[00m>lisp());
hits.cc:739:    if ( this[01;31m-[00m>_Hits.size() != 0 )
hits.cc:742:	for ( hi=this[01;31m-[00m>_Hits.const_begin(); hi!=this[01;31m-[00m>_Hits.const_end(); hi++ )
hits.cc:744:	    ss << (*hi)[01;31m-[00m>__repr__() << endl;
hits.cc:748:	ss << "[01;31m-[00m[01;31m-[00mempty[01;31m-[00m[01;31m-[00m";
hits.cc:758:{_F(this[01;31m-[00m>lisp());
hits.cc:761:    xml = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_XmlSaveArchive>();
hits.cc:762:    xml[01;31m-[00m>put("hitList",this[01;31m-[00m>sharedThis<O_HitList>());
hits.cc:763:    xml[01;31m-[00m>saveAs(fn);
hits.cc:769:{ _F(this[01;31m-[00m>lisp());
hits.cc:770:    RPRenderDisplayList dl = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
hits.cc:771:    RPRenderFrameList frames = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderFrameList>();
hits.cc:773:    for ( hit=this[01;31m-[00m>begin(); hit!=this[01;31m-[00m>end(); hit++ )
hits.cc:775:	RPRender dl = (*hit)[01;31m-[00m>rendered(opts);
hits.cc:777:	frames[01;31m-[00m>add(dl);
hits.cc:779:    dl[01;31m-[00m>add(frames);
hits.cc:780:    ASSERT_NOT_NULL(this[01;31m-[00m>_BuilderScorer);
hits.cc:781:    ASSERT(this[01;31m-[00m>_BuilderScorer[01;31m-[00m>notNil());
hits.cc:782:    dl[01;31m-[00m>add(this[01;31m-[00m>_BuilderScorer[01;31m-[00m>getScorerBackgroundRender());
hits.cc:783:    if ( this[01;31m-[00m>_Data[01;31m-[00m>canRender() )
hits.cc:785:        RPRender dataGraphics = this[01;31m-[00m>_Data[01;31m-[00m>rendered(opts);
hits.cc:786:	dl[01;31m-[00m>add(dataGraphics);
hits.cc:798:{_F(this[01;31m-[00m>lisp());
hits.cc:799:    RPHitList hits = this[01;31m-[00m>sharedThis<O_HitList>();
hits.cc:802:    RPBuilderScorer bs = this[01;31m-[00m>getBuilderScorer();
hits.cc:803:    for ( hi=hits[01;31m-[00m>begin(); hi!=hits[01;31m-[00m>end(); hi++ )
hits.cc:805:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m Hit #%d    score = %lf") % index% (*hi)[01;31m-[00m>getScore() );
hits.cc:806:	RPBuilderState state = (*hi)[01;31m-[00m>getBuilderState();
hits.cc:807:	bs[01;31m-[00m>restoreState(state);
hits.cc:808:	RPOligomer olig = bs[01;31m-[00m>getCurrentOligomer();
hits.cc:809:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % olig[01;31m-[00m>sequenceAsString().c_str() );
hits.cc:816:    this[01;31m-[00m>_BuilderScorer = bs;
hits.cc:820:{_F(this[01;31m-[00m>lisp());
hits.cc:821:    ASSERT_NOT_NULL(this[01;31m-[00m>_BuilderScorer);
hits.cc:822:    ASSERT(this[01;31m-[00m>_BuilderScorer[01;31m-[00m>notNil());
hits.cc:823:    return this[01;31m-[00m>_BuilderScorer;
hits.cc:827:{_F(this[01;31m-[00m>lisp());
hits.cc:828:    ASSERT_NOT_NULL(this[01;31m-[00m>_SearchStatistics);
hits.cc:829:    ASSERT(this[01;31m-[00m>_SearchStatistics[01;31m-[00m>notNil());
hits.cc:830:    return this[01;31m-[00m>_SearchStatistics;
hits.cc:836:{_F(this[01;31m-[00m>lisp());
hits.cc:837:    if ( this[01;31m-[00m>_Hits.size() == 0 )
hits.cc:839:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("To convert a HitList into a ConformationExplorer there has to be at least one hit"));
hits.cc:844:    RPHit firstHit = this[01;31m-[00m>_Hits.get(0);
hits.cc:845:    if ( this[01;31m-[00m>_Hits.size() > 1 )
hits.cc:847:	List<O_Hit>::iterator it = this[01;31m-[00m>_Hits.begin();
hits.cc:849:	for ( ; it!=this[01;31m-[00m>_Hits.end(); it++ )
hits.cc:851:	    if ( !firstHit[01;31m-[00m>hasSameOligomerAndSequenceAs(*it) )
hits.cc:853:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("In order to convert a HitList into a ConformationExplorer all hits must have the same Oligomer/Sequence [01;31m-[00m this one does not"));
hits.cc:857:    RPBuilderScorer builderScorer = this[01;31m-[00m>getBuilderScorer();
hits.cc:858:    RPBuilderState bs = firstHit[01;31m-[00m>getBuilderState();
hits.cc:859:    RPConformationExplorer conformationExplorer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ConformationExplorer>();
hits.cc:860:    builderScorer[01;31m-[00m>restoreState(bs);
hits.cc:861:    RPMolecule mol = builderScorer[01;31m-[00m>getBuiltMolecule();
hits.cc:862:    conformationExplorer[01;31m-[00m>setMatter(mol);
hits.cc:863:    conformationExplorer[01;31m-[00m>superposeAllHeavyAtoms();
hits.cc:864:    {_BLOCK_TRACEF(BF("Creating ConformationExplorer for %d hits") % this[01;31m-[00m>_Hits.size() );
hits.cc:865:	for ( List<O_Hit>::iterator it=this[01;31m-[00m>_Hits.begin(); it!=this[01;31m-[00m>_Hits.end(); it++ )
hits.cc:867:	    bs = (*it)[01;31m-[00m>getBuilderState();
hits.cc:868:	    builderScorer[01;31m-[00m>restoreConformationOfBuilderState(bs);
hits.cc:869:	    builderScorer[01;31m-[00m>writeScoreTransformedCoordinatesToBuiltMolecule((*it)[01;31m-[00m>getScorerState());
hits.cc:870:	    RPConformationExplorerEntry entry = conformationExplorer[01;31m-[00m>createEntry();
hits.cc:871:	    RPConformationExplorerEntryStage entryStage = entry[01;31m-[00m>createEntryStage();
hits.cc:872:	    entryStage[01;31m-[00m>setStageName("start");
hits.cc:873:	    entry[01;31m-[00m>setSelectedStage(entryStage);
hits.cc:874:	    entryStage[01;31m-[00m>extractCoordinatesFromMatter(mol);
hits.cc:875:	    entryStage[01;31m-[00m>setComplete(true);
hits.cc:876:	    entry[01;31m-[00m>appendEntryStage(entryStage);
hits.cc:877:	    conformationExplorer[01;31m-[00m>appendEntry(entry);
hits.cc:893:    if ( args[01;31m-[00m>length()<2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a name and max number of hits"));
hits.cc:894:    RPText name = args[01;31m-[00m>listref<O_Text>(0);
hits.cc:895:    RPInt maxHits = args[01;31m-[00m>listref<O_Int>(1);
hits.cc:896:    RPHitList hitList = lisp[01;31m-[00m>create<O_HitList>();
hits.cc:897:    hitList[01;31m-[00m>setMaxEntries(maxHits[01;31m-[00m>get());
hits.cc:898:    lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(lisp[01;31m-[00m>intern(name[01;31m-[00m>get()),hitList);
hits.cc:916:    if ( args[01;31m-[00m>length()!=2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a HitList and index"));
hits.cc:917:    RPHitList hits = args[01;31m-[00m>listref<O_HitList>(0);
hits.cc:918:    RPInt index = args[01;31m-[00m>listref<O_Int>(1);
hits.cc:919:    return hits[01;31m-[00m>getHit(index[01;31m-[00m>get());
hits.cc:930:    class_<O_Hit>(this[01;31m-[00m>lisp())
hits.cc:970:    defNoWrapPackage(MbbPackage,"hitListGet",&prim_hitListGet,this[01;31m-[00m>lisp());
hits.cc:972:    class_<O_HitList>(this[01;31m-[00m>lisp())
implementAmberFunction.cc:7:	string	getError() { return "FiniteDifferenceMismatch"; } //  @"+this[01;31m-[00m>functionName()+" term:("+this[01;31m-[00m>termName+")";};
implementAmberFunction.cc:18:	double eLow = this[01;31m-[00m>func argLow;\
implementAmberFunction.cc:19:	double eHigh = this[01;31m-[00m>func argHigh;\
implementAmberFunction.cc:20:	double numForce = [01;31m-[00m(eHigh[01;31m-[00meLow)/(delta);\
implementAmberFunction.cc:26:	double eLow = this[01;31m-[00m>func argLow;\
implementAmberFunction.cc:27:	double eMiddle = this[01;31m-[00m>func argMiddle;\
implementAmberFunction.cc:28:	double eHigh = this[01;31m-[00m>func argHigh;\
implementAmberFunction.cc:29:	double numHessian = (eHigh+eLow[01;31m-[00m2.0*eMiddle)/(((delta)/2.0)*((delta)/2.0));\
implementAmberFunction.cc:35:	double eMM = this[01;31m-[00m>func argMM;\
implementAmberFunction.cc:36:	double eMP = this[01;31m-[00m>func argMP;\
implementAmberFunction.cc:37:	double ePM = this[01;31m-[00m>func argPM;\
implementAmberFunction.cc:38:	double ePP = this[01;31m-[00m>func argPP;\
implementAmberFunction.cc:39:	double numHessian = ((ePP[01;31m-[00mePM)[01;31m-[00m(eMP[01;31m-[00meMM))/(delta*delta);\
implementAmberFunction.cc:52:{_F(this[01;31m-[00m>lisp());
implementAmberFunction.cc:53:    _lisp[01;31m-[00m>profiler().timer(timerPreconditioner).start();
implementAmberFunction.cc:54:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSetup).start();
implementAmberFunction.cc:59:    m[01;31m-[00m>fill(0.0);
implementAmberFunction.cc:61:    this[01;31m-[00m>_Stretch[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
implementAmberFunction.cc:62:    this[01;31m-[00m>_Angle[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
implementAmberFunction.cc:63:    this[01;31m-[00m>_Dihedral[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
implementAmberFunction.cc:65://    this[01;31m-[00m>_Nonbond[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
implementAmberFunction.cc:66:    this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
implementAmberFunction.cc:67:    this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
implementAmberFunction.cc:68:    this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>setupHessianPreconditioner(nvPosition, m );
implementAmberFunction.cc:70:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSetup).stop();
implementAmberFunction.cc:71:    _lisp[01;31m-[00m>profiler().timer(timerPreconditioner).stop();
implementAmberFunction.cc:84:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Should there be something here?"));
implementAmberFunction.cc:104:{_F(this[01;31m-[00m>lisp());
implementAmberFunction.cc:109:        force[01;31m-[00m>setElement((i)+(o),(v)+force[01;31m-[00m>getElement((i)+(o)));\
implementAmberFunction.cc:118:	    hessian[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
implementAmberFunction.cc:121:	    hdvec[01;31m-[00m>addToElement((i1)+(o1),v*dvec[01;31m-[00m>element((i2)+(o2)));\
implementAmberFunction.cc:122:	    hdvec[01;31m-[00m>addToElement((i2)+(o2),v*dvec[01;31m-[00m>element((i1)+(o1)));\
implementAmberFunction.cc:131:	    hessian[01;31m-[00m>addToElement((i1)+(o1),(i2)+(o2),v);\
implementAmberFunction.cc:134:	    hdvec[01;31m-[00m>addToElement((i1)+(o1),v*dvec[01;31m-[00m>element((i1)+(o1)));\
implementAmberFunction.cc:144:bool	hasForce = force[01;31m-[00m>notNil();
implementAmberFunction.cc:145:bool	hasHessian = hessian[01;31m-[00m>notNil();
implementAmberFunction.cc:146:bool	hasHdAndD = (hdvec[01;31m-[00m>notNil())&&(dvec[01;31m-[00m>notNil());
implementAmberFunction.cc:156:    if ( hasForce && force[01;31m-[00m>size() < pos[01;31m-[00m>size() ) {
implementAmberFunction.cc:157:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Force does not have the necessary dimensions"));
implementAmberFunction.cc:162:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Inconsistant arguments: if you want to calcDiagonalHessian or calcOffDiagonalHessian you must calcForce"));
implementAmberFunction.cc:165:	TOSS(_lisp[01;31m-[00m>create<O_LispError>"Inconsistant arguments: if you want to calcOffDiagonalHessian you must calcDiagonalHessian"));
implementAmberFunction.cc:172:	if ( hasForce ) force[01;31m-[00m>zero();
implementAmberFunction.cc:173:	if ( hasHessian ) hessian[01;31m-[00m>zero();
implementAmberFunction.cc:176:	    hdvec[01;31m-[00m>zero();	// Zero the result
implementAmberFunction.cc:180:	_lisp[01;31m-[00m>profiler().timer(timerEnergy).start();
implementAmberFunction.cc:182:	_lisp[01;31m-[00m>profiler().timer(timerBondAngleDihedral).start();
implementAmberFunction.cc:187:	_lisp[01;31m-[00m>profiler().timer(timerBond).start();
implementAmberFunction.cc:188:        this[01;31m-[00m>_Stretch[01;31m-[00m>evaluateAll( pos, calcForce, force,
implementAmberFunction.cc:192:	_lisp[01;31m-[00m>profiler().timer(timerBond).stop();
implementAmberFunction.cc:194:	_lisp[01;31m-[00m>profiler().timer(timerAngle).start();
implementAmberFunction.cc:195:        this[01;31m-[00m>_Angle[01;31m-[00m>evaluateAll( pos, calcForce, force,
implementAmberFunction.cc:199:	_lisp[01;31m-[00m>profiler().timer(timerAngle).stop();
implementAmberFunction.cc:201:	_lisp[01;31m-[00m>profiler().timer(timerDihedral).start();
implementAmberFunction.cc:202:        this[01;31m-[00m>_Dihedral[01;31m-[00m>evaluateAll( pos, calcForce, force,
implementAmberFunction.cc:206:	_lisp[01;31m-[00m>profiler().timer(timerDihedral).stop();
implementAmberFunction.cc:207:	_lisp[01;31m-[00m>profiler().timer(timerBondAngleDihedral).stop();
implementAmberFunction.cc:209:	_lisp[01;31m-[00m>profiler().timer(timerNonbond).start();
implementAmberFunction.cc:210:        this[01;31m-[00m>_Nonbond[01;31m-[00m>evaluateAll( pos, calcForce, force, 
implementAmberFunction.cc:212:	_lisp[01;31m-[00m>profiler().timer(timerNonbond).stop();
implementAmberFunction.cc:214:	_lisp[01;31m-[00m>profiler().timer(timerImproperRestraint).start();
implementAmberFunction.cc:215:        this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>evaluateAll( pos, calcForce, force, 
implementAmberFunction.cc:217:	_lisp[01;31m-[00m>profiler().timer(timerImproperRestraint).stop();
implementAmberFunction.cc:219:	_lisp[01;31m-[00m>profiler().timer(timerChiralRestraint).start();
implementAmberFunction.cc:220:        this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>evaluateAll( pos, calcForce, force, 
implementAmberFunction.cc:222:	_lisp[01;31m-[00m>profiler().timer(timerChiralRestraint).stop();
implementAmberFunction.cc:224:	_lisp[01;31m-[00m>profiler().timer(timerAnchorRestraint).start();
implementAmberFunction.cc:225:        this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>evaluateAll( pos, calcForce, force, 
implementAmberFunction.cc:227:	_lisp[01;31m-[00m>profiler().timer(timerAnchorRestraint).stop();
implementAmberFunction.cc:229:	this[01;31m-[00m>_TotalEnergy = this[01;31m-[00m>_Stretch[01;31m-[00m>getEnergy();
implementAmberFunction.cc:230:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_Angle[01;31m-[00m>getEnergy();
implementAmberFunction.cc:231:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_Dihedral[01;31m-[00m>getEnergy();
implementAmberFunction.cc:232:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_Nonbond[01;31m-[00m>getEnergy();
implementAmberFunction.cc:233:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>getEnergy();
implementAmberFunction.cc:234:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>getEnergy();
implementAmberFunction.cc:235:	this[01;31m-[00m>_TotalEnergy += this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>getEnergy();
implementAmberFunction.cc:237:	_lisp[01;31m-[00m>profiler().timer(timerEnergy).stop();
implementAmberFunction.cc:240:	if ( this[01;31m-[00m>isDebugEnergyEnabled() ) {
implementAmberFunction.cc:243:	    for ( z=1,ai=this[01;31m-[00m>_AtomTable[01;31m-[00m>begin(); ai<this[01;31m-[00m>_AtomTable[01;31m-[00m>end(); ai++,z++) {
implementAmberFunction.cc:244:		mbb::RPAtom aa = ai[01;31m-[00m>_Atom;
implementAmberFunction.cc:245:		LOG(BF("MEISTER total %d atom %s") % (z) % (aa[01;31m-[00m>getName().c_str() ) ); // vp0(("MEISTER total %d atom %s", z, aa[01;31m-[00m>getName().c_str() ));
implementAmberFunction.cc:246:		LOG(BF("MEISTER total %d residue %d") % (z) % (aa[01;31m-[00m>getResidueContainedBy()[01;31m-[00m>getId()) ); // vp0(("MEISTER total %d residue %d", z, aa[01;31m-[00m>getResidueContainedBy()[01;31m-[00m>getId()));
implementAmberFunction.cc:247:		LOG(BF("MEISTER total %d x %5.3lf") % (z) % (pos[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+0) ) ); // vp0(("MEISTER total %d x %5.3lf", z, pos[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+0) ));
implementAmberFunction.cc:248:		LOG(BF("MEISTER total %d y %5.3lf") % (z) % (pos[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+1) ) ); // vp0(("MEISTER total %d y %5.3lf", z, pos[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+1) ));
implementAmberFunction.cc:249:		LOG(BF("MEISTER total %d z %5.3lf") % (z) % (pos[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+2) ) ); // vp0(("MEISTER total %d z %5.3lf", z, pos[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+2) ));
implementAmberFunction.cc:251:		    LOG(BF("MEISTER total %d fx %5.3lf") % (z) % ([01;31m-[00mforce[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+0) ) ); // vp0(("MEISTER total %d fx %5.3lf", z, [01;31m-[00mforce[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+0) ));
implementAmberFunction.cc:252:		    LOG(BF("MEISTER total %d fy %5.3lf") % (z) % ([01;31m-[00mforce[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+1) ) ); // vp0(("MEISTER total %d fy %5.3lf", z, [01;31m-[00mforce[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+1) ));
implementAmberFunction.cc:253:		    LOG(BF("MEISTER total %d fz %5.3lf") % (z) % ([01;31m-[00mforce[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+2) ) ); // vp0(("MEISTER total %d fz %5.3lf", z, [01;31m-[00mforce[01;31m-[00m>getElement(ai[01;31m-[00m>_CoordinateIndex+2) ));
implementAmberFunction.cc:267:    return this[01;31m-[00m>_TotalEnergy;
implementAmberFunction.cc:286:        this[01;31m-[00m>_Stretch[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
implementAmberFunction.cc:287:        this[01;31m-[00m>_Angle[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
implementAmberFunction.cc:288:        this[01;31m-[00m>_Dihedral[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
implementAmberFunction.cc:289:        this[01;31m-[00m>_Nonbond[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
implementAmberFunction.cc:290:        this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
implementAmberFunction.cc:291:        this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
implementAmberFunction.cc:292:        this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
implementAmberFunction.cc:317:    pos = mbb::O_NVector::create(this[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
implementAmberFunction.cc:318:    this[01;31m-[00m>extractCoordinatesFromAtoms(pos);
implementAmberFunction.cc:321:	fails += this[01;31m-[00m>_Stretch[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
implementAmberFunction.cc:322:	fails += this[01;31m-[00m>_Angle[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
implementAmberFunction.cc:323:	fails += this[01;31m-[00m>_Dihedral[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
implementAmberFunction.cc:324:	fails += this[01;31m-[00m>_Nonbond[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
implementAmberFunction.cc:325:	fails += this[01;31m-[00m>_ImproperRestraint[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
implementAmberFunction.cc:326:	fails += this[01;31m-[00m>_ChiralRestraint[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
implementAmberFunction.cc:327:	fails += this[01;31m-[00m>_AnchorRestraint[01;31m-[00m>checkForBeyondThresholdInteractions(info,pos);
implementAmberFunction.cc:330:    this[01;31m-[00m>_Message = info.str();    
improperRestraintTerms.cc:2:	tx77 = [01;31m-[00mx2; 		/* rule 1 */
improperRestraintTerms.cc:6:	tx78 = [01;31m-[00my2; 		/* rule 5 */
improperRestraintTerms.cc:8:	tx50 = [01;31m-[00my3; 		/* rule 7 */
improperRestraintTerms.cc:12:	tx49 = [01;31m-[00mx3; 		/* rule 11 */
improperRestraintTerms.cc:16:	tx79 = [01;31m-[00mz2; 		/* rule 15 */
improperRestraintTerms.cc:22:	tx51 = [01;31m-[00mz3; 		/* rule 21 */
improperRestraintTerms.cc:85:	CosPhi=MAX([01;31m-[00m1.0,MIN(1.0,CosPhi));
improperRestraintTerms.cc:88:	tzz123 = [01;31m-[00mCosPhi; 		/* rule 87 */
improperRestraintTerms.cc:115:	DePhi = [01;31m-[00m2.*PhiMinusPhase*tzz124; 		/* rule 112 */
improperRestraintTerms.cc:118:	tzz120 = [01;31m-[00mtzz114; 		/* rule 115 */
improperRestraintTerms.cc:141:	tzz122 = [01;31m-[00mtzz112; 		/* rule 138 */
improperRestraintTerms.cc:159:	tzz121 = [01;31m-[00mtzz113; 		/* rule 156 */
improperRestraintTerms.cc:162:	tx104 = [01;31m-[00mtx95; 		/* rule 159 */
improperRestraintTerms.cc:167:	tx107 = [01;31m-[00mtx98; 		/* rule 164 */
improperRestraintTerms.cc:170:	tx108 = [01;31m-[00mtx101; 		/* rule 167 */
improperRestraintTerms.cc:181:	fx1 = [01;31m-[00mdx1; 		/* rule 178 */
improperRestraintTerms.cc:182:	fy1 = [01;31m-[00mdy1; 		/* rule 179 */
improperRestraintTerms.cc:183:	fz1 = [01;31m-[00mdz1; 		/* rule 180 */
improperRestraintTerms.cc:184:	fx2 = [01;31m-[00mdx2; 		/* rule 181 */
improperRestraintTerms.cc:185:	fy2 = [01;31m-[00mdy2; 		/* rule 182 */
improperRestraintTerms.cc:186:	fz2 = [01;31m-[00mdz2; 		/* rule 183 */
improperRestraintTerms.cc:187:	fx3 = [01;31m-[00mdx3; 		/* rule 184 */
improperRestraintTerms.cc:188:	fy3 = [01;31m-[00mdy3; 		/* rule 185 */
improperRestraintTerms.cc:189:	fz3 = [01;31m-[00mdz3; 		/* rule 186 */
improperRestraintTerms.cc:190:	fx4 = [01;31m-[00mdx4; 		/* rule 187 */
improperRestraintTerms.cc:191:	fy4 = [01;31m-[00mdy4; 		/* rule 188 */
improperRestraintTerms.cc:192:	fz4 = [01;31m-[00mdz4; 		/* rule 189 */
initializeClassesWithWx.cc:18:    lisp[01;31m-[00m>makePackage(WxPackage);
initializeClassesWithWx.cc:26:    lisp[01;31m-[00m>installGlobalInitializationCallback(initializeWxWidgetsConstants);
intArray.cc:26:    this[01;31m-[00m>Base::initialize();
intArray.cc:27:    this[01;31m-[00m>_Ints.clear();
intArray.cc:32:    node[01;31m-[00m>archiveVectorInt( "values", this[01;31m-[00m>_Ints );
intArray.cc:39:    ir[01;31m-[00m>resize(sz);
intArray.cc:45:{_F(this[01;31m-[00m>lisp());
intArray.cc:46:    this[01;31m-[00m>_Ints.clear();
intArray.cc:51:{_F(this[01;31m-[00m>lisp());
intArray.cc:53:    this[01;31m-[00m>_Ints.resize(sz);
intArray.cc:59:    this[01;31m-[00m>_Ints.push_back(val);
intArray.cc:65:{_F(this[01;31m-[00m>lisp());
intArray.cc:66:    ASSERT_lessThan(idx,this[01;31m-[00m>_Ints.size());
intArray.cc:67:    this[01;31m-[00m>_Ints[idx] = val;
intArray.cc:73:{_F(this[01;31m-[00m>lisp());
intArray.cc:74:    ASSERT_lessThan(idx,this[01;31m-[00m>_Ints.size());
intArray.cc:75:    return this[01;31m-[00m>_Ints[idx];
integerKeyObjectDictionary.cc:23:    if ( this[01;31m-[00m>_Map.count(ikey) == 0 ) {
integerKeyObjectDictionary.cc:26:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
integerKeyObjectDictionary.cc:28:    return this[01;31m-[00m>_Map[ikey];
integerKeyObjectDictionary.cc:33:    if ( this[01;31m-[00m>_Map.count(ikey) == 0 ) 
integerKeyObjectDictionary.cc:37:    return this[01;31m-[00m>get(ikey);
integerKeyObjectDictionary.cc:45:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ )
integerKeyObjectDictionary.cc:47:	ss << "Entry{ " << vi[01;31m-[00m>first << ": ";
integerKeyObjectDictionary.cc:48:	ss << vi[01;31m-[00m>second[01;31m-[00m>className();
integerKeyObjectDictionary.cc:49:	if ( vi[01;31m-[00m>second[01;31m-[00m>isAssignableTo<O_Value>() )
integerKeyObjectDictionary.cc:51:	    ss <<":" <<vi[01;31m-[00m>second[01;31m-[00m>__repr__();
integerKeyObjectDictionary.cc:63:    if ( this[01;31m-[00m>_Map.count(ikey) == 0 ) 
integerKeyObjectDictionary.cc:67:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
integerKeyObjectDictionary.cc:69:    obj = this[01;31m-[00m>_Map[ikey];
integerKeyObjectDictionary.cc:70:    this[01;31m-[00m>_Map.erase(ikey);
integerKeyObjectDictionary.cc:77:    if ( this[01;31m-[00m>_Map.count(ikey) == 0 ) {
integerKeyObjectDictionary.cc:80:    obj = this[01;31m-[00m>_Map[ikey];
integerKeyObjectDictionary.cc:81:    this[01;31m-[00m>_Map.erase(ikey);
integerKeyObjectDictionary.cc:87:{_F(this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:91:    dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:92:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ )
integerKeyObjectDictionary.cc:94:	LOG(BF("Looking to render %s") % vi[01;31m-[00m>second[01;31m-[00m>description().c_str()  ); // vp0(("Looking to render %s",vi[01;31m-[00m>second[01;31m-[00m>description().c_str() ));
integerKeyObjectDictionary.cc:95:	if ( vi[01;31m-[00m>second[01;31m-[00m>canRender() )
integerKeyObjectDictionary.cc:98:	    dlOne = vi[01;31m-[00m>second[01;31m-[00m>rendered(opts);
integerKeyObjectDictionary.cc:99:	    dlOne[01;31m-[00m>setName((boost::format("i%d")%vi[01;31m-[00m>first).str());
integerKeyObjectDictionary.cc:100:	    dl[01;31m-[00m>append(dlOne);
integerKeyObjectDictionary.cc:110:{_F(this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:114:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
integerKeyObjectDictionary.cc:115:        ss << vi[01;31m-[00m>first << " ";
integerKeyObjectDictionary.cc:121:{_F(this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:124:    RPCons first = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>onil(),this[01;31m-[00m>lisp()[01;31m-[00m>cnil(),this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:126:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
integerKeyObjectDictionary.cc:127:	RPCons one = O_Cons::create(O_Int::create(vi[01;31m-[00m>first,this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp()[01;31m-[00m>cnil(),this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:128:	cur[01;31m-[00m>setCdr(one);
integerKeyObjectDictionary.cc:131:    return first[01;31m-[00m>cdr();
integerKeyObjectDictionary.cc:135:{_F(this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:138:    RPCons first = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>onil(),this[01;31m-[00m>lisp()[01;31m-[00m>cnil(),this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:140:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
integerKeyObjectDictionary.cc:141:	RPCons one = O_Cons::create(vi[01;31m-[00m>second,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:142:	cur[01;31m-[00m>setCdr(one);
integerKeyObjectDictionary.cc:145:    return first[01;31m-[00m>cdr();
integerKeyObjectDictionary.cc:149:{_F(this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:153:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
integerKeyObjectDictionary.cc:154:        ss << vi[01;31m-[00m>first << ":";
integerKeyObjectDictionary.cc:155:	ss << vi[01;31m-[00m>second[01;31m-[00m>description() << endl;
integerKeyObjectDictionary.cc:165:{_F(this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:166:    if ( node[01;31m-[00m>saving() )
integerKeyObjectDictionary.cc:167:    { _BLOCK_TRACEF(BF("Saving IntegerKeyObjectDictionary [01;31m-[00m it contains %d objects") % this[01;31m-[00m>_Map.size() );
integerKeyObjectDictionary.cc:168:	if ( this[01;31m-[00m>_Map.size() != 0 )
integerKeyObjectDictionary.cc:173:	    for ( oi=this[01;31m-[00m>_Map.begin(); oi!=this[01;31m-[00m>_Map.end(); i++,oi++ )
integerKeyObjectDictionary.cc:175:	    	LOG(BF( "Archiving entry key(%d)")% oi[01;31m-[00m>first );
integerKeyObjectDictionary.cc:178:		string key = (boost::format("%d") % oi[01;31m-[00m>first).str();
integerKeyObjectDictionary.cc:179:		node[01;31m-[00m>archiveObject(key,oi[01;31m-[00m>second);
integerKeyObjectDictionary.cc:183:    { _BLOCK_TRACEF(BF("Loading IntegerKeyObjectDictionary with uid(%d)") % node[01;31m-[00m>getUniqueIdNumeric() );
integerKeyObjectDictionary.cc:186:	this[01;31m-[00m>_Map.clear();
integerKeyObjectDictionary.cc:187:	for ( ci=node[01;31m-[00m>begin_Children(); ci!=node[01;31m-[00m>end_Children(); ci++ )
integerKeyObjectDictionary.cc:189:	    (*ci)[01;31m-[00m>setRecognized(true);
integerKeyObjectDictionary.cc:190:	    object = node[01;31m-[00m>getArchive()[01;31m-[00m>loadObjectDirectly((*ci));
integerKeyObjectDictionary.cc:192:	    LOG(BF( "Adding to the IntegerKeyObjectDictionary key(%d)")% (*ci)[01;31m-[00m>getUniqueIdNumeric() );
integerKeyObjectDictionary.cc:193:	    uint ikey = (*ci)[01;31m-[00m>getUniqueIdNumeric();
integerKeyObjectDictionary.cc:194:	    this[01;31m-[00m>_Map[ikey] = object;
integerKeyObjectDictionary.cc:201:{_F(this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:202:    this[01;31m-[00m>archiveBase(node);
integerKeyObjectDictionary.cc:210:    RPCons list = O_Cons::nil(this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:211:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
integerKeyObjectDictionary.cc:212:        list = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Int>(vi[01;31m-[00m>first),list,this[01;31m-[00m>lisp());
integerKeyObjectDictionary.cc:223:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
integerKeyObjectDictionary.cc:224:	res.append(boost::python::str(vi[01;31m-[00m>first));
integerKeyObjectDictionary.cc:236:    class_<O_IntegerKeyObjectDictionary>(this[01;31m-[00m>lisp())
intrinsics.cc:47://    me[01;31m-[00m>setName(macroHolder[01;31m-[00m>getName());
intrinsics.cc:48:    me[01;31m-[00m>setMacroHolder(macroHolder);
intrinsics.cc:55:    return this[01;31m-[00m>_MacroHolder[01;31m-[00m>invoke(this,args,lisp);
intrinsics.cc:60:    this[01;31m-[00m>_MacroHolder = mh;
intrinsics.cc:71:    this[01;31m-[00m>Base::archiveBase(node);
intrinsics.cc:77:{_F(this[01;31m-[00m>lisp());
intrinsics.cc:91:    prim[01;31m-[00m>_WeakSymbol = sym;
intrinsics.cc:92:    prim[01;31m-[00m>_Functoid = func;
intrinsics.cc:102:{_F(this[01;31m-[00m>lisp());
intrinsics.cc:103:    LOG(BF("Evaluating primitive(%s)")% this[01;31m-[00m>getName());
intrinsics.cc:104:    return this[01;31m-[00m>_Functoid[01;31m-[00m>invoke(this[01;31m-[00m>sharedThis<O_FunctionPrimitive>(),args,environ,lisp);
intrinsics.cc:112:    prim[01;31m-[00m>_WeakSymbol = sym;
intrinsics.cc:113:    prim[01;31m-[00m>_WeakAppliesToClass = mc;
intrinsics.cc:114:    prim[01;31m-[00m>_Methoid = func;
intrinsics.cc:123:{_F(this[01;31m-[00m>lisp());
intrinsics.cc:125:    LOG(BF("Evaluating method args: %s") % args[01;31m-[00m>__repr__() );
intrinsics.cc:127:    return this[01;31m-[00m>_Methoid[01;31m-[00m>invoke(this[01;31m-[00m>sharedThis<O_MethodPrimitive>(),args,environ,lisp);
intrinsics.cc:136:    this[01;31m-[00m>Base::initialize();
intrinsics.cc:137://    this[01;31m-[00m>_WeakSymbol = O_Symbol::nil();
intrinsics.cc:138://    this[01;31m-[00m>_MethodIdx = UndefinedUnsignedInt;
intrinsics.cc:139:    this[01;31m-[00m>_WeakSymbol = O_Symbol::nil(this[01;31m-[00m>lisp());
intrinsics.cc:144:	ASSERT_NOT_NULL(this[01;31m-[00m>_WeakSymbol);
intrinsics.cc:145:	RPSymbol sym = this[01;31m-[00m>_WeakSymbol.lock();
intrinsics.cc:147:	ss << "Executable("<<sym[01;31m-[00m>fullName()<<")";
intrinsics.cc:164:    this[01;31m-[00m>Base::archiveBase(node);
intrinsics.cc:165:    node[01;31m-[00m>archiveWeakPointer("weakSymbol",this[01;31m-[00m>_WeakSymbol);
intrinsics.cc:170:    this[01;31m-[00m>_WeakSymbol = s;
intrinsics.cc:175:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakSymbol);
intrinsics.cc:176:    return this[01;31m-[00m>_WeakSymbol.lock();
intrinsics.cc:181:    return this[01;31m-[00m>getSymbol()[01;31m-[00m>__repr__();
intrinsics.cc:190:    this[01;31m-[00m>Base::initialize();
intrinsics.cc:191:    this[01;31m-[00m>_SlotKeywordSymbol = O_Symbol::nil(this[01;31m-[00m>lisp());
intrinsics.cc:197:    this[01;31m-[00m>_SlotKeywordSymbol = sym[01;31m-[00m>asKeywordSymbol();
intrinsics.cc:202:    return this[01;31m-[00m>_SlotKeywordSymbol;
intrinsics.cc:213:    this[01;31m-[00m>Base::initialize();
intrinsics.cc:220:    RPSlotSetter ss = lisp[01;31m-[00m>create<O_SlotSetter>();
intrinsics.cc:221:    ss[01;31m-[00m>setSlotKeywordSymbol(sym[01;31m-[00m>asKeywordSymbol());
intrinsics.cc:228:    RPCandoObject target = eval::evaluate(args[01;31m-[00m>ocar(),environ,lisp)[01;31m-[00m>as<O_CandoObject>();
intrinsics.cc:229:    ASSERTP(target[01;31m-[00m>_class()[01;31m-[00m>supportsSlots(),"The target doesn't support slots");
intrinsics.cc:230:    RPObject value = eval::evaluate(args[01;31m-[00m>ocadr(),environ,lisp)[01;31m-[00m>as<O_Object>();
intrinsics.cc:231:    target[01;31m-[00m>setSlot(this[01;31m-[00m>_SlotKeywordSymbol,value);
intrinsics.cc:243:    this[01;31m-[00m>Base::initialize();
intrinsics.cc:249:    RPSlotGetter ss = lisp[01;31m-[00m>create<O_SlotGetter>();
intrinsics.cc:250:    ss[01;31m-[00m>setSlotKeywordSymbol(sym[01;31m-[00m>asKeywordSymbol());
intrinsics.cc:256:    RPCandoObject target = eval::evaluate(args[01;31m-[00m>ocar(),environ,lisp)[01;31m-[00m>as<O_CandoObject>();
intrinsics.cc:257:    ASSERTP(target[01;31m-[00m>_class()[01;31m-[00m>supportsSlots(),"The target doesn't support slots");
intrinsics.cc:258:    RPObject value = target[01;31m-[00m>getSlot(this[01;31m-[00m>_SlotKeywordSymbol);
intrinsics.cc:272:    this[01;31m-[00m>Base::initialize();
intrinsics.cc:278:    this[01;31m-[00m>Base::archiveBase(node);
intrinsics.cc:283:{_F(this[01;31m-[00m>lisp());
intrinsics.cc:287:    ASSERT_NOT_NULL(this[01;31m-[00m>_Environment);
intrinsics.cc:288:    if ( this[01;31m-[00m>_Environment[01;31m-[00m>isNil() )
intrinsics.cc:290:	ASSERTF(environ[01;31m-[00m>notNil(),BF("this[01;31m-[00m>_Environment is nil and so is environ!"));
intrinsics.cc:293:    return this[01;31m-[00m>_Environment;
intrinsics.cc:298:{_F(this[01;31m-[00m>lisp());
intrinsics.cc:300:    this[01;31m-[00m>_Environment = environ;
intrinsics.cc:312:    boundMethod[01;31m-[00m>setMethod(method);
intrinsics.cc:313:    boundMethod[01;31m-[00m>setReceiver(receiver);
intrinsics.cc:320:    this[01;31m-[00m>_Receiver = obj;
intrinsics.cc:325:    this[01;31m-[00m>_Method = method;
intrinsics.cc:329:{_F(this[01;31m-[00m>lisp());
intrinsics.cc:331:    RPMethod exec = this[01;31m-[00m>_Method;
intrinsics.cc:332:    RPCons fullArgs = O_Cons::create(this[01;31m-[00m>_Receiver,args,lisp);
intrinsics.cc:333:    LOG(BF("Evaluating bound method with arguments: %s") % fullArgs[01;31m-[00m>__repr__() );
intrinsics.cc:334:    return exec[01;31m-[00m>evaluate(fullArgs,environ,lisp);
intrinsics.cc:350:    LOG(BF("Creating a procedure named: %s")% name[01;31m-[00m>currentName());
intrinsics.cc:353:    proc = lisp[01;31m-[00m>create<O_Procedure>();
intrinsics.cc:354:    proc[01;31m-[00m>_WeakSymbol = name;
intrinsics.cc:355:    proc[01;31m-[00m>setupArgumentHandling(arguments,lisp);
intrinsics.cc:356:    proc[01;31m-[00m>_DocString = docString;
intrinsics.cc:357:    proc[01;31m-[00m>_Code = code;
intrinsics.cc:358:    proc[01;31m-[00m>_Environment = environ;
intrinsics.cc:359:    if ( code[01;31m-[00m>isNil() )
intrinsics.cc:361:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The procedure code is Nil!!!!"));
intrinsics.cc:363:    LOG(BF("Created procedure with name: %s")% proc[01;31m-[00m>getName() );
intrinsics.cc:365:    LOG(BF("  Its className() = %s")% proc[01;31m-[00m>className() );
intrinsics.cc:366:    LOG(BF("  Its classId() = %d")% proc[01;31m-[00m>classId() );
intrinsics.cc:374:    this[01;31m-[00m>Base::initialize();
intrinsics.cc:375:    this[01;31m-[00m>_ArgumentHandler = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_ArgumentHandler>();
intrinsics.cc:376:    this[01;31m-[00m>_DocString = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Text>();
intrinsics.cc:377:    this[01;31m-[00m>_Code = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_ParsingCons>();
intrinsics.cc:378:    this[01;31m-[00m>_Environment = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Environment>();
intrinsics.cc:384:    this[01;31m-[00m>Base::archiveBase(node);
intrinsics.cc:385:    node[01;31m-[00m>archiveObject("argumentHandler",this[01;31m-[00m>_ArgumentHandler);
intrinsics.cc:386:    node[01;31m-[00m>archiveObjectIfDefined("docString",this[01;31m-[00m>_DocString);
intrinsics.cc:387:    node[01;31m-[00m>archiveObjectIfDefined("code",this[01;31m-[00m>_Code);
intrinsics.cc:393:    this[01;31m-[00m>_ArgumentHandler = lisp[01;31m-[00m>create<O_ArgumentHandler>();
intrinsics.cc:394:    this[01;31m-[00m>_ArgumentHandler[01;31m-[00m>setupArgumentHandling(args);
intrinsics.cc:401:    ASSERT_NOT_NULL(this[01;31m-[00m>_ArgumentHandler);
intrinsics.cc:402:    return this[01;31m-[00m>_ArgumentHandler[01;31m-[00m>numberOfRequiredArguments();
intrinsics.cc:407:{_F(this[01;31m-[00m>lisp());
intrinsics.cc:409:RPEnvironment localEnvironment = this[01;31m-[00m>closedEnvironment(environ);
intrinsics.cc:411:    ASSERTP(localEnvironment[01;31m-[00m>notNil(),"localEnvironment is nil [01;31m-[00m should never happen");
intrinsics.cc:413:    ASSERT_NOT_NULL(this[01;31m-[00m>_ArgumentHandler);
intrinsics.cc:414:    ASSERT(this[01;31m-[00m>_ArgumentHandler[01;31m-[00m>notNil());
intrinsics.cc:416:    this[01;31m-[00m>_ArgumentHandler[01;31m-[00m>populateLocalEnvironment(args,newEnvironment);
intrinsics.cc:417:    LOG(BF("About to evaluate the code in the environment[01;31m-[00m>\n%s") % newEnvironment[01;31m-[00m>__repr__() );
intrinsics.cc:418:    LOG(BF("About to evaluate code: %s")%this[01;31m-[00m>_Code[01;31m-[00m>__repr__() );
intrinsics.cc:420:    LOG(BF("Pushing code onto the backTrace: <%s>")%this[01;31m-[00m>_Code[01;31m-[00m>__repr__() );
intrinsics.cc:421:    newEnvironment[01;31m-[00m>setCode(this[01;31m-[00m>_Code);
intrinsics.cc:422:    PushCodeStack codeStack(this[01;31m-[00m>_Code,lisp);
intrinsics.cc:425:	if ( lisp[01;31m-[00m>debugLog().isEnabled() )
intrinsics.cc:427:	    if ( this[01;31m-[00m>_Code[01;31m-[00m>isOfClass<O_ParsingCons>() )
intrinsics.cc:428:	    {_StackTrace st(this[01;31m-[00m>_Code[01;31m-[00m>getParsePosFileName().c_str(),this[01;31m-[00m>getSymbol()[01;31m-[00m>currentName().c_str(),"CSC_PROC",this[01;31m-[00m>_Code[01;31m-[00m>getParsePosLineNumber(),_lisp);
intrinsics.cc:429:		result = eval::evaluate(this[01;31m-[00m>_Code,newEnvironment,lisp);
intrinsics.cc:431:	    {_StackTrace st("[01;31m-[00mno file[01;31m-[00m",this[01;31m-[00m>getSymbol()[01;31m-[00m>currentName().c_str(),"CSC_PROC",0,_lisp);
intrinsics.cc:432:		result = eval::evaluate(this[01;31m-[00m>_Code,newEnvironment,lisp);
intrinsics.cc:435:	{_BLOCK_TRACE("Calling evaluate on this[01;31m-[00m>_Code");
intrinsics.cc:436:	    result = eval::evaluate(this[01;31m-[00m>_Code,newEnvironment,lisp);
intrinsics.cc:441:	lisp[01;31m-[00m>clearReturnFlag();
intrinsics.cc:444:    lisp[01;31m-[00m>clearReturnFlag();
intrinsics.cc:445:    LOG(BF("Returning result: %s") % result[01;31m-[00m>__repr__().c_str()  ); // vp0(("Returning result: %s",result[01;31m-[00m>__repr__().c_str() ));
intrinsics.cc:464:    ASSERTP(messageKeyword[01;31m-[00m>isKeywordSymbol(),"Message symbols must be keywords, you can convert them to keywords here if you want");
intrinsics.cc:467:    proc[01;31m-[00m>_WeakSymbol = messageKeyword;
intrinsics.cc:468:    proc[01;31m-[00m>setupArgumentHandling(arguments,lisp);
intrinsics.cc:469:    proc[01;31m-[00m>_DocString = docString;
intrinsics.cc:470:    proc[01;31m-[00m>_Code = code;
intrinsics.cc:471:    proc[01;31m-[00m>closeOverEnvironment(environ);
intrinsics.cc:487:    proc[01;31m-[00m>setReceiverClass(receiverClass);
intrinsics.cc:494:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakReceiverClass);
intrinsics.cc:495:    return this[01;31m-[00m>_WeakReceiverClass.lock();
intrinsics.cc:501:    ss << this[01;31m-[00m>getReceiverClass()[01;31m-[00m>getPackagedName();
intrinsics.cc:502://    ss << "(" << this[01;31m-[00m>_AppliesToClassIdx << ")";
intrinsics.cc:504:    ss << this[01;31m-[00m>getSymbol()[01;31m-[00m>currentName();
intrinsics.cc:511:{_F(this[01;31m-[00m>lisp());
intrinsics.cc:512:    RPEnvironment closedEnvironment = this[01;31m-[00m>closedEnvironment(environment);
intrinsics.cc:516:    ASSERTP(newEnvironment[01;31m-[00m>notNil(),"newEnvironment is nil [01;31m-[00m should never happen");
intrinsics.cc:518:    this[01;31m-[00m>_ArgumentHandler[01;31m-[00m>populateLocalEnvironment(args,newEnvironment);
intrinsics.cc:520:    LOG(BF("About to evaluate code: %s") % this[01;31m-[00m>_Code[01;31m-[00m>__repr__() );
intrinsics.cc:528:    if ( args[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_CandoObject>() )
intrinsics.cc:530:        RPCandoObject candoObject = args[01;31m-[00m>car<O_CandoObject>();
intrinsics.cc:531:	if ( lisp[01;31m-[00m>debugLog().isEnabled() )
intrinsics.cc:533:	    if ( this[01;31m-[00m>_Code[01;31m-[00m>isOfClass<O_ParsingCons>() )
intrinsics.cc:534:	    {_StackTrace st( this[01;31m-[00m>_Code[01;31m-[00m>getParsePosFileName().c_str(),this[01;31m-[00m>getFullMethodName(lisp).c_str(),"CSC_METHOD",this[01;31m-[00m>_Code[01;31m-[00m>getParsePosLineNumber(),_lisp);
intrinsics.cc:535:		result = eval::evaluate(this[01;31m-[00m>_Code,newEnvironment,lisp);
intrinsics.cc:537:	    {_StackTrace st( "[01;31m-[00mno file[01;31m-[00m",this[01;31m-[00m>getFullMethodName(lisp).c_str(),"CSC_METHOD",this[01;31m-[00m>_Code[01;31m-[00m>getParsePosLineNumber(),_lisp);
intrinsics.cc:538:		result = eval::evaluate(this[01;31m-[00m>_Code,newEnvironment,lisp);
intrinsics.cc:542:	    result = eval::evaluate(this[01;31m-[00m>_Code,newEnvironment,lisp);
intrinsics.cc:546:	if ( lisp[01;31m-[00m>debugLog().isEnabled() )
intrinsics.cc:548:	    if ( this[01;31m-[00m>_Code[01;31m-[00m>isOfClass<O_ParsingCons>() )
intrinsics.cc:549:	    {_StackTrace st(this[01;31m-[00m>_Code[01;31m-[00m>getParsePosFileName().c_str(),this[01;31m-[00m>getFullMethodName(lisp).c_str(), "CSC_METHOD",this[01;31m-[00m>_Code[01;31m-[00m>getParsePosLineNumber(),_lisp);
intrinsics.cc:550:		result = eval::evaluate(this[01;31m-[00m>_Code,newEnvironment,lisp);
intrinsics.cc:552:	    {_StackTrace st("[01;31m-[00mnofile[01;31m-[00m",this[01;31m-[00m>getFullMethodName(_lisp).c_str(),"CSC_METHOD",0,_lisp);
intrinsics.cc:553:		result = eval::evaluate(this[01;31m-[00m>_Code,newEnvironment,lisp);
intrinsics.cc:557:	    result = eval::evaluate(this[01;31m-[00m>_Code,newEnvironment,lisp);
intrinsics.cc:560:    lisp[01;31m-[00m>clearReturnFlag();
intrinsics.cc:565:    LOG(BF("Returning result: %s") % result[01;31m-[00m>__repr__().c_str()  ); // vp0(("Returning result: %s",result[01;31m-[00m>__repr__().c_str() ));
iterateCons.cc:19:    this[01;31m-[00m>Base::initialize();
iterateCons.cc:25:    this[01;31m-[00m>_Cur = this[01;31m-[00m>_Begin;
iterateCons.cc:29:    this[01;31m-[00m>_Cur = this[01;31m-[00m>_Cur[01;31m-[00m>cdr();
iterateCons.cc:33:    ASSERT_NOT_NULL(this[01;31m-[00m>_Cur);
iterateCons.cc:34:    return (this[01;31m-[00m>_Cur[01;31m-[00m>isNil());
iterateCons.cc:39:    return this[01;31m-[00m>_Cur[01;31m-[00m>ocar();
iterateCons.cc:47:	class_<O_IterateCons>(this[01;31m-[00m>lisp())
iterateHits.cc:19:    r[01;31m-[00m>init(beg);
iterateHits.cc:25:    this[01;31m-[00m>Base::initialize();
iterateHits.cc:30:    this[01;31m-[00m>_Begin = c[01;31m-[00m>begin();
iterateHits.cc:31:    this[01;31m-[00m>_End = c[01;31m-[00m>end();
iterateHits.cc:36:    this[01;31m-[00m>_Cur = this[01;31m-[00m>_Begin;
iterateHits.cc:40:    this[01;31m-[00m>_Cur++;
iterateHits.cc:44:    return ( this[01;31m-[00m>_Cur >= this[01;31m-[00m>_End );
iterateHits.cc:49:    return (*(this[01;31m-[00m>_Cur));
iterateHits.cc:57:	class_<O_IterateHits>(this[01;31m-[00m>lisp())
iterateHits.cc:60://	def("hits",&O_IterateHits::create,this[01;31m-[00m>lisp());
iterateMatter.cc:15:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:16:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
iterateMatter.cc:23:    m[01;31m-[00m>_Top = top;
iterateMatter.cc:24:    m[01;31m-[00m>_Goal = goal;
iterateMatter.cc:32:    this[01;31m-[00m>Base::initialize();
iterateMatter.cc:43:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:45:    this[01;31m-[00m>_Top = top;
iterateMatter.cc:50:    this[01;31m-[00m>_Goal = goal;
iterateMatter.cc:56:    this[01;31m-[00m>_IsDone = false;
iterateMatter.cc:57:    this[01;31m-[00m>_Loop.loopTopGoal(this[01;31m-[00m>_Top,this[01;31m-[00m>_Goal);
iterateMatter.cc:58:    this[01;31m-[00m>next();
iterateMatter.cc:63:    this[01;31m-[00m>advance();
iterateMatter.cc:67:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:68:    if ( !this[01;31m-[00m>_IsDone )
iterateMatter.cc:70:        bool d = this[01;31m-[00m>_Loop.advance();
iterateMatter.cc:74:	    this[01;31m-[00m>_IsDone = true;
iterateMatter.cc:77:    return this[01;31m-[00m>_IsDone;
iterateMatter.cc:82:    if ( this[01;31m-[00m>_IsDone ) return O_Matter::nil(this[01;31m-[00m>lisp());
iterateMatter.cc:83:    RPMatter res = this[01;31m-[00m>_Loop.getMatter();
iterateMatter.cc:90:    return this[01;31m-[00m>_IsDone;
iterateMatter.cc:103:    ia[01;31m-[00m>initTopAndGoal(top,ATOMS);
iterateMatter.cc:111:    ASSERTP(args[01;31m-[00m>ocar()[01;31m-[00m>notNil(),"You must provide one Matter argument");
iterateMatter.cc:112:    ia[01;31m-[00m>initTopAndGoal(args[01;31m-[00m>car<O_Matter>(),ATOMS);
iterateMatter.cc:118:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:119:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
iterateMatter.cc:120:    RPMatter matter = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Matter>();
iterateMatter.cc:121:    this[01;31m-[00m>initTopAndGoal(matter,ATOMS);
iterateMatter.cc:125:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:126:    if ( this[01;31m-[00m>isDone() ) return O_Object::nil(this[01;31m-[00m>lisp());
iterateMatter.cc:127:    return this[01;31m-[00m>_Loop.getAtom();
iterateMatter.cc:137:    ia[01;31m-[00m>initTopAndGoal(top,RESIDUES);
iterateMatter.cc:143:    return O_IterateResidues::create(lisp,args[01;31m-[00m>car<O_Matter>());
iterateMatter.cc:148:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:149:    if ( this[01;31m-[00m>isDone() ) return O_Object::nil(this[01;31m-[00m>lisp());
iterateMatter.cc:150:    return this[01;31m-[00m>_Loop.getResidue();
iterateMatter.cc:159:    ia[01;31m-[00m>initTopAndGoal(top,BONDS);
iterateMatter.cc:165:    return O_IterateBonds::create(lisp,args[01;31m-[00m>car<O_Matter>());
iterateMatter.cc:171:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:172:    return this[01;31m-[00m>sharedThis<O_IterateBonds>();
iterateMatter.cc:177:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:178:    return this[01;31m-[00m>_Loop.getAtom1();
iterateMatter.cc:182:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:183:    return this[01;31m-[00m>_Loop.getAtom2();
iterateMatter.cc:187:{_F(this[01;31m-[00m>lisp());
iterateMatter.cc:188:    return this[01;31m-[00m>_Loop.getBondOrder();
iterateMatter.cc:209:	class_<O_IterateMatter>(this[01;31m-[00m>lisp())
iterateMatter.cc:213:	this[01;31m-[00m>lisp()[01;31m-[00m>installGlobalInitializationCallback(&O_IterateMatter::initializeGlobals);
iterateMatter.cc:234:	class_<O_IterateAtoms>(this[01;31m-[00m>lisp())
iterateMatter.cc:236:	defNoWrapPackage(MbbPackage,"atoms",&O_IterateAtoms::createForMatter,this[01;31m-[00m>lisp());
iterateMatter.cc:259:	class_<O_IterateResidues>(this[01;31m-[00m>lisp())
iterateMatter.cc:261:	defNoWrapPackage(MbbPackage,"residues",&O_IterateResidues::createForMatter,this[01;31m-[00m>lisp());
iterateMatter.cc:282:	class_<O_IterateBonds>(this[01;31m-[00m>lisp())
iterateMatter.cc:287:	defNoWrapPackage(MbbPackage,"bonds",&O_IterateBonds::createForMatter,this[01;31m-[00m>lisp());
iterateObjectDictionary.cc:19:    r[01;31m-[00m>init(beg);
iterateObjectDictionary.cc:25:    this[01;31m-[00m>Base::initialize();
iterateObjectDictionary.cc:29:{ _F(this[01;31m-[00m>lisp());
iterateObjectDictionary.cc:30:    this[01;31m-[00m>_Begin = c[01;31m-[00m>begin();
iterateObjectDictionary.cc:31:    this[01;31m-[00m>_End = c[01;31m-[00m>end();
iterateObjectDictionary.cc:35:{_F(this[01;31m-[00m>lisp());
iterateObjectDictionary.cc:36:    this[01;31m-[00m>_Cur = this[01;31m-[00m>_Begin;
iterateObjectDictionary.cc:39:{_F(this[01;31m-[00m>lisp());
iterateObjectDictionary.cc:40:    this[01;31m-[00m>_Cur++;
iterateObjectDictionary.cc:47:{_F(this[01;31m-[00m>lisp());
iterateObjectDictionary.cc:48:    return ( this[01;31m-[00m>_Cur == this[01;31m-[00m>_End );
iterateObjectDictionary.cc:55:{ _F(this[01;31m-[00m>lisp());
iterateObjectDictionary.cc:56:    return this[01;31m-[00m>sharedThis<O_IterateObjectDictionary>();
iterateObjectDictionary.cc:63:{_F(this[01;31m-[00m>lisp());
iterateObjectDictionary.cc:64:    return O_Text::create(this[01;31m-[00m>_Cur[01;31m-[00m>first,this[01;31m-[00m>lisp());
iterateObjectDictionary.cc:68:{_F(this[01;31m-[00m>lisp());
iterateObjectDictionary.cc:69:    return this[01;31m-[00m>_Cur[01;31m-[00m>second;
iterateObjectDictionary.cc:78:	class_<O_IterateObjectDictionary>(this[01;31m-[00m>lisp())
iterateObjectList.cc:19:    r[01;31m-[00m>init(beg);
iterateObjectList.cc:25:    this[01;31m-[00m>Base::initialize();
iterateObjectList.cc:29:{ _F(this[01;31m-[00m>lisp());
iterateObjectList.cc:30:    this[01;31m-[00m>_Begin = c[01;31m-[00m>begin();
iterateObjectList.cc:31:    this[01;31m-[00m>_End = c[01;31m-[00m>end();
iterateObjectList.cc:35:{_F(this[01;31m-[00m>lisp());
iterateObjectList.cc:36:    this[01;31m-[00m>_Cur = this[01;31m-[00m>_Begin;
iterateObjectList.cc:39:{_F(this[01;31m-[00m>lisp());
iterateObjectList.cc:40:    this[01;31m-[00m>_Cur++;
iterateObjectList.cc:47:{_F(this[01;31m-[00m>lisp());
iterateObjectList.cc:48:    return ( this[01;31m-[00m>_Cur == this[01;31m-[00m>_End );
iterateObjectList.cc:55:{ _F(this[01;31m-[00m>lisp());
iterateObjectList.cc:56:    return *(this[01;31m-[00m>_Cur);
iterateObjectList.cc:68:	class_<O_IterateObjectList>(this[01;31m-[00m>lisp())
iterateRange.cc:18:    r[01;31m-[00m>_Begin = ibegin;
iterateRange.cc:19:    r[01;31m-[00m>_Step = 1;
iterateRange.cc:20:    r[01;31m-[00m>_End = iend;
iterateRange.cc:28:    r[01;31m-[00m>_Begin = ibegin;
iterateRange.cc:29:    r[01;31m-[00m>_Step = istep;
iterateRange.cc:30:    r[01;31m-[00m>_End = iend;
iterateRange.cc:37:    this[01;31m-[00m>Base::initialize();
iterateRange.cc:38:    this[01;31m-[00m>_Cur = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Int>(0);
iterateRange.cc:44:    this[01;31m-[00m>_Begin=b;
iterateRange.cc:45:    this[01;31m-[00m>_End = e;
iterateRange.cc:46:    this[01;31m-[00m>_Step = 1;
iterateRange.cc:51:    this[01;31m-[00m>_Cur[01;31m-[00m>set(this[01;31m-[00m>_Begin);
iterateRange.cc:57:    this[01;31m-[00m>_Cur[01;31m-[00m>increment(this[01;31m-[00m>_Step);
iterateRange.cc:62:    ASSERT_NOT_NULL(this[01;31m-[00m>_Cur);
iterateRange.cc:63:    return this[01;31m-[00m>_Cur[01;31m-[00m>get()>=this[01;31m-[00m>_End;
iterateRange.cc:68:    return this[01;31m-[00m>_Cur;
iterateRange.cc:75:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Don't use range, use Range"));
iterateRange.cc:76:    int numArgs = args[01;31m-[00m>length();
iterateRange.cc:79:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Only 2 or 3 arguments for range allowed"));
iterateRange.cc:82:    int ibegin = args[01;31m-[00m>car<O_Int>()[01;31m-[00m>get();
iterateRange.cc:84:    int iend = args[01;31m-[00m>cadr<O_Int>()[01;31m-[00m>get();
iterateRange.cc:89:	istep = args[01;31m-[00m>caddr<O_Int>()[01;31m-[00m>get();
iterateRange.cc:106:	class_<O_IterateRange>(this[01;31m-[00m>lisp())
iterateRange.cc:109:	defNoWrapPackage(MbbPackage,"range",&O_IterateRange::prim_range,this[01;31m-[00m>lisp());
iterateRestraints.cc:17:    m[01;31m-[00m>initTop(matter);
iterateRestraints.cc:24:    this[01;31m-[00m>Base::initialize();
iterateRestraints.cc:29:{_F(this[01;31m-[00m>lisp());
iterateRestraints.cc:30:    RPRestraintList mine = m[01;31m-[00m>getRestraints();
iterateRestraints.cc:32:    for ( it=mine[01;31m-[00m>_Restraints_begin(); it!=mine[01;31m-[00m>_Restraints_end(); it++ )
iterateRestraints.cc:34:	RPCons one = O_Cons::create((*it),this[01;31m-[00m>_Restraints,this[01;31m-[00m>lisp());
iterateRestraints.cc:35:	this[01;31m-[00m>_Restraints = one;
iterateRestraints.cc:38:    for ( mit=m[01;31m-[00m>getContents().begin(); mit!=m[01;31m-[00m>getContents().end(); mit++ )
iterateRestraints.cc:40:	this[01;31m-[00m>_accumulateRestraints(*mit);
iterateRestraints.cc:50:{_F(this[01;31m-[00m>lisp());
iterateRestraints.cc:51:    this[01;31m-[00m>_Restraints = O_Cons::nil(this[01;31m-[00m>lisp());
iterateRestraints.cc:52:    this[01;31m-[00m>_accumulateRestraints(m);
iterateRestraints.cc:56:{_F(this[01;31m-[00m>lisp());
iterateRestraints.cc:57:    this[01;31m-[00m>_CurRestraint = this[01;31m-[00m>_Restraints;
iterateRestraints.cc:61:{_F(this[01;31m-[00m>lisp());
iterateRestraints.cc:62:    if ( this[01;31m-[00m>_CurRestraint[01;31m-[00m>notNil() )
iterateRestraints.cc:64:        this[01;31m-[00m>_CurRestraint = this[01;31m-[00m>_CurRestraint[01;31m-[00m>cdr();
iterateRestraints.cc:70:{_F(this[01;31m-[00m>lisp());
iterateRestraints.cc:71:    if ( this[01;31m-[00m>_CurRestraint[01;31m-[00m>isNil() ) return O_Object::nil(this[01;31m-[00m>lisp());
iterateRestraints.cc:72:    return this[01;31m-[00m>_CurRestraint[01;31m-[00m>ocar();
iterateRestraints.cc:76:{_F(this[01;31m-[00m>lisp());
iterateRestraints.cc:77:    ASSERT_NOT_NULL(this[01;31m-[00m>_CurRestraint);
iterateRestraints.cc:78:    return this[01;31m-[00m>_CurRestraint[01;31m-[00m>isNil();
iterateRestraints.cc:86:	class_<O_IterateRestraints>(this[01;31m-[00m>lisp())
iterator.cc:19:    this[01;31m-[00m>Base::initialize();
iterator.cc:32:	class_<O_Iterator>(this[01;31m-[00m>lisp())
jobHistory.cc:15:    this[01;31m-[00m>Base::initialize();
jobHistory.cc:16:    this[01;31m-[00m>_Command = "";
jobHistory.cc:17:    this[01;31m-[00m>_Outcome = "";
jobHistory.cc:18:    this[01;31m-[00m>_Comment = "";
jobHistory.cc:19:    this[01;31m-[00m>_StartSeconds = 0;
jobHistory.cc:20:    this[01;31m-[00m>_StopSeconds = 0;
jobHistory.cc:27:    node[01;31m-[00m>attribute("Command",this[01;31m-[00m>_Command);
jobHistory.cc:28:    node[01;31m-[00m>attribute("StartSeconds",this[01;31m-[00m>_StartSeconds);
jobHistory.cc:29:    node[01;31m-[00m>attribute("StopSeconds",this[01;31m-[00m>_StopSeconds);
jobHistory.cc:30:    node[01;31m-[00m>attribute("Outcome",this[01;31m-[00m>_Outcome);
jobHistory.cc:31:    if ( node[01;31m-[00m>loading() )
jobHistory.cc:33:        this[01;31m-[00m>_Comment = node[01;31m-[00m>characters();
jobHistory.cc:36:        node[01;31m-[00m>setCharacters(this[01;31m-[00m>_Comment);
jobHistory.cc:46:    this[01;31m-[00m>setStartSeconds(seconds);
jobHistory.cc:47:    this[01;31m-[00m>setCommand(command);
jobHistory.cc:56:    this[01;31m-[00m>setStopSeconds(seconds);
jobHistory.cc:57:    this[01;31m-[00m>setState(newStateName);
jobHistory.cc:63:    node[01;31m-[00m>archiveList<O_TrainerHistoryEntry>("entries",this[01;31m-[00m>_Entries);
jobHistory.cc:76:    class_<O_TrainerHistoryEntry>(this[01;31m-[00m>lisp())
jobHistory.cc:108:    class_<O_TrainerHistory>(this[01;31m-[00m>lisp())
keyedArguments.cc:21:    kargs[01;31m-[00m>fillFromCons(cons);
keyedArguments.cc:27:    this[01;31m-[00m>oldLispInitialize(kargs,env);
keyedArguments.cc:28:    RPCons cons = kargs[01;31m-[00m>getAndRemove("cons")[01;31m-[00m>as<O_Cons>();
keyedArguments.cc:29:    this[01;31m-[00m>fillFromCons(cons);
keyedArguments.cc:33:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:34:    LOG(BF("Create KeyedArguments from: %s") % cons[01;31m-[00m>__repr__().c_str()  ); // vp0(("Create KeyedArguments from: %s", cons[01;31m-[00m>__repr__().c_str() ));
keyedArguments.cc:38:    while ( cur[01;31m-[00m>notNil() )
keyedArguments.cc:40:	if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isOfClass<O_KeyedObject>() )
keyedArguments.cc:43:	    RPKeyedObject ko = cur[01;31m-[00m>car<O_KeyedObject>();
keyedArguments.cc:44:	    this[01;31m-[00m>set(ko[01;31m-[00m>getKeyName(),ko[01;31m-[00m>getValue());
keyedArguments.cc:45:	} else if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
keyedArguments.cc:47:	    RPSymbol sko = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
keyedArguments.cc:48:	    cur = cur[01;31m-[00m>cdr();
keyedArguments.cc:49:	    RPObject obj = cur[01;31m-[00m>ocar();
keyedArguments.cc:50:	    this[01;31m-[00m>set(sko[01;31m-[00m>identifierName(),obj);
keyedArguments.cc:55:		this[01;31m-[00m>appendPositionalArgument(cur[01;31m-[00m>ocar());
keyedArguments.cc:58:	        TOSS(_lisp[01;31m-[00m>create<O_LispError>("A non[01;31m-[00mkeyed/positional object was found after a keyed object in the argument list. The order should always be: positionalArguments... keyedArguments..."));
keyedArguments.cc:61:	cur = cur[01;31m-[00m>cdr();
keyedArguments.cc:63:    LOG(BF("Dictionary described:%s") % (this[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Dictionary described:%s", this[01;31m-[00m>__repr__().c_str() ));
keyedArguments.cc:70:    ss << this[01;31m-[00m>className() << endl;
keyedArguments.cc:71:    ss << "Number of positional arguments: " << this[01;31m-[00m>_PositionalArguments.size()<<endl;
keyedArguments.cc:73:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
keyedArguments.cc:74:	ss << boost::format("   %20s: %s") % vi[01;31m-[00m>first % vi[01;31m-[00m>second[01;31m-[00m>description() << endl;
keyedArguments.cc:79:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:80:    return this[01;31m-[00m>_PositionalArguments.size();
keyedArguments.cc:84:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:85:    ASSERT_lessThan(idx,this[01;31m-[00m>_PositionalArguments.size());
keyedArguments.cc:86:    return this[01;31m-[00m>_PositionalArguments.get(idx);
keyedArguments.cc:90:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:91:    this[01;31m-[00m>_PositionalArguments.push_back(obj);
keyedArguments.cc:97:    return this[01;31m-[00m>_PositionalArguments.asCons(this[01;31m-[00m>lisp());
keyedArguments.cc:101:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:104:    if ( this[01;31m-[00m>_Map.count(key) == 0 ) {
keyedArguments.cc:107:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
keyedArguments.cc:109:    return this[01;31m-[00m>_Map.get(key);
keyedArguments.cc:113:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:114:    if ( positionalExpected != this[01;31m-[00m>numberOfPositionalArguments() )
keyedArguments.cc:118:	ss << positionalExpected << " received " << this[01;31m-[00m>numberOfPositionalArguments();
keyedArguments.cc:119:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
keyedArguments.cc:121:    if ( this[01;31m-[00m>_Map.size() == 0 ) return;
keyedArguments.cc:124:    for ( it = this[01;31m-[00m>_Map.begin(); it!=this[01;31m-[00m>_Map.end(); it++ )
keyedArguments.cc:126:	ss << it[01;31m-[00m>first << " ";
keyedArguments.cc:128:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unused arguments("+ss.str()+")"));
keyedArguments.cc:132:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:136:    LOG(BF("   keys[01;31m-[00m> %s") % this[01;31m-[00m>allKeys().c_str()  ); // vp0(("   keys[01;31m-[00m> %s", this[01;31m-[00m>allKeys().c_str() ));
keyedArguments.cc:137:    if ( this[01;31m-[00m>_Map.count(name) == 0 ) {
keyedArguments.cc:140:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
keyedArguments.cc:142:    obj = this[01;31m-[00m>_Map.get(name);
keyedArguments.cc:143:    this[01;31m-[00m>_Map.remove(name);
keyedArguments.cc:148:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:151:    if ( this[01;31m-[00m>_Map.count(name) == 0 ) {
keyedArguments.cc:154:    obj = this[01;31m-[00m>_Map.get(name);
keyedArguments.cc:155:    this[01;31m-[00m>_Map.remove(name);
keyedArguments.cc:160:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:163:    if ( this[01;31m-[00m>_Map.count(name) == 0 ) {
keyedArguments.cc:164:	return O_Object::nil(this[01;31m-[00m>lisp());
keyedArguments.cc:166:    obj = this[01;31m-[00m>_Map.get(name);
keyedArguments.cc:167:    this[01;31m-[00m>_Map.remove(name);
keyedArguments.cc:172:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:174:    this[01;31m-[00m>_Map.set(key,obj);
keyedArguments.cc:178:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:180:    sv = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>();
keyedArguments.cc:181:    this[01;31m-[00m>set(key,sv);
keyedArguments.cc:185:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:188:    ASSERTF(this[01;31m-[00m>contains(key), BF("key=%s")% key);
keyedArguments.cc:189:    sv = downcast<O_String>(this[01;31m-[00m>get(key));
keyedArguments.cc:190:    return sv[01;31m-[00m>get();
keyedArguments.cc:194:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:197:    sv = this[01;31m-[00m>get(key)[01;31m-[00m>as<O_Text>();
keyedArguments.cc:198:    this[01;31m-[00m>_Map.remove(key);
keyedArguments.cc:199:    return sv[01;31m-[00m>get();
keyedArguments.cc:203:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:206:    if ( !this[01;31m-[00m>contains(key) ) return d;
keyedArguments.cc:207:    sv = this[01;31m-[00m>get(key)[01;31m-[00m>as<O_Text>();
keyedArguments.cc:208:    this[01;31m-[00m>_Map.remove(key);
keyedArguments.cc:209:    return sv[01;31m-[00m>get();
keyedArguments.cc:215:    if ( !this[01;31m-[00m>contains(key) ) return defVal;
keyedArguments.cc:216:    return this[01;31m-[00m>getString(key);
keyedArguments.cc:224:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:226:    sv = O_TextBlock::create(val,this[01;31m-[00m>lisp());
keyedArguments.cc:227:    this[01;31m-[00m>set(key,sv);
keyedArguments.cc:231:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:234:    ASSERTF(this[01;31m-[00m>contains(key), BF("key=%s")%key);
keyedArguments.cc:235:    sv = downcast<O_TextBlock>(this[01;31m-[00m>get(key));
keyedArguments.cc:236:    return sv[01;31m-[00m>get();
keyedArguments.cc:242:    if ( !this[01;31m-[00m>contains(key) ) return defVal;
keyedArguments.cc:243:    return this[01;31m-[00m>getTextBlock(key);
keyedArguments.cc:250:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:252:    sv = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Real>(val);
keyedArguments.cc:253:    this[01;31m-[00m>set(key,sv);
keyedArguments.cc:257:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:260:    ASSERTF(this[01;31m-[00m>contains(key), BF("key=%s")% key);
keyedArguments.cc:261:    RPObject valObj = this[01;31m-[00m>get(key);
keyedArguments.cc:262:    this[01;31m-[00m>_Map.remove(key);
keyedArguments.cc:263:    if ( valObj[01;31m-[00m>isAssignableTo<O_Real>() )
keyedArguments.cc:265:	return valObj[01;31m-[00m>as<O_Real>()[01;31m-[00m>get();
keyedArguments.cc:266:    } else if ( valObj[01;31m-[00m>isAssignableTo<O_Int>() )
keyedArguments.cc:268:	return valObj[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
keyedArguments.cc:270:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("I can't convert object of class(%s) into a Real")%valObj[01;31m-[00m>className()));
keyedArguments.cc:276:    if ( !this[01;31m-[00m>contains(key) ) return defVal;
keyedArguments.cc:277:    return this[01;31m-[00m>getDoubleAndRemove(key);
keyedArguments.cc:283:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:286:    sv = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Int>(val);
keyedArguments.cc:287:    this[01;31m-[00m>set(key,sv);
keyedArguments.cc:292:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:295:    ASSERTF(this[01;31m-[00m>contains(key), BF("key=%s")% key);
keyedArguments.cc:296:    sv = downcast<O_Int>(this[01;31m-[00m>get(key));
keyedArguments.cc:297:    return sv[01;31m-[00m>get();
keyedArguments.cc:302:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:304:    if ( !this[01;31m-[00m>contains(key) ) return defVal;
keyedArguments.cc:305:    return this[01;31m-[00m>getInt(key);
keyedArguments.cc:309:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:312:    sv = this[01;31m-[00m>get(key)[01;31m-[00m>as<O_Int>();
keyedArguments.cc:313:    this[01;31m-[00m>_Map.remove(key);
keyedArguments.cc:314:    return sv[01;31m-[00m>get();
keyedArguments.cc:318:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:321:    if ( !this[01;31m-[00m>contains(key) ) return d;
keyedArguments.cc:322:    sv = this[01;31m-[00m>get(key)[01;31m-[00m>as<O_Int>();
keyedArguments.cc:323:    this[01;31m-[00m>_Map.remove(key);
keyedArguments.cc:324:    return sv[01;31m-[00m>get();
keyedArguments.cc:333:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:335:    ASSERTF(this[01;31m-[00m>contains(key), BF("key=%s")% key);
keyedArguments.cc:336:    RPLongLongInt sv = downcast<O_LongLongInt>(this[01;31m-[00m>get(key));
keyedArguments.cc:337:    return sv[01;31m-[00m>get();
keyedArguments.cc:342:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:344:    if ( !this[01;31m-[00m>contains(key) ) return defVal;
keyedArguments.cc:345:    return this[01;31m-[00m>getLlint(key);
keyedArguments.cc:349:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:351:    RPLongLongInt sv = this[01;31m-[00m>get(key)[01;31m-[00m>as<O_LongLongInt>();
keyedArguments.cc:352:    this[01;31m-[00m>_Map.remove(key);
keyedArguments.cc:353:    return sv[01;31m-[00m>get();
keyedArguments.cc:357:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:359:    if ( !this[01;31m-[00m>contains(key) ) return d;
keyedArguments.cc:360:    RPLongLongInt sv = this[01;31m-[00m>get(key)[01;31m-[00m>as<O_LongLongInt>();
keyedArguments.cc:361:    this[01;31m-[00m>_Map.remove(key);
keyedArguments.cc:362:    return sv[01;31m-[00m>get();
keyedArguments.cc:372:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:375:    sv = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Bool>(val);
keyedArguments.cc:376:    this[01;31m-[00m>set(key,sv);
keyedArguments.cc:382:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:385:    ASSERTF(this[01;31m-[00m>contains(key), BF("key=%s")% key);
keyedArguments.cc:386:    RPObject bo = this[01;31m-[00m>get(key);
keyedArguments.cc:387:    if ( bo[01;31m-[00m>isNil() )
keyedArguments.cc:390:    } else if ( bo[01;31m-[00m>isOfClass<O_Bool>() )
keyedArguments.cc:392:	return bo[01;31m-[00m>as<O_Bool>()[01;31m-[00m>get();
keyedArguments.cc:393:    } else if ( bo[01;31m-[00m>isOfClass<O_Int>() )
keyedArguments.cc:395:	return bo[01;31m-[00m>as<O_Int>()[01;31m-[00m>get()!=0;
keyedArguments.cc:396:    } else if ( bo[01;31m-[00m>isAssignableTo<O_Text>() )
keyedArguments.cc:398:	string bs = bo[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
keyedArguments.cc:405:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Cannot convert object("+bo[01;31m-[00m>description()+") to boolean value"));
keyedArguments.cc:410:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:412:    if ( !this[01;31m-[00m>contains(key) ) return defVal;
keyedArguments.cc:413:    return this[01;31m-[00m>getBool(key);
keyedArguments.cc:417:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:420:    bool b = this[01;31m-[00m>getBool(key);
keyedArguments.cc:421:    this[01;31m-[00m>_Map.remove(key);
keyedArguments.cc:426:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:429:    if ( !this[01;31m-[00m>contains(key) ) return d;
keyedArguments.cc:430:    bool b = this[01;31m-[00m>getBool(key);
keyedArguments.cc:431:    this[01;31m-[00m>_Map.remove(key);
keyedArguments.cc:436:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:437:    return this[01;31m-[00m>_Map.count(key)>0;
keyedArguments.cc:452:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:456:    dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
keyedArguments.cc:457:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ )
keyedArguments.cc:459:	LOG(BF("Looking to render %s") % vi[01;31m-[00m>second[01;31m-[00m>description().c_str()  ); // vp0(("Looking to render %s",vi[01;31m-[00m>second[01;31m-[00m>description().c_str() ));
keyedArguments.cc:460:	if ( vi[01;31m-[00m>second[01;31m-[00m>canRender() )
keyedArguments.cc:463:	    dlOne = vi[01;31m-[00m>second[01;31m-[00m>rendered(opts);
keyedArguments.cc:464:	    dlOne[01;31m-[00m>setName(vi[01;31m-[00m>first);
keyedArguments.cc:465:	    dl[01;31m-[00m>append(dlOne);
keyedArguments.cc:475:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:479:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
keyedArguments.cc:480:        ss << vi[01;31m-[00m>first << " ";
keyedArguments.cc:486:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:490:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
keyedArguments.cc:491:        ss << vi[01;31m-[00m>first << ":";
keyedArguments.cc:492:	ss << vi[01;31m-[00m>second[01;31m-[00m>description() << endl;
keyedArguments.cc:499:{_F(this[01;31m-[00m>lisp());
keyedArguments.cc:503:    kargs = O_KeyedArguments::create(this[01;31m-[00m>lisp());
keyedArguments.cc:504:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) 
keyedArguments.cc:506:	kargs[01;31m-[00m>put(vi[01;31m-[00m>first,vi[01;31m-[00m>second);
keyedArguments.cc:509:    for ( oi=this[01;31m-[00m>_PositionalArguments.begin(); oi!=this[01;31m-[00m>_PositionalArguments.end(); oi++ )
keyedArguments.cc:511:	kargs[01;31m-[00m>_PositionalArguments.push_back(*oi);
keyedArguments.cc:522:RPCons	list = O_Cons::nil(this[01;31m-[00m>lisp());
keyedArguments.cc:524:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) 
keyedArguments.cc:526:        list = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(vi[01;31m-[00m>first),list,this[01;31m-[00m>lisp());
keyedArguments.cc:533:RPStringSet list = O_StringSet::create(this[01;31m-[00m>lisp());
keyedArguments.cc:535:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
keyedArguments.cc:536:	list[01;31m-[00m>insert(vi[01;31m-[00m>first);
keyedArguments.cc:547:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
keyedArguments.cc:548:	res.append(boost::python::str(vi[01;31m-[00m>first));
keyedArguments.cc:560:    class_<O_KeyedArguments>(this[01;31m-[00m>lisp())
keyedObject.cc:20:    ko[01;31m-[00m>setKeyName(key);
keyedObject.cc:21:    ko[01;31m-[00m>setValue(obj);
keyedObject.cc:26:{_F(this[01;31m-[00m>lisp());
keyedObject.cc:28:    this[01;31m-[00m>_KeyName = O_KeyedObject::dropColon(name);
keyedObject.cc:33:    this[01;31m-[00m>Base::initialize();
keyedObject.cc:34:    this[01;31m-[00m>_KeyName = "";
keyedObject.cc:35:    this[01;31m-[00m>_Value = O_Object::nil(this[01;31m-[00m>lisp());
keyedObject.cc:40:    node[01;31m-[00m>attribute("keyName",this[01;31m-[00m>_KeyName );
keyedObject.cc:41:    node[01;31m-[00m>archiveObject("value",this[01;31m-[00m>_Value);
keyedObject.cc:48:    RPObject evaluated = eval::evaluate(this[01;31m-[00m>_Value,environment,lisp);
keyedObject.cc:49:    return O_KeyedObject::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>getKeyName(),evaluated);
keyedObject.cc:56:    ss << this[01;31m-[00m>_KeyName << ":" << (this[01;31m-[00m>_Value[01;31m-[00m>__repr__());
keyedObject.cc:64:	class_<O_KeyedObject>(this[01;31m-[00m>lisp())
largeSquareMatrix.cc:35:{_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:36:    this[01;31m-[00m>_Triangle = type;
largeSquareMatrix.cc:37:    this[01;31m-[00m>_Columns = dim;
largeSquareMatrix.cc:38:    this[01;31m-[00m>_Rows = dim;
largeSquareMatrix.cc:43:    this[01;31m-[00m>_Triangle = orig._Triangle;
largeSquareMatrix.cc:44:    this[01;31m-[00m>_Columns = orig._Columns;
largeSquareMatrix.cc:45:    this[01;31m-[00m>_Rows = orig._Rows;
largeSquareMatrix.cc:52:    ii = this[01;31m-[00m>indexBegin();
largeSquareMatrix.cc:53:    iEnd = this[01;31m-[00m>indexEnd();
largeSquareMatrix.cc:55:	this[01;31m-[00m>setAtIndex(ii,d);
largeSquareMatrix.cc:56:	ii = this[01;31m-[00m>indexAdvance(ii);
largeSquareMatrix.cc:66:    ii = this[01;31m-[00m>indexBegin();
largeSquareMatrix.cc:67:    iEnd = this[01;31m-[00m>indexEnd();
largeSquareMatrix.cc:69:	dMaxAbs = MAX(dMaxAbs,fabs(this[01;31m-[00m>getAtIndex(ii)));
largeSquareMatrix.cc:70:	ii = this[01;31m-[00m>indexAdvance(ii);
largeSquareMatrix.cc:86:    for ( y = 0; y<this[01;31m-[00m>dimension(); y++ ) {
largeSquareMatrix.cc:91:	for ( x = 0; x<this[01;31m-[00m>dimension(); x++ ) {
largeSquareMatrix.cc:95:	    fout << this[01;31m-[00m>element(x,y);
largeSquareMatrix.cc:112:    for ( y = 0; y<this[01;31m-[00m>dimension(); y++ ) {
largeSquareMatrix.cc:117:	for ( x = 0; x<this[01;31m-[00m>dimension(); x++ ) {
largeSquareMatrix.cc:121:	    if ( this[01;31m-[00m>hasElement(x,y) ) {
largeSquareMatrix.cc:133://! Dump the matrix from 0,0[01;31m-[00mupto,upto
largeSquareMatrix.cc:137:    for ( y = 0; y<this[01;31m-[00m>dimension(); y++ ) {
largeSquareMatrix.cc:138:	for ( x = 0; x<this[01;31m-[00m>dimension(); x++ ) {
largeSquareMatrix.cc:140:		this[01;31m-[00m>lisp()[01;31m-[00m>print(BF(" "));
largeSquareMatrix.cc:142:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%12.7lf") % this[01;31m-[00m>element(x,y));
largeSquareMatrix.cc:144:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF(""));
largeSquareMatrix.cc:154:    if ( result[01;31m-[00m>size() != this[01;31m-[00m>_Rows ) {
largeSquareMatrix.cc:155:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Result vector does not have the correct dimension"));
largeSquareMatrix.cc:157:    if ( d[01;31m-[00m>size() != this[01;31m-[00m>_Rows ) {
largeSquareMatrix.cc:158:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Argument vector does not have the correct dimension"));
largeSquareMatrix.cc:161:    for ( y=0; y<this[01;31m-[00m>_Rows; y++ ) {
largeSquareMatrix.cc:163:	for ( x=0; x<this[01;31m-[00m>_Rows; x++ ) {
largeSquareMatrix.cc:164:	    sum += this[01;31m-[00m>element(x,y)*d[01;31m-[00m>element(x);
largeSquareMatrix.cc:166:	result[01;31m-[00m>setElement(y,sum);
largeSquareMatrix.cc:183:    res[01;31m-[00m>setup(dim,type);
largeSquareMatrix.cc:191:    this[01;31m-[00m>O_AbstractLargeSquareMatrix::setup(dim,type);
largeSquareMatrix.cc:193:	this[01;31m-[00m>_ActiveElements = dim*dim;
largeSquareMatrix.cc:195:	this[01;31m-[00m>_ActiveElements = ((dim+1)*dim)/2;
largeSquareMatrix.cc:197:	this[01;31m-[00m>_ActiveElements = ((dim+1)*dim)/2;
largeSquareMatrix.cc:199:    this[01;31m-[00m>_Values.resize(this[01;31m-[00m>_ActiveElements,0);
largeSquareMatrix.cc:207:    this[01;31m-[00m>_ActiveElements = orig._ActiveElements;
largeSquareMatrix.cc:208:    this[01;31m-[00m>_Values.assign(orig._Values.begin(),orig._Values.end());
largeSquareMatrix.cc:213:{_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:215:    if ( x >= this[01;31m-[00m>_Columns || y >= this[01;31m-[00m>_Rows ) {
largeSquareMatrix.cc:216:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Overflow in matrix operation"));
largeSquareMatrix.cc:218:    if ( this[01;31m-[00m>_Triangle == UpperDiagonalLower ) {
largeSquareMatrix.cc:219:	i = y*this[01;31m-[00m>_Columns+x;
largeSquareMatrix.cc:220:	if ( i >= this[01;31m-[00m>_ActiveElements ) {
largeSquareMatrix.cc:221:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("FullLargeSquareMatrix overflow"));
largeSquareMatrix.cc:224:    } else if ( this[01;31m-[00m>_Triangle == SymmetricDiagonalLower ) {
largeSquareMatrix.cc:235:	if ( i>=this[01;31m-[00m>_ActiveElements ) {
largeSquareMatrix.cc:236:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("FullLargeSquareMatrix overflow"));
largeSquareMatrix.cc:239:    } else if ( this[01;31m-[00m>_Triangle == SymmetricUpperDiagonal ) {
largeSquareMatrix.cc:246:	i = i0 + (x[01;31m-[00my);
largeSquareMatrix.cc:247:	if ( i>=this[01;31m-[00m>_ActiveElements ) {
largeSquareMatrix.cc:248:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("FullLargeSquareMatrix overflow"));
largeSquareMatrix.cc:252:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal FullLargeSquareMatrix triangle type"));
largeSquareMatrix.cc:269:    if ( ii < this[01;31m-[00m>indexBegin() || ii >= this[01;31m-[00m>indexEnd() ) {
largeSquareMatrix.cc:270:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Out of bounds in indicesFromValuePtr"));
largeSquareMatrix.cc:272:    if ( this[01;31m-[00m>_Triangle == UpperDiagonalLower ) {
largeSquareMatrix.cc:273:	y = ii/this[01;31m-[00m>_Columns;
largeSquareMatrix.cc:274:	x = ii%this[01;31m-[00m>_Columns;
largeSquareMatrix.cc:275:    } else if ( this[01;31m-[00m>_Triangle == SymmetricDiagonalLower ) {
largeSquareMatrix.cc:277:	for (i=0; i<=this[01;31m-[00m>_Rows; i++ ) {
largeSquareMatrix.cc:280:	y = i[01;31m-[00m1;
largeSquareMatrix.cc:281:	x = ii[01;31m-[00m((y+1)*y)/2;
largeSquareMatrix.cc:282:    } else if ( this[01;31m-[00m>_Triangle == SymmetricUpperDiagonal ) {
largeSquareMatrix.cc:284:	for (i=0; i<=this[01;31m-[00m>_Rows; i++ ) {
largeSquareMatrix.cc:287:	y = i[01;31m-[00m1;
largeSquareMatrix.cc:288:	x = ii[01;31m-[00m((y+1)*y)/2+y;
largeSquareMatrix.cc:291:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Test this function rigorously before using it"));
largeSquareMatrix.cc:293:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal triangle type"));
largeSquareMatrix.cc:315:    res[01;31m-[00m>setup(dim,type);
largeSquareMatrix.cc:326:    this[01;31m-[00m>releaseStorage();
largeSquareMatrix.cc:331:{_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:332:    this[01;31m-[00m>O_AbstractLargeSquareMatrix::setup(dim,type);
largeSquareMatrix.cc:333:    this[01;31m-[00m>_InsertionIsComplete = false;
largeSquareMatrix.cc:334:    this[01;31m-[00m>initializeStorage();
largeSquareMatrix.cc:347:    this[01;31m-[00m>_InsertionIsComplete = orig._InsertionIsComplete;
largeSquareMatrix.cc:348:    this[01;31m-[00m>_RowStartEntries = orig._RowStartEntries;
largeSquareMatrix.cc:349:    this[01;31m-[00m>_RowStarts.assign(orig._RowStarts.begin(),orig._RowStarts.end());
largeSquareMatrix.cc:350:    this[01;31m-[00m>_ActiveElements = orig._ActiveElements;
largeSquareMatrix.cc:351:    this[01;31m-[00m>_ReservedElements = orig._ReservedElements;
largeSquareMatrix.cc:352:    this[01;31m-[00m>_ColumnForValue.assign(orig._ColumnForValue.begin(),orig._ColumnForValue.end());
largeSquareMatrix.cc:353:    this[01;31m-[00m>_Values.assign(orig._Values.begin(),orig._Values.end());
largeSquareMatrix.cc:358:{_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:359:uint	rows = this[01;31m-[00m>_Rows;
largeSquareMatrix.cc:360:    this[01;31m-[00m>_InsertionIsComplete = false;
largeSquareMatrix.cc:361:    this[01;31m-[00m>_RowStartEntries = rows+1;
largeSquareMatrix.cc:362:    this[01;31m-[00m>_RowStarts.assign((rows+1),0);
largeSquareMatrix.cc:363:    this[01;31m-[00m>_ActiveElements = 0;
largeSquareMatrix.cc:364:    this[01;31m-[00m>_ReservedElements = 100;
largeSquareMatrix.cc:365:    this[01;31m-[00m>_ColumnForValue.reserve(this[01;31m-[00m>_ReservedElements);
largeSquareMatrix.cc:366:    this[01;31m-[00m>_Values.reserve(this[01;31m-[00m>_ReservedElements);
largeSquareMatrix.cc:373:    this[01;31m-[00m>_RowStarts.clear();
largeSquareMatrix.cc:374:    this[01;31m-[00m>_ColumnForValue.clear();
largeSquareMatrix.cc:375:    this[01;31m-[00m>_Values.clear();
largeSquareMatrix.cc:376:    this[01;31m-[00m>_RowStartEntries = 0;
largeSquareMatrix.cc:377:    this[01;31m-[00m>_ReservedElements = 0;
largeSquareMatrix.cc:378:    this[01;31m-[00m>_ActiveElements = 0;
largeSquareMatrix.cc:384:    this[01;31m-[00m>_ReservedElements *= 2;
largeSquareMatrix.cc:385:    this[01;31m-[00m>_ColumnForValue.reserve(this[01;31m-[00m>_ReservedElements);
largeSquareMatrix.cc:386:    this[01;31m-[00m>_Values.reserve(this[01;31m-[00m>_ReservedElements);
largeSquareMatrix.cc:391:{_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:392:    this[01;31m-[00m>releaseStorage();
largeSquareMatrix.cc:393:    this[01;31m-[00m>initializeStorage();
largeSquareMatrix.cc:398:{_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:403:    if ( this[01;31m-[00m>_InsertionIsComplete ) {
largeSquareMatrix.cc:404:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("SparseMatrix InsertionIsComplete so no more entries may be inserted"));
largeSquareMatrix.cc:406:    if ( y>=this[01;31m-[00m>_Rows || x>=this[01;31m-[00m>_Columns ) {
largeSquareMatrix.cc:407:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Overflow in matrix operation"));
largeSquareMatrix.cc:409:    if ( this[01;31m-[00m>_Triangle == SymmetricDiagonalLower && x>y ) {
largeSquareMatrix.cc:414:    } else if ( this[01;31m-[00m>_Triangle == SymmetricUpperDiagonal && x<y ) {
largeSquareMatrix.cc:420:    ib = this[01;31m-[00m>_RowStarts[y];
largeSquareMatrix.cc:421:    ie = this[01;31m-[00m>_RowStarts[y+1];
largeSquareMatrix.cc:423:	if ( this[01;31m-[00m>_ColumnForValue[i] == x ) {
largeSquareMatrix.cc:430:	if ( this[01;31m-[00m>_ColumnForValue[i] > x ) {
largeSquareMatrix.cc:437:    if ( this[01;31m-[00m>_ActiveElements>=this[01;31m-[00m>_ReservedElements ) {
largeSquareMatrix.cc:438:	this[01;31m-[00m>expandStorage();
largeSquareMatrix.cc:443:    printf("Sliding from %d to %d num=%d\n", i, i+1, (this[01;31m-[00m>_ActiveElements[01;31m-[00mi) );
largeSquareMatrix.cc:444:    printf("Befor slide value@%d = %d\n", i, this[01;31m-[00m>_ColumnForValue[i]);
largeSquareMatrix.cc:446:    this[01;31m-[00m>_ColumnForValue.insert(this[01;31m-[00m>_ColumnForValue.begin()+i,x);
largeSquareMatrix.cc:447:    this[01;31m-[00m>_Values.insert(this[01;31m-[00m>_Values.begin()+i,0.0);
largeSquareMatrix.cc:449:    printf("After slide value@%d = %d\n", i+1, this[01;31m-[00m>_ColumnForValue[i+1]);
largeSquareMatrix.cc:451:    this[01;31m-[00m>_ActiveElements++;
largeSquareMatrix.cc:455:    for ( uint rr = y+1; rr<this[01;31m-[00m>_RowStartEntries;rr++ ) {
largeSquareMatrix.cc:456:	this[01;31m-[00m>_RowStarts[rr]++;
largeSquareMatrix.cc:465:{_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:467:    if ( x >= this[01;31m-[00m>_Columns || y >= this[01;31m-[00m>_Rows ) {
largeSquareMatrix.cc:468:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Overflow in matrix operation"));
largeSquareMatrix.cc:470:    if ( this[01;31m-[00m>_Triangle == SymmetricDiagonalLower && x>y ) {
largeSquareMatrix.cc:473:    } else if ( this[01;31m-[00m>_Triangle == SymmetricUpperDiagonal && x<y ) {
largeSquareMatrix.cc:478:    uint ib = this[01;31m-[00m>_RowStarts[y];
largeSquareMatrix.cc:479:    uint ie = this[01;31m-[00m>_RowStarts[y+1][01;31m-[00m1;
largeSquareMatrix.cc:480:    LOG(BF("This row has columns in the list between indices: %d[01;31m-[00m%d") % ib % ie ); // vp0(( "This row has columns in the list between indices: %d[01;31m-[00m%d",ib,ie));
largeSquareMatrix.cc:482:    if ( ib >= this[01;31m-[00m>_ColumnForValue.size() ) return UndefinedUnsignedInt;
largeSquareMatrix.cc:483:    if ( x < this[01;31m-[00m>_ColumnForValue[ib] ) return UndefinedUnsignedInt;
largeSquareMatrix.cc:484:    if ( ie >= this[01;31m-[00m>_ColumnForValue.size() ) return UndefinedUnsignedInt;
largeSquareMatrix.cc:485:    if ( x > this[01;31m-[00m>_ColumnForValue[ie] ) return UndefinedUnsignedInt;
largeSquareMatrix.cc:486:    if ( x == this[01;31m-[00m>_ColumnForValue[ib] )
largeSquareMatrix.cc:491:    if ( x == this[01;31m-[00m>_ColumnForValue[ie] )
largeSquareMatrix.cc:496:    while ( ib<ie[01;31m-[00m1 ) {
largeSquareMatrix.cc:498:	if ( this[01;31m-[00m>_ColumnForValue[im] == x ) 
largeSquareMatrix.cc:503:	if ( this[01;31m-[00m>_ColumnForValue[im] < x ) {
largeSquareMatrix.cc:512:    if ( ret >= this[01;31m-[00m>_Values.size() )
largeSquareMatrix.cc:514:        this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Out of bounds at: %s line: %d") % __FILE__% __LINE__ );
largeSquareMatrix.cc:515:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Looking for point: %u, %u") % x% y );
largeSquareMatrix.cc:516:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Calculated: %u") % ret );
largeSquareMatrix.cc:517:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("this[01;31m-[00m>_Values.size() = %u") % this[01;31m-[00m>_Values.size() );
largeSquareMatrix.cc:518:	this[01;31m-[00m>debug();
largeSquareMatrix.cc:519:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Calculated a position that is beyond the range of Values"));
largeSquareMatrix.cc:529:    dest = RP_Copy<O_SparseLargeSquareMatrix>(this[01;31m-[00m>sharedThis<O_SparseLargeSquareMatrix>());
largeSquareMatrix.cc:537:    for ( r=0; r<this[01;31m-[00m>_Rows; r++ ) {
largeSquareMatrix.cc:538:	if ( this[01;31m-[00m>_RowStarts[r] > is ) break;
largeSquareMatrix.cc:540:    if ( this[01;31m-[00m>_RowStarts[r]<=is ) {
largeSquareMatrix.cc:544:    y = r[01;31m-[00m1;
largeSquareMatrix.cc:545:    x = this[01;31m-[00m>_ColumnForValue[is];
largeSquareMatrix.cc:552:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("this[01;31m-[00m>_Rows = %d") % this[01;31m-[00m>_Rows );
largeSquareMatrix.cc:553:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("this[01;31m-[00m>_Columns = %d") % this[01;31m-[00m>_Columns );
largeSquareMatrix.cc:554:    for ( uint r=0; r<this[01;31m-[00m>_Rows; r++ ) {
largeSquareMatrix.cc:555:	ib = this[01;31m-[00m>_RowStarts[r];
largeSquareMatrix.cc:556:	ie = this[01;31m-[00m>_RowStarts[r+1];
largeSquareMatrix.cc:557:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Row%3d [%3d[01;31m-[00m%3d]: ") % r % ib % ie );
largeSquareMatrix.cc:560:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF(" x%d@%[01;31m-[00m3d") % this[01;31m-[00m>_ColumnForValue[i] % i );
largeSquareMatrix.cc:562:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "" ));
largeSquareMatrix.cc:564:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Columns: "));
largeSquareMatrix.cc:565:    for ( uint i=0; i<this[01;31m-[00m>_ActiveElements; i++ ) {
largeSquareMatrix.cc:566:	this[01;31m-[00m>lisp()[01;31m-[00m>prin1(BF("x%d@%d ") % this[01;31m-[00m>_ColumnForValue[i] % i);
largeSquareMatrix.cc:568:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Number of values: %u") % this[01;31m-[00m>_Values.size() );
largeSquareMatrix.cc:575:	uint ii= this[01;31m-[00m>indexFromCoordinates(x,y);
largeSquareMatrix.cc:577:	return this[01;31m-[00m>_Values[ii];
largeSquareMatrix.cc:581:    {_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:583:	dp = this[01;31m-[00m>indexFromCoordinates(x,y);
largeSquareMatrix.cc:586:	    if ( this[01;31m-[00m>_InsertionIsComplete ) {
largeSquareMatrix.cc:588:		ss << "Trying to write to non[01;31m-[00mexistent element (x,y)=("<< x << "," << y <<") in sparse matrix";
largeSquareMatrix.cc:589:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
largeSquareMatrix.cc:591:		this[01;31m-[00m>insertElement(x,y);
largeSquareMatrix.cc:592:		dp = this[01;31m-[00m>indexFromCoordinates(x,y);
largeSquareMatrix.cc:597:	this[01;31m-[00m>_Values[dp] = d;
largeSquareMatrix.cc:601:    {_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:604:	dp = this[01;31m-[00m>indexFromCoordinates(x,y);
largeSquareMatrix.cc:607:	    if ( this[01;31m-[00m>_InsertionIsComplete ) {
largeSquareMatrix.cc:609:		ss << "Trying to write to non[01;31m-[00mexistent element (x,y)=("<< x << "," << y <<") in sparse matrix";
largeSquareMatrix.cc:610:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
largeSquareMatrix.cc:613:		this[01;31m-[00m>insertElement(x,y);
largeSquareMatrix.cc:614:		dp = this[01;31m-[00m>indexFromCoordinates(x,y);
largeSquareMatrix.cc:617:	if ( this[01;31m-[00m>_Values.size() == 0 )
largeSquareMatrix.cc:620:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Failing in %s line: %d") % __FILE__% __LINE__ );
largeSquareMatrix.cc:621:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Trying to add to element at: %u, %u") % x% y );
largeSquareMatrix.cc:622:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "inserted dp = %u") % dp );
largeSquareMatrix.cc:623:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "initial dp = %u") % idp );
largeSquareMatrix.cc:624:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "inserted = %d") % inserted );
largeSquareMatrix.cc:625:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "this[01;31m-[00m>_Values.size() = %u") % this[01;31m-[00m>_Values.size() );
largeSquareMatrix.cc:626:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "this[01;31m-[00m>_InsertionIsComplete = %d") % this[01;31m-[00m>_InsertionIsComplete );
largeSquareMatrix.cc:629:	ASSERT_lessThan(dp,this[01;31m-[00m>_Values.size());
largeSquareMatrix.cc:630:	this[01;31m-[00m>_Values[dp] += d;
largeSquareMatrix.cc:636:	ASSERT_lessThan(y,this[01;31m-[00m>_Rows);
largeSquareMatrix.cc:637:	return this[01;31m-[00m>_RowStarts[y+1][01;31m-[00m1;
largeSquareMatrix.cc:643:    {_F(this[01;31m-[00m>lisp());
largeSquareMatrix.cc:645:	ASSERT_lessThan(x,this[01;31m-[00m>_Columns);
largeSquareMatrix.cc:646:	ASSERT_lessThan(y,this[01;31m-[00m>_Rows);
largeSquareMatrix.cc:647:	ASSERT(this[01;31m-[00m>_Triangle == SymmetricUpperDiagonal);
largeSquareMatrix.cc:649:	uint ib = this[01;31m-[00m>_RowStarts[y];
largeSquareMatrix.cc:650:	uint ie = this[01;31m-[00m>_RowStarts[y+1][01;31m-[00m1;
largeSquareMatrix.cc:651:	LOG(BF("This row has columns in the list between indices: %d[01;31m-[00m%d") % ib % ie ); // vp0(( "This row has columns in the list between indices: %d[01;31m-[00m%d",ib,ie));
largeSquareMatrix.cc:653:	if ( x < this[01;31m-[00m>_ColumnForValue[ib] ) return ib;
largeSquareMatrix.cc:654:	if ( x > this[01;31m-[00m>_ColumnForValue[ie] ) return this[01;31m-[00m>_RowStarts[y+1];
largeSquareMatrix.cc:655:	if ( x == this[01;31m-[00m>_ColumnForValue[ib] ) return ib;
largeSquareMatrix.cc:656:	if ( x == this[01;31m-[00m>_ColumnForValue[ie] ) return ie;
largeSquareMatrix.cc:657:	while ( ib<ie[01;31m-[00m1 ) {
largeSquareMatrix.cc:659:	    if ( this[01;31m-[00m>_ColumnForValue[im] == x ) return im;
largeSquareMatrix.cc:660:	    if ( this[01;31m-[00m>_ColumnForValue[im] < x ) {
lightProfiler.cc:14:    this[01;31m-[00m>_Calls = 0;
lightProfiler.cc:15:    this[01;31m-[00m>_Problems = 0;
lightProfiler.cc:24:    this[01;31m-[00m>_Calls++;
lightProfiler.cc:25:    if ( prob ) this[01;31m-[00m>_Problems++;
lightProfiler.cc:38:	this[01;31m-[00m>_DarwinConversion = 1.0e[01;31m-[00m9*(double)info.numer/(double)info.denom;
lightProfiler.cc:49:    HARD_ASSERT(this[01;31m-[00m>_Profiler!=NULL);
lightProfiler.cc:50:    LightTimer& child = this[01;31m-[00m>_Profiler[01;31m-[00m>timer(childIndex);
lightProfiler.cc:51:    child._Sibling = this[01;31m-[00m>_Child;
lightProfiler.cc:52:    this[01;31m-[00m>_Child = childIndex;
lightProfiler.cc:59:    this[01;31m-[00m>_IsOn = true;
lightProfiler.cc:60:    this[01;31m-[00m>_Calls++;
lightProfiler.cc:62:    this[01;31m-[00m>_DarwinStartTime = mach_absolute_time();
lightProfiler.cc:64:    this[01;31m-[00m>_StartTime = clock();
lightProfiler.cc:76:    if ( !this[01;31m-[00m>_IsOn ) {
lightProfiler.cc:77:	THROW_HARD_ERROR(boost::format("Timer %s is not on") % this[01;31m-[00m>_Description );
lightProfiler.cc:79:    this[01;31m-[00m>_IsOn = false;
lightProfiler.cc:81:    difference = mach_absolute_time() [01;31m-[00m this[01;31m-[00m>_DarwinStartTime;
lightProfiler.cc:82:    cpu_time_used = difference*this[01;31m-[00m>_DarwinConversion;
lightProfiler.cc:85:    cpu_time_used = ((double) (end [01;31m-[00m this[01;31m-[00m>_StartTime)) / CLOCKS_PER_SEC;
lightProfiler.cc:88:        this[01;31m-[00m>_ClockResolutionFails++;
lightProfiler.cc:90:    this[01;31m-[00m>_AccumulatedTime += cpu_time_used;
lightProfiler.cc:99:    this[01;31m-[00m>_EventCounters.push_back(counter);
lightProfiler.cc:100:    return this[01;31m-[00m>_EventCounters.size()[01;31m-[00m1;
lightProfiler.cc:104:{_F(this[01;31m-[00m>lisp());
lightProfiler.cc:106:    if ( this[01;31m-[00m>_Timers.size() == 0 )
lightProfiler.cc:109:	this[01;31m-[00m>_Timers.push_back(child);
lightProfiler.cc:111:    ASSERT_lessThan(parent,this[01;31m-[00m>_Timers.size());
lightProfiler.cc:112:    child.setup(this[01;31m-[00m>_Timers.size(),name,parent);
lightProfiler.cc:113:    this[01;31m-[00m>_Timers.push_back(child);
lightProfiler.cc:116:        this[01;31m-[00m>_Timers[parent].addChild(child.getId());
lightProfiler.cc:125:    if ( id >= this[01;31m-[00m>_Timers.size() ) {
lightProfiler.cc:126:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal timer id" ));
lightProfiler.cc:128:    timer = this[01;31m-[00m>_Timers[id];
lightProfiler.cc:130:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Undefined timer" ));
lightProfiler.cc:139:    timer = this[01;31m-[00m>getTimer(id);
lightProfiler.cc:140:    timer[01;31m-[00m>start();
lightProfiler.cc:147:    timer = this[01;31m-[00m>getTimer(id);
lightProfiler.cc:148:    timer[01;31m-[00m>stop();
lightProfiler.cc:156:    if ( this[01;31m-[00m>_Timers[top].getCalls() == 0 ) return;
lightProfiler.cc:157:    child = this[01;31m-[00m>_Timers[top].getChild();
lightProfiler.cc:160:	this[01;31m-[00m>dumpChildTimers(level+3,this[01;31m-[00m>_Timers[child].getId());
lightProfiler.cc:161:	child = this[01;31m-[00m>_Timers[child].getSibling();
lightProfiler.cc:165:    printf( prefix.str().c_str(), this[01;31m-[00m>_Timers[top].getDescription().c_str() );
lightProfiler.cc:166:    if ( this[01;31m-[00m>_Timers[top].getClockResolutionFails() ) {
lightProfiler.cc:168:		this[01;31m-[00m>_Timers[top].getAccumulatedTime(), 
lightProfiler.cc:169:		this[01;31m-[00m>_Timers[top].getCalls(), 
lightProfiler.cc:170:		this[01;31m-[00m>_Timers[top].getClockResolutionFails() );
lightProfiler.cc:172:        printf( " %10.4lf s  %6d calls\n", this[01;31m-[00m>_Timers[top].getAccumulatedTime(), this[01;31m-[00m>_Timers[top].getCalls() );
lightProfiler.cc:177:{_F(this[01;31m-[00m>lisp());
lightProfiler.cc:179:    if ( !this[01;31m-[00m>_MessagesEnabled ) return;
lightProfiler.cc:184:    HARD_ASSERTF(this[01;31m-[00m>_Timers.size()>=2,BF("There is no timer root"));
lightProfiler.cc:194:    while ( this[01;31m-[00m>_Timers[root].getParent()!=UndefinedUnsignedInt ) 
lightProfiler.cc:196:	printf("\n%s:%d  looking for root [01;31m-[00m this[01;31m-[00m>_Timers[%d]._Parent = %d", __FILE__,__LINE__,root,this[01;31m-[00m>_Timers[root].getParent());
lightProfiler.cc:197:	root = this[01;31m-[00m>_Timers[root].getParent();
lightProfiler.cc:200://    printf( "Profiling with mach clock conversion=%lf\n", this[01;31m-[00m>_Timers[root]._DarwinConversion );
lightProfiler.cc:206:    this[01;31m-[00m>dumpChildTimers(0,root);
lightProfiler.cc:208:    for ( uint i=0; i<this[01;31m-[00m>_EventCounters.size(); i++ ) {
lightProfiler.cc:209:	int problems = this[01;31m-[00m>_EventCounters[i].getProblems();
lightProfiler.cc:210:	int calls = this[01;31m-[00m>_EventCounters[i].getCalls();
lightProfiler.cc:213:		this[01;31m-[00m>_EventCounters[i].getDescription().c_str(),
lightProfiler.cc:221:    this[01;31m-[00m>_Timers.clear();
lightProfiler.cc:222:    this[01;31m-[00m>_EventCounters.clear();
lightProfiler.cc:223:    this[01;31m-[00m>_MessagesEnabled = true;
lightProfiler.cc:228:    for ( uint i=0; i<this[01;31m-[00m>_Timers.size(); i++ ) {
lightProfiler.cc:229:	if ( this[01;31m-[00m>_Timers[i].getIsOn() ) this[01;31m-[00m>_Timers[i].stop();
lightProfiler.cc:231:    this[01;31m-[00m>dump();
lightProfiler.cc:238:    states.resize(this[01;31m-[00m>_Timers.size());
lightProfiler.cc:239:    for ( uint i=0; i<this[01;31m-[00m>_Timers.size(); i++ ) {
lightProfiler.cc:240:	states[i] = this[01;31m-[00m>_Timers[i].getIsOn();
lightProfiler.cc:242:    this[01;31m-[00m>_TimerStateStack.push_back(states);
lightProfiler.cc:248:    if ( this[01;31m-[00m>_TimerStateStack.size() == 0 ) return;
lightProfiler.cc:249:    states = this[01;31m-[00m>_TimerStateStack.back();
lightProfiler.cc:251:	if ( states[i] != this[01;31m-[00m>_Timers[i].getIsOn() ) {
lightProfiler.cc:253:		this[01;31m-[00m>_Timers[i].start();
lightProfiler.cc:255:		this[01;31m-[00m>_Timers[i].stop();
lightProfiler.cc:259:    this[01;31m-[00m>_TimerStateStack.erase(this[01;31m-[00m>_TimerStateStack.end()[01;31m-[00m1);
lightProfiler.cc:265:    ASSERT_lessThan(c,this[01;31m-[00m>_EventCounters.size());
lightProfiler.cc:266:    return this[01;31m-[00m>_EventCounters[c];
lightProfiler.cc:272:    ASSERT_lessThan(c,this[01;31m-[00m>_Timers.size());
lightProfiler.cc:273:    return this[01;31m-[00m>_Timers[c];
lightProfiler.cc:280:    this[01;31m-[00m>_MessagesEnabled = false;
linearAlgebra.cc:31:{_F(m[01;31m-[00m>lisp());
linearAlgebra.cc:40:    dim = m[01;31m-[00m>dimension();
linearAlgebra.cc:45:	ldlt[01;31m-[00m>insertElement(j,j);	// Diagonal element is always there
linearAlgebra.cc:46:	for ( i=j+1; i<dim; i++ ) {	// i is X[01;31m-[00mcoordinate
linearAlgebra.cc:47:	    if ( m[01;31m-[00m>hasElement(i,j) ) {
linearAlgebra.cc:48:		ldlt[01;31m-[00m>insertElement(i,j);
linearAlgebra.cc:50:	    if ( j>0 && ldlt[01;31m-[00m>hasElement(i,j[01;31m-[00m1) ) {
linearAlgebra.cc:51:		ldlt[01;31m-[00m>insertElement(i,j);
linearAlgebra.cc:55:    ldlt[01;31m-[00m>insertionIsComplete();
linearAlgebra.cc:62:{_F(m[01;31m-[00m>lisp());
linearAlgebra.cc:76:_lisp[01;31m-[00m>profiler().timer(timerPreconditioner).start();
linearAlgebra.cc:77:_lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolver).start();
linearAlgebra.cc:78:_lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolverFactor).start();
linearAlgebra.cc:79:    dim = m[01;31m-[00m>dimension();
linearAlgebra.cc:84:    epsilon = m[01;31m-[00m>maxAbsValue();
linearAlgebra.cc:86:    betaSquared = epsilon/(sqrt(ddim*(ddim[01;31m-[00m1.0)));
linearAlgebra.cc:87:    delta = 1e[01;31m-[00m9;
linearAlgebra.cc:92:	    cjkIndex = ldlt[01;31m-[00m>indexFromCoordinates(j,k);
linearAlgebra.cc:94:	    cjk = ldlt[01;31m-[00m>getAtIndex(cjkIndex);
linearAlgebra.cc:95:	    dk = ldlt[01;31m-[00m>element(k,k);
linearAlgebra.cc:99:	    ldlt[01;31m-[00m>setElement(j,k,ljk);
linearAlgebra.cc:103:	djbar = m[01;31m-[00m>element(j,j)[01;31m-[00mksum;
linearAlgebra.cc:111:        _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolverFactorFocus).start();
linearAlgebra.cc:114:	nvKSum[01;31m-[00m>zero();	// initialize ksum vector to zero
linearAlgebra.cc:118:	    rowFirstIndex = ldlt[01;31m-[00m>indexOfFirstElementAtOrAfterX(j,k);
linearAlgebra.cc:123:	    if ( ldlt[01;31m-[00m>columnForIndex(rowFirstIndex) > j ) continue;
linearAlgebra.cc:125:	    rowLastIndex = ldlt[01;31m-[00m>indexOfLastElementOnRow(k);
linearAlgebra.cc:127:	    ldltJk = ldlt[01;31m-[00m>getAtIndex(rowFirstIndex);
linearAlgebra.cc:131:		cik = ldlt[01;31m-[00m>getAtIndex(ii);
linearAlgebra.cc:132:		xII = ldlt[01;31m-[00m>columnForIndex(ii);
linearAlgebra.cc:133:		nvKSum[01;31m-[00m>addToElement(xII,cik*ldltJk);
linearAlgebra.cc:138:	    LOG(BF("Setting up to calculate cij j+1(%d) columns(%d)") % j+1 % ldlt[01;31m-[00m>columns() ); // vp0(( "Setting up to calculate cij j+1(%d) columns(%d)", j+1, ldlt[01;31m-[00m>columns()));
linearAlgebra.cc:139:	    rowFirstIndex = ldlt[01;31m-[00m>indexOfFirstElementAtOrAfterX(j+1,j);
linearAlgebra.cc:140:	    rowLastIndex = ldlt[01;31m-[00m>indexOfLastElementOnRow(j);
linearAlgebra.cc:141:			    // ii indexes along X[01;31m-[00mcoordinate
linearAlgebra.cc:145:		xII = ldlt[01;31m-[00m>columnForIndex(ii);
linearAlgebra.cc:147:		cij = m[01;31m-[00m>element(xII,j)[01;31m-[00mnvKSum[01;31m-[00m>element(xII);
linearAlgebra.cc:149:		ldlt[01;31m-[00m>setElement(xII,j,cij);
linearAlgebra.cc:156:	{	// i is X[01;31m-[00mcoordinate
linearAlgebra.cc:160:		cik = ldlt[01;31m-[00m>element(i,k); // Temporarily store cik in l
linearAlgebra.cc:162:		ksum += ldlt[01;31m-[00m>element(j,k)*cik;
linearAlgebra.cc:164:	    cij = m[01;31m-[00m>element(i,j)[01;31m-[00mksum;
linearAlgebra.cc:165:	    hasij = ldlt[01;31m-[00m>hasElement(i,j);
linearAlgebra.cc:169:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str().c_str()));
linearAlgebra.cc:173:	    ldlt[01;31m-[00m>setElement(i,j,cij);
linearAlgebra.cc:177:        _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolverFactorFocus).stop();
linearAlgebra.cc:191:	} else if ( djtilde < [01;31m-[00mdelta ) {
linearAlgebra.cc:195:	        dj = MAX(djtilde,[01;31m-[00mthetaSquared/betaSquared);
linearAlgebra.cc:201:	ldlt[01;31m-[00m>setElement(j,j,dj);
linearAlgebra.cc:203:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolverFactor).stop();
linearAlgebra.cc:204:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolver).stop();
linearAlgebra.cc:205:    _lisp[01;31m-[00m>profiler().timer(timerPreconditioner).stop();
linearAlgebra.cc:211:{_F(ldlt[01;31m-[00m>lisp());
linearAlgebra.cc:215:    _lisp[01;31m-[00m>profiler().timer(timerPreconditioner).start();
linearAlgebra.cc:216:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolver).start();
linearAlgebra.cc:217:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolverBackSubstitute).start();
linearAlgebra.cc:218:    tx = O_NVector::create(b[01;31m-[00m>size(),ldlt[01;31m-[00m>lisp());
linearAlgebra.cc:220:    for ( y=0; y<b[01;31m-[00m>size(); y++ ) {
linearAlgebra.cc:223:	    sum += ldlt[01;31m-[00m>element(x,y)*s[01;31m-[00m>element(x);
linearAlgebra.cc:225:	s[01;31m-[00m>setElement(y,b[01;31m-[00m>element(y)[01;31m-[00msum);
linearAlgebra.cc:229:    for ( x=0; x<s[01;31m-[00m>size(); x++ ) {
linearAlgebra.cc:230:	dd = ldlt[01;31m-[00m>element(x,x);
linearAlgebra.cc:232:	tx[01;31m-[00m>setElement(x,s[01;31m-[00m>element(x)/dd);
linearAlgebra.cc:236:    for ( y=b[01;31m-[00m>size()[01;31m-[00m1; y < b[01;31m-[00m>size(); y[01;31m-[00m[01;31m-[00m ) {
linearAlgebra.cc:238:	for ( x=y+1; x<b[01;31m-[00m>size(); x++ ) {
linearAlgebra.cc:239:	    sum += ldlt[01;31m-[00m>element(x,y)*s[01;31m-[00m>element(x);
linearAlgebra.cc:241:	s[01;31m-[00m>setElement(y,tx[01;31m-[00m>element(y)[01;31m-[00msum);
linearAlgebra.cc:243:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolverBackSubstitute).stop();
linearAlgebra.cc:244:    _lisp[01;31m-[00m>profiler().timer(timerPreconditionerSolver).stop();
linearAlgebra.cc:245:    _lisp[01;31m-[00m>profiler().timer(timerPreconditioner).stop();
lisp.cc:6:Cando[01;31m-[00mScript is a language tailored to constructing and searching virtual oligomer libraries.
lisp.cc:7:Cando[01;31m-[00mScript is modeled after the languages Lisp and Scheme with Smalltalk/Objective[01;31m-[00mC thrown in, not to be different but because
lisp.cc:11:Cando[01;31m-[00mScript is designed to allow a chemists to easily define virtual oligomer libraries, build 3D models of members of of
lisp.cc:14:in a desired three[01;31m-[00mdimensional constellation.\par
lisp.cc:16:Cando[01;31m-[00mScript commands are invoked using two forms: 
lisp.cc:19:\item Prefix form [01;31m-[00m [\textbf{command} \emph{arg1 arg2 arg3 ...} ]
lisp.cc:56:\item Infix form [01;31m-[00m ( object \textbf{command} \emph{arg1 arg2 ...} )
lisp.cc:67:The purpose of the infix[01;31m-[00mform is
lisp.cc:165:    this[01;31m-[00m>_freeOutputStream = false;
lisp.cc:166:    this[01;31m-[00m>_outputStream = &cout;
lisp.cc:172:    if ( this[01;31m-[00m>_DebugStream != NULL )
lisp.cc:174:	this[01;31m-[00m>_DebugStream[01;31m-[00m>beginNode("SHUTDOWN");
lisp.cc:176:    this[01;31m-[00m>_CommandLineArguments.reset();
lisp.cc:177:    this[01;31m-[00m>_Packages.clear();
lisp.cc:178:    this[01;31m-[00m>_GlobalEnvironment.reset();
lisp.cc:179:    this[01;31m-[00m>_DefaultHierarchy.reset();
lisp.cc:180:    this[01;31m-[00m>_HiddenBinder.reset();
lisp.cc:181:    this[01;31m-[00m>_Program.reset();
lisp.cc:182:    this[01;31m-[00m>_SpecialForms.clear();
lisp.cc:183:    this[01;31m-[00m>_Macros.clear();
lisp.cc:184:    this[01;31m-[00m>_Modules.reset();
lisp.cc:185:    this[01;31m-[00m>_BuilderDatabase.reset();
lisp.cc:186:    this[01;31m-[00m>_BackTrace.clear();
lisp.cc:187:    this[01;31m-[00m>_ConditionHandlers.reset();
lisp.cc:188:    this[01;31m-[00m>_ClassInitializationCallbacks.clear();
lisp.cc:189:    this[01;31m-[00m>_GlobalInitializationCallbacks.clear();
lisp.cc:190:    this[01;31m-[00m>_TrueObject.reset();
lisp.cc:191:    this[01;31m-[00m>_EofObject.reset();
lisp.cc:198:    for ( int i=this[01;31m-[00m>_ClassesByClassId.size()[01;31m-[00m1;  i>= 0; i[01;31m-[00m[01;31m-[00m )
lisp.cc:200:	lisp_LOG(this[01;31m-[00m>lisp(),BF( "About to destroy class#%d(%s)") % i % this[01;31m-[00m>_ClassesByClassId[i][01;31m-[00m>name().c_str() );
lisp.cc:201:	this[01;31m-[00m>_ClassesByClassId[i].reset();
lisp.cc:203://    this[01;31m-[00m>_ClassesByClassId.clear();
lisp.cc:204:    if ( this[01;31m-[00m>_Bundle != NULL )    
lisp.cc:206:	delete this[01;31m-[00m>_Bundle;    
lisp.cc:208:    if ( this[01;31m-[00m>_profiler != NULL )    {	delete this[01;31m-[00m>_profiler; }
lisp.cc:209:    if ( this[01;31m-[00m>_DebugStream!=NULL )    
lisp.cc:211:	this[01;31m-[00m>_DebugStream[01;31m-[00m>endNode("SHUTDOWN");
lisp.cc:212:	delete this[01;31m-[00m>_DebugStream; 
lisp.cc:214:    if ( this[01;31m-[00m>_freeOutputStream ) 
lisp.cc:216:	if ( this[01;31m-[00m>_outputStream!=NULL ) delete this[01;31m-[00m>_outputStream;
lisp.cc:237:    HARD_ASSERT(this[01;31m-[00m>_WeakThis.use_count() != 0);
lisp.cc:238:    return boost::shared_polymorphic_downcast<O_Lisp>(this[01;31m-[00m>_WeakThis.lock());
lisp.cc:243:    HARD_ASSERT(this[01;31m-[00m>_WeakThis.use_count() != 0);
lisp.cc:244:    return boost::shared_polymorphic_downcast<O_Lisp>(this[01;31m-[00m>_WeakThis.lock());
lisp.cc:259:    prog[01;31m-[00m>_ClassesByClassId[oclass::static_classId()] = co;
lisp.cc:260:    co[01;31m-[00m>_WeakThis = co;
lisp.cc:261:    co[01;31m-[00m>__setClass(_class);	/* Is this what I need here? */
lisp.cc:262:    co[01;31m-[00m>_InitializationOwner.reset();
lisp.cc:263:    co[01;31m-[00m>_WeakLisp = prog;
lisp.cc:264:    co[01;31m-[00m>_Name = oclass::static_className();
lisp.cc:265:    co[01;31m-[00m>_PackageName = ClPackage;
lisp.cc:266:    co[01;31m-[00m>_InstanceClassId = oclass::static_classId();
lisp.cc:267:    co[01;31m-[00m>_InstanceBaseClass.reset();
lisp.cc:279:    co[01;31m-[00m>setInstanceAllocator(oclass::static_allocatorCallback());
lisp.cc:280:    co[01;31m-[00m>setStaticBaseClassId(oclass::static_baseClassId());
lisp.cc:281:    co[01;31m-[00m>setInstanceNil((co[01;31m-[00m>instanceAllocatorCallback())(lisp));
lisp.cc:282:    co[01;31m-[00m>setSupportsSlots(oclass::static_supportsSlots());
lisp.cc:290:    ss << "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m classId: " << classId << endl;;
lisp.cc:291:    ss << co[01;31m-[00m>dumpInfo();
lisp.cc:297:    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m    dump_info    [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m className: %s @ %X")% oclass::static_className() % co.get());
lisp.cc:307:{_F(co[01;31m-[00m>lisp());
lisp.cc:308:    if ( co[01;31m-[00m>getInstanceBaseClass_unsafe().use_count() == 0 ) 
lisp.cc:313:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Base class for %s was already defined") % oclass::static_className() ));
lisp.cc:315:    co[01;31m-[00m>setInstanceBaseClass(cob);
lisp.cc:316:    co[01;31m-[00m>setStaticBaseClassId(oclass::static_baseClassId());
lisp.cc:325:    lisp[01;31m-[00m>setupMpi(mpiEnabled,mpiRank,mpiSize);
lisp.cc:326:    lisp[01;31m-[00m>__setWeakThis(lisp);
lisp.cc:327:    lisp[01;31m-[00m>__resetInitializationOwner();
lisp.cc:328:    lisp[01;31m-[00m>_DebugStream = new DebugStream(mpiRank);
lisp.cc:329:    lisp[01;31m-[00m>_profiler = new LightProfiler(lisp);
lisp.cc:330:    lisp[01;31m-[00m>_PrintvWrite = foundation_printv_write;
lisp.cc:331:    lisp[01;31m-[00m>_PrintvWriteChar = foundation_printv_writeChar;
lisp.cc:332:    lisp[01;31m-[00m>_PrintvFlush = foundation_printv_flush;
lisp.cc:338:    this[01;31m-[00m>_MpiEnabled = mpiEnabled;
lisp.cc:339:    this[01;31m-[00m>_MpiRank = mpiRank;
lisp.cc:340:    this[01;31m-[00m>_MpiSize = mpiSize;
lisp.cc:344:{_F(this[01;31m-[00m>lisp());
lisp.cc:345:    initializeProfiler(this[01;31m-[00m>profiler(),this[01;31m-[00m>lisp());
lisp.cc:346:    this[01;31m-[00m>_Interactive = false;
lisp.cc:347:    this[01;31m-[00m>_CoreObjectClassesInitialized = false;
lisp.cc:348:    this[01;31m-[00m>_PackagesInitialized = false;
lisp.cc:349:    this[01;31m-[00m>_ObjectClassesInitialized = false;
lisp.cc:350:    this[01;31m-[00m>_NilsCreated = false;
lisp.cc:351:    this[01;31m-[00m>_GenSymIndex = 1000;
lisp.cc:352:    this[01;31m-[00m>_EnvironmentInitialized = false;
lisp.cc:353:    this[01;31m-[00m>_EnvironmentId = 0;
lisp.cc:354:    this[01;31m-[00m>_CommandLineArguments.reset();
lisp.cc:355:    this[01;31m-[00m>_Modules.reset();
lisp.cc:356:    this[01;31m-[00m>_GlobalEnvironment.reset();
lisp.cc:357:    this[01;31m-[00m>_BuilderDatabase.reset();
lisp.cc:358:    this[01;31m-[00m>_ConditionHandlers.reset();
lisp.cc:359:    this[01;31m-[00m>_Graphical = false;
lisp.cc:362:    this[01;31m-[00m>_Bundle = bundle;
lisp.cc:364:	// this[01;31m-[00m>_Class = __setClass(NULL); // Null for now [01;31m-[00m down below we will set this up
lisp.cc:365:	this[01;31m-[00m>__resetInitializationOwner();
lisp.cc:397:	this[01;31m-[00m>_ClassesByClassId.resize(get_nextGlobalClassId());
lisp.cc:404:	RPObjectClass classDummy= hand_initialize_class<_RootDummyClass>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),noClass);
lisp.cc:405:	RPObjectClass classObject = hand_initialize_allocatable_class<O_Object>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classDummy);
lisp.cc:406:	RPObjectClass classMetaClass = hand_initialize_allocatable_class<O_MetaClass>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classDummy);
lisp.cc:407:	RPObjectClass classObjectClass = hand_initialize_allocatable_class<O_ObjectClass>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classDummy);
lisp.cc:408:	RPObjectClass classCandoClass = hand_initialize_allocatable_class<O_CandoClass>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classDummy);
lisp.cc:412:	classDummy[01;31m-[00m>__setClass(classObjectClass);
lisp.cc:413:	classObject[01;31m-[00m>__setClass(classObjectClass);
lisp.cc:414:	classMetaClass[01;31m-[00m>__setClass(classObjectClass);
lisp.cc:415:	classObjectClass[01;31m-[00m>__setClass(classObjectClass);
lisp.cc:416:	classCandoClass[01;31m-[00m>__setClass(classObjectClass);
lisp.cc:417:	RPObjectClass classPackage = hand_initialize_allocatable_class<O_Package>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:418:	RPObjectClass classSymbol = hand_initialize_allocatable_class<O_Symbol>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:419:	RPObjectClass classExecutable = hand_initialize_allocatable_class<O_Executable>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:420:	RPObjectClass classSpecialForm = hand_initialize_allocatable_class<O_SpecialForm>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:421:	RPObjectClass classMethodPrimitive = hand_initialize_allocatable_class<O_MethodPrimitive>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:422:	RPObjectClass classFunctionPrimitive = hand_initialize_allocatable_class<O_FunctionPrimitive>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:423:	RPObjectClass classFormBinder = hand_initialize_allocatable_class<O_FormBinder>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:424:	RPObjectClass classBinder = hand_initialize_allocatable_class<O_Binder>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:425:	RPObjectClass classEnvironment = hand_initialize_allocatable_class<O_Environment>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:426:	RPObjectClass classCons = hand_initialize_allocatable_class<O_Cons>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:427:	RPObjectClass classValue = hand_initialize_allocatable_class<O_Value>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:428:	RPObjectClass classNumber = hand_initialize_allocatable_class<O_Number>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:429:	RPObjectClass classInt = hand_initialize_allocatable_class<O_Int>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:430:	RPObjectClass classCandoObject = hand_initialize_allocatable_class<O_CandoObject>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:431:	RPObjectClass classArgumentHandler = hand_initialize_allocatable_class<O_ArgumentHandler>(classesHandInitialized,this[01;31m-[00m>sharedThis<O_Lisp>(),classObjectClass);
lisp.cc:433:	dump_info<O_Object>(classObject,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:434:	dump_info<O_MetaClass>(classMetaClass,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:435:	dump_info<O_ObjectClass>(classObjectClass,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:436:	dump_info<O_CandoClass>(classCandoClass,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:437:	dump_info<O_Package>(classPackage,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:438:	dump_info<O_Symbol>(classSymbol,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:439:	dump_info<O_Executable>(classExecutable,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:440:	dump_info<O_SpecialForm>(classSpecialForm,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:441:	dump_info<O_MethodPrimitive>(classMethodPrimitive,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:442:	dump_info<O_FunctionPrimitive>(classFunctionPrimitive,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:443:	dump_info<O_FormBinder>(classFormBinder,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:444:	dump_info<O_Binder>(classBinder,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:445:	dump_info<O_Environment>(classEnvironment,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:446:	dump_info<O_Cons>(classCons,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:447:	dump_info<O_Value>(classValue,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:448:	dump_info<O_Number>(classNumber,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:449:	dump_info<O_Int>(classInt,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:450:	dump_info<O_CandoObject>(classCandoObject,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:451:	dump_info<O_ArgumentHandler>(classArgumentHandler,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:457:	classObject[01;31m-[00m>_InstanceBaseClass.reset();
lisp.cc:459:	set_base_class<O_Object>(classObject,O_MetaClass::nil(this[01;31m-[00m>sharedThis<O_Lisp>()),classesUpdated);
lisp.cc:484:	this[01;31m-[00m>_CoreObjectClassesInitialized = true;
lisp.cc:487:	this[01;31m-[00m>_GlobalEnvironment = O_Environment::create(this[01;31m-[00m>nil<O_Environment>(),this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:492:	// Currently this should cause problems [01;31m-[00m because ObjectClass hasn't been defined
lisp.cc:496:	clPackage = O_Package::create(this[01;31m-[00m>sharedThis<O_Lisp>(),ClPackage);
lisp.cc:497:	this[01;31m-[00m>_Packages.set(ClPackage,clPackage);
lisp.cc:498:	this[01;31m-[00m>_ClPackage = clPackage;
lisp.cc:500:	keywordPackage = O_Package::create(this[01;31m-[00m>sharedThis<O_Lisp>(),KeywordPackage);
lisp.cc:501:	keywordPackage[01;31m-[00m>setKeywordPackage(true);
lisp.cc:502:	this[01;31m-[00m>_KeywordPackage = keywordPackage;
lisp.cc:503:	this[01;31m-[00m>_Packages.set(KeywordPackage,keywordPackage);
lisp.cc:505:	ampPackage = O_Package::create(this[01;31m-[00m>sharedThis<O_Lisp>(),AmpPackage);
lisp.cc:506:	ampPackage[01;31m-[00m>setAmpPackage(true);
lisp.cc:507:	this[01;31m-[00m>_AmpPackage = ampPackage;
lisp.cc:508:	this[01;31m-[00m>_Packages.set(AmpPackage,ampPackage);
lisp.cc:510:	mbbPackage = O_Package::create(this[01;31m-[00m>sharedThis<O_Lisp>(),MbbPackage);
lisp.cc:511:	mbbPackage[01;31m-[00m>setKeywordPackage(false);
lisp.cc:512:	this[01;31m-[00m>_MbbPackage = mbbPackage;
lisp.cc:513:	this[01;31m-[00m>_Packages.set(MbbPackage,mbbPackage);
lisp.cc:515:	this[01;31m-[00m>_CurrentPackage = clPackage;
lisp.cc:516:	this[01;31m-[00m>_Star_Package_Star = this[01;31m-[00m>intern("*PACKAGE*");
lisp.cc:517:	this[01;31m-[00m>_PackagesInitialized = true;
lisp.cc:518://	this[01;31m-[00m>_Environment = O_Environment::create(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:519:	this[01;31m-[00m>_EnvironmentInitialized = true;
lisp.cc:520:	eval::defineSpecialForms(this[01;31m-[00m>sharedThis<O_Lisp>(),clPackage);
lisp.cc:521:	this[01;31m-[00m>createHiddenBinder();
lisp.cc:524://	exposeClassesAndDefineNils(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:526:	    RPLisp lisp = this[01;31m-[00m>sharedThis<O_Lisp>();
lisp.cc:535:	    this[01;31m-[00m>_LockClassInitialization = true;  
lisp.cc:536:	    for ( vector<InitializationCallback>::iterator vic=this[01;31m-[00m>_ClassInitializationCallbacks.begin();
lisp.cc:537:		  vic != this[01;31m-[00m>_ClassInitializationCallbacks.end(); vic++ )
lisp.cc:539:		(*vic)(this[01;31m-[00m>lisp());
lisp.cc:542:	this[01;31m-[00m>_ObjectClassesInitialized = true;
lisp.cc:543:	LOG(BF("ALL CLASSES: %s")% this[01;31m-[00m>dumpClasses() );
lisp.cc:545:	    for ( uint i=1; i<this[01;31m-[00m>numberOfClasses(); i++ )
lisp.cc:548:		RPMetaClass mc = this[01;31m-[00m>classFromClassId(i);
lisp.cc:549:		{ _BLOCK_TRACE((boost::format("Initializing class nil for: %s")% mc[01;31m-[00m>instanceClassName()).str().c_str() );
lisp.cc:550:		    LOG(BF("%s")%dump_instanceClass_info(mc,this[01;31m-[00m>sharedThis<O_Lisp>(),i));
lisp.cc:551:		    if (mc[01;31m-[00m>instanceNil<O_Object>().use_count() == 0 )
lisp.cc:553:			RPObject nil = mc[01;31m-[00m>allocateObject();
lisp.cc:555:			mc[01;31m-[00m>setInstanceNil(nil);
lisp.cc:560:	this[01;31m-[00m>_NilsCreated= true;
lisp.cc:562:	    for ( uint i=1; i<this[01;31m-[00m>numberOfClasses(); i++ )
lisp.cc:564:		RPMetaClass mc = this[01;31m-[00m>classFromClassId(i);
lisp.cc:565:		{_BLOCK_TRACEF(BF("Initializing nil for class: %s")% mc[01;31m-[00m>instanceClassName() );
lisp.cc:566:		    mc[01;31m-[00m>instanceNil<O_Object>()[01;31m-[00m>initialize();
lisp.cc:577:	initialize_mbbPackage(this[01;31m-[00m>sharedThis<O_Lisp>(),mbbPackage);
lisp.cc:581:	RPLisp lisp = this[01;31m-[00m>sharedThis<O_Lisp>();
lisp.cc:585:    LOG(BF("Package(%s) symbols: %s")% clPackage[01;31m-[00m>getName() % clPackage[01;31m-[00m>allSymbols() );
lisp.cc:586:    LOG(BF("Package(%s) symbols: %s")% keywordPackage[01;31m-[00m>getName() % keywordPackage[01;31m-[00m>allSymbols() );
lisp.cc:591:    this[01;31m-[00m>_CommandLineArguments = O_Cons::nil(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:592:    this[01;31m-[00m>_Modules = O_StringSet::create(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:593:    this[01;31m-[00m>_BuilderDatabase = O_BuilderDatabase::nil(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:594:    this[01;31m-[00m>_ConditionHandlers = O_Cons::nil(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:598://    this[01;31m-[00m>_DefaultHierarchy = O_Hierarchy::create(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:599:    this[01;31m-[00m>_Program = O_Cons::nil(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:600:    this[01;31m-[00m>__setClass(this[01;31m-[00m>classFromClassId(O_Lisp::static_classId()));
lisp.cc:603:        RPLisp lisp = this[01;31m-[00m>sharedThis<O_Lisp>();
lisp.cc:610:	this[01;31m-[00m>_AmpKeySymbol = this[01;31m-[00m>intern("&key");
lisp.cc:611:	this[01;31m-[00m>_AmpRestSymbol = this[01;31m-[00m>intern("&rest");
lisp.cc:612:	this[01;31m-[00m>_AmpOptionalSymbol = this[01;31m-[00m>intern("&optional");
lisp.cc:613:	this[01;31m-[00m>_TrueObject = this[01;31m-[00m>create<O_Bool>(true);
lisp.cc:614:	this[01;31m-[00m>_EofObject = this[01;31m-[00m>create<O_Int>(0);
lisp.cc:615://	this[01;31m-[00m>_FormNameSymbol = this[01;31m-[00m>intern("__formNameSymbol__");
lisp.cc:620:    userPackage = O_Package::create(this[01;31m-[00m>sharedThis<O_Lisp>(),UserPackage);
lisp.cc:621:    this[01;31m-[00m>_Packages.set(UserPackage,userPackage);
lisp.cc:623:	RPPackage clPackage = this[01;31m-[00m>getPackage(ClPackage);
lisp.cc:624:	clPackage[01;31m-[00m>exportAllSymbols();
lisp.cc:625:	userPackage[01;31m-[00m>usePackage(clPackage);
lisp.cc:626:	this[01;31m-[00m>_CurrentPackage = userPackage;
lisp.cc:629:	RPPackage mbbPackage = this[01;31m-[00m>getPackage(MbbPackage);
lisp.cc:630:	mbbPackage[01;31m-[00m>exportAllSymbols();
lisp.cc:631:	userPackage[01;31m-[00m>usePackage(mbbPackage);
lisp.cc:632:	RPBuilderDatabase bdb = O_BuilderDatabase::create(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:633:	this[01;31m-[00m>setBuilderDatabase(bdb);
lisp.cc:636:        initializeAllPredefinedSymbols(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:639:	boost::filesystem::path scriptPath = bundle[01;31m-[00m>getCandoScriptDir();
lisp.cc:640:	RPCons path = this[01;31m-[00m>create<O_Cons>(this[01;31m-[00m>create<O_String>("./"));
lisp.cc:643:	    RPString scriptDir = this[01;31m-[00m>create<O_String>(scriptPath.file_string());
lisp.cc:644:	    path = O_Cons::create(scriptDir,path,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:646:	RPSymbol sym = this[01;31m-[00m>predefinedSymbol(_sym_ClPackage_StarPATHStar);
lisp.cc:647:	this[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(sym,path);
lisp.cc:648:	this[01;31m-[00m>_RequireLevel = 0;
lisp.cc:651:	for ( uint i=1; i<this[01;31m-[00m>numberOfClasses(); i++ )
lisp.cc:654:	    RPObjectClass oc = this[01;31m-[00m>classFromClassId(i)[01;31m-[00m>as<O_ObjectClass>();
lisp.cc:655:	    oc[01;31m-[00m>setup__init__arguments();
lisp.cc:662:	this[01;31m-[00m>_LockGlobalInitialization = true;
lisp.cc:663:        for ( vector<InitializationCallback>::iterator ic = this[01;31m-[00m>_GlobalInitializationCallbacks.begin(); 
lisp.cc:664:	      ic!=this[01;31m-[00m>_GlobalInitializationCallbacks.end(); ic++ )
lisp.cc:666:	    (*ic)(this[01;31m-[00m>lisp());
lisp.cc:672:    initializeElementsAndHybridization(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:678:    this[01;31m-[00m>_PrintvWrite = pvw;
lisp.cc:679:    this[01;31m-[00m>_PrintvWriteChar = pvc;
lisp.cc:680:    this[01;31m-[00m>_PrintvFlush = pf;
lisp.cc:686:    this[01;31m-[00m>printvWrite("\n");
lisp.cc:687:    this[01;31m-[00m>printvWrite(fmt.str().c_str());
lisp.cc:688:    this[01;31m-[00m>printvFlush();
lisp.cc:693:    this[01;31m-[00m>printvWrite(fmt.str().c_str());
lisp.cc:694:    this[01;31m-[00m>printvFlush();
lisp.cc:701:    HARD_ASSERT(this[01;31m-[00m>_PrintvWrite!=NULL);
lisp.cc:702:    (this[01;31m-[00m>_PrintvWrite)(this[01;31m-[00m>lisp(),buffer);
lisp.cc:707:    HARD_ASSERT(this[01;31m-[00m>_PrintvWriteChar!=NULL);
lisp.cc:708:    (this[01;31m-[00m>_PrintvWriteChar)(this[01;31m-[00m>lisp(),c);
lisp.cc:713:    HARD_ASSERT(this[01;31m-[00m>_PrintvFlush!=NULL);
lisp.cc:714:    (this[01;31m-[00m>_PrintvFlush)(this[01;31m-[00m>lisp());
lisp.cc:723:{_F(this[01;31m-[00m>lisp());
lisp.cc:724:    ASSERT_NOT_NULL(this[01;31m-[00m>_GlobalEnvironment);
lisp.cc:725:    return this[01;31m-[00m>_GlobalEnvironment;
lisp.cc:731:    if ( this[01;31m-[00m>_freeOutputStream )
lisp.cc:733:	delete this[01;31m-[00m>_outputStream;
lisp.cc:735:    this[01;31m-[00m>_freeOutputStream = true;
lisp.cc:736:    this[01;31m-[00m>_outputStream = o;
lisp.cc:741:    return *(this[01;31m-[00m>_outputStream);
lisp.cc:747:{_F(this[01;31m-[00m>lisp());
lisp.cc:748:    LOG(BF("Defining macro for symbol(%s) macro=\n%s") % macroSymbol[01;31m-[00m>__repr__() % code[01;31m-[00m>__repr__() );
lisp.cc:749:    this[01;31m-[00m>_Macros[macroSymbol] = code;
lisp.cc:754:{_F(this[01;31m-[00m>lisp());
lisp.cc:756:    RPFunctionPrimitive prim = O_FunctionPrimitive::create(macroSymbol,functoid,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:757:    this[01;31m-[00m>defineMacro(macroSymbol,prim);
lisp.cc:765:{_F(this[01;31m-[00m>lisp());
lisp.cc:766:    RPCons args = code[01;31m-[00m>cdr();
lisp.cc:767:    while ( args[01;31m-[00m>notNil() )
lisp.cc:769:	if ( args[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Cons>() )
lisp.cc:771:	    RPCons oneArg = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
lisp.cc:774:		args[01;31m-[00m>setCar(oneArg);
lisp.cc:777:	args = args[01;31m-[00m>cdr();
lisp.cc:782:    if ( code[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
lisp.cc:784:	RPSymbol head = code[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
lisp.cc:785:	if ( this[01;31m-[00m>_Macros.count(head)>0 )
lisp.cc:788:	    RPCons result = eval::evaluateMacro(head,code[01;31m-[00m>cdr(),this[01;31m-[00m>nil<O_Environment>(),this[01;31m-[00m>sharedThis<O_Lisp>())[01;31m-[00m>as<O_Cons>();
lisp.cc:792:    } else if ( code[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Cons>() )
lisp.cc:794:	RPCons headCons = code[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
lisp.cc:796:	// The head is a cons (maybe a lambda) [01;31m-[00m we have to walk it and
lisp.cc:799:	if ( this[01;31m-[00m>expandMacrosRecursive(sawAMacro,headCons) )
lisp.cc:801:	    code[01;31m-[00m>setCar(headCons);
lisp.cc:809:{_F(this[01;31m-[00m>lisp());
lisp.cc:810:    LOG(BF("About to expand macros in code:\n%s") % code[01;31m-[00m>__repr__() );
lisp.cc:812:    this[01;31m-[00m>expandMacrosRecursive(sawAMacro,code);
lisp.cc:816:	LOG(BF("Finished expand macros in code:\n%s") % code[01;31m-[00m>__repr__() );
lisp.cc:826:{_F(this[01;31m-[00m>lisp());
lisp.cc:828:    while ( this[01;31m-[00m>expandMacrosOnce(code) )
lisp.cc:833:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Macro expansion happened %d times [01;31m-[00m You may have a macro expansion infinite loop") % macroExpansionCount ));
lisp.cc:842:    return this[01;31m-[00m>create<O_LispError>(fmt);
lisp.cc:851:{_F(this[01;31m-[00m>lisp());
lisp.cc:852:    this[01;31m-[00m>_PredefinedSymbols.clear();
lisp.cc:853:    this[01;31m-[00m>_PredefinedSymbols.resize(numberOfSymbols);
lisp.cc:864:    symId = this[01;31m-[00m>_PredefinedSymbols.size();
lisp.cc:865:    this[01;31m-[00m>_PredefinedSymbols.push_back(sym);
lisp.cc:873:{_F(this[01;31m-[00m>lisp());
lisp.cc:874:    if ( symbolIndex >= this[01;31m-[00m>_PredefinedSymbols.size() )
lisp.cc:876:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("There is only space for %d predefined symbols and you are trying to define one with index(%d) and symbol(%s)")
lisp.cc:877:					% this[01;31m-[00m>_PredefinedSymbols.size() % symbolIndex % symbolString ));
lisp.cc:887:    this[01;31m-[00m>_PredefinedSymbols[symbolIndex] = this[01;31m-[00m>intern(sym);
lisp.cc:892:{_F(this[01;31m-[00m>lisp());
lisp.cc:893:    if ( symbolIndex >= this[01;31m-[00m>_PredefinedSymbols.size() )
lisp.cc:895:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You are trying to access a predefined symbol with index(%d) and the table only contains %d entries") % symbolIndex % this[01;31m-[00m>_PredefinedSymbols.size() ));
lisp.cc:897:    return this[01;31m-[00m>_PredefinedSymbols[symbolIndex];
lisp.cc:904:{_F(this[01;31m-[00m>lisp());
lisp.cc:905:    this[01;31m-[00m>_HiddenBinder = this[01;31m-[00m>create<O_Binder>();
lisp.cc:909:{_F(this[01;31m-[00m>lisp());
lisp.cc:910:    ASSERTF(this[01;31m-[00m>isGlobalInitializationAllowed(),"An attempt was made to access the hiddenBinder before global initialization was allowed.\nMove the access into a GlobalInitialization function");
lisp.cc:911:    ASSERT_NOT_NULL(this[01;31m-[00m>_HiddenBinder);
lisp.cc:912:    ASSERT(this[01;31m-[00m>_HiddenBinder[01;31m-[00m>notNil());
lisp.cc:913:    return this[01;31m-[00m>_HiddenBinder;
lisp.cc:920:    RPSymbol sym = this[01;31m-[00m>intern(formName);
lisp.cc:921:    RPSpecialForm special = O_SpecialForm::create(sym,fp,this[01;31m-[00m>lisp());
lisp.cc:922:    ASSERTP(this[01;31m-[00m>_SpecialForms.count(sym)==0,"You cant define a special form with the symbol("+formName+") it has already been defined");
lisp.cc:923:    this[01;31m-[00m>_SpecialForms[sym] = special;
lisp.cc:931:{_F(this[01;31m-[00m>lisp());
lisp.cc:932:    return this[01;31m-[00m>_GenSymIndex;
lisp.cc:936:{_F(this[01;31m-[00m>lisp());
lisp.cc:937:    this[01;31m-[00m>_GenSymIndex++;
lisp.cc:938:    return this[01;31m-[00m>_GenSymIndex;
lisp.cc:948:    RPSymbol sym = this[01;31m-[00m>_ClPackage[01;31m-[00m>findSymbol(formName);
lisp.cc:949:    if ( sym[01;31m-[00m>isNil() ) return O_SpecialForm::nil(this[01;31m-[00m>lisp());
lisp.cc:950:    map<RPSymbol,RPSpecialForm>::iterator si = this[01;31m-[00m>_SpecialForms.find(sym);
lisp.cc:951:    if ( si==this[01;31m-[00m>_SpecialForms.end() ) return O_SpecialForm::nil(this[01;31m-[00m>lisp());
lisp.cc:952:    return si[01;31m-[00m>second;
lisp.cc:961:    HARD_ASSERT(this[01;31m-[00m>_LockClassInitialization == false);
lisp.cc:962:    this[01;31m-[00m>_ClassInitializationCallbacks.push_back(cb);
lisp.cc:970:    HARD_ASSERT(this[01;31m-[00m>_LockGlobalInitialization == false);
lisp.cc:971:    this[01;31m-[00m>_GlobalInitializationCallbacks.push_back(cb);
lisp.cc:976:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Never archive Lisp objects"));
lisp.cc:982:{_F(this[01;31m-[00m>lisp());
lisp.cc:983:    RPSymbol classSymbol = this[01;31m-[00m>intern(packageName,className);
lisp.cc:984:    this[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(classSymbol,mc);
lisp.cc:985:    mc[01;31m-[00m>__setArgumentHandlerString(mc[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>__getArgumentHandlerString());
lisp.cc:991:{_F(this[01;31m-[00m>lisp());
lisp.cc:994:    RPMetaClass baseClass = this[01;31m-[00m>classFromClassId(baseClassId);
lisp.cc:998:	RPSymbol sym = this[01;31m-[00m>intern(packageName,className);
lisp.cc:999:	LOG(BF("Adding CandoClass with classId(%d) lisp[01;31m-[00m>_ClassesByClassId.size() = %d")% classId % this[01;31m-[00m>_ClassesByClassId.size() );
lisp.cc:1000:	cc = O_CandoClass::create(this[01;31m-[00m>lisp(),sym,classId);
lisp.cc:1002:	LOG(BF("Adding ObjectClass with classId(%d)  lisp[01;31m-[00m>_ClassesByClassId.size() = %d")% classId % this[01;31m-[00m>_ClassesByClassId.size() );
lisp.cc:1003:	cc = O_ObjectClass::create(this[01;31m-[00m>lisp(),className,classId);
lisp.cc:1005:    cc[01;31m-[00m>setSupportsSlots(baseClass[01;31m-[00m>supportsSlots());
lisp.cc:1006:    ASSERT_eq(classId,this[01;31m-[00m>_ClassesByClassId.size());
lisp.cc:1007:    this[01;31m-[00m>_ClassesByClassId.push_back(cc);
lisp.cc:1008:    cc[01;31m-[00m>setStaticBaseClassId(baseClassId);
lisp.cc:1009:    cc[01;31m-[00m>setPackageName(packageName);
lisp.cc:1010:    cc[01;31m-[00m>setInstanceBaseClass(baseClass);
lisp.cc:1011:    cc[01;31m-[00m>setInstanceAllocator(alloc);
lisp.cc:1012:    cc[01;31m-[00m>__setArgumentHandlerString(cc[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>__getArgumentHandlerString());
lisp.cc:1013:    this[01;31m-[00m>addClassToEnvironment(packageName,className,cc);
lisp.cc:1018:{_F(this[01;31m-[00m>lisp());
lisp.cc:1019:    RPStringSet ss = this[01;31m-[00m>create<O_StringSet>();
lisp.cc:1020:    for ( List<O_MetaClass>::iterator li=this[01;31m-[00m>_ClassesByClassId.begin();
lisp.cc:1021:	  li!=this[01;31m-[00m>_ClassesByClassId.end(); li++ )
lisp.cc:1023:	ss[01;31m-[00m>insert((*li)[01;31m-[00m>getPackagedName());
lisp.cc:1029:{_F(this[01;31m-[00m>lisp());
lisp.cc:1030:    if ( !this[01;31m-[00m>_ObjectClassesInitialized )
lisp.cc:1032:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You cannot create CandoClass until all ObjectClasses are initialized"));
lisp.cc:1034:    ASSERT(this[01;31m-[00m>_EnvironmentInitialized);
lisp.cc:1035:    LOG(BF( "defineCandoClass with className: %s")% name[01;31m-[00m>__repr__() );
lisp.cc:1038:    if ( this[01;31m-[00m>globalEnvironment()[01;31m-[00m>definedQ(name) )
lisp.cc:1040:	LOG(BF("The symbol(%s) was already defined") % name[01;31m-[00m>__repr__() );
lisp.cc:1041:	RPObject boundObject = this[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(name);
lisp.cc:1042:	if ( boundObject[01;31m-[00m>isAssignableTo<O_CandoClass>() )
lisp.cc:1045:	    cc = this[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(name)[01;31m-[00m>as<O_CandoClass>();
lisp.cc:1046:	    cc[01;31m-[00m>reset();
lisp.cc:1047:	    cc[01;31m-[00m>resetMethods();
lisp.cc:1050:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("The symbol(%s) is already bound but not to a class")%name[01;31m-[00m>fullName()));
lisp.cc:1055:	instanceClassId = this[01;31m-[00m>_ClassesByClassId.size();
lisp.cc:1056:	cc = O_CandoClass::create(this[01;31m-[00m>lisp(),name,instanceClassId);
lisp.cc:1057:	this[01;31m-[00m>_ClassesByClassId.push_back(cc);
lisp.cc:1058:	cc[01;31m-[00m>setInstanceNil(O_CandoClass::nil(this[01;31m-[00m>lisp()));
lisp.cc:1059:	this[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(name,cc);
lisp.cc:1061:	RPFunctionPrimitive creator = O_FunctionPrimitive::create(name,functoid,this[01;31m-[00m>lisp());
lisp.cc:1062:	this[01;31m-[00m>globalEnvironment()[01;31m-[00m>extendForm(name,creator);
lisp.cc:1070:{_F(this[01;31m-[00m>lisp());
lisp.cc:1071:    RPCandoClass newClass = this[01;31m-[00m>defineCandoClass(name);
lisp.cc:1072:    newClass[01;31m-[00m>setInstanceBaseClass(baseClass);
lisp.cc:1073:    newClass[01;31m-[00m>appendInstanceVariablesFromListOfSymbols(instanceVariableSymbolNames);
lisp.cc:1074://    newClass[01;31m-[00m>setupAccessors(instanceVariableSymbolNames);
lisp.cc:1082:{_F(this[01;31m-[00m>lisp());
lisp.cc:1084:    for ( uint i=0; i<this[01;31m-[00m>_ClassesByClassId.size(); i++ )
lisp.cc:1086:        ss << dump_instanceClass_info(this[01;31m-[00m>_ClassesByClassId[i],this[01;31m-[00m>lisp(),i);
lisp.cc:1093:{_F(this[01;31m-[00m>lisp());
lisp.cc:1094:    ASSERTP(this[01;31m-[00m>_Packages.count(name) == 0,"There already exists a package with name: "+name);
lisp.cc:1095:    RPPackage newPackage = O_Package::create(this[01;31m-[00m>sharedThis<O_Lisp>(),name);
lisp.cc:1096:    this[01;31m-[00m>_Packages.set(name,newPackage);
lisp.cc:1101:{_F(this[01;31m-[00m>lisp());
lisp.cc:1102:    ASSERTF(this[01;31m-[00m>_Packages.count(name) != 0,BF("In usePackage [01;31m-[00m there is no package with name[%s]")%name);
lisp.cc:1103:    RPPackage usePackage = this[01;31m-[00m>_Packages.get(name);
lisp.cc:1104:    bool used = this[01;31m-[00m>_CurrentPackage[01;31m-[00m>usePackage(usePackage);
lisp.cc:1109:{_F(this[01;31m-[00m>lisp());
lisp.cc:1110:    ASSERTF(this[01;31m-[00m>_Packages.count(name) != 0,BF("In getPackage [01;31m-[00m there is no package with name[%s]")%name);
lisp.cc:1111:    RPPackage getPackage = this[01;31m-[00m>_Packages.get(name);
lisp.cc:1118:    return this[01;31m-[00m>_CurrentPackage;
lisp.cc:1123:    this[01;31m-[00m>_CurrentPackage = pack;
lisp.cc:1128:    Map<O_Package>::iterator pi = this[01;31m-[00m>_Packages.find(packageName);
lisp.cc:1129:    return ( pi!=this[01;31m-[00m>_Packages.end() );
lisp.cc:1134:    Map<O_Package>::iterator pi = this[01;31m-[00m>_Packages.find(p);
lisp.cc:1135:    if ( pi==this[01;31m-[00m>_Packages.end() )
lisp.cc:1137:	ASSERTP(this[01;31m-[00m>recognizesPackage(p),"I do not recognize package: "+p);
lisp.cc:1139:    this[01;31m-[00m>_CurrentPackage = pi[01;31m-[00m>second;
lisp.cc:1147:{    _F(this[01;31m-[00m>lisp());
lisp.cc:1148:    RPSymbol sym = this[01;31m-[00m>internKeyword(name);
lisp.cc:1149:    RPMetaClass mc = this[01;31m-[00m>classFromClassId(classId);
lisp.cc:1150:    RPMethodPrimitive mp = O_MethodPrimitive::create(sym,mc,methoid,this[01;31m-[00m>lisp());
lisp.cc:1151:    mc[01;31m-[00m>addMethod(sym,mp);
lisp.cc:1156:{_F(this[01;31m-[00m>lisp());
lisp.cc:1157:    if ( this[01;31m-[00m>_ObjectClassesInitialized ) return;
lisp.cc:1158:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Cpp[01;31m-[00mclasses are not initialized"));
lisp.cc:1162:{_F(this[01;31m-[00m>lisp());
lisp.cc:1168: * using the lisp[01;31m-[00m>PATH variable
lisp.cc:1172:{_F(this[01;31m-[00m>lisp());
lisp.cc:1174:    RPSymbol pathSym = this[01;31m-[00m>symbol(_sym_ClPackage_StarPATHStar);
lisp.cc:1175:    RPCons pathList = this[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(pathSym)[01;31m-[00m>as<O_Cons>();
lisp.cc:1176:    LOG(BF("PATH variable = %s") % pathList[01;31m-[00m>__repr__().c_str()  ); // vp0(("PATH variable = %s", pathList[01;31m-[00m>__repr__().c_str() ));
lisp.cc:1177:    while ( pathList[01;31m-[00m>notNil() )
lisp.cc:1179:	boost::filesystem::path onePath(pathList[01;31m-[00m>car<O_Text>()[01;31m-[00m>get());
lisp.cc:1182:	pathList = pathList[01;31m-[00m>cdr();
lisp.cc:1187:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("include "+fileName+" error, file does not exist"));
lisp.cc:1192:    this[01;31m-[00m>_EnvironmentId++;
lisp.cc:1193:    return this[01;31m-[00m>_EnvironmentId;
lisp.cc:1199:    ASSERT(this[01;31m-[00m>_EnvironmentInitialized);
lisp.cc:1200:    return this[01;31m-[00m>_Environment[01;31m-[00m>allLocalNamesAsCons();
lisp.cc:1205:{_F(this[01;31m-[00m>lisp());
lisp.cc:1219:    this[01;31m-[00m>_RenderFileName = "";
lisp.cc:1259:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s")% ss.str());
lisp.cc:1268:    // So cando [01;31m-[00m> CANDO/init/candoBoot.csc
lisp.cc:1269:    //    candoMpi [01;31m-[00m> CANDO/init/candoMpiBoot.csc
lisp.cc:1270:    //    candoView [01;31m-[00m> CANDO/init/candoViewBoot.csc
lisp.cc:1272:    this[01;31m-[00m>_RCFileName = (BF("CANDO/init/%sBoot.csc") % argv[0] ).str();
lisp.cc:1275:	this[01;31m-[00m>_RCFileName = vm["init"].as<string>();
lisp.cc:1276:	LOG(BF( "Using initialization file(%s)")% this[01;31m-[00m>_RCFileName);
lisp.cc:1284:	this[01;31m-[00m>loadBuilderDatabase(dbFileName,0);
lisp.cc:1289:	this[01;31m-[00m>_Interactive = true;
lisp.cc:1294:	LOG(BF("Parsing option [01;31m-[00mo %s") % outputFileName.c_str()  ); // vp0(("Parsing option [01;31m-[00mo %s", outputFileName.c_str() ));
lisp.cc:1296:	fn % outputFileName % this[01;31m-[00m>mpiRank();
lisp.cc:1298:	printvSetOutputFileName(fn.str(),this[01;31m-[00m>lisp());
lisp.cc:1304:	LOG(BF("Parsing option [01;31m-[00ms %s") % seed.c_str()  ); // vp0(("Parsing option [01;31m-[00ms %s", seed.c_str() ));
lisp.cc:1305:	seedRandomNumberGenerators(iseed,this[01;31m-[00m>lisp());
lisp.cc:1308:	seedRandomNumberGenerators(this[01;31m-[00m>mpiRank(),this[01;31m-[00m>lisp());
lisp.cc:1315:    RPCons args = O_Cons::createFromVectorStringsCommandLineArguments(to_pass_further,this[01;31m-[00m>lisp());
lisp.cc:1316:    LOG(BF(" Command line arguments are being set in Lisp to: %s") % args[01;31m-[00m>__repr__().c_str()  ); // vp0((" Command line arguments are being set in Lisp to: %s", args[01;31m-[00m>__repr__().c_str() ));
lisp.cc:1317:    this[01;31m-[00m>_CommandLineArguments = args;
lisp.cc:1322:    // Get the script from the command line or the input[01;31m-[00mfile
lisp.cc:1327:	this[01;31m-[00m>_ProgramCode._ScriptInFile = false;
lisp.cc:1328:	this[01;31m-[00m>_ProgramCode._FileNameOrCode = script+"\n";
lisp.cc:1332:	RPSymbol sym = this[01;31m-[00m>symbol(_sym_ClPackage_StarARGSStar);
lisp.cc:1333:	LOG(BF("Binding symbol(%s) to: %s") % sym[01;31m-[00m>fullName() % this[01;31m-[00m>_CommandLineArguments[01;31m-[00m>__repr__() );
lisp.cc:1334:        this[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(sym,this[01;31m-[00m>_CommandLineArguments);
lisp.cc:1335:	this[01;31m-[00m>_ProgramCode._ScriptInFile = true;
lisp.cc:1336:	this[01;31m-[00m>_ProgramCode._FileNameOrCode = this[01;31m-[00m>_CommandLineArguments[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
lisp.cc:1340:	this[01;31m-[00m>_RenderFileName = vm["render"].as<string>();
lisp.cc:1342:    LOG(BF("lisp[01;31m-[00m>_ScriptInFile(%d)  lisp[01;31m-[00m>_FileNameOrCode(%s)") % this[01;31m-[00m>_ProgramCode._ScriptInFile % this[01;31m-[00m>_ProgramCode._FileNameOrCode );
lisp.cc:1353:{_F(this[01;31m-[00m>lisp());
lisp.cc:1354:    LOG(BF(" Looking up form(%s)")% head[01;31m-[00m>currentName() );
lisp.cc:1355://    ASSERT(this[01;31m-[00m>_EnvironmentInitialized);
lisp.cc:1356:    return this[01;31m-[00m>_GlobalEnvironment[01;31m-[00m>lookupForm(head);
lisp.cc:1365:{_F(this[01;31m-[00m>lisp());
lisp.cc:1366:    LOG(BF(" Looking up form(%s)")% head[01;31m-[00m>currentName() );
lisp.cc:1367:    if ( this[01;31m-[00m>_Macros.count(head) == 0 ) return this[01;31m-[00m>nil<O_Executable>();
lisp.cc:1368:    return this[01;31m-[00m>_Macros[head];
lisp.cc:1379:{_F(this[01;31m-[00m>lisp());
lisp.cc:1381:    ASSERT_NOT_NULL(this[01;31m-[00m>_BuilderDatabase);
lisp.cc:1382:    return this[01;31m-[00m>_BuilderDatabase;
lisp.cc:1386:{_F(this[01;31m-[00m>lisp());
lisp.cc:1387:    return this[01;31m-[00m>_BuilderDatabase[01;31m-[00m>notNil();
lisp.cc:1399:{_F(this[01;31m-[00m>lisp());
lisp.cc:1400:    ASSERT_NOT_NULL(this[01;31m-[00m>_BuilderDatabase);
lisp.cc:1402:    this[01;31m-[00m>_BuilderDatabase = bdb;
lisp.cc:1403:    RPSymbol sym = this[01;31m-[00m>intern(MbbPackage,"*DATABASE*");
lisp.cc:1404:    this[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(sym,bdb);
lisp.cc:1411:{_F(this[01;31m-[00m>lisp());
lisp.cc:1414:    xml = O_XmlLoadArchive::create(this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:1415:    xml[01;31m-[00m>setVerbosity(verbosity);
lisp.cc:1416:    xml[01;31m-[00m>open(fileName);
lisp.cc:1417:    if ( xml[01;31m-[00m>contains("builderDatabase") )
lisp.cc:1419:	RPObject obj = xml[01;31m-[00m>get("builderDatabase");
lisp.cc:1420:	if (!obj[01;31m-[00m>isOfClass<O_BuilderDatabase>() )
lisp.cc:1422:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("The 'builderDatabase' object is not of class BuilderDatabase"));
lisp.cc:1424:        bdb = obj[01;31m-[00m>as<O_BuilderDatabase>();
lisp.cc:1425:    } else if ( xml[01;31m-[00m>contains("only" ) )
lisp.cc:1427:	RPObject obj = xml[01;31m-[00m>get("only");
lisp.cc:1428:	if (!obj[01;31m-[00m>isOfClass<O_BuilderDatabase>() )
lisp.cc:1430:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("The 'only' object is not of class BuilderDatabase"));
lisp.cc:1432:        bdb = obj[01;31m-[00m>as<O_BuilderDatabase>();
lisp.cc:1435:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find database in file: "+fileName ) );
lisp.cc:1437:    this[01;31m-[00m>setBuilderDatabase(bdb);
lisp.cc:1446:{_F(this[01;31m-[00m>lisp());
lisp.cc:1454:	exec = lisp_compile(script,this[01;31m-[00m>lisp(),fileName,errorStream);
lisp.cc:1455:	if ( exec[01;31m-[00m>isNil() )
lisp.cc:1460:	LOG(BF("Finished compileScriptInStream code=%s") % exec[01;31m-[00m>__repr__().c_str()  );
lisp.cc:1468:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "Compiling: %s", err.conditionObject()[01;31m-[00m>message().c_str() );
lisp.cc:1479:{_F(this[01;31m-[00m>lisp());
lisp.cc:1484:    block = this[01;31m-[00m>compileScriptInStream(sin,script);
lisp.cc:1493:{_F(this[01;31m-[00m>lisp());
lisp.cc:1500:	pathName = this[01;31m-[00m>findFileInLispPath(fileName);
lisp.cc:1503:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("The script file: %s could not be found") % fileName.c_str() );
lisp.cc:1506:    block = this[01;31m-[00m>compileScriptInStream(fin,fileName);
lisp.cc:1514:{_F(this[01;31m-[00m>lisp());
lisp.cc:1517:    RPObject result = this[01;31m-[00m>onil();
lisp.cc:1521:	expression = this[01;31m-[00m>compileScriptInStream(script,fileName);
lisp.cc:1525:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("read error: %s") % err.message().c_str() );
lisp.cc:1531://	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Evaluating: %s") % expression[01;31m-[00m>__repr__().c_str() );
lisp.cc:1532:	    result = eval::evaluateListReturnLast(expression,this[01;31m-[00m>globalEnvironment(),this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:1533:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % result[01;31m-[00m>__repr__().c_str() );
lisp.cc:1536:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("read error: %s") % err.message().c_str() );
lisp.cc:1539:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Unknown exception: %s") % excep.what() );
lisp.cc:1542:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Unknown error in interactiveReadEvalPrintLoop"));
lisp.cc:1548:{_F(this[01;31m-[00m>lisp());
lisp.cc:1552:    ExceptionSafeIFStreamAccess fileAccessor(fileName,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:1553:    RPObject result = this[01;31m-[00m>compileScriptInStream(fileAccessor.fin,fileName);
lisp.cc:1558:{_F(this[01;31m-[00m>lisp());
lisp.cc:1561:    RPObject result = this[01;31m-[00m>compileAndRunScriptInStream(sin,"[01;31m-[00minternal string[01;31m-[00m",0);
lisp.cc:1585:	    pathName = lisp[01;31m-[00m>findFileInLispPath(fileName);
lisp.cc:1588:	    lisp[01;31m-[00m>print(BF("The script file: %s could not be found")% fileName );
lisp.cc:1590:	this[01;31m-[00m>fin.open(pathName.c_str(),ios::in);
lisp.cc:1594:	this[01;31m-[00m>fin.close();
lisp.cc:1601:    TOSS(this[01;31m-[00m>error(BF("Implement debugger")));
lisp.cc:1611:	{_BLOCK_TRACEF(BF("[01;31m-[00mread stage[01;31m-[00m"));
lisp.cc:1612:	    RPObject expression = reader[01;31m-[00m>read();
lisp.cc:1613:	    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00mread[%s]") % expression[01;31m-[00m>__repr__() );
lisp.cc:1614:	    if ( expression[01;31m-[00m>isEof() ) break;
lisp.cc:1616:	    {_BLOCK_TRACEF(BF("[01;31m-[00meval/print stage[01;31m-[00m"));
lisp.cc:1617:		if ( expression[01;31m-[00m>isAssignableTo<O_Cons>() )
lisp.cc:1618:		{_BLOCK_TRACEF(BF("[01;31m-[00mexpand macros[01;31m-[00m"));
lisp.cc:1619:		    RPCons cexp = expression[01;31m-[00m>as<O_Cons>();
lisp.cc:1620:		    this[01;31m-[00m>expandMacros(cexp);
lisp.cc:1623:		RPObject result = eval::evaluate(expression,this[01;31m-[00m>globalEnvironment(),this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:1624:		LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00mresult[%s]") % result[01;31m-[00m>__repr__() );
lisp.cc:1627:		    this[01;31m-[00m>print(BF("; [01;31m-[00m[01;31m-[00m> %s")% result[01;31m-[00m>__repr__() );
lisp.cc:1631:		this[01;31m-[00m>print(BF("evaluate error: %s") % err.message() );
lisp.cc:1632:		    this[01;31m-[00m>enterDebugger();
lisp.cc:1635:		this[01;31m-[00m>print(BF("HardError: %s") % err.message() );
lisp.cc:1636:		this[01;31m-[00m>enterDebugger();
lisp.cc:1639:		this[01;31m-[00m>print(BF("Unknown error in interactiveReadEvalPrintLoop %s:%d\n") % __FILE__ % __LINE__);
lisp.cc:1640:		this[01;31m-[00m>enterDebugger();
lisp.cc:1644:	    this[01;31m-[00m>print(BF("read error: %s") % err.message() );
lisp.cc:1645:	    this[01;31m-[00m>enterDebugger();
lisp.cc:1648:	    this[01;31m-[00m>print(BF("HardError: %s") % err.message() );
lisp.cc:1649:	    this[01;31m-[00m>enterDebugger();
lisp.cc:1652:	    this[01;31m-[00m>print(BF("Unknown exception occurred at %s:%d") % __FILE__ % __LINE__);
lisp.cc:1653:	    this[01;31m-[00m>enterDebugger();
lisp.cc:1655:	if ( this[01;31m-[00m>getExitFlag() ) return;
lisp.cc:1663:    RPReader reader = O_Reader::createOnFile(pathName,this[01;31m-[00m>lisp());
lisp.cc:1664:    this[01;31m-[00m>readEvalPrint(reader,printResults);
lisp.cc:1665:    reader[01;31m-[00m>close();
lisp.cc:1672:    RPReader reader = O_Reader::createOnString(code,this[01;31m-[00m>lisp());
lisp.cc:1673:    this[01;31m-[00m>readEvalPrint(reader,printResults);
lisp.cc:1674:    reader[01;31m-[00m>close();
lisp.cc:1683:    RPReader reader = O_Reader::create(this[01;31m-[00m>lisp());
lisp.cc:1687:	line << myReadLine("Cando: ", this[01;31m-[00m>lisp()) << endl;
lisp.cc:1688:	RPReader reader = O_Reader::createOnString(line.str(),this[01;31m-[00m>lisp());
lisp.cc:1689:	this[01;31m-[00m>readEvalPrint(reader,true);
lisp.cc:1690:	if ( this[01;31m-[00m>getExitFlag() ) return;
lisp.cc:1699:{_F(this[01;31m-[00m>lisp());
lisp.cc:1707:{_F(this[01;31m-[00m>lisp());
lisp.cc:1709:    for ( ; handlerLists[01;31m-[00m>notNil(); handlerLists = handlerLists[01;31m-[00m>cdr() )
lisp.cc:1711:	RPCons cur = handlerLists[01;31m-[00m>car<O_Cons>();
lisp.cc:1712:	for ( ; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
lisp.cc:1714:	    RPCons oneHandler = cur[01;31m-[00m>car<O_Cons>();
lisp.cc:1715:	    LOG(BF("  Testing handler: %s")% oneHandler[01;31m-[00m>__repr__() );
lisp.cc:1716:	    if ( oneHandler[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
lisp.cc:1718:		RPSymbol classSymbol = oneHandler[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
lisp.cc:1719:		LOG(BF("    Handler handles class with symbol: %s") % classSymbol[01;31m-[00m>__repr__() );
lisp.cc:1720:		RPMetaClass conditionClass = this[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(classSymbol)[01;31m-[00m>as<O_MetaClass>();
lisp.cc:1722:		if ( conditionClass.get() == condition[01;31m-[00m>_class().get() )
lisp.cc:1730:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Illegal object for condition [01;31m-[00m you passed: %s") % condition[01;31m-[00m>__repr__() ));
lisp.cc:1735:    return O_Cons::nil(this[01;31m-[00m>lisp());
lisp.cc:1739:{_F(this[01;31m-[00m>lisp());
lisp.cc:1740:    RPCons stack = this[01;31m-[00m>_ConditionHandlers;
lisp.cc:1741:    return this[01;31m-[00m>findHigherUpConditionHandler(condition,stack);
lisp.cc:1749:{_F(this[01;31m-[00m>lisp());
lisp.cc:1750:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("O_Lisp::unhandledCondition entered") );
lisp.cc:1751:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % this[01;31m-[00m>backTraceAsString().c_str() );
lisp.cc:1752:    if ( cb[01;31m-[00m>isAssignableTo<O_ConditionBase>() )
lisp.cc:1754:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Condition: %s") % cb[01;31m-[00m>as<O_ConditionBase>()[01;31m-[00m>message().c_str() );
lisp.cc:1757:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Condition type: %s") % cb[01;31m-[00m>className().c_str() );
lisp.cc:1766:    RPCons entry = O_Cons::create(handlers,this[01;31m-[00m>_ConditionHandlers,this[01;31m-[00m>lisp());
lisp.cc:1767:    this[01;31m-[00m>_ConditionHandlers = entry;
lisp.cc:1772:    if ( this[01;31m-[00m>_ConditionHandlers[01;31m-[00m>isNil() ) return;
lisp.cc:1773:    this[01;31m-[00m>_ConditionHandlers = this[01;31m-[00m>_ConditionHandlers[01;31m-[00m>cdr();
lisp.cc:1781:{_F(this[01;31m-[00m>lisp());
lisp.cc:1782:    RPConditionBase cb = condition.conditionObject()[01;31m-[00m>as<O_ConditionBase>();
lisp.cc:1783:    RPObject result = O_Object::nil(this[01;31m-[00m>lisp());
lisp.cc:1785:	LOG(BF("The condition class(%s) must be in conditionHandlers: %s") % cb[01;31m-[00m>className() % environment[01;31m-[00m>__repr__() );
lisp.cc:1786:	RPExecutable handler = environment[01;31m-[00m>lookupHandler(cb[01;31m-[00m>_class());
lisp.cc:1787:	if ( handler[01;31m-[00m>notNil() )
lisp.cc:1789:	    RPCons args = O_Cons::create(cb,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:1790:	    RPObject result = eval::evaluateForm(handler,args,environment,this[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:1800:	    if ( environment[01;31m-[00m>findHigherUpConditionHandler(cb)[01;31m-[00m>notNil() )
lisp.cc:1809:    this[01;31m-[00m>unhandledCondition(cb,environment);
lisp.cc:1810:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Unhandled condition returned [01;31m-[00m it should never do this")));
lisp.cc:1823:    lisp[01;31m-[00m>print(BF("Environment%s\n") % environ[01;31m-[00m>__repr__().c_str() );
lisp.cc:1824:    LOG(BF("Environment\n%s") %environ[01;31m-[00m>__repr__() );
lisp.cc:1825:    return lisp[01;31m-[00m>onil();
lisp.cc:1838:    return lisp[01;31m-[00m>_boolean(lisp[01;31m-[00m>mpiEnabled());
lisp.cc:1851:    return O_Int::create(lisp[01;31m-[00m>mpiRank(),lisp);
lisp.cc:1864:    return O_Int::create(lisp[01;31m-[00m>mpiSize(),lisp);
lisp.cc:1877:    lisp[01;31m-[00m>print(BF("Hidden Binder keys:%s\n") % lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>summaryOfContents().c_str() );
lisp.cc:1878:    return lisp[01;31m-[00m>onil();
lisp.cc:1885:    string symbolPrefix = "GENSYM[01;31m-[00m";
lisp.cc:1886:    if ( args[01;31m-[00m>ocar()[01;31m-[00m>notNil() )
lisp.cc:1888:	if ( args[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Text>() )
lisp.cc:1890:	    symbolPrefix = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
lisp.cc:1893:    ss << symbolPrefix << lisp[01;31m-[00m>advanceGenSymIndex();
lisp.cc:1901:    RPCons arg = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>(); // Get the form to expand
lisp.cc:1902:    lisp[01;31m-[00m>expandMacrosOnce(arg);
lisp.cc:1908:    RPCons arg = args[01;31m-[00m>car<O_Cons>(); // Get the form to expand
lisp.cc:1909:    lisp[01;31m-[00m>expandMacros(arg);
lisp.cc:1928:    lisp[01;31m-[00m>print(BF("Just entered prim_makePackage"));
lisp.cc:1929:    RPSymbol packageName = args[01;31m-[00m>car<O_Symbol>();
lisp.cc:1930:    ASSERT(packageName[01;31m-[00m>isKeywordSymbol());
lisp.cc:1931:    return lisp[01;31m-[00m>makePackage(packageName[01;31m-[00m>identifierName());
lisp.cc:1947:    RPCons packages = lisp[01;31m-[00m>cnil();
lisp.cc:1948:    for ( Map<O_Package>::iterator mi = lisp[01;31m-[00m>packages().begin(); mi!=lisp[01;31m-[00m>packages().end(); mi++ )
lisp.cc:1950:	packages = lisp[01;31m-[00m>create<O_Cons>(mi[01;31m-[00m>second,packages);
lisp.cc:1962:	for ( O_Package::symbolIterator si = (*pi)[01;31m-[00m>begin();
lisp.cc:1963:	      si != (*pi)[01;31m-[00m>end(); si++ )
lisp.cc:1965:	    string symbolName = si[01;31m-[00m>second[01;31m-[00m>identifierName();
lisp.cc:1971:		symbols.insert(si[01;31m-[00m>second);
lisp.cc:1977:	lisp[01;31m-[00m>print(BF("%s") % (*si)[01;31m-[00m>fullName().c_str() );
lisp.cc:1993:    string substring = args[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
lisp.cc:1994:    if ( args[01;31m-[00m>cdr()[01;31m-[00m>notNil() )
lisp.cc:1996:	string packageName = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
lisp.cc:1997:	RPPackage package = lisp[01;31m-[00m>getPackage(packageName);
lisp.cc:2000:	return lisp[01;31m-[00m>nil<O_Object>();
lisp.cc:2002:    for ( Map<O_Package>::iterator pi=lisp[01;31m-[00m>packages().begin();
lisp.cc:2003:	  pi != lisp[01;31m-[00m>packages().end(); pi++ )
lisp.cc:2005://	if ( pi[01;31m-[00m>second != lisp[01;31m-[00m>keywordPackage()
lisp.cc:2006://	    	&& pi[01;31m-[00m>second != lisp[01;31m-[00m>ampPackage() )
lisp.cc:2007:	if ( pi[01;31m-[00m>second != lisp[01;31m-[00m>ampPackage() )
lisp.cc:2009:	    packages.push_back(pi[01;31m-[00m>second);
lisp.cc:2013:    return lisp[01;31m-[00m>nil<O_Object>();
lisp.cc:2030:    lisp[01;31m-[00m>print(BF("Just entered prim_usePackage"));
lisp.cc:2031:    RPSymbol packageName = args[01;31m-[00m>car<O_Symbol>();
lisp.cc:2032:    return lisp[01;31m-[00m>_boolean(lisp[01;31m-[00m>usePackage(packageName[01;31m-[00m>identifierName()));
lisp.cc:2045:    RPPackage package = lisp[01;31m-[00m>getCurrentPackage();
lisp.cc:2048:    while ( cur[01;31m-[00m>notNil() )
lisp.cc:2050:	if ( !cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
lisp.cc:2052:	    if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Package>() )
lisp.cc:2054:		ASSERTF(cur[01;31m-[00m>cdr()[01;31m-[00m>isNil(),"Package must be the last argument");
lisp.cc:2055:		package = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Package>();
lisp.cc:2058:		TOSS(_lisp[01;31m-[00m>error(BF("Illegal argument(%s)")%cur[01;31m-[00m>ocar()[01;31m-[00m>__repr__()));
lisp.cc:2061:	cur = cur[01;31m-[00m>cdr();
lisp.cc:2064:    while ( cur[01;31m-[00m>notNil() )
lisp.cc:2066:	if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Symbol>() )
lisp.cc:2068:	    RPSymbol sym = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
lisp.cc:2069:	    package[01;31m-[00m>import(sym[01;31m-[00m>identifierName(),sym);
lisp.cc:2071:	cur = cur[01;31m-[00m>cdr();
lisp.cc:2073:    return lisp[01;31m-[00m>_true();
lisp.cc:2086:    lisp[01;31m-[00m>print(BF("Just entered macro_inPackage"));
lisp.cc:2087:    RPSymbol packageName = args[01;31m-[00m>car<O_Symbol>();
lisp.cc:2088:    RPPackage pkg = lisp[01;31m-[00m>getPackage(packageName[01;31m-[00m>identifierName());
lisp.cc:2089:    lisp[01;31m-[00m>setCurrentPackage(pkg);
lisp.cc:2090:    return lisp[01;31m-[00m>onil();
lisp.cc:2104:    lisp[01;31m-[00m>print(BF("Just entered prim_getPackage"));
lisp.cc:2105:    RPText packageName = args[01;31m-[00m>car<O_Text>();
lisp.cc:2106:    return lisp[01;31m-[00m>getPackage(packageName[01;31m-[00m>get());
lisp.cc:2121:    RPExecutable form = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Executable>();
lisp.cc:2122:    RPCons passArgs = args[01;31m-[00m>cdr();
lisp.cc:2143:    RPExecutable form = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Executable>();
lisp.cc:2144:    RPCons passArgs = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
lisp.cc:2166:    RPSymbol symbol = args[01;31m-[00m>car<O_Symbol>();
lisp.cc:2167:    RPExecutable exec = environ[01;31m-[00m>lookupForm(symbol);
lisp.cc:2183:    ASSERT_eq(args[01;31m-[00m>length(),1);
lisp.cc:2184:    LOG(BF("all args |%s|") % args[01;31m-[00m>__repr__().c_str()  ); // vp0(( "all args |%s|", args[01;31m-[00m>__repr__().c_str() ));
lisp.cc:2185:    RPCons l = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
lisp.cc:2186:    LOG(BF("first arg |%s|") % l[01;31m-[00m>__repr__().c_str()  ); // vp0(( "first arg |%s|", l[01;31m-[00m>__repr__().c_str() ));
lisp.cc:2187:    for ( RPCons c=l; c[01;31m-[00m>notNil(); c=c[01;31m-[00m>cdr() )
lisp.cc:2189:	RPObject o = c[01;31m-[00m>ocar();
lisp.cc:2190:	LOG(BF("Object|%s|") % o[01;31m-[00m>__repr__().c_str()  ); // vp0(( "Object|%s|", o[01;31m-[00m>__repr__().c_str() ));
lisp.cc:2191:	ss << c[01;31m-[00m>ocar()[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
lisp.cc:2197:    RPCons result = lisp[01;31m-[00m>compileScriptInStream(ss,"[01;31m-[00m[01;31m-[00mnoFileName[01;31m-[00m[01;31m-[00m")[01;31m-[00m>cdr();
lisp.cc:2198:    RPObject oresult = result[01;31m-[00m>ocar();
lisp.cc:2208:	return x[01;31m-[00m>lt(y);
lisp.cc:2216:    RPCons unsorted = args[01;31m-[00m>car<O_Cons>();
lisp.cc:2217:    if ( unsorted[01;31m-[00m>length() == 0 ) return O_Cons::nil(lisp);
lisp.cc:2218:    sorted.fillFromCons(args[01;31m-[00m>car<O_Cons>());
lisp.cc:2236:	this[01;31m-[00m>_Lisp = lisp;
lisp.cc:2237:	this[01;31m-[00m>_Environment = environ;
lisp.cc:2238:	this[01;31m-[00m>_SortExecutable = proc;
lisp.cc:2239:	this[01;31m-[00m>_args = O_Cons::createList(lisp[01;31m-[00m>onil(),lisp[01;31m-[00m>onil(),lisp);
lisp.cc:2243:	this[01;31m-[00m>_args[01;31m-[00m>setCar(x);
lisp.cc:2244:	this[01;31m-[00m>_args[01;31m-[00m>cdr()[01;31m-[00m>setCar(y);
lisp.cc:2245:	return this[01;31m-[00m>_SortExecutable[01;31m-[00m>evaluate(this[01;31m-[00m>_args,this[01;31m-[00m>_Environment,this[01;31m-[00m>_Lisp)[01;31m-[00m>notNil();
lisp.cc:2251:    ASSERTF(environ[01;31m-[00m>notNil(),BF("Environment cannot be nil in prim_sort"));
lisp.cc:2253:    RPCons unsorted = args[01;31m-[00m>car<O_Cons>();
lisp.cc:2254:    LOG(BF("Unsorted data: %s") % args[01;31m-[00m>__repr__() );
lisp.cc:2255:    if ( unsorted[01;31m-[00m>length() == 0 ) return O_Cons::nil(lisp);
lisp.cc:2256:    sorted.fillFromCons(args[01;31m-[00m>car<O_Cons>());
lisp.cc:2257:    RPExecutable sortProc = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Executable>();
lisp.cc:2258:    LOG(BF("Sort function: %s") % sortProc[01;31m-[00m>__repr__() );
lisp.cc:2277:    ASSERT(args[01;31m-[00m>length()==1);
lisp.cc:2278:    return args[01;31m-[00m>ocar();
lisp.cc:2292://    RPCons names = lisp[01;31m-[00m>allLocalNamesAsCons();
lisp.cc:2307:    RPCons code = lisp[01;31m-[00m>__getCode();
lisp.cc:2309:    RPText sourceFile = O_Text::create(code[01;31m-[00m>getParsePosFileName(),lisp);
lisp.cc:2310:    LOG(BF("sourceFile = %s") % sourceFile[01;31m-[00m>get().c_str()  ); // vp0(( "sourceFile = %s", sourceFile[01;31m-[00m>get().c_str() ));
lisp.cc:2311:    RPInt lineNo = lisp[01;31m-[00m>create<O_Int>(code[01;31m-[00m>getParsePosLineNumber());
lisp.cc:2312:    LOG(BF("lineNo = %d") % lineNo[01;31m-[00m>get() ); // vp0(( "lineNo = %d", lineNo[01;31m-[00m>get()));
lisp.cc:2328:    RPCons bt = lisp[01;31m-[00m>getBackTrace();
lisp.cc:2344:    RPCons names = lisp[01;31m-[00m>allLocalNamesAsCons();
lisp.cc:2345:    lisp[01;31m-[00m>print(BF("%s") % names[01;31m-[00m>__repr__().c_str() );
lisp.cc:2359:    RPString dir = lisp[01;31m-[00m>create<O_String>(lisp[01;31m-[00m>bundle().getDatabasesDir().file_string());
lisp.cc:2372:    LOG(BF("isTopLevelScript = %d") % lisp[01;31m-[00m>getRequireLevel()  ); // vp0(( "isTopLevelScript = %d", lisp[01;31m-[00m>getRequireLevel() ));
lisp.cc:2373:    RPObject top = lisp[01;31m-[00m>_boolean(lisp[01;31m-[00m>getRequireLevel() == 0);
lisp.cc:2393:    for ( p = args; p[01;31m-[00m>notNil(); p = p[01;31m-[00m>cdr() )
lisp.cc:2395:	o = p[01;31m-[00m>car<O_Number>();
lisp.cc:2396:	if ( max[01;31m-[00m>isNil() || o[01;31m-[00m>asReal() > max[01;31m-[00m>asReal() )
lisp.cc:2421:    for ( p = args; p[01;31m-[00m>notNil(); p = p[01;31m-[00m>cdr() )
lisp.cc:2423:	o = p[01;31m-[00m>car<O_Number>();
lisp.cc:2424:	if ( min[01;31m-[00m>isNil() || o[01;31m-[00m>asReal() < min[01;31m-[00m>asReal() )
lisp.cc:2448:    if ( args[01;31m-[00m>length() != 0 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("No arguments needed"));
lisp.cc:2449:    lisp[01;31m-[00m>debugLog().setSuppressMessages(false);
lisp.cc:2465:    if ( args[01;31m-[00m>length() != 0 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("No arguments needed"));
lisp.cc:2466:    lisp[01;31m-[00m>debugLog().setSuppressMessages(true);
lisp.cc:2479:    lisp[01;31m-[00m>debugDump();
lisp.cc:2496:    if ( args[01;31m-[00m>length() != 1 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Need a file name")); 
lisp.cc:2497:    string fileName = args[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
lisp.cc:2507:    RPConditionBase cx = args[01;31m-[00m>car<O_ConditionBase>();
lisp.cc:2510:	if ( args[01;31m-[00m>cadr<O_Bool>()[01;31m-[00m>isTrue() )
lisp.cc:2512:	    _lisp[01;31m-[00m>print(BF("Expanded macro: About to throw condition(%s) condition.use_count()=%d") % cx[01;31m-[00m>message().c_str() % cx.use_count() );
lisp.cc:2514:	    cond[01;31m-[00m>setThrowPosition(__FILE__,__FUNCTION__,__LINE__);
lisp.cc:2515:	    ::mbb::lisp_logException(_lisp,__FILE__,__FUNCTION__,__LINE__,"exception thrown", cond[01;31m-[00m>message());
lisp.cc:2519:	    _lisp[01;31m-[00m>print(BF("MACRO: About to throw condition(%s) condition.use_count()=%d") % cx[01;31m-[00m>message().c_str() % cx.use_count() );
lisp.cc:2524:	_lisp[01;31m-[00m>print(BF("Caught condition(%s) and continuing") % err.message().c_str() );
lisp.cc:2525:	_lisp[01;31m-[00m>print(BF("conditionObject().use_count() = %d") % err.conditionObject().use_count());
lisp.cc:2527:    return _lisp[01;31m-[00m>onil();
lisp.cc:2537:    RPLisp lisp() { return this[01;31m-[00m>_Lisp;};
lisp.cc:2540:	this[01;31m-[00m>_Lisp = lisp;
lisp.cc:2541:	this[01;31m-[00m>_fileName = fileName;
lisp.cc:2542:	lisp[01;31m-[00m>addModule(fileName);
lisp.cc:2543:	lisp[01;31m-[00m>pushRequireLevel();
lisp.cc:2544:     	LOG(BF("  pushed require level to %d") % lisp[01;31m-[00m>getRequireLevel()  );
lisp.cc:2545:	lisp[01;31m-[00m>readEvalPrintFile(fileName,false);
lisp.cc:2549:	this[01;31m-[00m>_Lisp[01;31m-[00m>popRequireLevel();
lisp.cc:2550:	LOG(BF("  popped require level to %d") % this[01;31m-[00m>_Lisp[01;31m-[00m>getRequireLevel()  );
lisp.cc:2569:    if ( args[01;31m-[00m>length() != 1 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Need a file name")); 
lisp.cc:2570:    string fileName = args[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
lisp.cc:2571:    if ( lisp[01;31m-[00m>recognizesModule(fileName) )
lisp.cc:2579:    return lisp[01;31m-[00m>_true();
lisp.cc:2597:    RPText fileNameArg = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Text>();
lisp.cc:2598:    if ( args[01;31m-[00m>cdr()[01;31m-[00m>notNil() ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Need a file name")); 
lisp.cc:2599:    string fileName = args[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
lisp.cc:2600:    lisp[01;31m-[00m>readEvalPrintFile(fileName,false);
lisp.cc:2601:    return lisp[01;31m-[00m>_true();
lisp.cc:2611:    if ( args[01;31m-[00m>length() != 2 )
lisp.cc:2613:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("map needs two arguments: op and argument list"));
lisp.cc:2615:    RPProcedure op = args[01;31m-[00m>car<O_Procedure>();
lisp.cc:2616:    RPCons argList = args[01;31m-[00m>cadr<O_Cons>();
lisp.cc:2620:    if ( op[01;31m-[00m>numberOfPositionalArguments() == 0 )
lisp.cc:2622:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The operator must accept at least one argument" ));
lisp.cc:2624:    if ( op[01;31m-[00m>numberOfPositionalArguments() == 1 )
lisp.cc:2626:	for ( cur=argList; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
lisp.cc:2628:	    RPCons oneArg = O_Cons::create(cur[01;31m-[00m>ocar(),lisp);
lisp.cc:2629:	    LOG(BF("About to evaluate map (op element) [01;31m-[00m[01;31m-[00m> %s %s") % op[01;31m-[00m>__repr__() % oneArg[01;31m-[00m>__repr__() );
lisp.cc:2632:	    curResult[01;31m-[00m>setCdr(one);
lisp.cc:2635:    } else if ( op[01;31m-[00m>numberOfPositionalArguments() > 1 )
lisp.cc:2637:	for ( cur=argList; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
lisp.cc:2639:	    RPCons one = cur[01;31m-[00m>car<O_Cons>();
lisp.cc:2640:	    LOG(BF("About to evaluate map (op element) [01;31m-[00m[01;31m-[00m> %s %s") % op[01;31m-[00m>__repr__() % one[01;31m-[00m>__repr__() );
lisp.cc:2643:	    curResult[01;31m-[00m>setCdr(resEntry);
lisp.cc:2647:    return result[01;31m-[00m>cdr();
lisp.cc:2660:    if ( args[01;31m-[00m>isNil() )
lisp.cc:2664:    RPCons cons = args[01;31m-[00m>car<O_Cons>();
lisp.cc:2665:    return cons[01;31m-[00m>ocar();
lisp.cc:2678:    RPObject obj = args[01;31m-[00m>ocar();
lisp.cc:2679:    RPCons rest = args[01;31m-[00m>cadr<O_Cons>();
lisp.cc:2696:    if ( args[01;31m-[00m>isNil() )
lisp.cc:2700:    RPCons cons = args[01;31m-[00m>car<O_Cons>();
lisp.cc:2701:    return cons[01;31m-[00m>cdr();
lisp.cc:2715:    if ( args[01;31m-[00m>isNil() )
lisp.cc:2719:    RPCons cons = args[01;31m-[00m>car<O_Cons>();
lisp.cc:2720:    return cons[01;31m-[00m>cddr();
lisp.cc:2733:    if ( args[01;31m-[00m>isNil() )
lisp.cc:2737:    RPCons cons = args[01;31m-[00m>car<O_Cons>();
lisp.cc:2738:    return cons[01;31m-[00m>cdddr();
lisp.cc:2751:    if ( args[01;31m-[00m>isNil() )
lisp.cc:2755:    RPCons cons = args[01;31m-[00m>car<O_Cons>();
lisp.cc:2756:    return cons[01;31m-[00m>ocadr();
lisp.cc:2770:    if ( args[01;31m-[00m>isNil() )
lisp.cc:2774:    RPCons cons = args[01;31m-[00m>car<O_Cons>();
lisp.cc:2775:    return cons[01;31m-[00m>ocaddr();
lisp.cc:2792:    if ( args[01;31m-[00m>length() != 1 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Need one argument"));
lisp.cc:2793:    sz = args[01;31m-[00m>car<O_Cons>()[01;31m-[00m>length();
lisp.cc:2794:    return lisp[01;31m-[00m>create<O_Int>(sz);
lisp.cc:2811:    RPCons list = args[01;31m-[00m>car<O_Cons>();
lisp.cc:2812:    int i = args[01;31m-[00m>cadr<O_Int>()[01;31m-[00m>get();
lisp.cc:2813:    return list[01;31m-[00m>olistref(i);
lisp.cc:2830:    if ( args[01;31m-[00m>length() != 1 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Need one argument"));
lisp.cc:2831:    RPObject obj = args[01;31m-[00m>ocar();
lisp.cc:2832:    if ( !obj[01;31m-[00m>isOfClass<O_CandoObject>() ) return lisp[01;31m-[00m>create<O_String>(obj[01;31m-[00m>className());
lisp.cc:2833:    return lisp[01;31m-[00m>create<O_String>(obj[01;31m-[00m>className());
lisp.cc:2846:    ASSERT_eq(args[01;31m-[00m>length(),2);
lisp.cc:2847:    LOG(BF("Entered prim_isAssignableTo with arguments: %s")% args[01;31m-[00m>__repr__() );
lisp.cc:2848:    RPObject tag = args[01;31m-[00m>ocar();
lisp.cc:2849:    RPObject secondArgument = args[01;31m-[00m>ocadr();
lisp.cc:2850:    RPMetaClass mc = secondArgument[01;31m-[00m>as<O_MetaClass>();;
lisp.cc:2851:    LOG(BF("Checking if instances of class(%s) is assignable to variables of class(%s)")% tag[01;31m-[00m>className() % mc[01;31m-[00m>className() );
lisp.cc:2852:    bool io = (tag[01;31m-[00m>isAssignableToByClassId(mc[01;31m-[00m>getInstanceClassId()));
lisp.cc:2853:    return lisp[01;31m-[00m>_boolean(io);
lisp.cc:2865:    ASSERT_eq(args[01;31m-[00m>length(),2);
lisp.cc:2866:    LOG(BF("Entered prim_isSubClassOf with arguments: %s")% args[01;31m-[00m>__repr__() );
lisp.cc:2867:    RPMetaClass tag = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_MetaClass>();
lisp.cc:2868:    RPObject secondArgument = args[01;31m-[00m>ocadr();
lisp.cc:2869:    RPMetaClass mc = secondArgument[01;31m-[00m>as<O_MetaClass>();;
lisp.cc:2870:    LOG(BF("Checking if instances of class(%s) is assignable to variables of class(%s)")% tag[01;31m-[00m>className() % mc[01;31m-[00m>className() );
lisp.cc:2871:    bool io = tag[01;31m-[00m>isSubClassOf(mc);
lisp.cc:2872:    return lisp[01;31m-[00m>_boolean(io);
lisp.cc:2886:    if ( args[01;31m-[00m>length() != 2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Need two arguments"));
lisp.cc:2887:    RPObject obj = args[01;31m-[00m>ocar();
lisp.cc:2888:    RPMetaClass oclass = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_MetaClass>();
lisp.cc:2889:    bool res = ( obj[01;31m-[00m>_class().get() == oclass.get() );
lisp.cc:2890:    return lisp[01;31m-[00m>_boolean(res);
lisp.cc:2906:    if ( args[01;31m-[00m>length() != 1 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Need one argument"));
lisp.cc:2907:    res = lisp[01;31m-[00m>create<O_String>(args[01;31m-[00m>car<O_Object>()[01;31m-[00m>__repr__());
lisp.cc:2947:  \scriptCmdRet{[01;31m-[00m}{valueA:number valueB:number}{number}
lisp.cc:2955:    return oTr::create(((Tx)(ox[01;31m-[00m>as<oTx>()[01;31m-[00m>get()))[01;31m-[00m((Ty)(oy[01;31m-[00m>as<oTy>()[01;31m-[00m>get())),lisp);
lisp.cc:2965:    if ( args[01;31m-[00m>length() != 2 )
lisp.cc:2967:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("sub takes only two arguments"));
lisp.cc:2969:    RPObject x = args[01;31m-[00m>ocar();
lisp.cc:2970:    RPObject y = args[01;31m-[00m>ocadr();
lisp.cc:2971:    if ( x[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:2973:	if ( y[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:2976:	} else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:2979:	} else if ( y[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:2983:    } else if ( x[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:2985:	if ( y[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:2988:	} else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:2991:	} else if ( y[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:2995:    } else if ( x[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:2997:	if ( y[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:3000:	} else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:3003:	} else if ( y[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:3008:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for sub"));
lisp.cc:3023:    return oTr::create(((Tx)(ox[01;31m-[00m>as<oTx>()[01;31m-[00m>get()))/((Ty)(oy[01;31m-[00m>as<oTy>()[01;31m-[00m>get())),lisp);
lisp.cc:3033:    if ( args[01;31m-[00m>length() != 2 )
lisp.cc:3035:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("div takes only two arguments"));
lisp.cc:3037:    RPObject x = args[01;31m-[00m>ocar();
lisp.cc:3038:    RPObject y = args[01;31m-[00m>ocadr();
lisp.cc:3039:    if ( x[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:3041:	if ( y[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:3044:	} else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:3047:	} else if ( y[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:3051:    } else if ( x[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:3053:	if ( y[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:3056:	} else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:3059:	} else if ( y[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:3063:    } else if ( x[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:3065:	if ( y[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:3068:	} else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:3071:	} else if ( y[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:3076:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for div"));
lisp.cc:3091:    return oTr::create(((Tx)(ox[01;31m-[00m>as<oTx>()[01;31m-[00m>get()))*((Ty)(oy[01;31m-[00m>as<oTy>()[01;31m-[00m>get())),lisp);
lisp.cc:3101:    if ( args[01;31m-[00m>length() != 2 )
lisp.cc:3103:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("mul takes only two arguments"));
lisp.cc:3105:    RPObject x = args[01;31m-[00m>ocar();
lisp.cc:3106:    RPObject y = args[01;31m-[00m>ocadr();
lisp.cc:3107:    if ( x[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:3109:	if ( y[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:3112:	} else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:3115:	} else if ( y[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:3119:    } else if ( x[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:3121:	if ( y[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:3124:	} else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:3127:	} else if ( y[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:3131:    } else if ( x[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:3133:	if ( y[01;31m-[00m>isOfClass<O_Int>() )
lisp.cc:3136:	} else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
lisp.cc:3139:	} else if ( y[01;31m-[00m>isOfClass<O_Real>() )
lisp.cc:3144:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for mul"));
lisp.cc:3170:    if ( args[01;31m-[00m>length() != 2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Need two arguments"));
lisp.cc:3171:    RPObject o1 = args[01;31m-[00m>ocar();
lisp.cc:3172:    RPObject o2 = args[01;31m-[00m>ocadr();
lisp.cc:3174:    d1 = safe_downcast<O_Int>(o1)[01;31m-[00m>get();
lisp.cc:3175:    d2 = safe_downcast<O_Int>(o2)[01;31m-[00m>get();
lisp.cc:3176:    return lisp[01;31m-[00m>create<O_Int>(d1 % d2);
lisp.cc:3196:    if ( args[01;31m-[00m>length() != 2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("eq needs two arguments"));
lisp.cc:3197:    RPObject o1 = args[01;31m-[00m>ocar();
lisp.cc:3198:    RPObject o2 = args[01;31m-[00m>ocadr();
lisp.cc:3199:    return lisp[01;31m-[00m>_boolean(o1[01;31m-[00m>equal(o2));
lisp.cc:3212:    if ( args[01;31m-[00m>length() != 2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("ne needs two arguments"));
lisp.cc:3213:    RPObject o1 = args[01;31m-[00m>ocar();
lisp.cc:3214:    RPObject o2 = args[01;31m-[00m>ocadr();
lisp.cc:3215:    return lisp[01;31m-[00m>_boolean(o1[01;31m-[00m>ne(o2));
lisp.cc:3229:    if ( args[01;31m-[00m>length() != 2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("lt needs two arguments"));
lisp.cc:3230:    RPObject o1 = args[01;31m-[00m>ocar();
lisp.cc:3231:    RPObject o2 = args[01;31m-[00m>ocadr();
lisp.cc:3232:    return lisp[01;31m-[00m>_boolean(o1[01;31m-[00m>lt(o2));
lisp.cc:3246:    if ( args[01;31m-[00m>length() != 2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("gt needs two arguments"));
lisp.cc:3247:    RPObject o1 = args[01;31m-[00m>ocar();
lisp.cc:3248:    RPObject o2 = args[01;31m-[00m>ocadr();
lisp.cc:3249:    return lisp[01;31m-[00m>_boolean(o1[01;31m-[00m>gt(o2));
lisp.cc:3263:    if ( args[01;31m-[00m>length() != 2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("le needs two arguments"));
lisp.cc:3264:    RPObject o1 = args[01;31m-[00m>olistref(0);
lisp.cc:3265:    RPObject o2 = args[01;31m-[00m>olistref(1);
lisp.cc:3266:    return lisp[01;31m-[00m>_boolean(o1[01;31m-[00m>le(o2));
lisp.cc:3280:    if ( args[01;31m-[00m>length() != 2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("ge needs two arguments"));
lisp.cc:3281:    RPObject o1 = args[01;31m-[00m>olistref(0);
lisp.cc:3282:    RPObject o2 = args[01;31m-[00m>olistref(1);
lisp.cc:3283:    return lisp[01;31m-[00m>_boolean(o1[01;31m-[00m>ge(o2));
lisp.cc:3298:    ASSERTP(args[01;31m-[00m>cdr()[01;31m-[00m>isNil(),"not only accepts one argument");
lisp.cc:3299:    return lisp[01;31m-[00m>_boolean(!args[01;31m-[00m>ocar()[01;31m-[00m>isTrue());
lisp.cc:3311:    while (args[01;31m-[00m>notNil() )
lisp.cc:3313:	if (args[01;31m-[00m>ocar()[01;31m-[00m>isFalse() ) return lisp[01;31m-[00m>_false();
lisp.cc:3314:	args = args[01;31m-[00m>cdr();
lisp.cc:3316:    return lisp[01;31m-[00m>_true();
lisp.cc:3329:    while (args[01;31m-[00m>notNil() )
lisp.cc:3331:	if (args[01;31m-[00m>ocar()[01;31m-[00m>isTrue() ) return lisp[01;31m-[00m>_true();
lisp.cc:3332:	args = args[01;31m-[00m>cdr();
lisp.cc:3334:    return lisp[01;31m-[00m>_false();
lisp.cc:3351:    string pref = args[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
lisp.cc:3380:    for ( RPCons p=args; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() ) sout << p[01;31m-[00m>ocar()[01;31m-[00m>__str__();
lisp.cc:3381:    lisp[01;31m-[00m>print(BF("%s") % sout.str().c_str());
lisp.cc:3395:    for ( RPCons p=args; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() ) sout << p[01;31m-[00m>ocar()[01;31m-[00m>__str__();
lisp.cc:3396:    lisp[01;31m-[00m>printvWrite("\n");
lisp.cc:3397:    lisp[01;31m-[00m>printvWrite(sout.str().c_str());
lisp.cc:3398:    lisp[01;31m-[00m>printvFlush();
lisp.cc:3412:    for ( RPCons p=args; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() ) sout << p[01;31m-[00m>ocar()[01;31m-[00m>__str__();
lisp.cc:3413:    lisp[01;31m-[00m>printvWrite(sout.str().c_str());
lisp.cc:3414:    lisp[01;31m-[00m>printvFlush();
lisp.cc:3427:    lisp[01;31m-[00m>setExit(1);
lisp.cc:3434:    for ( RPCons p=args; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() ) 
lisp.cc:3435:	sout << p[01;31m-[00m>ocar()[01;31m-[00m>__repr__();
lisp.cc:3436:    lisp[01;31m-[00m>print(BF("%s") % sout.str().c_str());
lisp.cc:3444:    for ( RPCons p=args; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() ) sout << p[01;31m-[00m>ocar()[01;31m-[00m>__repr__();
lisp.cc:3445:    lisp[01;31m-[00m>print(BF("%s") % sout.str().c_str());
lisp.cc:3451:{_F(this[01;31m-[00m>lisp());
lisp.cc:3452:    ASSERT(this[01;31m-[00m>_EnvironmentInitialized);
lisp.cc:3453:    this[01;31m-[00m>_GlobalEnvironment[01;31m-[00m>extendForm(sym,form);
lisp.cc:3460:    ASSERT_NOT_NULL(this[01;31m-[00m>_Environment);
lisp.cc:3461:    return this[01;31m-[00m>_Environment[01;31m-[00m>isGlobalDefined(sym);
lisp.cc:3469:    RPMetaClass mc = this[01;31m-[00m>classFromClassName(name);
lisp.cc:3470:    return mc[01;31m-[00m>classId();
lisp.cc:3475:{_F(this[01;31m-[00m>lisp());
lisp.cc:3476:    LOG(BF("createObjectOfClass(%s)") % mc[01;31m-[00m>getPackagedName() );
lisp.cc:3477:    RPObject obj = mc[01;31m-[00m>allocateObject();
lisp.cc:3478:    obj[01;31m-[00m>initialize();
lisp.cc:3485:    ASSERT_lt(cid,this[01;31m-[00m>_ClassesByClassId.size());
lisp.cc:3486:    RPMetaClass mc = this[01;31m-[00m>_ClassesByClassId[cid];
lisp.cc:3492:    RPMetaClass mc = this[01;31m-[00m>_ClassesByClassId[cid];
lisp.cc:3493:    return mc[01;31m-[00m>getPackagedName();
lisp.cc:3502:    RPSymbol sym = this[01;31m-[00m>findSymbol(name);
lisp.cc:3503:    if ( sym[01;31m-[00m>isNil() )
lisp.cc:3505:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find class with name: "+name ));
lisp.cc:3507:    return this[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(sym)[01;31m-[00m>as<O_MetaClass>();
lisp.cc:3513:{_F(this[01;31m-[00m>lisp());
lisp.cc:3517:	package = this[01;31m-[00m>_KeywordPackage;
lisp.cc:3525:	package = this[01;31m-[00m>_AmpPackage;
lisp.cc:3534:	package = this[01;31m-[00m>_CurrentPackage;
lisp.cc:3542:	LOG(BF("It's a non[01;31m-[00mexported symbol"));
lisp.cc:3548:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There can only be one ':' or '::' in a symbol name"));
lisp.cc:3551:    package = this[01;31m-[00m>getPackage(name.substr(0,colonPos));
lisp.cc:3553:    LOG(BF("It's a packaged symbol (%s :: %s)") % package[01;31m-[00m>getName()% symbolName );
lisp.cc:3562:    ASSERT(this[01;31m-[00m>_PackagesInitialized);
lisp.cc:3564:    Map<O_Package>::iterator pi = this[01;31m-[00m>_Packages.find(packageName);
lisp.cc:3565:    if ( pi==this[01;31m-[00m>_Packages.end() )
lisp.cc:3567:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown package name("+packageName+")"));
lisp.cc:3569:    RPPackage package = pi[01;31m-[00m>second;
lisp.cc:3570:    return package[01;31m-[00m>intern(symbolName);
lisp.cc:3575:{_F(this[01;31m-[00m>lisp());
lisp.cc:3577:    Map<O_Package>::iterator pi = this[01;31m-[00m>_Packages.find(packageName);
lisp.cc:3578:    if ( pi == this[01;31m-[00m>_Packages.end() ) 
lisp.cc:3580:	LOG(BF("Could not find package, returning symbol([01;31m-[00mnil[01;31m-[00m)"));
lisp.cc:3581:	return O_Symbol::nil(this[01;31m-[00m>lisp());
lisp.cc:3584:    RPSymbol sym = (pi[01;31m-[00m>second)[01;31m-[00m>findSymbol(name);
lisp.cc:3585:    LOG(BF("Returning symbol from package: %s") % sym[01;31m-[00m>fullName());
lisp.cc:3591:{_F(this[01;31m-[00m>lisp());
lisp.cc:3593:    ASSERT(this[01;31m-[00m>_PackagesInitialized);
lisp.cc:3598:    this[01;31m-[00m>parseStringIntoPackageAndSymbolName(name,package,symbolName,exported);
lisp.cc:3599:    return package[01;31m-[00m>findSymbol(symbolName);
lisp.cc:3605:{_F(this[01;31m-[00m>lisp());
lisp.cc:3609:    this[01;31m-[00m>parseStringIntoPackageAndSymbolName(name,package,symbolName,exported);
lisp.cc:3610:    return package[01;31m-[00m>intern(symbolName);
lisp.cc:3621:    return this[01;31m-[00m>_KeywordPackage[01;31m-[00m>intern(realName);
lisp.cc:3631:    return this[01;31m-[00m>_AmpPackage[01;31m-[00m>intern(realName);
lisp.cc:3639:    RPSymbol sym = this[01;31m-[00m>intern(name);
lisp.cc:3640:    if ( !this[01;31m-[00m>globalEnvironment()[01;31m-[00m>definedQ(sym) ) return false;
lisp.cc:3641:    RPObject obj = this[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(sym);
lisp.cc:3642:    return obj[01;31m-[00m>isAssignableTo<O_MetaClass>();
lisp.cc:3656:{_F(lisp[01;31m-[00m>sharedThis<O_Lisp>());
lisp.cc:3657:    while ( mc[01;31m-[00m>notNil())
lisp.cc:3659:	LOG(BF("Looking for method(%s) in class(%s)")% sym[01;31m-[00m>currentName() % mc[01;31m-[00m>getPackagedName() );
lisp.cc:3660:	RPExecutable exec = mc[01;31m-[00m>getMethodOrNil(sym, receiver);
lisp.cc:3661:	if ( exec[01;31m-[00m>notNil() ) 
lisp.cc:3666:	mc = mc[01;31m-[00m>getInstanceBaseClass();
lisp.cc:3669:    return lisp[01;31m-[00m>nil<O_Executable>();
lisp.cc:3675:{_F(this[01;31m-[00m>lisp());
lisp.cc:3686:    ASSERT(class1<this[01;31m-[00m>_ClassesByClassId.size());
lisp.cc:3687:    ASSERT(class2<this[01;31m-[00m>_ClassesByClassId.size());
lisp.cc:3688:    RPMetaClass mc1 = this[01;31m-[00m>_ClassesByClassId[class1];
lisp.cc:3689:    RPMetaClass mc2 = this[01;31m-[00m>_ClassesByClassId[class2];
lisp.cc:3690:    return mc2[01;31m-[00m>isSubClassOf(mc1);
lisp.cc:3699:    RPCons btReversed = this[01;31m-[00m>getBackTrace();
lisp.cc:3700:    RPCons bt = btReversed[01;31m-[00m>reverse();
lisp.cc:3701:    strace << "Cando[01;31m-[00mbacktrace number of entries: " << bt[01;31m-[00m>length() <<endl;
lisp.cc:3702:    while ( bt[01;31m-[00m>notNil() )
lisp.cc:3704:	RPCons entry = bt[01;31m-[00m>car<O_Cons>();
lisp.cc:3705:	if ( entry[01;31m-[00m>hasParsePos() )
lisp.cc:3707:	    strace << entry[01;31m-[00m>getParsePosFileName() << ":" << entry[01;31m-[00m>getParsePosLineNumber() << endl;
lisp.cc:3710:	    strace << "no[01;31m-[00mfunction: " << entry[01;31m-[00m>__repr__() << endl;
lisp.cc:3712:	bt = bt[01;31m-[00m>cdr();
lisp.cc:3714:    strace << "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m backtrace done [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
lisp.cc:3723:{_F(this[01;31m-[00m>lisp());
lisp.cc:3728:    if ( this[01;31m-[00m>_RCFileName != "" )
lisp.cc:3729:    {_BLOCK_TRACEF(BF("Evaluating initialization code in(%s)") % this[01;31m-[00m>_RCFileName );
lisp.cc:3730:	boost::filesystem::path rcPath(this[01;31m-[00m>_RCFileName);
lisp.cc:3733:	    this[01;31m-[00m>readEvalPrintFile(this[01;31m-[00m>_RCFileName,false);
lisp.cc:3736:    this[01;31m-[00m>_ExitStatus = 0;
lisp.cc:3737:    if ( !this[01;31m-[00m>_ProgramCode._ScriptInFile && this[01;31m-[00m>_ProgramCode._FileNameOrCode != "" )
lisp.cc:3739:	LOG(BF("Compiling script in string: %s")% this[01;31m-[00m>_ProgramCode._FileNameOrCode);
lisp.cc:3740:	this[01;31m-[00m>readEvalPrintFile(this[01;31m-[00m>_ProgramCode._FileNameOrCode,false);
lisp.cc:3743:	string& scriptFileName = this[01;31m-[00m>_ProgramCode._FileNameOrCode;
lisp.cc:3747:	    this[01;31m-[00m>readEvalPrintFile(scriptFileName,false);
lisp.cc:3750:	    LOG(BF("this[01;31m-[00m>_ProgramCode._FileNameOrCode is empty"));
lisp.cc:3757:    if ( this[01;31m-[00m>_Interactive )
lisp.cc:3760:	// Implement a Read[01;31m-[00mEval[01;31m-[00mPrint[01;31m-[00mLoop
lisp.cc:3762:	this[01;31m-[00m>print(BF("Starting interactive\n"));
lisp.cc:3763:	this[01;31m-[00m>readEvalPrintInteractive();
lisp.cc:3765:    this[01;31m-[00m>_ExitStatus = 0;
lisp.cc:3771:{_F(this[01;31m-[00m>lisp());
lisp.cc:3774:    ss << this[01;31m-[00m>_Program[01;31m-[00m>__repr__();
lisp.cc:3784:    string d = lisp[01;31m-[00m>dumpClasses();
lisp.cc:3785:    lisp[01;31m-[00m>print(BF("%s") % d.c_str() );
lisp.cc:3792:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Throwing exception as a test"));
lisp.cc:3800:    ASSERT(args[01;31m-[00m>length() == 2 );
lisp.cc:3801:    RPObject tag = args[01;31m-[00m>ocar();
lisp.cc:3802:    RPObject parent = args[01;31m-[00m>ocadr();
lisp.cc:3804://    lisp[01;31m-[00m>defaultHierarchy()[01;31m-[00m>derive(tag,parent);
lisp.cc:3805:    return lisp[01;31m-[00m>nil<O_Object>();
lisp.cc:3811:    ASSERT(args[01;31m-[00m>length() == 2 );
lisp.cc:3812:    RPObject tag = args[01;31m-[00m>ocar();
lisp.cc:3813:    RPObject ancestor = args[01;31m-[00m>ocadr();
lisp.cc:3814:    if ( tag[01;31m-[00m>eq(ancestor) ) goto isTrue;
lisp.cc:3815:    if ( ancestor[01;31m-[00m>isAssignableTo<O_MetaClass>() )
lisp.cc:3817:	if ( tag[01;31m-[00m>isAssignableToByClassId(ancestor[01;31m-[00m>as<O_MetaClass>()[01;31m-[00m>instanceClassId()) ) goto isTrue;
lisp.cc:3819:    if ( lisp[01;31m-[00m>defaultHierarchy()[01;31m-[00m>isADescendant(tag,ancestor) ) goto isTrue;
lisp.cc:3820:    return lisp[01;31m-[00m>_false();
lisp.cc:3822:    return lisp[01;31m-[00m>_true();
lisp.cc:3838:    ASSERT(args[01;31m-[00m>length()==1);
lisp.cc:3839:    maxi = args[01;31m-[00m>car<O_Int>()[01;31m-[00m>get();
lisp.cc:3840:    lisp[01;31m-[00m>print(BF("Starting prim_testomp enabled= %d") % cando_omp_enabled() );
lisp.cc:3843:	lisp[01;31m-[00m>print(BF("Hello from omp thread(%d)") % cando_omp_get_thread_num() );
lisp.cc:3860:	lisp[01;31m-[00m>print(BF("thread(%d) c=%ld") % cando_omp_get_thread_num() % c);
lisp.cc:3862:    lisp[01;31m-[00m>print(BF("c = %ld") % c );
lisp.cc:3872:	class_<O_Lisp>(this[01;31m-[00m>lisp());
lisp.cc:3873:	defNoWrapPackage(ClPackage,"apropos",&prim_apropos,this[01;31m-[00m>lisp());
lisp.cc:3874:	defNoWrapPackage(ClPackage,"makePackage", &prim_makePackage,this[01;31m-[00m>lisp());
lisp.cc:3875:	defNoWrapPackage(ClPackage,"make[01;31m-[00mpackage", &prim_makePackage,this[01;31m-[00m>lisp());
lisp.cc:3876:	defNoWrapPackage(ClPackage,"listAllPackages", &prim_listAllPackages,this[01;31m-[00m>lisp());
lisp.cc:3877:	defNoWrapPackage(ClPackage,"list[01;31m-[00mall[01;31m-[00mpackages", &prim_listAllPackages,this[01;31m-[00m>lisp());
lisp.cc:3878:	defNoWrapPackage(ClPackage,"usePackage", &prim_usePackage,this[01;31m-[00m>lisp());
lisp.cc:3879:	defNoWrapPackage(ClPackage,"getPackage", &prim_getPackage,this[01;31m-[00m>lisp());
lisp.cc:3880:	defNoWrapPackage(ClPackage,"use[01;31m-[00mpackage", &prim_usePackage,this[01;31m-[00m>lisp());
lisp.cc:3881://	defNoWrapPackage(ClPackage,"apply", &prim_apply,this[01;31m-[00m>lisp());
lisp.cc:3882:	defNoWrapPackage(ClPackage,"getForm", &prim_getForm,this[01;31m-[00m>lisp());
lisp.cc:3883:	defNoWrapPackage(ClPackage,"testomp", &prim_testomp,this[01;31m-[00m>lisp());
lisp.cc:3884:	defNoWrapPackage(ClPackage,"testThrowCatch", &prim_testThrowCatch,this[01;31m-[00m>lisp());
lisp.cc:3885:	defNoWrapPackage(ClPackage,"testThrowError", &prim_testThrowError,this[01;31m-[00m>lisp());
lisp.cc:3886:	defNoWrapPackage(ClPackage,"isTopLevelScript", &prim_isTopLevelScript ,this[01;31m-[00m>lisp());
lisp.cc:3887://	defNoWrapPackage(ClPackage,"allGlobalNames", &prim_allGlobalNames ,this[01;31m-[00m>lisp());
lisp.cc:3888:	defNoWrapPackage(ClPackage,"localVariableNames", &prim_localVariableNames,this[01;31m-[00m>lisp());
lisp.cc:3889://	defNoWrapPackage(ClPackage,"locals", &prim_locals,this[01;31m-[00m>lisp());
lisp.cc:3890:	defNoWrapPackage(ClPackage,"sourceFileLine", &prim_sourceFileLine,this[01;31m-[00m>lisp());
lisp.cc:3891:	defNoWrapPackage(ClPackage,"backtrace", &prim_backtrace,this[01;31m-[00m>lisp());
lisp.cc:3892://	defNoWrapPackage(ClPackage,"globals", &prim_globals,this[01;31m-[00m>lisp());
lisp.cc:3893:	defNoWrapPackage(ClPackage,"require", &prim_require ,this[01;31m-[00m>lisp());
lisp.cc:3894:	defNoWrapPackage(ClPackage,"load", &prim_load,this[01;31m-[00m>lisp());
lisp.cc:3895:	defNoWrapPackage(ClPackage,"import",&prim_import,this[01;31m-[00m>lisp());
lisp.cc:3896:	defNoWrapPackage(ClPackage,"testScanner", &prim_testScanner ,this[01;31m-[00m>lisp());
lisp.cc:3897:	defNoWrapPackage(ClPackage,"printPushPrefix", &prim_printPushPrefix ,this[01;31m-[00m>lisp());
lisp.cc:3898:	defNoWrapPackage(ClPackage,"printPopPrefix", &prim_printPopPrefix ,this[01;31m-[00m>lisp());
lisp.cc:3899:	defNoWrapPackage(ClPackage,"println", &prim_println ,this[01;31m-[00m>lisp());
lisp.cc:3900:	defNoWrapPackage(ClPackage,"print", &prim_print ,this[01;31m-[00m>lisp());
lisp.cc:3901:	defNoWrapPackage(ClPackage,"prin1", &prim_prin1 ,this[01;31m-[00m>lisp());
lisp.cc:3902:	defNoWrapPackage(ClPackage,"dump", &prim_dump ,this[01;31m-[00m>lisp());
lisp.cc:3903:	defNoWrapPackage(ClPackage,"isAssignableTo", &prim_isAssignableTo ,this[01;31m-[00m>lisp());
lisp.cc:3904:	defNoWrapPackage(ClPackage,"isSubClassOf", &prim_isSubClassOf,this[01;31m-[00m>lisp());
lisp.cc:3905:	defNoWrapPackage(ClPackage,"isOfClass", &prim_isOfClass ,this[01;31m-[00m>lisp());
lisp.cc:3906://	defNoWrapPackage(ClPackage,"derive", &prim_derive ,this[01;31m-[00m>lisp());
lisp.cc:3907://	defNoWrapPackage(ClPackage,"isA", &prim_isA ,this[01;31m-[00m>lisp());
lisp.cc:3908:	defNoWrapPackage(ClPackage,"dumpln", &prim_dumpln ,this[01;31m-[00m>lisp());
lisp.cc:3909://	defNoWrapPackage(ClPackage,"parseConsOfStrings", &prim_parseConsOfStrings ,this[01;31m-[00m>lisp());
lisp.cc:3910:	defNoWrapPackage(ClPackage,"exit", &prim_exit ,this[01;31m-[00m>lisp());
lisp.cc:3911:	defNoWrapPackage(ClPackage,"quit", &prim_exit ,this[01;31m-[00m>lisp());
lisp.cc:3912:	defNoWrapPackage(ClPackage,"funcall", &prim_funcall ,this[01;31m-[00m>lisp());
lisp.cc:3913:	defNoWrapPackage(ClPackage,"apply", &prim_apply ,this[01;31m-[00m>lisp());
lisp.cc:3914:	defNoWrapPackage(ClPackage,"map", &prim_map ,this[01;31m-[00m>lisp());
lisp.cc:3915:	defNoWrapPackage(ClPackage,"min", &prim_min ,this[01;31m-[00m>lisp());
lisp.cc:3916:	defNoWrapPackage(ClPackage,"max", &prim_max ,this[01;31m-[00m>lisp());
lisp.cc:3917://	defNoWrapPackage(ClPackage,"sub", &prim_sub ,this[01;31m-[00m>lisp());
lisp.cc:3918://	defNoWrapPackage(ClPackage,"[01;31m-[00m", &prim_sub ,this[01;31m-[00m>lisp());
lisp.cc:3919://	defNoWrapPackage(ClPackage,"div", &prim_div ,this[01;31m-[00m>lisp());
lisp.cc:3920:	defNoWrapPackage(ClPackage,"mod", &prim_mod ,this[01;31m-[00m>lisp());
lisp.cc:3921://	defNoWrapPackage(ClPackage,"/", &prim_div ,this[01;31m-[00m>lisp());
lisp.cc:3922://	defNoWrapPackage(ClPackage,"mul", &prim_mul ,this[01;31m-[00m>lisp());
lisp.cc:3923://	defNoWrapPackage(ClPackage,"*", &prim_mul ,this[01;31m-[00m>lisp());
lisp.cc:3924:	defNoWrapPackage(ClPackage,"length", &prim_length ,this[01;31m-[00m>lisp());
lisp.cc:3925:	defNoWrapPackage(ClPackage,"listref", &prim_listref ,this[01;31m-[00m>lisp());
lisp.cc:3926:	defNoWrapPackage(ClPackage,"@", &prim_listref ,this[01;31m-[00m>lisp());
lisp.cc:3927:	defNoWrapPackage(ClPackage,"car", &prim_car ,this[01;31m-[00m>lisp());
lisp.cc:3928:	defNoWrapPackage(ClPackage,"cons", &prim_cons ,this[01;31m-[00m>lisp());
lisp.cc:3929:	defNoWrapPackage(ClPackage,"cdr", &prim_cdr ,this[01;31m-[00m>lisp());
lisp.cc:3930:	defNoWrapPackage(ClPackage,"cddr", &prim_cddr ,this[01;31m-[00m>lisp());
lisp.cc:3931:	defNoWrapPackage(ClPackage,"cdddr", &prim_cdddr ,this[01;31m-[00m>lisp());
lisp.cc:3932:	defNoWrapPackage(ClPackage,"cadr", &prim_cadr ,this[01;31m-[00m>lisp());
lisp.cc:3933:	defNoWrapPackage(ClPackage,"caddr", &prim_caddr ,this[01;31m-[00m>lisp());
lisp.cc:3934:	defNoWrapPackage(ClPackage,"className", &prim_className ,this[01;31m-[00m>lisp());
lisp.cc:3935:	defNoWrapPackage(ClPackage,"repr", &prim_repr ,this[01;31m-[00m>lisp());
lisp.cc:3936:	defNoWrapPackage(ClPackage,"yourself", &prim_yourself ,this[01;31m-[00m>lisp());
lisp.cc:3937:	defNoWrapPackage(ClPackage,"!", &prim_yourself ,this[01;31m-[00m>lisp());
lisp.cc:3938:	defNoWrapPackage(ClPackage,"list", &prim_list ,this[01;31m-[00m>lisp());
lisp.cc:3939:	defNoWrapPackage(ClPackage,"keyedList", &prim_keyedList ,this[01;31m-[00m>lisp());
lisp.cc:3941:	defNoWrapPackage(ClPackage,"eq", &prim_eq,this[01;31m-[00m>lisp());
lisp.cc:3942:	defNoWrapPackage(ClPackage,"==", &prim_eq,this[01;31m-[00m>lisp());
lisp.cc:3943:	defNoWrapPackage(ClPackage,"ne", &prim_ne,this[01;31m-[00m>lisp());
lisp.cc:3944:	defNoWrapPackage(ClPackage,"!=", &prim_ne,this[01;31m-[00m>lisp());
lisp.cc:3945:	defNoWrapPackage(ClPackage,"lt", &prim_lt,this[01;31m-[00m>lisp());
lisp.cc:3946:	defNoWrapPackage(ClPackage,"<", &prim_lt,this[01;31m-[00m>lisp());
lisp.cc:3947:	defNoWrapPackage(ClPackage,"gt", &prim_gt,this[01;31m-[00m>lisp());
lisp.cc:3948:	defNoWrapPackage(ClPackage,">", &prim_gt,this[01;31m-[00m>lisp());
lisp.cc:3949:	defNoWrapPackage(ClPackage,"le", &prim_le,this[01;31m-[00m>lisp());
lisp.cc:3950:	defNoWrapPackage(ClPackage,"<=", &prim_le,this[01;31m-[00m>lisp());
lisp.cc:3951:	defNoWrapPackage(ClPackage,"ge", &prim_ge,this[01;31m-[00m>lisp());
lisp.cc:3952:	defNoWrapPackage(ClPackage,">=", &prim_ge,this[01;31m-[00m>lisp());
lisp.cc:3954:	defNoWrapPackage(ClPackage,"not", &prim_not,this[01;31m-[00m>lisp());
lisp.cc:3955:	defNoWrapPackage(ClPackage,"or", &prim_or,this[01;31m-[00m>lisp());
lisp.cc:3956:	defNoWrapPackage(ClPackage,"and", &prim_and,this[01;31m-[00m>lisp());
lisp.cc:3957:	defNoWrapPackage(ClPackage,"debugLogOn",&prim_debugLogOn,this[01;31m-[00m>lisp());
lisp.cc:3958:	defNoWrapPackage(ClPackage,"debugLogOff",&prim_debugLogOff,this[01;31m-[00m>lisp());
lisp.cc:3959:	defNoWrapPackage(ClPackage,"dumpClasses",&prim_dumpClasses,this[01;31m-[00m>lisp());
lisp.cc:3962:	defNoWrapPackage(ClPackage,"mpiEnabled",&prim_mpiEnabled,this[01;31m-[00m>lisp());
lisp.cc:3963:	defNoWrapPackage(ClPackage,"mpiRank",&prim_mpiRank,this[01;31m-[00m>lisp());
lisp.cc:3964:	defNoWrapPackage(ClPackage,"mpiSize",&prim_mpiSize,this[01;31m-[00m>lisp());
lisp.cc:3968:	defNoWrapPackage(MbbPackage,"atomAliases", &prim_list ,this[01;31m-[00m>lisp());
lisp.cc:3969:	defNoWrapPackage(MbbPackage,"aliasAtoms", &prim_list ,this[01;31m-[00m>lisp());
lisp.cc:3970:	defNoWrapPackage(MbbPackage,"addPart", &prim_list ,this[01;31m-[00m>lisp());
lisp.cc:3971:	defNoWrapPackage(MbbPackage,"parts", &prim_list ,this[01;31m-[00m>lisp());
lisp.cc:3972:	defNoWrapPackage(MbbPackage,"monomerAlias", &prim_list ,this[01;31m-[00m>lisp());
lisp.cc:3973:	defNoWrapPackage(ClPackage,"comparer", &prim_list ,this[01;31m-[00m>lisp());
lisp.cc:3974:	defNoWrapPackage(ClPackage,"sorted", &prim_sorted ,this[01;31m-[00m>lisp());
lisp.cc:3975:	defNoWrapPackage(ClPackage,"sort", &prim_sort,this[01;31m-[00m>lisp());
lisp.cc:3976:	defNoWrapPackage(ClPackage,"macroexpand[01;31m-[00m1", &prim_macroExpandMinus1,this[01;31m-[00m>lisp());
lisp.cc:3977:	defNoWrapPackage(ClPackage,"macroexpand", &prim_macroExpand,this[01;31m-[00m>lisp());
lisp.cc:3980:	defNoWrapPackage(ClPackage,"databaseDir", &prim_databaseDir,this[01;31m-[00m>lisp());
lisp.cc:3981:	defNoWrapPackage(ClPackage,"dumpHidden", &prim_dumpHidden,this[01;31m-[00m>lisp());
lisp.cc:3982:	defNoWrapPackage(ClPackage,"dumpEnvironment", &prim_dumpEnvironment,this[01;31m-[00m>lisp());
lisp.cc:3983:	defNoWrapPackage(ClPackage,"gensym", &prim_gensym,this[01;31m-[00m>lisp());
lisp.cc:3985:	this[01;31m-[00m>lisp()[01;31m-[00m>defineMacro(this[01;31m-[00m>lisp()[01;31m-[00m>intern(ClPackage,"inPackage"), &macro_inPackage );
lisp.cc:3986:	this[01;31m-[00m>lisp()[01;31m-[00m>defineMacro(this[01;31m-[00m>lisp()[01;31m-[00m>intern(ClPackage,"in[01;31m-[00mpackage"), &macro_inPackage );
lisp.cc:3988:	setupCandoPrimitives(this[01;31m-[00m>lisp());
lisp.cc:4020:    this[01;31m-[00m>_Lisp = O_Lisp::createLispEnvironment(mpiEnabled,mpiRank,mpiSize);
lisp.cc:4028:    RPLisp _lisp = this[01;31m-[00m>_Lisp;
lisp.cc:4040:    bundle[01;31m-[00m>initialize(argv0,cwd,appPathEnvironmentVariable);
lisp.cc:4041:    this[01;31m-[00m>_Lisp[01;31m-[00m>startupLispEnvironment(bundle);
lisp.cc:4042:    if (_lisp[01;31m-[00m>mpiEnabled() )
lisp.cc:4045:	ss << "P"<<_lisp[01;31m-[00m>mpiRank()<<":";
lisp.cc:4048:    _lisp[01;31m-[00m>parseCommandLineArguments(argc,argv,true);
lisp.cc:4056:    this[01;31m-[00m>_Lisp[01;31m-[00m>shutdownLispEnvironment();
lispCallback.cc:22:    class_<O_LispCallback>(e[01;31m-[00m>lisp())
lispCallback.cc:41:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
lispCallback.cc:42:    this[01;31m-[00m>_WeakEnvironment = env;
lispCallback.cc:43:    if ( kargs[01;31m-[00m>numberOfPositionalArguments() != 1 )
lispCallback.cc:45:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide one argument [01;31m-[00m an executable"));
lispCallback.cc:47:    this[01;31m-[00m>_Executable = kargs[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Executable>();
lispCallback.cc:52:    this[01;31m-[00m>Base::initialize();
lispCallback.cc:53:    this[01;31m-[00m>_WeakEnvironment.reset();
lispCallback.cc:54:    this[01;31m-[00m>_Executable = O_Executable::nil(this[01;31m-[00m>lisp());
lispCallback.cc:59:    this[01;31m-[00m>Base::archiveBase(node);
lispCallback.cc:65:{_F(this[01;31m-[00m>lisp());
lispCallback.cc:66:    ASSERT_NOT_NULL(this[01;31m-[00m>_Executable);
lispCallback.cc:67:    if ( this[01;31m-[00m>_Executable[01;31m-[00m>isNil() ) return O_Object::nil(this[01;31m-[00m>lisp());
lispCallback.cc:68:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakEnvironment);
lispCallback.cc:69:    RPLisp lisp = this[01;31m-[00m>_WeakEnvironment.lock();
lispCallback.cc:70:    ASSERT(lisp[01;31m-[00m>notNil());
lispCallback.cc:71:    return this[01;31m-[00m>_Executable[01;31m-[00m>evaluate(args,lisp[01;31m-[00m>nil<O_Environment>(),lisp);
lispCallback.cc:75:{_F(this[01;31m-[00m>lisp());
lispCallback.cc:76:    ASSERT_NOT_NULL(this[01;31m-[00m>_Executable);
lispCallback.cc:77:    if ( this[01;31m-[00m>_Executable[01;31m-[00m>isNil() ) return O_Object::nil(this[01;31m-[00m>lisp());
lispCallback.cc:78:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakEnvironment);
lispCallback.cc:79:    RPLisp lisp = this[01;31m-[00m>_WeakEnvironment.lock();
lispCallback.cc:80:    ASSERT(lisp[01;31m-[00m>notNil());
lispCallback.cc:81:    RPCons args = O_Cons::create(arg1,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
lispCallback.cc:82:    return this[01;31m-[00m>_Executable[01;31m-[00m>evaluate(args,lisp[01;31m-[00m>nil<O_Environment>(),lisp);
lispCallback.cc:86:{_F(this[01;31m-[00m>lisp());
lispCallback.cc:87:    ASSERT_NOT_NULL(this[01;31m-[00m>_Executable);
lispCallback.cc:88:    if ( this[01;31m-[00m>_Executable[01;31m-[00m>isNil() ) return O_Object::nil(this[01;31m-[00m>lisp());
lispCallback.cc:89:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakEnvironment);
lispCallback.cc:90:    RPLisp lisp = this[01;31m-[00m>_WeakEnvironment.lock();
lispCallback.cc:91:    ASSERT(lisp[01;31m-[00m>notNil());
lispCallback.cc:92:    RPCons args = O_Cons::createList(arg1,arg2,this[01;31m-[00m>lisp());
lispCallback.cc:93:    return this[01;31m-[00m>_Executable[01;31m-[00m>evaluate(args,lisp[01;31m-[00m>nil<O_Environment>(),lisp);
lispCallback.cc:97:{_F(this[01;31m-[00m>lisp());
lispCallback.cc:98:    ASSERT_NOT_NULL(this[01;31m-[00m>_Executable);
lispCallback.cc:99:    if ( this[01;31m-[00m>_Executable[01;31m-[00m>isNil() ) return O_Object::nil(this[01;31m-[00m>lisp());
lispCallback.cc:100:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakEnvironment);
lispCallback.cc:101:    RPLisp lisp = this[01;31m-[00m>_WeakEnvironment.lock();
lispCallback.cc:102:    ASSERT(lisp[01;31m-[00m>notNil());
lispCallback.cc:103:    RPCons args = O_Cons::createList(arg1,arg2,arg3,this[01;31m-[00m>lisp());
lispCallback.cc:104:    return this[01;31m-[00m>_Executable[01;31m-[00m>evaluate(args,lisp[01;31m-[00m>nil<O_Environment>(),lisp);
lispStream.cc:18:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
lispStream.cc:19:    this[01;31m-[00m>_FileName = kargs[01;31m-[00m>getStringAndRemove("fileName");
lispStream.cc:20:    this[01;31m-[00m>_Stream.open(this[01;31m-[00m>_FileName.c_str());
lispStream.cc:26:    this[01;31m-[00m>Base::initialize();
lispStream.cc:32:    this[01;31m-[00m>_Stream << s;
lispStream.cc:37:    this[01;31m-[00m>_Stream << s << endl;
lispStream.cc:42:    this[01;31m-[00m>_Stream.close();
lispStream.cc:49:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
lispStream.cc:55:    this[01;31m-[00m>Base::initialize();
lispStream.cc:56:    this[01;31m-[00m>_Stream.str("");
lispStream.cc:61:    this[01;31m-[00m>_Stream.str("");
lispStream.cc:66:    this[01;31m-[00m>_Stream << s;
lispStream.cc:71:    this[01;31m-[00m>_Stream << s << endl;
lispStream.cc:76:    return this[01;31m-[00m>_Stream.str();
lispStream.cc:84:	class_<O_StreamBase>(this[01;31m-[00m>lisp())
lispStream.cc:100:	class_<O_OStream>(this[01;31m-[00m>lisp())
lispStream.cc:127:	class_<O_FileOutStream>(this[01;31m-[00m>lisp())
lispStream.cc:151:	class_<O_StringStream>(this[01;31m-[00m>lisp())
loop.cc:35:{_F(c[01;31m-[00m>lisp());
loop.cc:36:    LOG(BF("pushSubLoop: Starting a subloop over: %s") % c[01;31m-[00m>description().c_str()  ); // vp0(("pushSubLoop: Starting a subloop over: %s",c[01;31m-[00m>description().c_str() ));
loop.cc:37:    this[01;31m-[00m>curSubLoop++;
loop.cc:38:    this[01;31m-[00m>subLoopTop[this[01;31m-[00m>curSubLoop] = c;
loop.cc:39:    this[01;31m-[00m>subLoopIteratorCur[this[01;31m-[00m>curSubLoop] = c[01;31m-[00m>_contents.begin();
loop.cc:40:    this[01;31m-[00m>subLoopIteratorEnd[this[01;31m-[00m>curSubLoop] = c[01;31m-[00m>_contents.end();
loop.cc:41:    LOG(BF("pushSubLoop:  number of children count = %d") % c[01;31m-[00m>_contents.size()  ); // vp0(("pushSubLoop:  number of children count = %d",c[01;31m-[00m>_contents.size() ));
loop.cc:46:{_F(this[01;31m-[00m>top[01;31m-[00m>lisp());
loop.cc:47:    if ( !this[01;31m-[00m>done) {
loop.cc:49:        this[01;31m-[00m>advanceLoop();
loop.cc:50:	if ( this[01;31m-[00m>done )
loop.cc:80:    fFlags = aAtom[01;31m-[00m>getFlags();
loop.cc:81:    if ( (fFlags&this[01;31m-[00m>fVisibleFlagsOn)!=this[01;31m-[00m>fVisibleFlagsOn )
loop.cc:84:    if ( (fFlags|(~(this[01;31m-[00m>fVisibleFlagsOff)))!=(~(this[01;31m-[00m>fVisibleFlagsOff)) )
loop.cc:91:    if ( this[01;31m-[00m>fVisibilityFlags & TEMPINTUSED ) {
loop.cc:92:	if ( this[01;31m-[00m>fVisibilityFlags & TEMPINTINVISIBLE ) {
loop.cc:93:	    if ( aAtom[01;31m-[00m>getTempInt() == this[01;31m-[00m>iTempInt ) {
loop.cc:97:	    if ( aAtom[01;31m-[00m>getTempInt() != this[01;31m-[00m>iTempInt ) {
loop.cc:107:    if ( this[01;31m-[00m>aInvisibleAtom == aAtom ) return(false);
loop.cc:129:    if ( aAtom[01;31m-[00m>getSeenId() == this[01;31m-[00m>iSeenId ) {
loop.cc:137:    if ( this[01;31m-[00m>iMaxDistanceFromRoot >= 0 ) {
loop.cc:138:	if ( this[01;31m-[00m>iMaxDistanceFromRoot <
loop.cc:139:		this[01;31m-[00m>aCurSpan[01;31m-[00m>getBackCount()+1 ) {
loop.cc:143:    return(this[01;31m-[00m>bLoopAtomVisible( aAtom ));
loop.cc:160:    this[01;31m-[00m>loopTopGoal(cont,over);
loop.cc:166:    this[01;31m-[00m>iIndex0 = 0;
loop.cc:167:    this[01;31m-[00m>iIndex1 = 0;
loop.cc:168:    this[01;31m-[00m>iIndex2 = 0;
loop.cc:169:    this[01;31m-[00m>iIndex3 = 0;
loop.cc:170:    this[01;31m-[00m>_Impropers.clear();
loop.cc:171:    this[01;31m-[00m>_ImproperIndex = [01;31m-[00m1;
loop.cc:176:{_F(a[01;31m-[00m>lisp());
loop.cc:180:    this[01;31m-[00m>_Impropers.clear();
loop.cc:181:    blrest0 = a[01;31m-[00m>getBondList();
loop.cc:182:    if ( blrest0[01;31m-[00m>size() < 3 ) return;
loop.cc:183:    for ( bl1=blrest0[01;31m-[00m>begin(); bl1!=blrest0[01;31m-[00m>end(); bl1++ ) {
loop.cc:185:	accumulate1 = RP_Create<O_BondList>(a[01;31m-[00m>lisp());
loop.cc:186:	accumulate1[01;31m-[00m>append(*bl1);
loop.cc:188:	blrest1[01;31m-[00m>removeBond(*bl1);
loop.cc:189:	for ( bl2 = blrest1[01;31m-[00m>begin(); bl2!=blrest1[01;31m-[00m>end(); bl2++ ) {
loop.cc:192:	    accumulate2[01;31m-[00m>append(*bl2);
loop.cc:194:	    blrest2[01;31m-[00m>removeBond(*bl2);
loop.cc:195:	    for ( bl3=blrest2[01;31m-[00m>begin(); bl3!=blrest2[01;31m-[00m>end(); bl3++ ) {
loop.cc:198:		accumulate3[01;31m-[00m>append(*bl3);
loop.cc:199:		this[01;31m-[00m>_Impropers.push_back(accumulate3);
loop.cc:207:{_F(c[01;31m-[00m>lisp());
loop.cc:209:    if ( c[01;31m-[00m>isNil() ) {
loop.cc:210:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Attempt to loop over null object"));
loop.cc:213:    this[01;31m-[00m>goal = 	goal;
loop.cc:214:    this[01;31m-[00m>top = 	c;
loop.cc:215:    this[01;31m-[00m>initialized = false;
loop.cc:216:    this[01;31m-[00m>done	= 	false;
loop.cc:221:    this[01;31m-[00m>iTempInt = 0;
loop.cc:222:    this[01;31m-[00m>curSubLoop = [01;31m-[00m1;
loop.cc:223:    this[01;31m-[00m>clearAtomIndices();
loop.cc:224:    this[01;31m-[00m>fVisibilityFlags = 0;
loop.cc:229:        LOG(BF("Loop::loopTopGoal pushing subloop object=%s") % c[01;31m-[00m>description().c_str()  ); // vp0(("Loop::loopTopGoal pushing subloop object=%s",c[01;31m-[00m>description().c_str() ));
loop.cc:230:	this[01;31m-[00m>pushSubLoop( c );
loop.cc:237: * and put it in the atom array this[01;31m-[00m>atoms[] and return true
loop.cc:241:{_F(this[01;31m-[00m>top[01;31m-[00m>lisp());
loop.cc:252:    top = downcast<O_Atom>(this[01;31m-[00m>getCurSubLoopTop());
loop.cc:253:    allowDuplicates = ( (this[01;31m-[00m>goal&ALLOWDUPLICATES) != 0 );
loop.cc:254:    LOG(BF("Loop::nextObjectInAtom atom name: %s  address=0x%08x") % top[01;31m-[00m>getName().c_str() % top.get() ); // vp0(( "Loop::nextObjectInAtom atom name: %s  address=0x%08x", top[01;31m-[00m>getName().c_str(), top.get()));
loop.cc:255:    switch ( this[01;31m-[00m>goal&GOALONLY ) {
loop.cc:268:	    while ( this[01;31m-[00m>iIndex0 < top[01;31m-[00m>coordination() ) {
loop.cc:272:		ASSERT(this[01;31m-[00m>iIndex0<top[01;31m-[00m>numberOfBonds());
loop.cc:273:		bondedTo = top[01;31m-[00m>bondedNeighbor(this[01;31m-[00m>iIndex0);
loop.cc:279:		    this[01;31m-[00m>atoms[0] = top;
loop.cc:281:		    this[01;31m-[00m>atoms[1] = top[01;31m-[00m>bondedNeighbor(this[01;31m-[00m>iIndex0);
loop.cc:283:		    this[01;31m-[00m>bondOrder = top[01;31m-[00m>bondedOrder(this[01;31m-[00m>iIndex0);
loop.cc:285:		    this[01;31m-[00m>iIndex0++;
loop.cc:290:		this[01;31m-[00m>iIndex0++;
loop.cc:309:		if ( this[01;31m-[00m>iIndex0>=top[01;31m-[00m>coordination() ) goto ANONE;
loop.cc:310:		aAtom1 = top[01;31m-[00m>bondedNeighbor( this[01;31m-[00m>iIndex0 );
loop.cc:311:		if ( this[01;31m-[00m>iIndex1>=aAtom1[01;31m-[00m>coordination() ) goto AINC1;
loop.cc:312:		aAtom2 = aAtom1[01;31m-[00m>bondedNeighbor( this[01;31m-[00m>iIndex1 );
loop.cc:318:		if ( !top[01;31m-[00m>atLowerAddressThan(aAtom2) && !allowDuplicates )
loop.cc:330:		this[01;31m-[00m>iIndex1++;
loop.cc:331:		if ( this[01;31m-[00m>iIndex1 >= aAtom1[01;31m-[00m>coordination() ) {
loop.cc:333:		    this[01;31m-[00m>iIndex0++;
loop.cc:334:		    this[01;31m-[00m>iIndex1 = 0;
loop.cc:338:	    this[01;31m-[00m>atoms[0] = top;
loop.cc:339:	    this[01;31m-[00m>atoms[1] = aAtom1;
loop.cc:340:	    this[01;31m-[00m>atoms[2] = aAtom2;
loop.cc:368:		if ( this[01;31m-[00m>iIndex0>=top[01;31m-[00m>coordination() ) goto TNONE;
loop.cc:369:                aAtom1 = top[01;31m-[00m>bondedNeighbor(this[01;31m-[00m>iIndex0);
loop.cc:370:		if ( this[01;31m-[00m>iIndex1>=aAtom1[01;31m-[00m>coordination() ) goto TINC1;
loop.cc:371:		aAtom2 = aAtom1[01;31m-[00m>bondedNeighbor( this[01;31m-[00m>iIndex1 );
loop.cc:372:		if ( this[01;31m-[00m>iIndex2>=aAtom2[01;31m-[00m>coordination() ) goto TINC2;
loop.cc:373:		aAtom3 = aAtom2[01;31m-[00m>bondedNeighbor( this[01;31m-[00m>iIndex2 );
loop.cc:375:		if ( !top[01;31m-[00m>atLowerAddressThan(aAtom3) && !allowDuplicates )  goto TINC2;
loop.cc:385:		this[01;31m-[00m>iIndex2++;
loop.cc:386:		if ( this[01;31m-[00m>iIndex2 >= aAtom2[01;31m-[00m>coordination() ) {
loop.cc:388:		    this[01;31m-[00m>iIndex1++;
loop.cc:389:		    this[01;31m-[00m>iIndex2 = 0;
loop.cc:390:		    if ( this[01;31m-[00m>iIndex1 >= aAtom1[01;31m-[00m>coordination() ) {
loop.cc:392:			this[01;31m-[00m>iIndex0++;
loop.cc:393:			this[01;31m-[00m>iIndex1 = 0;
loop.cc:398:	    this[01;31m-[00m>atoms[0] = top;
loop.cc:399:	    this[01;31m-[00m>atoms[1] = aAtom1;
loop.cc:400:	    this[01;31m-[00m>atoms[2] = aAtom2;
loop.cc:401:	    this[01;31m-[00m>atoms[3] = aAtom3;
loop.cc:424:	    if ( this[01;31m-[00m>_Impropers.size() == 0 ) {
loop.cc:425:		this[01;31m-[00m>buildListOfImpropersCenteredOn(top);
loop.cc:426:		if ( this[01;31m-[00m>_Impropers.size() == 0 ) goto FAIL;
loop.cc:427:		this[01;31m-[00m>_ImproperIndex = 0;
loop.cc:429:	    if ( this[01;31m-[00m>_ImproperIndex < this[01;31m-[00m>_Impropers.size() ) {
loop.cc:431:		this[01;31m-[00m>atoms[2] = top;
loop.cc:432:		bl = this[01;31m-[00m>_Impropers[this[01;31m-[00m>_ImproperIndex];
loop.cc:433:		this[01;31m-[00m>atoms[3] = bl[01;31m-[00m>atIndex(0)[01;31m-[00m>getTo().lock();
loop.cc:434:		this[01;31m-[00m>atoms[0] = bl[01;31m-[00m>atIndex(1)[01;31m-[00m>getTo().lock();
loop.cc:435:		this[01;31m-[00m>atoms[1] = bl[01;31m-[00m>atIndex(2)[01;31m-[00m>getTo().lock();
loop.cc:436:		this[01;31m-[00m>_ImproperIndex++;
loop.cc:442:	    if ( this[01;31m-[00m>iIndex1 <= this[01;31m-[00m>iIndex0 )
loop.cc:443:			    this[01;31m-[00m>iIndex1 = this[01;31m-[00m>iIndex0+1;
loop.cc:444:	    if ( this[01;31m-[00m>iIndex2 <= this[01;31m-[00m>iIndex1 )
loop.cc:445:			    this[01;31m-[00m>iIndex2 = this[01;31m-[00m>iIndex1+1;
loop.cc:446:	    else this[01;31m-[00m>iIndex2++;
loop.cc:447:	    if ( this[01;31m-[00m>iIndex2 >= top[01;31m-[00m>coordination() ) {
loop.cc:448:		this[01;31m-[00m>iIndex1++;
loop.cc:449:		this[01;31m-[00m>iIndex2 = this[01;31m-[00m>iIndex1 + 1;
loop.cc:450:		if ( this[01;31m-[00m>iIndex2 >= top[01;31m-[00m>coordination()) {
loop.cc:451:		    this[01;31m-[00m>iIndex0++;
loop.cc:452:		    this[01;31m-[00m>iIndex1 = this[01;31m-[00m>iIndex0 + 1;
loop.cc:453:		    this[01;31m-[00m>iIndex2 = this[01;31m-[00m>iIndex1 + 1;
loop.cc:456:	    if ( this[01;31m-[00m>iIndex2 < (top[01;31m-[00m>coordination()) ) {
loop.cc:457:		this[01;31m-[00m>atoms[2] = top;
loop.cc:458:		this[01;31m-[00m>atoms[0] = top[01;31m-[00m>bondedNeighbor(this[01;31m-[00m>iIndex0);
loop.cc:459:		this[01;31m-[00m>atoms[1] = top[01;31m-[00m>bondedNeighbor(this[01;31m-[00m>iIndex1);
loop.cc:460:		this[01;31m-[00m>atoms[3] = top[01;31m-[00m>bondedNeighbor(this[01;31m-[00m>iIndex2);
loop.cc:468:    this[01;31m-[00m>clearAtomIndices();
loop.cc:481:{_F(this[01;31m-[00m>top[01;31m-[00m>lisp());
loop.cc:486:    goalOnly = this[01;31m-[00m>goal & GOALONLY;
loop.cc:497:	ANN(this[01;31m-[00m>getCurSubLoopTop());
loop.cc:498:	if ( (this[01;31m-[00m>getCurSubLoopTop()[01;31m-[00m>getMatterType()==ATOM_CLASS) &&
loop.cc:499:		    (this[01;31m-[00m>goal&NONCONTAINERLOOP)!=0 ){
loop.cc:501:	    if ( this[01;31m-[00m>nextObjectInAtom() ) {
loop.cc:503:		retVal = this[01;31m-[00m>getCurSubLoopTop();
loop.cc:510:	    LOG(BF("this[01;31m-[00m>curSubLoop=%d") % this[01;31m-[00m>curSubLoop  ); // vp0(( "this[01;31m-[00m>curSubLoop=%d", this[01;31m-[00m>curSubLoop ));
loop.cc:514:	    hitEnd = this[01;31m-[00m>curSubLoopIteratorDone();
loop.cc:518:	        retVal = this[01;31m-[00m>getCurSubLoopIteratorCur();
loop.cc:519:		LOG(BF("getCurSubLoopIteratorCur = %s") % retVal[01;31m-[00m>description().c_str()  ); // vp0(("getCurSubLoopIteratorCur = %s",retVal[01;31m-[00m>description().c_str() ));
loop.cc:520:		this[01;31m-[00m>curSubLoopAdvanceIteratorCur();
loop.cc:531:	    this[01;31m-[00m>popSubLoop();
loop.cc:533:	    if ( this[01;31m-[00m>noSubLoops() ) {
loop.cc:535:		retVal = O_Matter::nil(this[01;31m-[00m>top[01;31m-[00m>lisp());
loop.cc:536:		this[01;31m-[00m>done = true;
loop.cc:547:	LOG(BF("retVal[01;31m-[00m>getMatterType() = %d") % retVal[01;31m-[00m>getMatterType()  ); // vp0(("retVal[01;31m-[00m>getMatterType() = %d",retVal[01;31m-[00m>getMatterType() ));
loop.cc:548:	if ( goalOnly == retVal[01;31m-[00m>getMatterType() ) {
loop.cc:549:    	    LOG(BF("goalOnly == retVal[01;31m-[00m>getMatterType() ") ); // vp0(("goalOnly == retVal[01;31m-[00m>getMatterType() "));
loop.cc:553:		if ( retVal[01;31m-[00m>getMatterType()!=ATOM_CLASS ) 
loop.cc:555:    		    LOG(BF("retVal[01;31m-[00m>getMatterType() !=ATOM_CLASS") ); // vp0(("retVal[01;31m-[00m>getMatterType() !=ATOM_CLASS"));
loop.cc:556:		    this[01;31m-[00m>pushSubLoop(retVal);
loop.cc:560:	    if ( retVal[01;31m-[00m>getMatterType() == ATOM_CLASS ) {
loop.cc:571:	this[01;31m-[00m>pushSubLoop(retVal);
loop.cc:582:// At the end of this function either this[01;31m-[00m>currentObject is the next object
loop.cc:583:// or this[01;31m-[00m>done == true, in which case this[01;31m-[00m>currentObject is invalid.
loop.cc:586:{_F(this[01;31m-[00m>top[01;31m-[00m>lisp());
loop.cc:591:    if ( this[01;31m-[00m>done ) {
loop.cc:597:    goalOnly = this[01;31m-[00m>goal & GOALONLY;
loop.cc:600:    retVal = this[01;31m-[00m>nextHierarchyMatter();
loop.cc:602:    this[01;31m-[00m>currentObject = retVal;
loop.cc:605:    if ( retVal[01;31m-[00m>notNil() )
loop.cc:607:        LOG(BF("Loop::next returning with object: %s") % retVal[01;31m-[00m>description().c_str()  ); // vp0(( "Loop::next returning with object: %s", retVal[01;31m-[00m>description().c_str() ));
macro.cc:21:    this[01;31m-[00m>_Name = name;
macro.cc:32:    return this[01;31m-[00m>_Macro.invoke(e,args,lisp);
macro.cc:64:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
macro.cc:75:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
macroModel.cc:66:    this[01;31m-[00m>file = fopen(fn.c_str(),"r");
macroModel.cc:67:    fgets( caLine, sizeof(caLine), this[01;31m-[00m>file );
macroModel.cc:69:    this[01;31m-[00m>lines = iAtoms;
macroModel.cc:82:    this[01;31m-[00m>file = fopen(fn.c_str(),"w");
macroModel.cc:93:    if ( this[01;31m-[00m>file ) {
macroModel.cc:94:        return feof(this[01;31m-[00m>file);
macroModel.cc:106:    fclose(this[01;31m-[00m>file);
macroModel.cc:107:    this[01;31m-[00m>file = NULL;
macroModel.cc:189://    I5 NIATMS (INTEGER*4) [01;31m-[00m The number of atoms in the entry
macroModel.cc:190://    A70 (CHARACTER*70) [01;31m-[00m The text name of the entry (optional)
macroModel.cc:206://    F11.6 (REAL*4) [01;31m-[00m X[01;31m-[00mcoordinate in Angstroms.
macroModel.cc:207://    F11.6 (REAL*4) [01;31m-[00m Y[01;31m-[00mcoordinate in Angstroms.
macroModel.cc:208://    F11.6 (REAL*4) [01;31m-[00m Z[01;31m-[00mcoordinate in Angstroms.
macroModel.cc:209://    I5 (INTEGER*4) [01;31m-[00m Optional residue number (used only with biopolymers).
macroModel.cc:210://    A1 (CHARACTER*1) [01;31m-[00m Optional single[01;31m-[00mcharacter MacroModel residue
macroModel.cc:212://    A1 (CHARACTER*1) [01;31m-[00m Optional single[01;31m-[00mcharacter residue chain name.
macroModel.cc:213://    I4 (INTEGER*4) [01;31m-[00m Optional atom color (see below). If no color
macroModel.cc:215://		atom type[01;31m-[00mbased color.
macroModel.cc:216://    2F9.5 (REAL*4) [01;31m-[00m Optional atomic charge in electron units (BatchMin
macroModel.cc:221://    A4 (CHARACTER*4) [01;31m-[00m Optional ascii residue name (e.g. PDB residue name)
macroModel.cc:222://    A4 (CHARACTER*4) [01;31m-[00m Optional ascii atom name (e.g. PDB atom name)
macroModel.cc:225:    iAtoms = this[01;31m-[00m>lines;
macroModel.cc:227:	fgets( caLine, sizeof(caLine), this[01;31m-[00m>file );
macroModel.cc:357:    mol = env[01;31m-[00m>create<O_Molecule>();
macroModel.cc:364:	    res = env[01;31m-[00m>create<O_Residue>();
macroModel.cc:366:	    res[01;31m-[00m>setName(sTemp);
macroModel.cc:368:	    mol[01;31m-[00m>addMatter(res);
macroModel.cc:380:	aPAtom = env[01;31m-[00m>create<O_Atom>();
macroModel.cc:388:	res[01;31m-[00m>addAtom(aPAtom);
macroModel.cc:393:	aPAtom[01;31m-[00m>setName(sTemp);
macroModel.cc:394:	aPAtom[01;31m-[00m>setTypeString(mmodToAmberTypes[atoms[i].iType]);
macroModel.cc:395:	aPAtom[01;31m-[00m>setElementFromString(mmodToAmberElement[atoms[i].iType]);
macroModel.cc:397:	aPAtom[01;31m-[00m>setPosition(vPos);
macroModel.cc:398:        aPAtom[01;31m-[00m>setCharge(atoms[i].dCharge );
macroModel.cc:410:		    aPTo = atoms[iTo[01;31m-[00m1].atom;
macroModel.cc:411:		    if ( aPAtom[01;31m-[00m>atLowerAddressThan(aPTo) )
macroModel.cc:413:			aPAtom[01;31m-[00m>bondTo(aPTo,iOrder);
macroModel.cc:423:    fgets( caLine, sizeof(caLine), this[01;31m-[00m>file );
macroModel.cc:425:    this[01;31m-[00m>lines = iAtoms;
mainBoostPython.cc:37:		if ( cDest[01;31m-[00mcDestArray > destSize[01;31m-[00m3 ) {
mainBoostPython.cc:38:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("cPrint OVERFLOW"));
mainBoostPython.cc:45:		if ( cDest[01;31m-[00mcDestArray > destSize[01;31m-[00m3 ) {
mainBoostPython.cc:46:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("cPrint OVERFLOW"));
mainBoostPython.cc:53:		if ( cDest[01;31m-[00mcDestArray > destSize[01;31m-[00m4 ) {
mainBoostPython.cc:54:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("cPrint OVERFLOW"));
mainBoostPython.cc:62:		if ( cDest[01;31m-[00mcDestArray > destSize[01;31m-[00m5 ) {
mainBoostPython.cc:63:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("cPrint OVERFLOW"));
mainBoostPython.cc:72:		if ( cDest[01;31m-[00mcDestArray > destSize[01;31m-[00m4 ) {
mainBoostPython.cc:73:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("cPrint OVERFLOW"));
mainBoostPython.cc:173:    debugLog().write(obj[01;31m-[00m>asXmlStringWrap(nodeName,ss.str()));
mainBoostPython.cc:184:	_BoostPythonLispObject = O_Lisp::create(this[01;31m-[00m>lisp());
matrix.cc:87:		a[a.index(i,j)]=g[01;31m-[00ms*(h+g*tau);			\
matrix.cc:88:		a[a.index(k,l)]=h+s*(g[01;31m-[00mh*tau);			\
matrix.cc:110:	for (ip=0;ip<n[01;31m-[00m1;ip++) { // Sum o[01;31m-[00mdiagonal elements.
matrix.cc:124:	for (ip=0;ip<n[01;31m-[00m1;ip++) {
matrix.cc:128:				// if the o[01;31m-[00mdiagonal element is small.
matrix.cc:134:		    h = d[iq][01;31m-[00md[ip];
matrix.cc:140:			if (theta < 0.0) t = [01;31m-[00mt;
matrix.cc:146:		    z[ip] [01;31m-[00m= h;
matrix.cc:148:		    d[ip] [01;31m-[00m= h;
matrix.cc:151:		    for (j=0;j<=ip[01;31m-[00m1;j++) { // Case of rotations 1 <= j < p.
matrix.cc:154:		    for (j=ip+1;j<=iq[01;31m-[00m1;j++) { // Case of rotations p < j < q.
matrix.cc:195:    this[01;31m-[00m>identity();
matrix.cc:204:    Matrix::iterator mi = this[01;31m-[00m>elements.begin();
matrix.cc:229:    Matrix::iterator mi = this[01;31m-[00m>elements.begin();
matrix.cc:255:    vd.reserve(this[01;31m-[00m>elements.size());
matrix.cc:258:    el = this[01;31m-[00m>elements.begin();
matrix.cc:259:    for ( uint zz = 0; zz < this[01;31m-[00m>elements.size(); zz++ )
matrix.cc:273:    vd.reserve(this[01;31m-[00m>elements.size());
matrix.cc:280:	    *it++ = this[01;31m-[00m>elements[this[01;31m-[00m>index(c,r)];
matrix.cc:290:    this[01;31m-[00m>elements = m.elements;
matrix.cc:304:		res.atRowColAdd( r, c, this[01;31m-[00m>atRowCol(r,x)*m.atRowCol(x,c) );
matrix.cc:314:		acc += this[01;31m-[00m>elements[this[01;31m-[00m>index(r,x)]*m.elements[this[01;31m-[00m>index(x,c)];
matrix.cc:316:	    res.elements[this[01;31m-[00m>index(r,c)] = acc;
matrix.cc:332:	    res.atRowColPut(r,c,this[01;31m-[00m>atRowCol(r,c)+m.atRowCol(r,c));
matrix.cc:338:Matrix Matrix::operator[01;31m-[00m( const Matrix& m)
matrix.cc:345:	    res.atRowColPut(r,c,this[01;31m-[00m>atRowCol(r,c)[01;31m-[00mm.atRowCol(r,c));
matrix.cc:368:	    res[r] += this[01;31m-[00m>atRowCol(r,c)*vv[c];
matrix.cc:383:	    res.atRowColPut(r,c,this[01;31m-[00m>atRowCol(r,c)*m);
matrix.cc:399:	        res.atRowColPut(r,c,(this[01;31m-[00m>atRowCol(c,r)));
matrix.cc:412:    this[01;31m-[00m>identity();
matrix.cc:413:    this[01;31m-[00m>atRowColPut(0,3,v[01;31m-[00m>getX());
matrix.cc:414:    this[01;31m-[00m>atRowColPut(1,3,v[01;31m-[00m>getY());
matrix.cc:415:    this[01;31m-[00m>atRowColPut(2,3,v[01;31m-[00m>getZ());
matrix.cc:416:    this[01;31m-[00m>atRowColPut(3,3,1.0);
matrix.cc:422:    v.set( this[01;31m-[00m>atRowCol(0,3), this[01;31m-[00m>atRowCol(1,3), this[01;31m-[00m>atRowCol(2,3) );
matrix.cc:433:	    printf( "%8.4lf ", this[01;31m-[00m>atRowCol(r,c) );
matrix.cc:444:	    out << prefix << this[01;31m-[00m>atRowCol(r,c) << endl;
matrix.cc:455:	    out << this[01;31m-[00m>atRowCol(r,c) << " ";
matrix.cc:470:	    this[01;31m-[00m>atRowColPut(r,c,vd[i]);
matrix.cc:486:	    this[01;31m-[00m>atRowColPut(r,c,vals[i]); i++;
matrix.cc:495:    return this[01;31m-[00m>elements[0]
matrix.cc:496:    		+this[01;31m-[00m>elements[this[01;31m-[00m>index(1,1)]
matrix.cc:497:    		+this[01;31m-[00m>elements[this[01;31m-[00m>index(2,2)]
matrix.cc:498:    		+this[01;31m-[00m>elements[this[01;31m-[00m>index(3,3)];
matrix.cc:521:	    _lisp[01;31m-[00m>print(BF("first!=last  v.size() = %d") % v.size());
matrix.cc:541:	 return (abs_n >= 1e5 || abs_n < 1e[01;31m-[00m5)
matrix.cc:572:            space,                          // the delimiter[01;31m-[00mgenerator
matrix.cc:583:    vector<double>	v(this[01;31m-[00m>elements.begin(),this[01;31m-[00m>elements.end());
matrix.cc:605:	    val = this[01;31m-[00m>atRowCol(r,c);
matrix.cc:612:	    } else if ( val == [01;31m-[00m1.0 )
matrix.cc:614:		strcpy(cstr,"[01;31m-[00m1");
matrix.cc:656:	serr << "[01;31m-[00m[01;31m-[00m[01;31m-[00mdone dump";
matrix.cc:657:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
matrix.cc:663:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("Too many numbers |"+str+"|"));
matrix.cc:668:    this[01;31m-[00m>setFromDoubleArray(16,vals);
matrix.cc:676:    for ( uint zz=0; zz<this[01;31m-[00m>elements.size(); zz++ )
matrix.cc:678:	this[01;31m-[00m>elements[zz] = val;
matrix.cc:686:    this[01;31m-[00m>elements[this[01;31m-[00m>index(0,0)] = q.getZ();
matrix.cc:687:    this[01;31m-[00m>elements[this[01;31m-[00m>index(0,1)] = [01;31m-[00mq.getY();
matrix.cc:688:    this[01;31m-[00m>elements[this[01;31m-[00m>index(0,2)] = q.getX();
matrix.cc:689:    this[01;31m-[00m>elements[this[01;31m-[00m>index(0,3)] = q.getW();
matrix.cc:690:    this[01;31m-[00m>elements[this[01;31m-[00m>index(1,0)] = q.getY();
matrix.cc:691:    this[01;31m-[00m>elements[this[01;31m-[00m>index(1,1)] = q.getZ();
matrix.cc:692:    this[01;31m-[00m>elements[this[01;31m-[00m>index(1,2)] = [01;31m-[00mq.getW();
matrix.cc:693:    this[01;31m-[00m>elements[this[01;31m-[00m>index(1,3)] = q.getX();
matrix.cc:694:    this[01;31m-[00m>elements[this[01;31m-[00m>index(2,0)] = [01;31m-[00mq.getX();
matrix.cc:695:    this[01;31m-[00m>elements[this[01;31m-[00m>index(2,1)] = q.getW();
matrix.cc:696:    this[01;31m-[00m>elements[this[01;31m-[00m>index(2,2)] = q.getZ();
matrix.cc:697:    this[01;31m-[00m>elements[this[01;31m-[00m>index(2,3)] = q.getY();
matrix.cc:698:    this[01;31m-[00m>elements[this[01;31m-[00m>index(3,0)] = [01;31m-[00mq.getW();
matrix.cc:699:    this[01;31m-[00m>elements[this[01;31m-[00m>index(3,1)] = [01;31m-[00mq.getX();
matrix.cc:700:    this[01;31m-[00m>elements[this[01;31m-[00m>index(3,2)] = [01;31m-[00mq.getY();
matrix.cc:701:    this[01;31m-[00m>elements[this[01;31m-[00m>index(3,3)] = q.getZ();
matrix.cc:720:    this[01;31m-[00m>setFromDoubleVector(vs);
matrix.cc:771:    double x = v[01;31m-[00m>getX();
matrix.cc:772:    double y = v[01;31m-[00m>getY();
matrix.cc:773:    double z = v[01;31m-[00m>getZ();
matrix.cc:776:    this[01;31m-[00m>atRowColPut( 0, 0, 1.0 + (1.0[01;31m-[00mcos(a))*(x*x[01;31m-[00m1.0) );
matrix.cc:777:    this[01;31m-[00m>atRowColPut( 0, 1, [01;31m-[00mz*sin(a)+(1.0[01;31m-[00mcos(a))*x*y );
matrix.cc:778:    this[01;31m-[00m>atRowColPut( 0, 2, y*sin(a)+(1.0[01;31m-[00mcos(a))*x*z );
matrix.cc:779:    this[01;31m-[00m>atRowColPut( 0, 3,	0.0	);
matrix.cc:781:    this[01;31m-[00m>atRowColPut( 1, 0, z*sin(a)+(1.0[01;31m-[00mcos(a))*x*y );
matrix.cc:782:    this[01;31m-[00m>atRowColPut( 1, 1, 1.0 + (1.0[01;31m-[00mcos(a))*(y*y[01;31m-[00m1.0) );
matrix.cc:783:    this[01;31m-[00m>atRowColPut( 1, 2, [01;31m-[00mx*sin(a)+(1.0[01;31m-[00mcos(a))*y*z );
matrix.cc:784:    this[01;31m-[00m>atRowColPut( 1, 3,	0.0	);
matrix.cc:786:    this[01;31m-[00m>atRowColPut( 2, 0, [01;31m-[00my*sin(a)+(1.0[01;31m-[00mcos(a))*x*z );
matrix.cc:787:    this[01;31m-[00m>atRowColPut( 2, 1, x*sin(a)+(1.0[01;31m-[00mcos(a))*y*z );
matrix.cc:788:    this[01;31m-[00m>atRowColPut( 2, 2, 1.0 + (1.0[01;31m-[00mcos(a))*(z*z[01;31m-[00m1.0) );
matrix.cc:789:    this[01;31m-[00m>atRowColPut( 2, 3,	0.0	);
matrix.cc:791:    this[01;31m-[00m>atRowColPut( 3, 0,	0.0	);
matrix.cc:792:    this[01;31m-[00m>atRowColPut( 3, 1,	0.0	);
matrix.cc:793:    this[01;31m-[00m>atRowColPut( 3, 2,	0.0	);
matrix.cc:794:    this[01;31m-[00m>atRowColPut( 3, 3,	1.0	);
matrix.cc:808:    this[01;31m-[00m>atRowColPut( 0, 0,	1.0	);
matrix.cc:809:    this[01;31m-[00m>atRowColPut( 0, 1,	0.0	);
matrix.cc:810:    this[01;31m-[00m>atRowColPut( 0, 2,	0.0	);
matrix.cc:811:    this[01;31m-[00m>atRowColPut( 0, 3,	0.0	);
matrix.cc:813:    this[01;31m-[00m>atRowColPut( 1, 0,	0.0	);
matrix.cc:814:    this[01;31m-[00m>atRowColPut( 1, 1,	cos(a)	);
matrix.cc:815:    this[01;31m-[00m>atRowColPut( 1, 2,	sin(a)	);
matrix.cc:816:    this[01;31m-[00m>atRowColPut( 1, 3,	0.0	);
matrix.cc:818:    this[01;31m-[00m>atRowColPut( 2, 0,	0.0	);
matrix.cc:819:    this[01;31m-[00m>atRowColPut( 2, 1,	[01;31m-[00msin(a)	);
matrix.cc:820:    this[01;31m-[00m>atRowColPut( 2, 2,	cos(a)	);
matrix.cc:821:    this[01;31m-[00m>atRowColPut( 2, 3,	0.0	);
matrix.cc:823:    this[01;31m-[00m>atRowColPut( 3, 0,	0.0	);
matrix.cc:824:    this[01;31m-[00m>atRowColPut( 3, 1,	0.0	);
matrix.cc:825:    this[01;31m-[00m>atRowColPut( 3, 2,	0.0	);
matrix.cc:826:    this[01;31m-[00m>atRowColPut( 3, 3,	1.0	);
matrix.cc:841:    this[01;31m-[00m>atRowColPut( 0, 0,	cos(a)	);
matrix.cc:842:    this[01;31m-[00m>atRowColPut( 0, 1,	0.0	);
matrix.cc:843:    this[01;31m-[00m>atRowColPut( 0, 2,	[01;31m-[00msin(a)	);
matrix.cc:844:    this[01;31m-[00m>atRowColPut( 0, 3,	0.0	);
matrix.cc:846:    this[01;31m-[00m>atRowColPut( 1, 0,	0.0	);
matrix.cc:847:    this[01;31m-[00m>atRowColPut( 1, 1,	1.0	);
matrix.cc:848:    this[01;31m-[00m>atRowColPut( 1, 2,	0.0	);
matrix.cc:849:    this[01;31m-[00m>atRowColPut( 1, 3,	0.0	);
matrix.cc:851:    this[01;31m-[00m>atRowColPut( 2, 0,	sin(a)	);
matrix.cc:852:    this[01;31m-[00m>atRowColPut( 2, 1,	0.0	);
matrix.cc:853:    this[01;31m-[00m>atRowColPut( 2, 2,	cos(a)	);
matrix.cc:854:    this[01;31m-[00m>atRowColPut( 2, 3,	0.0	);
matrix.cc:856:    this[01;31m-[00m>atRowColPut( 3, 0,	0.0	);
matrix.cc:857:    this[01;31m-[00m>atRowColPut( 3, 1,	0.0	);
matrix.cc:858:    this[01;31m-[00m>atRowColPut( 3, 2,	0.0	);
matrix.cc:859:    this[01;31m-[00m>atRowColPut( 3, 3,	1.0	);
matrix.cc:872:    this[01;31m-[00m>atRowColPut( 0, 0,	cos(a)	);
matrix.cc:873:    this[01;31m-[00m>atRowColPut( 0, 1,	sin(a)	);
matrix.cc:874:    this[01;31m-[00m>atRowColPut( 0, 2,	0.0	);
matrix.cc:875:    this[01;31m-[00m>atRowColPut( 0, 3,	0.0	);
matrix.cc:877:    this[01;31m-[00m>atRowColPut( 1, 0,	[01;31m-[00msin(a)	);
matrix.cc:878:    this[01;31m-[00m>atRowColPut( 1, 1,	cos(a)	);
matrix.cc:879:    this[01;31m-[00m>atRowColPut( 1, 2,	0.0	);
matrix.cc:880:    this[01;31m-[00m>atRowColPut( 1, 3,	0.0	);
matrix.cc:882:    this[01;31m-[00m>atRowColPut( 2, 0,	0.0	);
matrix.cc:883:    this[01;31m-[00m>atRowColPut( 2, 1,	0.0	);
matrix.cc:884:    this[01;31m-[00m>atRowColPut( 2, 2,	1.0	);
matrix.cc:885:    this[01;31m-[00m>atRowColPut( 2, 3,	0.0	);
matrix.cc:887:    this[01;31m-[00m>atRowColPut( 3, 0,	0.0	);
matrix.cc:888:    this[01;31m-[00m>atRowColPut( 3, 1,	0.0	);
matrix.cc:889:    this[01;31m-[00m>atRowColPut( 3, 2,	0.0	);
matrix.cc:890:    this[01;31m-[00m>atRowColPut( 3, 3,	1.0	);
matrix.cc:903:    this[01;31m-[00m>atRowColPut( 0, 0,	1.0	);
matrix.cc:904:    this[01;31m-[00m>atRowColPut( 0, 1,	0.0	);
matrix.cc:905:    this[01;31m-[00m>atRowColPut( 0, 2,	0.0	);
matrix.cc:906:    this[01;31m-[00m>atRowColPut( 0, 3,	0.0	);
matrix.cc:908:    this[01;31m-[00m>atRowColPut( 1, 0,	0.0	);
matrix.cc:909:    this[01;31m-[00m>atRowColPut( 1, 1,	cos([01;31m-[00ma)	);
matrix.cc:910:    this[01;31m-[00m>atRowColPut( 1, 2,	sin([01;31m-[00ma)	);
matrix.cc:911:    this[01;31m-[00m>atRowColPut( 1, 3,	0.0	);
matrix.cc:913:    this[01;31m-[00m>atRowColPut( 2, 0,	0.0	);
matrix.cc:914:    this[01;31m-[00m>atRowColPut( 2, 1,	[01;31m-[00msin([01;31m-[00ma));
matrix.cc:915:    this[01;31m-[00m>atRowColPut( 2, 2,	cos([01;31m-[00ma)	);
matrix.cc:916:    this[01;31m-[00m>atRowColPut( 2, 3,	0.0	);
matrix.cc:918:    this[01;31m-[00m>atRowColPut( 3, 0,	0.0	);
matrix.cc:919:    this[01;31m-[00m>atRowColPut( 3, 1,	0.0	);
matrix.cc:920:    this[01;31m-[00m>atRowColPut( 3, 2,	0.0	);
matrix.cc:921:    this[01;31m-[00m>atRowColPut( 3, 3,	1.0	);
matrix.cc:936:    this[01;31m-[00m>atRowColPut( 0, 0,	cos([01;31m-[00ma)	);
matrix.cc:937:    this[01;31m-[00m>atRowColPut( 0, 1,	0.0	);
matrix.cc:938:    this[01;31m-[00m>atRowColPut( 0, 2,	[01;31m-[00msin([01;31m-[00ma)	);
matrix.cc:939:    this[01;31m-[00m>atRowColPut( 0, 3,	0.0	);
matrix.cc:941:    this[01;31m-[00m>atRowColPut( 1, 0,	0.0	);
matrix.cc:942:    this[01;31m-[00m>atRowColPut( 1, 1,	1.0	);
matrix.cc:943:    this[01;31m-[00m>atRowColPut( 1, 2,	0.0	);
matrix.cc:944:    this[01;31m-[00m>atRowColPut( 1, 3,	0.0	);
matrix.cc:946:    this[01;31m-[00m>atRowColPut( 2, 0,	sin([01;31m-[00ma)	);
matrix.cc:947:    this[01;31m-[00m>atRowColPut( 2, 1,	0.0	);
matrix.cc:948:    this[01;31m-[00m>atRowColPut( 2, 2,	cos([01;31m-[00ma)	);
matrix.cc:949:    this[01;31m-[00m>atRowColPut( 2, 3,	0.0	);
matrix.cc:951:    this[01;31m-[00m>atRowColPut( 3, 0,	0.0	);
matrix.cc:952:    this[01;31m-[00m>atRowColPut( 3, 1,	0.0	);
matrix.cc:953:    this[01;31m-[00m>atRowColPut( 3, 2,	0.0	);
matrix.cc:954:    this[01;31m-[00m>atRowColPut( 3, 3,	1.0	);
matrix.cc:959:{_F(node[01;31m-[00m>lisp());
matrix.cc:960:    if ( node[01;31m-[00m>loading() )
matrix.cc:962:        const string& values = node[01;31m-[00m>characters();
matrix.cc:964:	this[01;31m-[00m>setFromString(values,node[01;31m-[00m>lisp());
matrix.cc:965:	LOG(BF("Set myself using that string and the result is: %s") % (this[01;31m-[00m>asString().c_str() ) ); // vp0(("Set myself using that string and the result is: %s",this[01;31m-[00m>asString().c_str() ));
matrix.cc:968:        string values = this[01;31m-[00m>asString();
matrix.cc:969:	node[01;31m-[00m>setCharacters(values);
matrix.cc:984:    this[01;31m-[00m>atRowColPut( 0, 0,	cos([01;31m-[00ma)	);
matrix.cc:985:    this[01;31m-[00m>atRowColPut( 0, 1,	sin([01;31m-[00ma)	);
matrix.cc:986:    this[01;31m-[00m>atRowColPut( 0, 2,	0.0	);
matrix.cc:987:    this[01;31m-[00m>atRowColPut( 0, 3,	0.0	);
matrix.cc:989:    this[01;31m-[00m>atRowColPut( 1, 0,	[01;31m-[00msin([01;31m-[00ma)	);
matrix.cc:990:    this[01;31m-[00m>atRowColPut( 1, 1,	cos([01;31m-[00ma)	);
matrix.cc:991:    this[01;31m-[00m>atRowColPut( 1, 2,	0.0	);
matrix.cc:992:    this[01;31m-[00m>atRowColPut( 1, 3,	0.0	);
matrix.cc:994:    this[01;31m-[00m>atRowColPut( 2, 0,	0.0	);
matrix.cc:995:    this[01;31m-[00m>atRowColPut( 2, 1,	0.0	);
matrix.cc:996:    this[01;31m-[00m>atRowColPut( 2, 2,	1.0	);
matrix.cc:997:    this[01;31m-[00m>atRowColPut( 2, 3,	0.0	);
matrix.cc:999:    this[01;31m-[00m>atRowColPut( 3, 0,	0.0	);
matrix.cc:1000:    this[01;31m-[00m>atRowColPut( 3, 1,	0.0	);
matrix.cc:1001:    this[01;31m-[00m>atRowColPut( 3, 2,	0.0	);
matrix.cc:1002:    this[01;31m-[00m>atRowColPut( 3, 3,	1.0	);
matrix.cc:1033:{_F(node[01;31m-[00m>lisp());
matrix.cc:1037:    if ( node[01;31m-[00m>loading() )
matrix.cc:1039:        this[01;31m-[00m>_Matrices.clear();
matrix.cc:1040:        const string& rawData = node[01;31m-[00m>characters();
matrix.cc:1045:	    this[01;31m-[00m>_Matrices.push_back(m);
matrix.cc:1050:        for ( i=0; i<this[01;31m-[00m>_Matrices.size(); i++ )
matrix.cc:1056:	    rawData << this[01;31m-[00m>_Matrices[i].asString();
matrix.cc:1058:	node[01;31m-[00m>setCharacters(rawData.str());
matrix.cc:1066:    HARD_ASSERT(i<this[01;31m-[00m>_Matrices.size());
matrix.cc:1067:    return this[01;31m-[00m>_Matrices[i];
matter.cc:43:    this[01;31m-[00m>Base::initialize();
matter.cc:44:    this[01;31m-[00m>_Id = 1; // UNDEFINED_ID;
matter.cc:45:    this[01;31m-[00m>_NextContentId = 1;
matter.cc:46:    this[01;31m-[00m>setContainedByNothing();
matter.cc:51:{_F(this[01;31m-[00m>lisp());
matter.cc:52:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
matter.cc:53:    this[01;31m-[00m>name = dict[01;31m-[00m>getStringAndRemoveOrDefault("name","");
matter.cc:59:    ss << this[01;31m-[00m>className();
matter.cc:70:    this[01;31m-[00m>_NextContentId = c._NextContentId;
matter.cc:71:    this[01;31m-[00m>_Id = c._Id;
matter.cc:72:    this[01;31m-[00m>name = c.name;
matter.cc:73:    this[01;31m-[00m>containerContainedBy = c.containerContainedBy;
matter.cc:85:    this[01;31m-[00m>_contents.erase( this[01;31m-[00m>_contents.begin(), this[01;31m-[00m>_contents.end() );
matter.cc:93:{_F(this[01;31m-[00m>lisp());
matter.cc:96:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) {
matter.cc:97:	LOG(BF("Looking at(%s) for(%s)") % (*aCur)[01;31m-[00m>getName().c_str() % sName.c_str()  ); // vp0(( "Looking at(%s) for(%s)", (*aCur)[01;31m-[00m>getName().c_str(), sName.c_str() ));
matter.cc:98:        if ( (*aCur)[01;31m-[00m>getName() == sName ) {
matter.cc:108:{_F(this[01;31m-[00m>lisp());
matter.cc:109:    this[01;31m-[00m>_Properties.erase(prop);
matter.cc:113:{_F(this[01;31m-[00m>lisp());
matter.cc:114:    this[01;31m-[00m>_Properties.set(prop,val);
matter.cc:118:{_F(this[01;31m-[00m>lisp());
matter.cc:119:    this[01;31m-[00m>_Properties.set(prop,this[01;31m-[00m>lisp()[01;31m-[00m>_boolean(true));
matter.cc:123:{_F(this[01;31m-[00m>lisp());
matter.cc:124:    if ( this[01;31m-[00m>_Properties.count(prop) == 0 )
matter.cc:126:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown property: "+ prop[01;31m-[00m>fullName() ));
matter.cc:128:    return this[01;31m-[00m>_Properties.get(prop,_lisp);
matter.cc:132:{_F(this[01;31m-[00m>lisp());
matter.cc:133:    if ( this[01;31m-[00m>_Properties.count(prop) == 0 )
matter.cc:137:    return this[01;31m-[00m>_Properties.get(prop,_lisp);
matter.cc:141:{_F(this[01;31m-[00m>lisp());
matter.cc:142:    return ( this[01;31m-[00m>_Properties.count(prop) != 0 );
matter.cc:150:    l.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),ATOMS);
matter.cc:154:	if ( a[01;31m-[00m>getName() == name )
matter.cc:159:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Could not find atom with name: "+name));
matter.cc:166:    l.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),ATOMS);
matter.cc:170:	if ( a[01;31m-[00m>isOfClass<O_VirtualAtom>() )
matter.cc:172:	    RPVirtualAtom va = a[01;31m-[00m>as<O_VirtualAtom>();
matter.cc:173:	    va[01;31m-[00m>calculatePosition();
matter.cc:180:{_F(this[01;31m-[00m>lisp());
matter.cc:183:    la.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),ATOMS);
matter.cc:189:    for ( ai=atoms.begin(); ai<atoms.end()[01;31m-[00m1; ai++ )
matter.cc:191:	Vector3 aipos = (*ai)[01;31m-[00m>getPosition();
matter.cc:194:	    Vector3 ajpos = (*aj)[01;31m-[00m>getPosition();
matter.cc:195:	    if ( fabs(ajpos.getX()[01;31m-[00maipos.getX()) > 2.0 ) continue;
matter.cc:196:	    if ( fabs(ajpos.getY()[01;31m-[00maipos.getY()) > 2.0 ) continue;
matter.cc:197:	    if ( fabs(ajpos.getZ()[01;31m-[00maipos.getZ()) > 2.0 ) continue;
matter.cc:198:	    if ( (*ai)[01;31m-[00m>isBondedTo(*aj) ) continue;
matter.cc:201:	    (*ai)[01;31m-[00m>bondToSingle(*aj);
matter.cc:217:{_F(this[01;31m-[00m>lisp());
matter.cc:220:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) {
matter.cc:221:	LOG(BF("Looking at(%s) for(%s)") % (*aCur)[01;31m-[00m>getName().c_str() % sName.c_str()  ); // vp0(( "Looking at(%s) for(%s)", (*aCur)[01;31m-[00m>getName().c_str(), sName.c_str() ));
matter.cc:222:        if ( (*aCur)[01;31m-[00m>getName() == sName ) {
matter.cc:226:    LOG(BF("Matter(%s) with %d contents does not contain content with name(%s)") % this[01;31m-[00m>name.c_str() % this[01;31m-[00m>_contents.size() % sName.c_str()  ); // vp0(( "Matter(%s) with %d contents does not contain content with name(%s)", this[01;31m-[00m>name.c_str(), this[01;31m-[00m>_contents.size(), sName.c_str() ));
matter.cc:228:    ss << this[01;31m-[00m>className() << " (" << this[01;31m-[00m>name << ") does not contain name(" << sName << ")";
matter.cc:229:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>(ss.str()));
matter.cc:237:{_F(this[01;31m-[00m>lisp());
matter.cc:240:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) {
matter.cc:241:	LOG(BF("Looking at(%s) for(%s)") % (*aCur)[01;31m-[00m>getName().c_str() % sName.c_str()  ); // vp0(( "Looking at(%s) for(%s)", (*aCur)[01;31m-[00m>getName().c_str(), sName.c_str() ));
matter.cc:242:        if ( (*aCur)[01;31m-[00m>getName() == sName ) {
matter.cc:246:    return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Matter>();
matter.cc:252:{_F(this[01;31m-[00m>lisp());
matter.cc:254:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) 
matter.cc:256:	(*aCur)[01;31m-[00m>makeAllAtomNamesInEachResidueUnique();
matter.cc:261:{_F(this[01;31m-[00m>lisp());
matter.cc:263:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) 
matter.cc:265:	(*aCur)[01;31m-[00m>fillInImplicitHydrogensOnCarbon();
matter.cc:270:{_F(this[01;31m-[00m>lisp());
matter.cc:272:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) 
matter.cc:274:	(*aCur)[01;31m-[00m>randomizeAtomPositions();
matter.cc:280:{_F(this[01;31m-[00m>lisp());
matter.cc:282:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) 
matter.cc:284:	(*aCur)[01;31m-[00m>perturbAtomPositions(dist);
matter.cc:300:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++, i++ ) {
matter.cc:301:        if ( (*aCur)[01;31m-[00m>getName() == sName ) {
matter.cc:306:    ss << this[01;31m-[00m>description() <<") does not contain name("<<sName<<")";
matter.cc:307:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
matter.cc:319:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) {
matter.cc:321:	LOG(BF("Looking at content with id(%d)") % c[01;31m-[00m>getId() ); // vp0(( "Looking at content with id(%d)",c[01;31m-[00m>getId()));
matter.cc:322:        if ( c[01;31m-[00m>getId() == lid ) {
matter.cc:328:    ss << this[01;31m-[00m>description() << ") does not contain id("<<lid<<")";
matter.cc:329:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
matter.cc:336:{_F(this[01;31m-[00m>lisp());
matter.cc:339:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) {
matter.cc:341:	LOG(BF("Looking at content with id(%d)") % c[01;31m-[00m>getId() ); // vp0(( "Looking at content with id(%d)",c[01;31m-[00m>getId()));
matter.cc:342:        if ( c[01;31m-[00m>getId() == lid ) {
matter.cc:361:    LOG(BF("Looking in container(%s) type(%c) for content with storageId(%d)") % this[01;31m-[00m>name.c_str() % this[01;31m-[00m>containerType % lid ); // vp0(( "Looking in container(%s) type(%c) for content with storageId(%d)",this[01;31m-[00m>name.c_str(),this[01;31m-[00m>containerType,lid));
matter.cc:362:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) {
matter.cc:364:	LOG(BF("Looking at content with id(%d)") % c[01;31m-[00m>getId() ); // vp0(( "Looking at content with id(%d)",c[01;31m-[00m>getId()));
matter.cc:365:        if ( c[01;31m-[00m>getStorageId() == lid ) {
matter.cc:372:    ss << "Matter("<<this[01;31m-[00m>name<<") type("<<this[01;31m-[00m>containerType<<") does not contain id("<<lid<<")";
matter.cc:373:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
matter.cc:383:    LOG(BF("Looking in container(%s) type(%c) for content with storageId(%d)") % this[01;31m-[00m>name.c_str() % this[01;31m-[00m>containerType % lid ); // vp0(( "Looking in container(%s) type(%c) for content with storageId(%d)",this[01;31m-[00m>name.c_str(),this[01;31m-[00m>containerType,lid));
matter.cc:384:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) {
matter.cc:386:	LOG(BF("Looking at content with id(%d)") % c[01;31m-[00m>getId() ); // vp0(( "Looking at content with id(%d)",c[01;31m-[00m>getId()));
matter.cc:387:        if ( c[01;31m-[00m>getStorageId() == lid ) {
matter.cc:407:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++, i++ ) {
matter.cc:409:        if ( c[01;31m-[00m>getId() == lid ) {
matter.cc:413:    strncpy( str1, &(this[01;31m-[00m>name[0]), this[01;31m-[00m>name.length() );
matter.cc:414:    str1[this[01;31m-[00m>name.length()] = '\0';
matter.cc:416:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Content with id was not found"));
matter.cc:432:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++, i++ ) {
matter.cc:437:    strncpy( str1, &(this[01;31m-[00m>name[0]), this[01;31m-[00m>name.length() );
matter.cc:438:    str1[this[01;31m-[00m>name.length()] = '\0';
matter.cc:439:    strncpy( str2, &(cc[01;31m-[00m>getName()[0]), (cc[01;31m-[00m>getName()).length() );
matter.cc:440:    str2[(cc[01;31m-[00m>getName()).length()] = '\0';
matter.cc:442:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Content not found" ));
matter.cc:453:    LOG(BF("Adding: %s of type: %c") % cp[01;31m-[00m>getName().c_str() % cp[01;31m-[00m>getMatterType()  ); // vp0(( "Adding: %s of type: %c",cp[01;31m-[00m>getName().c_str(),cp[01;31m-[00m>getMatterType() ));
matter.cc:454:    ctemp = this[01;31m-[00m>sharedThis<O_Matter>();
matter.cc:455:    cp[01;31m-[00m>setContainedBy(ctemp);
matter.cc:456:    LOG(BF("Adding %c:0x%08x to parent %c:0x%08x") % (cp[01;31m-[00m>getMatterType()) % (cp.get()) % (this[01;31m-[00m>getMatterType()) % (this ) ); // vp0(( "Adding %c:0x%08x to parent %c:0x%08x", cp[01;31m-[00m>getMatterType(),cp.get(), this[01;31m-[00m>getMatterType(),this ));
matter.cc:460:    this[01;31m-[00m>_contents.push_back(cp);
matter.cc:461:    if ( this[01;31m-[00m>_Id == UNDEFINED_ID )
matter.cc:463:	this[01;31m-[00m>_Id = this[01;31m-[00m>_NextContentId;
matter.cc:464:	this[01;31m-[00m>_NextContentId++;
matter.cc:478:    LOG(BF("addMatterRetainId to %s adding container %s") % this[01;31m-[00m>description().c_str() % cp[01;31m-[00m>description().c_str()  ); // vp0(( "addMatterRetainId to %s adding container %s", this[01;31m-[00m>description().c_str(), cp[01;31m-[00m>description().c_str() ));
matter.cc:479:    ctemp = this[01;31m-[00m>sharedThis<O_Matter>();
matter.cc:480:    cp[01;31m-[00m>setContainedBy(ctemp);
matter.cc:481:    LOG(BF("Adding %c:0x%08x to parent %c:0x%08x") % (cp[01;31m-[00m>getMatterType()) % (cp.get()) % (this[01;31m-[00m>getMatterType()) % (this ) ); // vp0(( "Adding %c:0x%08x to parent %c:0x%08x", cp[01;31m-[00m>getMatterType(),cp.get(), this[01;31m-[00m>getMatterType(),this ));
matter.cc:485:    this[01;31m-[00m>_contents.push_back(cp);
matter.cc:486:    if (this[01;31m-[00m>_NextContentId <= cp[01;31m-[00m>_Id ) 
matter.cc:488:	this[01;31m-[00m>_NextContentId = cp[01;31m-[00m>_Id+1;
matter.cc:501:    if ( this[01;31m-[00m>_NextContentId < i ) {
matter.cc:502:	this[01;31m-[00m>_NextContentId = i+1;
matter.cc:504:    this[01;31m-[00m>_Id = i;
matter.cc:517:    for ( a=this[01;31m-[00m>_contents.begin(); a!=this[01;31m-[00m>_contents.end(); a++ ) {
matter.cc:518:	(*a)[01;31m-[00m>applyTransformToAtoms(m);
matter.cc:529:    for ( a=this[01;31m-[00m>_contents.begin(); a!=this[01;31m-[00m>_contents.end(); a++ ) {
matter.cc:530:	(*a)[01;31m-[00m>invertStructureAndRestraints();
matter.cc:534:    if ( this[01;31m-[00m>hasRestraints() )
matter.cc:537:	for ( it=this[01;31m-[00m>beginRestraints(); it!=this[01;31m-[00m>endRestraints(); it++ )
matter.cc:539:	    (*it)[01;31m-[00m>invertStereochemistryOfRestraint();
matter.cc:546:{_F(this[01;31m-[00m>lisp());
matter.cc:549:    this[01;31m-[00m>applyTransformToAtoms(transform);
matter.cc:554:{_F(this[01;31m-[00m>lisp());
matter.cc:555:    RPMatter outer = this[01;31m-[00m>sharedThis<O_Matter>();
matter.cc:559:	if ( !outer[01;31m-[00m>containedByValid() ) return false;
matter.cc:560:	outer = outer[01;31m-[00m>containedByLock();
matter.cc:569:    if ( this[01;31m-[00m>containedByValid() ) {
matter.cc:570:        if ( (parentShouldBe != RPMatter(this[01;31m-[00m>containedBy())) ) {
matter.cc:572:	    LOG(BF("  My name/type = %s/%c") % this[01;31m-[00m>getName().c_str() % this[01;31m-[00m>getMatterType()  ); // vp0(( "  My name/type = %s/%c", this[01;31m-[00m>getName().c_str(), this[01;31m-[00m>getMatterType() ));
matter.cc:573://	    LOG(BF("  My parent address = %x  was supposed to be: %x") % &(RPMatter(this[01;31m-[00m>containedBy))() % &parentShouldBe  ); // vp0(( "  My parent address = %x  was supposed to be: %x",&(RPMatter(this[01;31m-[00m>containedBy))(), &parentShouldBe ));
matter.cc:579:    c = this[01;31m-[00m>sharedThis<O_Matter>();
matter.cc:580:    for ( a=this[01;31m-[00m>_contents.begin(); a!=this[01;31m-[00m>_contents.end(); a++ ) {
matter.cc:582:	if ( !(c[01;31m-[00m>testConsistancy(this[01;31m-[00m>sharedThis<O_Matter>())) ) {
matter.cc:597://    oldParent = this[01;31m-[00m>containedBy();
matter.cc:598:    this[01;31m-[00m>setContainedBy(newParent);
matter.cc:599:    newParent[01;31m-[00m>addMatter(this[01;31m-[00m>sharedThis<O_Matter>());
matter.cc:604:{_F(this[01;31m-[00m>lisp());
matter.cc:606:    l.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),RESIDUES);
matter.cc:612:	netCharge += r[01;31m-[00m>getNetCharge();
matter.cc:620:{_F(this[01;31m-[00m>lisp());
matter.cc:622:    l.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),ATOMS);
matter.cc:627:	a[01;31m-[00m>setMask(m);
matter.cc:648:{_F(this[01;31m-[00m>lisp());
matter.cc:649:    if ( this[01;31m-[00m>isOfClass<O_Atom>() )
matter.cc:651:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Needs Aggregate, Molecule or Residue"));
matter.cc:653:    LOG(BF("setAtomAliasesForResiduesNamed with parts(%s) atomAliases(%s)") % parts[01;31m-[00m>__repr__().c_str() % atomAliases[01;31m-[00m>__repr__().c_str()  ); // vp0(("setAtomAliasesForResiduesNamed with parts(%s) atomAliases(%s)", parts[01;31m-[00m>__repr__().c_str(), atomAliases[01;31m-[00m>__repr__().c_str() ));
matter.cc:655:    for ( RPCons cur = parts; cur[01;31m-[00m>notNil(); cur=cur[01;31m-[00m>cdr() )
matter.cc:657:	RPCons oneExtend = cur[01;31m-[00m>car<O_Cons>();
matter.cc:658:	if ( oneExtend[01;31m-[00m>length() != 2 )
matter.cc:660:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Each entry must have two elements: "+oneExtend[01;31m-[00m>__repr__() ));
matter.cc:662:	RPText residueName = oneExtend[01;31m-[00m>car<O_Text>();
matter.cc:663:	RPCons aliasAtoms = oneExtend[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
matter.cc:664:	LOG(BF("residueName(%s) aliasAtoms(%s)") % residueName[01;31m-[00m>get().c_str() % aliasAtoms[01;31m-[00m>__repr__().c_str() ); // vp0(("residueName(%s) aliasAtoms(%s)", residueName[01;31m-[00m>get().c_str(), aliasAtoms[01;31m-[00m>__repr__().c_str()));
matter.cc:665:	residueNamesToAliasAtoms[residueName[01;31m-[00m>get()] = aliasAtoms;
matter.cc:671:    lResidues.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),RESIDUES);
matter.cc:675:	if ( residueNamesToAliasAtoms.count(res[01;31m-[00m>getName())>0 )
matter.cc:677:	    LOG(BF("%s:%d Setting aliases for residue(%s)") % (__FILE__) % (__LINE__) % (res[01;31m-[00m>getName().c_str()) ); // vp0(( "%s:%d Setting aliases for residue(%s)", __FILE__,__LINE__,res[01;31m-[00m>getName().c_str()));
matter.cc:678:	    RPCons aliasAtoms = residueNamesToAliasAtoms[res[01;31m-[00m>getName()];
matter.cc:679:	    LOG(BF("setting aliases for residueName(%s) aliasAtoms(%s) atomAliases(%s)") % res[01;31m-[00m>getName().c_str() % aliasAtoms[01;31m-[00m>__repr__().c_str() % atomAliases[01;31m-[00m>__repr__().c_str() ); // vp0(("setting aliases for residueName(%s) aliasAtoms(%s) atomAliases(%s)", res[01;31m-[00m>getName().c_str(), aliasAtoms[01;31m-[00m>__repr__().c_str(), atomAliases[01;31m-[00m>__repr__().c_str()));
matter.cc:680:	    res[01;31m-[00m>setAliasesForAtoms(aliasAtoms,atomAliases);
matter.cc:683:	    LOG(BF("%s:%d Not setting aliases for residue(%s)") % (__FILE__) % (__LINE__) % (res[01;31m-[00m>getName().c_str()) ); // vp0(( "%s:%d Not setting aliases for residue(%s)", __FILE__,__LINE__,res[01;31m-[00m>getName().c_str()));
matter.cc:698:    c = this[01;31m-[00m>sharedThis<O_Matter>();
matter.cc:704:	sum = sum + a[01;31m-[00m>getPosition();
matter.cc:717:{_F(this[01;31m-[00m>lisp());
matter.cc:724:    c = this[01;31m-[00m>sharedThis<O_Matter>();
matter.cc:727:    RPBoundingBox bbox = O_BoundingBox::create(this[01;31m-[00m>lisp());
matter.cc:731:	bbox[01;31m-[00m>expandToEncompassPoint(a[01;31m-[00m>getPosition());
matter.cc:734:    bbox[01;31m-[00m>pad(pad);
matter.cc:740:{_F(this[01;31m-[00m>lisp());
matter.cc:741:    RPCons cur = O_Cons::nil(this[01;31m-[00m>lisp());
matter.cc:743:    for ( it=this[01;31m-[00m>_contents.end()[01;31m-[00m1; it>=this[01;31m-[00m>_contents.begin(); it[01;31m-[00m[01;31m-[00m )
matter.cc:745:	cur = O_Cons::create(*it,cur,this[01;31m-[00m>lisp());
matter.cc:753:{_F(this[01;31m-[00m>lisp());
matter.cc:756:    atoms = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectList>();
matter.cc:757:    la.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),ATOMS);
matter.cc:760:        atoms[01;31m-[00m>append(la.getAtom());
matter.cc:767:{_F(this[01;31m-[00m>lisp());
matter.cc:771:    atoms = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectList>();
matter.cc:772:    la.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),ATOMS);
matter.cc:776:	if ( a[01;31m-[00m>getElement() == element )
matter.cc:778:            atoms[01;31m-[00m>append(a);
matter.cc:786:{_F(this[01;31m-[00m>lisp());
matter.cc:788:    lRes.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),RESIDUES);
matter.cc:791:	if ( lRes.getResidue()[01;31m-[00m>recognizesMonomerAlias(alias[01;31m-[00m>getMonomerAlias()) )
matter.cc:796:    return O_Residue::nil(this[01;31m-[00m>lisp());
matter.cc:801:    RPResidue a = this[01;31m-[00m>aliasResidueOrNil(alias);
matter.cc:802:    if ( a[01;31m-[00m>notNil() ) return a;
matter.cc:803:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("could not find aliasResidue"));
matter.cc:808:    RPResidue res = this[01;31m-[00m>aliasResidueOrNil(alias);
matter.cc:809:    if ( res[01;31m-[00m>isNil() ) return O_Atom::nil(this[01;31m-[00m>lisp());
matter.cc:810:    return res[01;31m-[00m>atomWithAliasOrNil(alias[01;31m-[00m>getAtomAlias());
matter.cc:815:    RPAtom a = this[01;31m-[00m>aliasAtomOrNil(alias);
matter.cc:816:    if ( a[01;31m-[00m>notNil() ) return a;
matter.cc:817:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("could not find aliasAtom"));
matter.cc:825:{_F(this[01;31m-[00m>lisp());
matter.cc:829:    list = O_Cons::nil(this[01;31m-[00m>lisp());
matter.cc:830:    la.loopTopGoal(this[01;31m-[00m>sharedThis<O_Matter>(),ATOMS);
matter.cc:834:	if ( a[01;31m-[00m>getElement() == element )
matter.cc:836:	    list = O_Cons::create(a,list,this[01;31m-[00m>lisp());
matter.cc:844:{_F(this[01;31m-[00m>lisp());
matter.cc:845:    node[01;31m-[00m>attribute<string>("name",this[01;31m-[00m>name);
matter.cc:846:    LOG(BF("Got name(%s)") % this[01;31m-[00m>name.c_str()  ); // vp0(( "Got name(%s)", this[01;31m-[00m>name.c_str() ));
matter.cc:847:    node[01;31m-[00m>attribute<int>("id",this[01;31m-[00m>_Id);
matter.cc:848:    node[01;31m-[00m>archiveSymbolMapIfDefined("properties",this[01;31m-[00m>_Properties);
matter.cc:849://    this[01;31m-[00m>containerContainedBy = node[01;31m-[00m>archiveWeakPointer("parent",
matter.cc:850://    		this[01;31m-[00m>containerContainedBy);
matter.cc:853:    if ( node[01;31m-[00m>saving() ) {
matter.cc:854:        LOG(BF("About to archive the contents of a O_Matter %d objects") % this[01;31m-[00m>_contents.size()  ); // vp0(( "About to archive the contents of a O_Matter %d objects", this[01;31m-[00m>_contents.size() ));
matter.cc:857:    node[01;31m-[00m>archiveObjectVector<O_Matter>("c",this[01;31m-[00m>subMatter()+"s",this[01;31m-[00m>_contents);
matter.cc:859:    if ( node[01;31m-[00m>loading() ) {
matter.cc:860:	_BLOCK_TRACEF(BF("serializing container contents [01;31m-[00m there are %d objects")% this[01;31m-[00m>_contents.size() );
matter.cc:862:	RPMatter c = this[01;31m-[00m>sharedThis<O_Matter>();
matter.cc:864:	for ( ai=this[01;31m-[00m>_contents.begin(); ai!=this[01;31m-[00m>_contents.end(); ai++ ) {
matter.cc:865:	    (*ai)[01;31m-[00m>setContainedBy(c);
matter.cc:883:    RPMatter matter = args[01;31m-[00m>listref<O_Matter>(0);
matter.cc:884:    RPText name = args[01;31m-[00m>listref<O_Text>(1);
matter.cc:885:    return matter[01;31m-[00m>contentWithName(name[01;31m-[00m>get());
matter.cc:892:    return O_RestraintList::nil(this[01;31m-[00m>lisp());
matter.cc:897:    return O_Render::nil(this[01;31m-[00m>lisp());
matter.cc:904:    class_<O_Matter>(this[01;31m-[00m>lisp())
mbbComp.cc:33:    printf( "Energy = %f\n", ((Minimizer*)p)[01;31m-[00m>energy() );
mbbComp.cc:73:    l.loopTopGoal( agg.firstMolecule()[01;31m-[00m>firstResidue(), ATOMS );
mbbComp.cc:74:    cout << "Atoms in |test.moe|[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
mbbComp.cc:78:	a[01;31m-[00m>dump();
mbbComp.cc:85:    r = c[01;31m-[00m>getResidue();
mbbComp.cc:87:    sl = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SpanningLoop>();
mbbComp.cc:88:    sl[01;31m-[00m>setTop(r[01;31m-[00m>firstAtom());
mbbComp.cc:89://    sl.loopTopAtomGoal( r[01;31m-[00m>firstAtom(), S_PANNINGTREE );
mbbComp.cc:90:    cout << "Atoms in |end|[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
mbbComp.cc:91:    while ( sl[01;31m-[00m>advanceLoopAndProcess() ) {
mbbComp.cc:92:	a = sl[01;31m-[00m>getAtom();
mbbComp.cc:95:	a[01;31m-[00m>dump();
mbbComp.cc:102:	r[01;31m-[00m>removeAtomDeleteBonds((*aa));
mbbComp.cc:110:    cout << "Atoms in |end|[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
mbbComp.cc:114:	a[01;31m-[00m>dump();
mbbComp.cc:119:    cout << "Bonds[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
mbbComp.cc:122:	cout << "Bond " << a1[01;31m-[00m>getName() << "[01;31m-[00m" << a2[01;31m-[00m>getName() << endl;
mbbComp.cc:126:    cout << "Angles[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
mbbComp.cc:130:	cout << "Angle " << a1[01;31m-[00m>getName() << "[01;31m-[00m" << a2[01;31m-[00m>getName() << "[01;31m-[00m" << a3[01;31m-[00m>getName() << endl;
mbbComp.cc:134:    pc[01;31m-[00m>setSophisticationLevelCrude();
mbbComp.cc:135:    pc[01;31m-[00m>buildSequence( &cb, names );
mbbComp.cc:137:    mol = pc[01;31m-[00m>getMolecule();
mbbComp.cc:139:    cout << "Atoms in polymer [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" << endl;
mbbComp.cc:142:	cout << "Proper " << a1[01;31m-[00m>getName() << "[01;31m-[00m" << a2[01;31m-[00m>getName() << "[01;31m-[00m" << a3[01;31m-[00m>getName() << "[01;31m-[00m" << a4[01;31m-[00m>getName() << endl;
mbbCoreTools.cc:49:	sum = sum + a[01;31m-[00m>getPosition();
mbbCoreTools.cc:105:	    x = (*ai)[01;31m-[00m>getPosition().getX() [01;31m-[00m a[01;31m-[00m>getPosition().getX();
mbbCoreTools.cc:107:	    y = (*ai)[01;31m-[00m>getPosition().getY() [01;31m-[00m a[01;31m-[00m>getPosition().getY();
mbbCoreTools.cc:109:	    z = (*ai)[01;31m-[00m>getPosition().getZ() [01;31m-[00m a[01;31m-[00m>getPosition().getZ();
mbbCoreTools.cc:145:    for ( rmain = residues.size()[01;31m-[00m1; rmain>= 0; rmain[01;31m-[00m[01;31m-[00m ) {
mbbCoreTools.cc:147:	    for ( rtemp = rmain[01;31m-[00m2; rtemp >= 0; rtemp[01;31m-[00m[01;31m-[00m ) {
mbbCoreTools.cc:155:	if ( rmain<((int)residues.size()[01;31m-[00m2) ) {
mbbCoreTools.cc:173:	for ( vector<RPAtom>::iterator i1 = atoms.begin(); i1!=atoms.end()[01;31m-[00m1; i1++ )
mbbCoreTools.cc:175:	    Vector3 v1 = (*i1)[01;31m-[00m>getPosition();
mbbCoreTools.cc:176:	    double rad1 = vdwRadiusForElement((*i1)[01;31m-[00m>getElement());
mbbCoreTools.cc:179:		Vector3 v2 = (*i2)[01;31m-[00m>getPosition();
mbbCoreTools.cc:180:		double rad2 = vdwRadiusForElement((*i2)[01;31m-[00m>getElement());
mbbCoreTools.cc:183:		double maxLen = maximumBondLengthBetweenElements((*i1)[01;31m-[00m>getElement(),(*i2)[01;31m-[00m>getElement());
mbbCoreTools.cc:186:		    if (!(*i1)[01;31m-[00m>isBondedTo(*i2))
mbbCoreTools.cc:188:			LOG(BF("Forming bond between atom(%s) and atom(%s) [01;31m-[00m they were %lf angstroms apart < max(%lf)") % (*i1)[01;31m-[00m>description() % (*i2)[01;31m-[00m>description() % len % maxLen );
mbbCoreTools.cc:189:			(*i1)[01;31m-[00m>bondToSingle(*i2);
mbbCoreTools.cc:211://	lisp[01;31m-[00m>print(BF("Number of unconnected atoms(%d)") % atoms.size() );
mbbCoreTools.cc:212://	lisp[01;31m-[00m>print(BF("Number of atoms connected by vdw overlap(%d)") % numVdwConnected);
mbbCoreTools.cc:228:	    Vector3 pos = a[01;31m-[00m>getPosition();
mbbCoreTools.cc:234:		result[01;31m-[00m>insert(a);
mbbCoreTools.cc:252:	    result[01;31m-[00m>insert(a);
metaClass.cc:14:    return cl[01;31m-[00m>getInstanceClassId() == classId;
metaClass.cc:19:    return cl[01;31m-[00m>isOfClass(testClass);
metaClass.cc:24:    return cl[01;31m-[00m>isSubClassOf(baseClass);
metaClass.cc:29:    RPMetaClass baseClass = cl[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(baseClassId);
metaClass.cc:30:    return cl[01;31m-[00m>isSubClassOf(baseClass);
metaClass.cc:38:	this[01;31m-[00m>_WeakLisp = mc[01;31m-[00m>lisp();
metaClass.cc:41:	this[01;31m-[00m>_WeakLisp.reset();
metaClass.cc:43:    this[01;31m-[00m>_InstanceBaseClass.reset();
metaClass.cc:44:    this[01;31m-[00m>_InstanceNil.reset();
metaClass.cc:45:    this[01;31m-[00m>_Methods.clear();
metaClass.cc:57:    ASSERT_NOT_NULL(this[01;31m-[00m>_InstanceBaseClass); 
metaClass.cc:58:    return this[01;31m-[00m>_InstanceBaseClass; 
metaClass.cc:65:    return this[01;31m-[00m>instanceClassName();
metaClass.cc:66://    TOSS(_lisp[01;31m-[00m>create<O_LispError>("You should use instanceClassName rather than className for classes"));
metaClass.cc:71:    return this[01;31m-[00m>instanceClassId();
metaClass.cc:72://    TOSS(_lisp[01;31m-[00m>create<O_LispError>("You should use instanceClassId rather than classId for classes"));
metaClass.cc:77:{_F(this[01;31m-[00m>lisp());
metaClass.cc:78:    RPLisp env = this[01;31m-[00m>lisp();
metaClass.cc:80:    ASSERTP(this[01;31m-[00m>_InstanceAllocatorCallback != NULL, "_InstanceAllocatorCallback is NULL!!");
metaClass.cc:81:    RPObject newObject = (this[01;31m-[00m>_InstanceAllocatorCallback)(env);
metaClass.cc:87:    return this[01;31m-[00m>_InstanceBaseClass; 
metaClass.cc:98:    if ( ancestor[01;31m-[00m>_InstanceClassId == O_Object::static_classId() ) return true;
metaClass.cc:99:    if ( this[01;31m-[00m>_InstanceClassId == O_Object::static_classId() ) return false;
metaClass.cc:100:    RPMetaClass baseClass = this[01;31m-[00m>_InstanceBaseClass;
metaClass.cc:103:	if ( baseClass[01;31m-[00m>_InstanceClassId == O_Object::static_classId() ) break;
metaClass.cc:104:	if ( baseClass[01;31m-[00m>_InstanceClassId == UndefinedUnsignedInt ) break;
metaClass.cc:105://	LOG(BF("baseClass[01;31m-[00m>_InstanceClassId = %d")% baseClass[01;31m-[00m>_InstanceClassId );
metaClass.cc:106://	LOG(BF("Checking to see if class(%s) is a subclass of class(%s)")% baseClass[01;31m-[00m>instanceClassName() % ancestor[01;31m-[00m>instanceClassName() );
metaClass.cc:112:	baseClass = baseClass[01;31m-[00m>_InstanceBaseClass;
metaClass.cc:115:    LOG(BF("FAILED: %s is not a subclass of %s")%this[01;31m-[00m>instanceClassName() % ancestor[01;31m-[00m>instanceClassName() );
metaClass.cc:129:    this[01;31m-[00m>Base::initialize();
metaClass.cc:130:    RPLisp lisp = this[01;31m-[00m>O_Object::lisp();
metaClass.cc:132:    this[01;31m-[00m>_InstanceClassId = UndefinedUnsignedInt;
metaClass.cc:133:    this[01;31m-[00m>_InstanceBaseClass = O_MetaClass::nil(lisp);
metaClass.cc:134:    ASSERTP(this[01;31m-[00m>_Class!=NULL,"O_MetaClass::initialize [01;31m-[00m[01;31m-[00m> this[01;31m-[00m>_Class is NULL!!!");
metaClass.cc:135:    this[01;31m-[00m>_WeakLisp= lisp;
metaClass.cc:136:    this[01;31m-[00m>_SupportsSlots = false;
metaClass.cc:143:    HARD_ASSERT(this[01;31m-[00m>_WeakLisp.use_count()>0);
metaClass.cc:144:    return this[01;31m-[00m>_WeakLisp.lock();
metaClass.cc:149:    HARD_ASSERT(this[01;31m-[00m>_WeakLisp.use_count()>0);
metaClass.cc:150:    return this[01;31m-[00m>_WeakLisp.lock();
metaClass.cc:158:    ss << "[InstanceClass("<<this[01;31m-[00m>_Name<<"/"<<this[01;31m-[00m>_InstanceClassId<<")";
metaClass.cc:159:    ss << " _class("<<this[01;31m-[00m>_class()[01;31m-[00m>className()<<"/"<<this[01;31m-[00m>_class()[01;31m-[00m>classId()<<")";
metaClass.cc:160:    ss << " static_Class("<<this[01;31m-[00m>static_className()<<"/"<<this[01;31m-[00m>static_classId()<<")";
metaClass.cc:161:    ss << " InstanceBaseClass("<<this[01;31m-[00m>_InstanceBaseClass[01;31m-[00m>instanceClassName()<<")]";
metaClass.cc:167:    return this[01;31m-[00m>_PackageName;
metaClass.cc:173:{_F(this[01;31m-[00m>lisp());
metaClass.cc:174:    return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_ArgumentHandler>();
metaClass.cc:181:    ss << (boost::format("this.instanceClassName: %s @ %X") % this[01;31m-[00m>instanceClassName() % this) << endl;
metaClass.cc:182:    ss << "_PackageName("<<this[01;31m-[00m>_PackageName<<")"<<endl;
metaClass.cc:183:    RPArgumentHandler ah = this[01;31m-[00m>__init__argumentHandler();
metaClass.cc:186:	if ( ah[01;31m-[00m>notNil() )
metaClass.cc:188:	    ss << "__getArgumentHandlerString() = " << this[01;31m-[00m>__getArgumentHandlerString() << endl;
metaClass.cc:189:	    ss << "    argument handler = " << ah[01;31m-[00m>asArgumentString() << endl;
metaClass.cc:192:	    ss << "[01;31m-[00m[01;31m-[00m no __init__ arguments" << endl;
metaClass.cc:198:    if ( this[01;31m-[00m>_Class != NULL )
metaClass.cc:200:	ss << boost::format("    _Class = %X  this._Class.instanceClassName()=%s\n") % this[01;31m-[00m>_Class % this[01;31m-[00m>_Class[01;31m-[00m>instanceClassName();
metaClass.cc:205:    if ( this[01;31m-[00m>_InstanceBaseClass.use_count() == 0 )
metaClass.cc:210:	ss << boost::format("this.getInstanceBaseClass().instanceClassName() = %s") % this[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>instanceClassName() << endl;
metaClass.cc:211:	ss << boost::format("this.getInstanceBaseClass().instanceClassId() = %s") % this[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>instanceClassId() << endl;
metaClass.cc:213:    ss << BF("Init argument string[%s]") % this[01;31m-[00m>__getArgumentHandlerString() << endl;
metaClass.cc:214:    if ( !this[01;31m-[00m>has__init__argumentHandler() )
metaClass.cc:219:	ss << BF("Init arguments after parse[%s]") % this[01;31m-[00m>__init__argumentHandler()[01;31m-[00m>asArgumentString() << endl;
metaClass.cc:221:    ss << boost::format("this.supportsSlots() = %d")% this[01;31m-[00m>supportsSlots() << endl;
metaClass.cc:222:    ss << boost::format("this.staticBaseClassId() = %d")% this[01;31m-[00m>staticBaseClassId() << endl;
metaClass.cc:223:    ss << boost::format("this.getInstanceClassId() = %d")%  this[01;31m-[00m>getInstanceClassId() << endl;
metaClass.cc:224:    ss << boost::format("this.instanceAllocatorCallback() = %X") % (void*)(this[01;31m-[00m>instanceAllocatorCallback()) << endl;
metaClass.cc:225:    ss << boost::format("this._InstanceNil.use_count() = %d")%  this[01;31m-[00m>_InstanceNil.use_count() <<endl;
metaClass.cc:226:    ss << BF("this._WeakLisp.use_count() = %d") % this[01;31m-[00m>_WeakLisp.use_count() << endl;
metaClass.cc:227:    if ( this[01;31m-[00m>_WeakLisp.use_count() != 0 )
metaClass.cc:229:        ss << BF("this._WeakLisp points @%X" ) % this[01;31m-[00m>_WeakLisp.lock().get() << endl;
metaClass.cc:233:    for ( map<O_Symbol*,RPExecutable>::iterator mi=this[01;31m-[00m>_Methods.begin(); mi!=this[01;31m-[00m>_Methods.end(); mi++ )
metaClass.cc:235:	ss << "     " << mi[01;31m-[00m>first[01;31m-[00m>currentName() << endl;
metaClass.cc:244:    ss << this[01;31m-[00m>_PackageName << ":" << this[01;31m-[00m>_Name;
metaClass.cc:251:    ss << this[01;31m-[00m>_PackageName << ":" << this[01;31m-[00m>_Name;
metaClass.cc:257:    this[01;31m-[00m>_Methods.clear();
metaClass.cc:262:{_F(this[01;31m-[00m>lisp());
metaClass.cc:263:    LOG(BF("Adding method(%s) to class(%s)") % methodSymbol[01;31m-[00m>__repr__() % this[01;31m-[00m>instanceClassName() );
metaClass.cc:265:    if ( !method[01;31m-[00m>isKeywordSymbol() )
metaClass.cc:267:	method = this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(methodSymbol[01;31m-[00m>name());
metaClass.cc:269:    if ( this[01;31m-[00m>_Methods.count(method) > 0)
metaClass.cc:271:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You are overwritting an existing method(%s) for class(%s)") % methodSymbol[01;31m-[00m>__repr__() % this[01;31m-[00m>instanceClassName()  ));
metaClass.cc:273:    this[01;31m-[00m>_Methods[method] = exec;
metaClass.cc:279:{_F(this[01;31m-[00m>lisp());
metaClass.cc:281:    if ( !method[01;31m-[00m>isKeywordSymbol() )
metaClass.cc:283:	method = this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(methodSymbol[01;31m-[00m>name());
metaClass.cc:285:    map<RPSymbol,RPExecutable>::iterator mi = this[01;31m-[00m>_Methods.find(method);
metaClass.cc:286:    if ( mi!=this[01;31m-[00m>_Methods.end() ) return mi[01;31m-[00m>second;
metaClass.cc:287:    LOG(BF("This class doesn't recognize the message(%s)") % methodSymbol[01;31m-[00m>fullName() );
metaClass.cc:292:    if ( this == (this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(O_Object::static_classId())).get())
metaClass.cc:295:        return O_Executable::nil(this[01;31m-[00m>lisp());
metaClass.cc:300:    LOG(BF("Looking for the method in the base class(%s)") % this[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>className() );
metaClass.cc:301:    return this[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>getMethodOrNil(methodSymbol,receiver);
metaClass.cc:309:    oclass[01;31m-[00m>_PackageName = package;
metaClass.cc:310:    oclass[01;31m-[00m>_Name = name;
metaClass.cc:311:    oclass[01;31m-[00m>_InstanceClassId = instanceClassId;
metaClass.cc:325:{_F(this[01;31m-[00m>lisp());
metaClass.cc:326:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % this[01;31m-[00m>dumpInfo().c_str() );
metaClass.cc:331:{_F(this[01;31m-[00m>lisp());
metaClass.cc:340:	class_<O_MetaClass>(this[01;31m-[00m>lisp())
metaClass.cc:344:	    .def("make[01;31m-[00minstance",&O_MetaClass::makeInstance)
microHeap.cc:18:    this[01;31m-[00m>_EntrySize = UndefinedUnsignedInt;
microHeap.cc:19:    this[01;31m-[00m>_NextEntryIndex = UndefinedUnsignedInt;
microHeap.cc:20:    this[01;31m-[00m>_Entries = NULL;
microHeap.cc:26:    this[01;31m-[00m>_EntrySize = entrySize;
microHeap.cc:27:    this[01;31m-[00m>_MaxEntries = maxEntries;
microHeap.cc:28:    this[01;31m-[00m>_NextEntryIndex = 0;
microHeap.cc:29:    this[01;31m-[00m>_Entries = (byte*)(malloc(entrySize*maxEntries));
microHeap.cc:30:    HARD_ASSERT(this[01;31m-[00m>_Entries!=NULL);
microHeap.cc:35:    if ( this[01;31m-[00m>_Entries!=NULL )
microHeap.cc:37:        free(this[01;31m-[00m>_Entries);
microHeap.cc:43:    HARD_ASSERT(i<this[01;31m-[00m>_MaxEntries);
microHeap.cc:44:    byte* bp = this[01;31m-[00m>_Entries+(i*this[01;31m-[00m>_EntrySize);
microHeap.cc:51://    LOG(BF("Test if can allocate new entry, this[01;31m-[00m>_NextEntryIndex(%u)<this[01;31m-[00m>_MaxEntries(%u)") % this[01;31m-[00m>_NextEntryIndex % this[01;31m-[00m>_MaxEntries  ); // vp0(( "Test if can allocate new entry, this[01;31m-[00m>_NextEntryIndex(%u)<this[01;31m-[00m>_MaxEntries(%u)", this[01;31m-[00m>_NextEntryIndex, this[01;31m-[00m>_MaxEntries ));
microHeap.cc:52:    if ( this[01;31m-[00m>_NextEntryIndex < this[01;31m-[00m>_MaxEntries )
microHeap.cc:63:    HARD_ASSERT(this[01;31m-[00m>canAllocateNewEntry());
microHeap.cc:64:    idx = this[01;31m-[00m>_NextEntryIndex;
microHeap.cc:65:    byte* p = this[01;31m-[00m>_Entries+(this[01;31m-[00m>_EntrySize*this[01;31m-[00m>_NextEntryIndex);
microHeap.cc:66:    this[01;31m-[00m>_NextEntryIndex++;
microHeap.cc:67://    LOG(BF("Returning rawNewEntry this[01;31m-[00m>_NextEntryIndex is now %u") % this[01;31m-[00m>_NextEntryIndex ); // vp0(( "Returning rawNewEntry this[01;31m-[00m>_NextEntryIndex is now %u", this[01;31m-[00m>_NextEntryIndex));
microHeap.cc:77:    h[01;31m-[00m>setEntrySize(entrySize);
microHeap.cc:78:    h[01;31m-[00m>setMaxEntries(maxEntries);
microHeap.cc:79:    h[01;31m-[00m>createNewBlock();
microHeap.cc:86:	this[01;31m-[00m>_Blocks.clear();
microHeap.cc:92:    for ( vector<MicroHeapBlock*>::iterator it=this[01;31m-[00m>_Blocks.begin();
microHeap.cc:93:    		it!=this[01;31m-[00m>_Blocks.end(); it++ )
microHeap.cc:97:    this[01;31m-[00m>_Blocks.clear();
microHeap.cc:104:    this[01;31m-[00m>_Blocks.clear();
microHeap.cc:105:    this[01;31m-[00m>_EntrySize = UndefinedUnsignedInt;
microHeap.cc:106:    this[01;31m-[00m>_MaxEntriesPerBlock = UndefinedUnsignedInt;
microHeap.cc:113:    if ( this[01;31m-[00m>_Blocks.size() == 0 )
microHeap.cc:117:    uint num = (this[01;31m-[00m>_Blocks.size()[01;31m-[00m1)*this[01;31m-[00m>_MaxEntriesPerBlock;
microHeap.cc:118:    num += this[01;31m-[00m>_Blocks.back()[01;31m-[00m>numberOfEntries();
microHeap.cc:124:{_F(this[01;31m-[00m>lisp());
microHeap.cc:125:    ASSERT(this[01;31m-[00m>_Blocks.size() > 0 );
microHeap.cc:126:    uint blocki = i / (this[01;31m-[00m>_MaxEntriesPerBlock);
microHeap.cc:127:    uint blocko = i % (this[01;31m-[00m>_MaxEntriesPerBlock);
microHeap.cc:128:    MicroHeapBlock* Pblock = this[01;31m-[00m>_Blocks[blocki];
microHeap.cc:129:    return Pblock[01;31m-[00m>rawGetEntry(blocko);
microHeap.cc:135:{_F(this[01;31m-[00m>lisp());
microHeap.cc:136:    ASSERTP(this[01;31m-[00m>_EntrySize!=UndefinedUnsignedInt,"You must set EntrySize first");
microHeap.cc:137:    MicroHeapBlock* block = new MicroHeapBlock(this[01;31m-[00m>_MaxEntriesPerBlock,this[01;31m-[00m>_EntrySize);
microHeap.cc:138:    this[01;31m-[00m>_Blocks.push_back(block);
microHeap.cc:142:{_F(this[01;31m-[00m>lisp());
microHeap.cc:143:    if ( this[01;31m-[00m>_Blocks.size() == 0 )
microHeap.cc:145:	this[01;31m-[00m>createNewBlock();
microHeap.cc:147:    ASSERT_gt(this[01;31m-[00m>_Blocks.size(),0);
microHeap.cc:148:    MicroHeapBlock* PBlock = this[01;31m-[00m>_Blocks.back();
microHeap.cc:149:    if ( !PBlock[01;31m-[00m>canAllocateNewEntry() )
microHeap.cc:151:	this[01;31m-[00m>createNewBlock();
microHeap.cc:152:	PBlock = this[01;31m-[00m>_Blocks.back();
microHeap.cc:155:    i = (this[01;31m-[00m>_Blocks.size()[01;31m-[00m1)*this[01;31m-[00m>_MaxEntriesPerBlock;
microHeap.cc:156:    void* ptr = PBlock[01;31m-[00m>rawNewEntry(offset);
microHeap.cc:165:	class_<O_MicroHeap>(this[01;31m-[00m>lisp())
minimizer.cc:60:#define	EPS	1.0e[01;31m-[00m10
minimizer.cc:61:#define	TOL	2.0e[01;31m-[00m4
minimizer.cc:63:#define ZEPS 1.0e[01;31m-[00m10
minimizer.cc:68:#define	SIGN(a,b)	((b)>0.0?fabs(a):[01;31m-[00mfabs(a))
minimizer.cc:70:#define	TINY	1.0e[01;31m-[00m20
minimizer.cc:81:#define NOTFOUND                        [01;31m-[00m1
minimizer.cc:100:	    return "[01;31m-[00munknown preconditioner[01;31m-[00m";
minimizer.cc:102:    return "[01;31m-[00munknown preconditioner[01;31m-[00m";
minimizer.cc:128:{_F(this[01;31m-[00m>lisp());
minimizer.cc:129:    RPBinder options = O_Binder::createFromKeywordCons(optionCons,minimizerOptions,this[01;31m-[00m>lisp());
minimizer.cc:130:    options[01;31m-[00m>setBoolValueIfAvailable(this[01;31m-[00m>_ShowElapsedTime,":showElapsedTime");
minimizer.cc:138:    switch (this[01;31m-[00m>_Status) {
minimizer.cc:158:    status = status + "[01;31m-[00m" + stringForPreconditionerType(this[01;31m-[00m>_CurrentPreconditioner);
minimizer.cc:163:{_F(this[01;31m-[00m>lisp());
minimizer.cc:164:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
minimizer.cc:166:    RPMatter matter = kargs[01;31m-[00m>getAndRemoveOrDefault("matter",O_Matter::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Matter>();
minimizer.cc:167:    RPForceField forceField = kargs[01;31m-[00m>getAndRemoveOrDefault("forceField",O_ForceField::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_ForceField>();
minimizer.cc:168:    RPEnergyFunction givenEnergyFunction = kargs[01;31m-[00m>getAndRemoveOrDefault("energyFunction",O_EnergyFunction::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_EnergyFunction>();
minimizer.cc:169:    if ( givenEnergyFunction[01;31m-[00m>isNil() )
minimizer.cc:171:	if ( matter[01;31m-[00m>notNil() && forceField[01;31m-[00m>notNil() )
minimizer.cc:174:	    RPEnergyFunction ef = O_EnergyFunction::create(this[01;31m-[00m>lisp());
minimizer.cc:175:	    ef[01;31m-[00m>defineForMatter(matter,forceField);
minimizer.cc:176:	    this[01;31m-[00m>setEnergyFunction(ef);
minimizer.cc:180:	if ( matter[01;31m-[00m>isNil() && forceField[01;31m-[00m>isNil() )
minimizer.cc:183:	    this[01;31m-[00m>setEnergyFunction(givenEnergyFunction);
minimizer.cc:188:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("When initializing a Minimizer object you must either provide an (energyFunction) or a (Matter/ForceField) pair"));
minimizer.cc:194:    node[01;31m-[00m>attribute("_InitialLineSearchStep",this[01;31m-[00m>_InitialLineSearchStep);
minimizer.cc:195:    node[01;31m-[00m>attribute("_ShowElapsedTime",this[01;31m-[00m>_ShowElapsedTime);
minimizer.cc:196:    node[01;31m-[00m>attribute("_SteepestDescentTolerance",this[01;31m-[00m>_SteepestDescentTolerance);
minimizer.cc:197:    node[01;31m-[00m>attribute("_NumberOfSteepestDescentSteps",this[01;31m-[00m>_NumberOfSteepestDescentSteps);
minimizer.cc:198:    node[01;31m-[00m>attribute("_NumberOfConjugateGradientSteps",this[01;31m-[00m>_NumberOfConjugateGradientSteps);
minimizer.cc:199:    node[01;31m-[00m>attribute("_ConjugateGradientTolerance",this[01;31m-[00m>_ConjugateGradientTolerance);
minimizer.cc:200:    node[01;31m-[00m>attribute("_NumberOfTruncatedNewtonSteps",this[01;31m-[00m>_NumberOfTruncatedNewtonSteps);
minimizer.cc:201:    node[01;31m-[00m>attribute("_TruncatedNewtonTolerance",this[01;31m-[00m>_TruncatedNewtonTolerance);
minimizer.cc:202:    node[01;31m-[00m>archiveObject("energyFunction",this[01;31m-[00m>_EnergyFunction );
minimizer.cc:204://    node[01;31m-[00m>attribute("_ZZ",this[01;31m-[00m>_ZZ);
minimizer.cc:210:    switch (this[01;31m-[00m>_Status) {
minimizer.cc:229:    status = status + shortStringForPreconditionerType(this[01;31m-[00m>_CurrentPreconditioner);
minimizer.cc:236:{_F(this[01;31m-[00m>lisp());
minimizer.cc:237:    this[01;31m-[00m>_StepCallback = cb;
minimizer.cc:241:{_F(this[01;31m-[00m>lisp());
minimizer.cc:242:    this[01;31m-[00m>_DebugOn = true;
minimizer.cc:244:    this[01;31m-[00m>_Log = O_MinimizerLog::create(this[01;31m-[00m>lisp());
minimizer.cc:246:    this[01;31m-[00m>_Log[01;31m-[00m>_Minimizer = this[01;31m-[00m>sharedThis<O_Minimizer>();
minimizer.cc:252:{_F(this[01;31m-[00m>lisp());
minimizer.cc:254:    if ( !this[01;31m-[00m>_DebugOn ) return;
minimizer.cc:255:    ASSERT_NOT_NULL(this[01;31m-[00m>_Log);
minimizer.cc:258:    arc = O_XmlSaveArchive::create(this[01;31m-[00m>lisp());
minimizer.cc:260:    arc[01;31m-[00m>put("minimizerLog",this[01;31m-[00m>_Log);
minimizer.cc:262:    arc[01;31m-[00m>saveAs(fileName);
minimizer.cc:278:    nvResult[01;31m-[00m>XPlusYTimesScalar(nvOrigin,nvDirection,x);
minimizer.cc:294:    dEnergy = this[01;31m-[00m>_EnergyFunction[01;31m-[00m>evaluateEnergy( nvPos );
minimizer.cc:310:{_F(this[01;31m-[00m>lisp());
minimizer.cc:314:    return this[01;31m-[00m>_EnergyFunction[01;31m-[00m>evaluateEnergyForce(nvPos,true,nvForce);
minimizer.cc:326://    this[01;31m-[00m>nvP1DSearchOrigin[01;31m-[00m>debugDump("origin");
minimizer.cc:328://    this[01;31m-[00m>nvP1DSearchDirection[01;31m-[00m>debugDump("direction");
minimizer.cc:330:    this[01;31m-[00m>getPosition(this[01;31m-[00m>nvP1DSearchTemp1, this[01;31m-[00m>nvP1DSearchOrigin, this[01;31m-[00m>nvP1DSearchDirection,x);
minimizer.cc:331:    return this[01;31m-[00m>_EnergyFunction[01;31m-[00m>evaluateEnergy(this[01;31m-[00m>nvP1DSearchTemp1);
minimizer.cc:343://    this[01;31m-[00m>nvP1DSearchOrigin[01;31m-[00m>debugDump("origin");
minimizer.cc:345://    this[01;31m-[00m>nvP1DSearchDirection[01;31m-[00m>debugDump("direction");
minimizer.cc:347:    this[01;31m-[00m>getPosition(this[01;31m-[00m>nvP1DSearchTemp1,
minimizer.cc:348:			this[01;31m-[00m>nvP1DSearchOrigin,
minimizer.cc:349:			this[01;31m-[00m>nvP1DSearchDirection, x );
minimizer.cc:350:    *fx = this[01;31m-[00m>_EnergyFunction[01;31m-[00m>evaluateEnergyForce( this[01;31m-[00m>nvP1DSearchTemp1,
minimizer.cc:351:	    					true, this[01;31m-[00m>nvP1DSearchTemp2 );
minimizer.cc:352:    *dfx = [01;31m-[00m(this[01;31m-[00m>nvP1DSearchTemp2)[01;31m-[00m>dotProduct(this[01;31m-[00m>nvP1DSearchDirection);
minimizer.cc:378:{_F(this[01;31m-[00m>lisp());
minimizer.cc:382:    this[01;31m-[00m>_MinBracketSteps = 0;
minimizer.cc:385:    fa = this[01;31m-[00m>d1DTotalEnergy(xa);
minimizer.cc:386:    fb = this[01;31m-[00m>d1DTotalEnergy(xb);
minimizer.cc:387:	// Make sure that we are going downhill a[01;31m-[00m>b
minimizer.cc:392:    xc = xb+GOLD*(xb[01;31m-[00mxa);
minimizer.cc:393:    fc = this[01;31m-[00m>d1DTotalEnergy(xc);
minimizer.cc:396:	this[01;31m-[00m>_MinBracketSteps++;
minimizer.cc:398:	r = (xb[01;31m-[00mxa)*(fb[01;31m-[00mfc);
minimizer.cc:399:	q = (xb[01;31m-[00mxc)*(fb[01;31m-[00mfa);
minimizer.cc:400:	u = xb[01;31m-[00m((xb[01;31m-[00mxc)*q[01;31m-[00m(xb[01;31m-[00mxa)*r)/
minimizer.cc:401:		(2.0*SIGN(MAX(fabs(q[01;31m-[00mr),TINY),q[01;31m-[00mr));
minimizer.cc:402:	ulim = (xb)+GLIMIT*(xc[01;31m-[00mxb);
minimizer.cc:403:	if (( xb[01;31m-[00mu)*(u[01;31m-[00mxc)>0.0) {
minimizer.cc:404:	    fu = this[01;31m-[00m>d1DTotalEnergy(u);
minimizer.cc:416:	    u = xc+GOLD*(xc[01;31m-[00mxb);
minimizer.cc:417:	    fu = this[01;31m-[00m>d1DTotalEnergy(u);
minimizer.cc:418:	} else if ((xc[01;31m-[00mu)*(u[01;31m-[00mulim) > 0.0) {
minimizer.cc:419:	    fu = this[01;31m-[00m>d1DTotalEnergy(u);
minimizer.cc:421:		LEFT_SHIFT_VALUES( xb, xc, u, xc+GOLD*(xc[01;31m-[00mxb) );
minimizer.cc:422:		LEFT_SHIFT_VALUES( fb, fc, fu, this[01;31m-[00m>d1DTotalEnergy(u));
minimizer.cc:425:	} else if ((u[01;31m-[00mulim)*(ulim[01;31m-[00mxc)>=0.0 ){
minimizer.cc:427:	    fu = this[01;31m-[00m>d1DTotalEnergy(u);
minimizer.cc:429:	    u = xc+GOLD*(xc[01;31m-[00mxb);
minimizer.cc:430:	    fu = this[01;31m-[00m>d1DTotalEnergy(u);
minimizer.cc:472:{_F(this[01;31m-[00m>lisp());
minimizer.cc:501:	if (fabs(x[01;31m-[00mxm) <=(tol2[01;31m-[00m0.5*(_b[01;31m-[00m_a))) {	// Stopping criterion
minimizer.cc:504:	    LOG(BF("done due to (fabs(x[01;31m-[00mxm).LE.(tol2[01;31m-[00m0.5*(_b[01;31m-[00m_a)))") ); // vp0(( "done due to (fabs(x[01;31m-[00mxm).LE.(tol2[01;31m-[00m0.5*(_b[01;31m-[00m_a)))"));
minimizer.cc:508:	    d1=2.0*(_b[01;31m-[00m_a);
minimizer.cc:510:	    if (dw != dx ) d1=(w[01;31m-[00mx)*dx/(dx[01;31m-[00mdw); // Secant method, first on one, then on
minimizer.cc:511:	    if (dv != dx ) d2=(v[01;31m-[00mx)*dx/(dx[01;31m-[00mdv); // the other point
minimizer.cc:517:	    ok1=(_a[01;31m-[00mu1)*(u1[01;31m-[00m_b)>0.0 && dx*d1 <= 0.0;
minimizer.cc:518:	    ok2=(_a[01;31m-[00mu2)*(u2[01;31m-[00m_b)>0.0 && dx*d2 <= 0.0;
minimizer.cc:531:		    if ( u[01;31m-[00m_a<tol2 || _b[01;31m-[00mu < tol2 )
minimizer.cc:532:		        _d = SIGN(tol1,xm[01;31m-[00mx);
minimizer.cc:534:		    _e=(dx>=0.0?_a[01;31m-[00mx:_b[01;31m-[00mx); // Bisect, not golden section
minimizer.cc:540:	        _e=(dx>=0.0?_a[01;31m-[00mx:_b[01;31m-[00mx);
minimizer.cc:544:	    _e=(dx>=0.0?_a[01;31m-[00mx:_b[01;31m-[00mx);
minimizer.cc:585:    retval = [01;31m-[00m1.0;
minimizer.cc:600:    lenForce = nvForce[01;31m-[00m>magnitude();
minimizer.cc:601:    lenDir = nvDir[01;31m-[00m>magnitude();
minimizer.cc:605:	cosAngle = nvDir[01;31m-[00m>dotProduct(nvForce)/(lenForce*lenDir);
minimizer.cc:607:	if ( cosAngle < [01;31m-[00m1.0 ) cosAngle = [01;31m-[00m1.0;
minimizer.cc:610:    report[01;31m-[00m>_AngleBetweenDirectionAndForceDeg = angle/0.0174533;
minimizer.cc:611:    report[01;31m-[00m>_Xa = xa;
minimizer.cc:612:    report[01;31m-[00m>_Xb = xb;
minimizer.cc:613:    report[01;31m-[00m>_Xc = xc;
minimizer.cc:614:    report[01;31m-[00m>_Fa = fa;
minimizer.cc:615:    report[01;31m-[00m>_Fb = fb;
minimizer.cc:616:    report[01;31m-[00m>_Fc = fc;
minimizer.cc:617:    report[01;31m-[00m>_MinBracketSteps = this[01;31m-[00m>_MinBracketSteps;
minimizer.cc:618:    report[01;31m-[00m>_EnergyTermsEnabled = this[01;31m-[00m>_EnergyFunction[01;31m-[00m>energyTermsEnabled();
minimizer.cc:619:    report[01;31m-[00m>_TotalEnergy = this[01;31m-[00m>d1DTotalEnergy(0.0);
minimizer.cc:620:    report[01;31m-[00m>_DirectionMagnitude = nvDir[01;31m-[00m>magnitude();
minimizer.cc:621:    report[01;31m-[00m>_ForceMagnitude = nvForce[01;31m-[00m>magnitude();
minimizer.cc:622:    report[01;31m-[00m>_MinimizerStatus = this[01;31m-[00m>statusAsString();
minimizer.cc:627:	report[01;31m-[00m>_Direction = "searchForward";
minimizer.cc:631:	report[01;31m-[00m>_Direction = "searchBackward";
minimizer.cc:636:    double xinc = (dxc[01;31m-[00mdxa)/100.0;
minimizer.cc:637:    report[01;31m-[00m>_LineSearchPosition = nvPos[01;31m-[00m>deepCopy();
minimizer.cc:638:    report[01;31m-[00m>_LineSearchDirection = nvDir[01;31m-[00m>deepCopy();
minimizer.cc:639:    report[01;31m-[00m>_TotalEnergyFn = O_NumericalFunction::create("Alpha","Total",xmin,xinc,this[01;31m-[00m>lisp());
minimizer.cc:640:    report[01;31m-[00m>_StretchEnergyFn = O_NumericalFunction::create("Alpha","Stretch",xmin,xinc,this[01;31m-[00m>lisp());
minimizer.cc:641:    report[01;31m-[00m>_AngleEnergyFn = O_NumericalFunction::create("Alpha","Angle",xmin,xinc,this[01;31m-[00m>lisp());
minimizer.cc:642:    report[01;31m-[00m>_DihedralEnergyFn = O_NumericalFunction::create("Alpha","Dihedral",xmin,xinc,this[01;31m-[00m>lisp());
minimizer.cc:643:    report[01;31m-[00m>_NonbondEnergyFn = O_NumericalFunction::create("Alpha","Nonbond",xmin,xinc,this[01;31m-[00m>lisp());
minimizer.cc:644:    report[01;31m-[00m>_ImproperEnergyFn = O_NumericalFunction::create("Alpha","Improper",xmin,xinc,this[01;31m-[00m>lisp());
minimizer.cc:645:    report[01;31m-[00m>_ChiralRestraintEnergyFn = O_NumericalFunction::create("Alpha","ChiralRestraint",xmin,xinc,this[01;31m-[00m>lisp());
minimizer.cc:646:    report[01;31m-[00m>_AnchorRestraintEnergyFn = O_NumericalFunction::create("Alpha","AnchorRestraint",xmin,xinc,this[01;31m-[00m>lisp());
minimizer.cc:647:    report[01;31m-[00m>_FixedNonbondRestraintEnergyFn = O_NumericalFunction::create("Alpha","FixedNonbondRestraint",xmin,xinc,this[01;31m-[00m>lisp());
minimizer.cc:649:    for ( zx=dxa;zx<=dxc;zx+=(dxc[01;31m-[00mdxa)/100.0 ) {
minimizer.cc:650:	zy = this[01;31m-[00m>d1DTotalEnergy(zx);
minimizer.cc:651:	report[01;31m-[00m>_TotalEnergyFn[01;31m-[00m>appendValue(zy);
minimizer.cc:652:	report[01;31m-[00m>_StretchEnergyFn[01;31m-[00m>appendValue(
minimizer.cc:653:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getStretchComponent()[01;31m-[00m>getEnergy());
minimizer.cc:655:	report[01;31m-[00m>_AngleEnergyFn[01;31m-[00m>appendValue(
minimizer.cc:656:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getAngleComponent()[01;31m-[00m>getEnergy());
minimizer.cc:657:	report[01;31m-[00m>_DihedralEnergyFn[01;31m-[00m>appendValue(
minimizer.cc:658:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getDihedralComponent()[01;31m-[00m>getEnergy());
minimizer.cc:659:	report[01;31m-[00m>_NonbondEnergyFn[01;31m-[00m>appendValue(
minimizer.cc:660:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getNonbondComponent()[01;31m-[00m>getEnergy());
minimizer.cc:661:	report[01;31m-[00m>_ImproperEnergyFn[01;31m-[00m>appendValue(
minimizer.cc:662:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getImproperRestraintComponent()[01;31m-[00m>getEnergy());
minimizer.cc:663:	report[01;31m-[00m>_ChiralRestraintEnergyFn[01;31m-[00m>appendValue(
minimizer.cc:664:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getChiralRestraintComponent()[01;31m-[00m>getEnergy());
minimizer.cc:665:	report[01;31m-[00m>_AnchorRestraintEnergyFn[01;31m-[00m>appendValue(
minimizer.cc:666:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getAnchorRestraintComponent()[01;31m-[00m>getEnergy());
minimizer.cc:667:	report[01;31m-[00m>_FixedNonbondRestraintEnergyFn[01;31m-[00m>appendValue(
minimizer.cc:668:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getFixedNonbondRestraintComponent()[01;31m-[00m>getEnergy());
minimizer.cc:680:    ASSERT(report[01;31m-[00m>_Iteration == this[01;31m-[00m>_Iteration);
minimizer.cc:681:    report[01;31m-[00m>_DbrentSteps = dbrentSteps;
minimizer.cc:682:    report[01;31m-[00m>_EnergyEvals = energyEvals;
minimizer.cc:683:    report[01;31m-[00m>_ForceEvals = forceEvals;
minimizer.cc:684:    report[01;31m-[00m>_Step = step;
minimizer.cc:685:    report[01;31m-[00m>_FMin = fMin;
minimizer.cc:691:    ASSERT(report[01;31m-[00m>_Iteration == this[01;31m-[00m>_Iteration);
minimizer.cc:692:    report[01;31m-[00m>_ForceMagnitude = force[01;31m-[00m>magnitude();
minimizer.cc:693:    report[01;31m-[00m>_TotalEnergy = energy;
minimizer.cc:694:    report[01;31m-[00m>_IterationMessages = this[01;31m-[00m>_IterationMessages.str();
minimizer.cc:712:{_F(this[01;31m-[00m>lisp());
minimizer.cc:725:   this[01;31m-[00m>define1DSearch(nvOrigin,nvDirection,nvTemp1,nvTemp2);
minimizer.cc:726:   double directionMag = nvDirection[01;31m-[00m>magnitude();
minimizer.cc:728:       xb = this[01;31m-[00m>_InitialLineSearchStep;
minimizer.cc:730:	xb = this[01;31m-[00m>_InitialLineSearchStep/directionMag;
minimizer.cc:738:   this[01;31m-[00m>minBracket( nvOrigin, nvDirection,
minimizer.cc:743:   if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:745:       this[01;31m-[00m>lineSearchInitialReport(report,nvOrigin,nvDirection,nvForce,
minimizer.cc:759:   if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:761:       this[01;31m-[00m>lineSearchFinalReport( report, step, fb, energyEvals,
minimizer.cc:787:    if ( this[01;31m-[00m>_Iteration%10 == 1 || this[01;31m-[00m>_DebugOn ) 
minimizer.cc:789:	sout << "[01;31m-[00m[01;31m-[00m[01;31m-[00mStage[01;31m-[00m[01;31m-[00m";
minimizer.cc:790:	if ( this[01;31m-[00m>_ShowElapsedTime )
minimizer.cc:792:	    sout << "Seconds[01;31m-[00m";
minimizer.cc:794:	sout << "Step[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mAlpha[01;31m-[00m[01;31m-[00m[01;31m-[00mDir[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mEnergy[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mRMSforce";
minimizer.cc:795:	if ( this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getName() != "" ) 
minimizer.cc:797:	    sout << "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mName";
minimizer.cc:801:    sout << BF(" min%4s") % this[01;31m-[00m>statusAsShortString();
minimizer.cc:802:    if ( this[01;31m-[00m>_ShowElapsedTime )
minimizer.cc:804:	RPPosixTimeDuration elapsed = O_PosixTimeDuration::createDurationSince(this[01;31m-[00m>_StartTime);
minimizer.cc:805:	sout << BF(" %8ld") % elapsed[01;31m-[00m>totalSeconds();
minimizer.cc:807:    sout << BF(" %5d") % this[01;31m-[00m>_Iteration;
minimizer.cc:814:	if ( cosAngle < [01;31m-[00m1.0 ) cosAngle = [01;31m-[00m1.0;
minimizer.cc:825:    if ( this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getName() != "" ) 
minimizer.cc:827:	sout << BF(" %s") % this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getName();
minimizer.cc:830:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s") % sout.str() );
minimizer.cc:831:    if ( this[01;31m-[00m>_DebugOn ) 
minimizer.cc:833:        this[01;31m-[00m>_Log[01;31m-[00m>addMessage(buffer);
minimizer.cc:846:{_F(this[01;31m-[00m>lisp());
minimizer.cc:847:RPStepReport	stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:861:    if ( this[01;31m-[00m>_Status == minimizerError ) return;
minimizer.cc:862:    this[01;31m-[00m>_Status = steepestDescentRunning;
minimizer.cc:863:    this[01;31m-[00m>_CurrentPreconditioner = noPreconditioner;
minimizer.cc:874:    iRestartSteps = x[01;31m-[00m>size();
minimizer.cc:876:    force = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:877:    s = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:879:    dir = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:880:    tv1 = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:881:    tv2 = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:886:    double fp = this[01;31m-[00m>dTotalEnergyForce( x, force );
minimizer.cc:888://    r[01;31m-[00m>inPlaceTimesScalar([01;31m-[00m1.0);
minimizer.cc:890:    s[01;31m-[00m>copyIntoMe(force);
minimizer.cc:894:	// s = M^([01;31m-[00m1)force rather than just copying it from force
minimizer.cc:897:            s[01;31m-[00m>copy(force);
minimizer.cc:901:	    m[01;31m-[00m>fill(1.0);
minimizer.cc:902:	    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>backSubstituteDiagonalPreconditioner(m,s,force);
minimizer.cc:906:	    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>setupDiagonalPreconditioner(x,m);
minimizer.cc:907:	    LOG(BF("Preconditioner max value: %lf") % m[01;31m-[00m>maxValue() ); // vp0(( "Preconditioner max value: %lf",m[01;31m-[00m>maxValue()));
minimizer.cc:908:	    LOG(BF("Preconditioner min value: %lf") % m[01;31m-[00m>minValue() ); // vp0(( "Preconditioner min value: %lf",m[01;31m-[00m>minValue()));
minimizer.cc:909:	    minVal = m[01;31m-[00m>minValue();
minimizer.cc:911:		m[01;31m-[00m>addScalar(m,fabs(minVal)+1.0);
minimizer.cc:913:	    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>backSubstituteDiagonalPreconditioner(m,s,force);
minimizer.cc:916:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unsupported preconditioner"));
minimizer.cc:919:    dir[01;31m-[00m>copyIntoMe(s);
minimizer.cc:920:    deltaNew = force[01;31m-[00m>dotProduct(dir);
minimizer.cc:927:    if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:928:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "======= Starting Steepest Descent Minimizer" ));
minimizer.cc:937:	    forceMag = force[01;31m-[00m>magnitude();
minimizer.cc:938:	    forceRmsMag = force[01;31m-[00m>rmsMagnitude();
minimizer.cc:939:	    this[01;31m-[00m>_RMSForce = forceRmsMag;
minimizer.cc:941:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:942:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("DONE absolute force test:\nforceRmsMag(%lf).LT.forceTolerance(%lf)") % forceRmsMag % forceTolerance );
minimizer.cc:947:	    this[01;31m-[00m>_IterationMessages.str("");
minimizer.cc:961:// 1. F(x(k[01;31m-[00m1)) [01;31m-[00m F(xk) < T (1 + |F(xk)|)
minimizer.cc:962:// 2. |x(k[01;31m-[00m1) [01;31m-[00m xk| < Sqrt(T)(1+|xk|)
minimizer.cc:981:		if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:983:		    stepReport = O_StepReport::create(this[01;31m-[00m>lisp());
minimizer.cc:984:		    stepReport[01;31m-[00m>_Iteration = this[01;31m-[00m>_Iteration;
minimizer.cc:993:		dirMag = dir[01;31m-[00m>magnitude();
minimizer.cc:997:		    cosAngle = force[01;31m-[00m>dotProduct(dir)/(forceMag*dirMag);
minimizer.cc:1000:		    dir[01;31m-[00m>copyIntoMe(force);
minimizer.cc:1008:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1009:		    this[01;31m-[00m>_displayIntermediateMessage(step,fnew,forceMag,forceRmsMag,cosAngle,steepestDescent);
minimizer.cc:1012:		this[01;31m-[00m>lineSearch( &step, &fnew, x, dir, force, tv1, tv2, localSteps, stepReport );
minimizer.cc:1020:		x[01;31m-[00m>inPlaceAddTimesScalar( dir, step );
minimizer.cc:1022:			// r = [01;31m-[00mf'(x)   r == force!!!!
minimizer.cc:1026:		if ( this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getMessages() != "" ) {
minimizer.cc:1027:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("O_Minimizer::steepestDescentWithPreconditioner>> energy function messages: %s",this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getMessages().c_str());
minimizer.cc:1028:		    this[01;31m-[00m>_IterationMessages << this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getMessages();
minimizer.cc:1032:		if ( this[01;31m-[00m>_DebugOn ) {
minimizer.cc:1033:		    this[01;31m-[00m>stepReport(stepReport,fp,force);
minimizer.cc:1038:		this[01;31m-[00m>validateForce(x,force);
minimizer.cc:1043:	s[01;31m-[00m>copyIntoMe(force);
minimizer.cc:1048:			s[01;31m-[00m>copy(force);
minimizer.cc:1051:			m[01;31m-[00m>fill(1.0);
minimizer.cc:1052:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>backSubstituteDiagonalPreconditioner(m,s,force);
minimizer.cc:1056:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>setupDiagonalPreconditioner(x,m);
minimizer.cc:1057:			LOG(BF("Preconditioner max value: %lf") % m[01;31m-[00m>maxValue()  ); // vp0(( "Preconditioner max value: %lf",m[01;31m-[00m>maxValue() ));
minimizer.cc:1058:			LOG(BF("Preconditioner min value: %lf") % m[01;31m-[00m>minValue()  ); // vp0(( "Preconditioner min value: %lf",m[01;31m-[00m>minValue() ));
minimizer.cc:1059:			minVal = m[01;31m-[00m>minValue();
minimizer.cc:1061:			    m[01;31m-[00m>addScalar(m,fabs(minVal)+1.0);
minimizer.cc:1063:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>backSubstituteDiagonalPreconditioner(m,s,force);
minimizer.cc:1064:    //		    if ( s[01;31m-[00m>dotProduct(force) < 0 ) {
minimizer.cc:1065:    //			s[01;31m-[00m>copy(force);
minimizer.cc:1069:			TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unsupported preconditioner"));
minimizer.cc:1073:		dir[01;31m-[00m>copyIntoMe(s);
minimizer.cc:1074:	        if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1076:		    ASSERT_NOT_NULL(this[01;31m-[00m>_Log);
minimizer.cc:1077:		    this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1078:		    stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1081:		this[01;31m-[00m>_Iteration++;
minimizer.cc:1083:	    if ( this[01;31m-[00m>_StepCallback[01;31m-[00m>notNil() )
minimizer.cc:1084:		this[01;31m-[00m>_StepCallback[01;31m-[00m>invoke(this[01;31m-[00m>sharedThis<O_Minimizer>());
minimizer.cc:1087:	if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1090:	    if ( stepReport[01;31m-[00m>notNil() )
minimizer.cc:1092:		stepReport[01;31m-[00m>prematureTermination("ExceededNumSteps");
minimizer.cc:1093:		this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1094:		stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1103:	this[01;31m-[00m>_EnergyFunction[01;31m-[00m>writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1104:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("%s")%fail.message()));
minimizer.cc:1107:    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1109:    if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1113:	if ( stepReport[01;31m-[00m>notNil() )
minimizer.cc:1116:	    stepReport[01;31m-[00m>prematureTermination("Stuck");
minimizer.cc:1117:	    ASSERT_NOT_NULL(this[01;31m-[00m>_Log);
minimizer.cc:1119:	    this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1121:	    stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1133:{_F(this[01;31m-[00m>lisp());
minimizer.cc:1134:RPStepReport	stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1151:    if ( this[01;31m-[00m>_Status == minimizerError ) return;
minimizer.cc:1152:    this[01;31m-[00m>_Status = conjugateGradientRunning;
minimizer.cc:1153:    this[01;31m-[00m>_CurrentPreconditioner = noPreconditioner;
minimizer.cc:1161:    iRestartSteps = x[01;31m-[00m>size();
minimizer.cc:1163:    force = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:1164:    s = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:1165:    d = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:1166:    tv1 = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:1167:    tv2 = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:1171://    r[01;31m-[00m>inPlaceTimesScalar([01;31m-[00m1.0);
minimizer.cc:1173:	// s = M^([01;31m-[00m1)r rather than just copying it from r
minimizer.cc:1174:    s[01;31m-[00m>copyIntoMe(force);
minimizer.cc:1178:	    s[01;31m-[00m>copy(force);
minimizer.cc:1181:	    diag = O_NVector::create(iRestartSteps,this[01;31m-[00m>lisp());
minimizer.cc:1182:	    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>setupDiagonalPreconditioner(x,diag);
minimizer.cc:1183:	    LOG(BF("Preconditioner max value: %lf") % diag[01;31m-[00m>maxValue() ); // vp0(( "Preconditioner max value: %lf",diag[01;31m-[00m>maxValue()));
minimizer.cc:1184:	    LOG(BF("Preconditioner min value: %lf") % diag[01;31m-[00m>minValue() ); // vp0(( "Preconditioner min value: %lf",diag[01;31m-[00m>minValue()));
minimizer.cc:1185:	    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>backSubstituteDiagonalPreconditioner(diag,s,force);
minimizer.cc:1190:	    m[01;31m-[00m>fill(0.0);
minimizer.cc:1191:	    ldlt[01;31m-[00m>fill(0.0);
minimizer.cc:1192:	    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>setupHessianPreconditioner(x,m);
minimizer.cc:1193:	    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>unconventionalModifiedCholeskyFactorization(m,ldlt);
minimizer.cc:1194:	    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>backSubstituteLDLt(ldlt,s,force);
minimizer.cc:1197:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown preconditioner option"));
minimizer.cc:1200:    d[01;31m-[00m>copyIntoMe(s);
minimizer.cc:1201:    deltaNew = force[01;31m-[00m>dotProduct(d);
minimizer.cc:1209:    if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1210:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "======= Starting Conjugate Gradient Minimizer" ));
minimizer.cc:1219:	    forceMag = force[01;31m-[00m>magnitude();
minimizer.cc:1220:	    forceRmsMag = force[01;31m-[00m>rmsMagnitude();
minimizer.cc:1221:	    this[01;31m-[00m>_RMSForce = forceRmsMag;
minimizer.cc:1223:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1224:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("DONE absolute force test:\nforceRmsMag(%lf).LT.forceTolerance(%lf)")% forceRmsMag % forceTolerance );
minimizer.cc:1229:	    this[01;31m-[00m>_IterationMessages.str("");
minimizer.cc:1233:		    if ( this[01;31m-[00m>_PrintIntermediateResults )
minimizer.cc:1235:			this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "Exceeded max number of steps(%d)") % numSteps );
minimizer.cc:1244:		    MinimizerError_Stuck fail("CG[01;31m-[00mTwo successive steps went nowhere!!!!");
minimizer.cc:1254:// 1. F(x(k[01;31m-[00m1)) [01;31m-[00m F(xk) < T (1 + |F(xk)|)
minimizer.cc:1255:// 2. |x(k[01;31m-[00m1) [01;31m-[00m xk| < Sqrt(T)(1+|xk|)
minimizer.cc:1273:		if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1275:		    stepReport = O_StepReport::create(this[01;31m-[00m>lisp());
minimizer.cc:1276:		    stepReport[01;31m-[00m>_Iteration = this[01;31m-[00m>_Iteration;
minimizer.cc:1281:	//	deltaD = d[01;31m-[00m>squared();	// Used for secant method
minimizer.cc:1289:		dirMag = d[01;31m-[00m>magnitude();
minimizer.cc:1296:		    cosAngle = force[01;31m-[00m>dotProduct(d)/(forceMag*dirMag);
minimizer.cc:1299:		    d[01;31m-[00m>copyIntoMe(force);
minimizer.cc:1304:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1305:		    this[01;31m-[00m>_displayIntermediateMessage(prevStep,fnew,forceMag,forceRmsMag,cosAngle,steepestDescent);
minimizer.cc:1308:		this[01;31m-[00m>lineSearch( &step, &fnew, x, d, force,
minimizer.cc:1314:			// r = [01;31m-[00mf'(x)   r == force!!!!
minimizer.cc:1315:		x[01;31m-[00m>inPlaceAddTimesScalar( d, step );
minimizer.cc:1319:		if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1321:		    this[01;31m-[00m>stepReport(stepReport,fp,force);
minimizer.cc:1326:		this[01;31m-[00m>validateForce(x,force);
minimizer.cc:1329:		deltaMid = force[01;31m-[00m>dotProduct(s);
minimizer.cc:1332:		s[01;31m-[00m>copyIntoMe(force);
minimizer.cc:1336:			// s = M^([01;31m-[00m1)r
minimizer.cc:1339:			s[01;31m-[00m>copy(force);
minimizer.cc:1342:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>setupDiagonalPreconditioner(x,diag);
minimizer.cc:1343:			LOG(BF("Preconditioner max value: %lf") % diag[01;31m-[00m>maxValue() ); // vp0(( "Preconditioner max value: %lf",diag[01;31m-[00m>maxValue()));
minimizer.cc:1344:			LOG(BF("Preconditioner min value: %lf") % diag[01;31m-[00m>minValue() ); // vp0(( "Preconditioner min value: %lf",diag[01;31m-[00m>minValue()));
minimizer.cc:1345:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>backSubstituteDiagonalPreconditioner(diag,s,force);
minimizer.cc:1350:			    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>setupHessianPreconditioner(x,m);
minimizer.cc:1351:			    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>unconventionalModifiedCholeskyFactorization(m,ldlt);
minimizer.cc:1354:			this[01;31m-[00m>_EnergyFunction[01;31m-[00m>backSubstituteLDLt(ldlt,s,force);
minimizer.cc:1357:			TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown preconditioner option"));
minimizer.cc:1360:		deltaNew = force[01;31m-[00m>dotProduct(s);		// deltaNew = r.r
minimizer.cc:1361:		beta = (deltaNew[01;31m-[00mdeltaMid)/deltaOld;
minimizer.cc:1364:		    d[01;31m-[00m>copyIntoMe(s);
minimizer.cc:1368:		    d[01;31m-[00m>XPlusYTimesScalar(s,d,beta);
minimizer.cc:1370:		if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1372:		    ASSERT_NOT_NULL(this[01;31m-[00m>_Log);
minimizer.cc:1373:		    this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1374:		    stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1377:		this[01;31m-[00m>_Iteration++;
minimizer.cc:1379:	    if ( this[01;31m-[00m>_StepCallback[01;31m-[00m>notNil() )
minimizer.cc:1380:		this[01;31m-[00m>_StepCallback[01;31m-[00m>invoke(this[01;31m-[00m>sharedThis<O_Minimizer>());
minimizer.cc:1383:	if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1385:	    if ( stepReport[01;31m-[00m>notNil() )
minimizer.cc:1387:		stepReport[01;31m-[00m>prematureTermination("ExceededNumSteps");
minimizer.cc:1388:		this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1389:		stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1397:	this[01;31m-[00m>_EnergyFunction[01;31m-[00m>writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1398:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("%s")%fail.message()));
minimizer.cc:1400:	if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1402:	    if ( stepReport[01;31m-[00m>notNil() )
minimizer.cc:1404:		stepReport[01;31m-[00m>prematureTermination("Stuck");
minimizer.cc:1405:		this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1406:		stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1414:	this[01;31m-[00m>_EnergyFunction[01;31m-[00m>writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1415:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("%s")%fail.message()));
minimizer.cc:1418:    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1419:    if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1421:	if ( stepReport[01;31m-[00m>notNil() )
minimizer.cc:1423:	    stepReport[01;31m-[00m>prematureTermination("Stuck");
minimizer.cc:1424:	    this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1425:	    stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1447:{_TF(this[01;31m-[00m>lisp(),BF("O_Minimizer::_truncatedNewtonInnerLoop>> k = %d")%kk);
minimizer.cc:1456:    ASSERT_NOT_NULL(this[01;31m-[00m>_EnergyFunction);
minimizer.cc:1458:    nvDummy = O_NVector::nil(this[01;31m-[00m>lisp());
minimizer.cc:1459:    nmDummy = O_SparseLargeSquareMatrix::nil(this[01;31m-[00m>lisp());
minimizer.cc:1461:    if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1463:	this[01;31m-[00m>_Log[01;31m-[00m>addMessage("_truncatedNewtonInnerLoop>>Starting\n");
minimizer.cc:1467:    pj[01;31m-[00m>zero();	// NVector
minimizer.cc:1469:    delta = 10.0e[01;31m-[00m10;
minimizer.cc:1472:    rj[01;31m-[00m>copyIntoMe(force);
minimizer.cc:1486:    LOG(BF("this[01;31m-[00m>_EnergyFunction.use_count() = %d") % this[01;31m-[00m>_EnergyFunction.use_count()  ); // vp0(( "this[01;31m-[00m>_EnergyFunction.use_count() = %d", this[01;31m-[00m>_EnergyFunction.use_count() ));
minimizer.cc:1489://    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>unconventionalModifiedCholeskyFactorization(mprecon,ldlt);
minimizer.cc:1493:	// systems: (L)(x)=(rj) and (L^T)(zj)=(D^[01;31m-[00m1)(x)
minimizer.cc:1501:    dj[01;31m-[00m>copyIntoMe(zj);
minimizer.cc:1503:    rjDotzj = rj[01;31m-[00m>dotProduct(zj);
minimizer.cc:1507:	    // Compute the matrix[01;31m-[00mvector product qj=(H)(dj)
minimizer.cc:1509:	    // or |((dj)^T).(qj)|<=delta (e.g., delta=10^[01;31m-[00m10)
minimizer.cc:1513:	this[01;31m-[00m>_EnergyFunction[01;31m-[00m>evaluateAll( xk, true, nvDummy,
minimizer.cc:1518:	// rjDotzj = rj[01;31m-[00m>dotProduct(zj);
minimizer.cc:1519:	djDotqj = dj[01;31m-[00m>dotProduct(qj);
minimizer.cc:1522:		pj[01;31m-[00m>copyIntoMe(force);
minimizer.cc:1524:	    if ( this[01;31m-[00m>_DebugOn ) {
minimizer.cc:1527:		this[01;31m-[00m>_Log[01;31m-[00m>addMessage(ss.str().c_str());
minimizer.cc:1528:		this[01;31m-[00m>_Log[01;31m-[00m>addMessage("_truncatedNewtonInnerLoop>>Singularity test was true\n" );
minimizer.cc:1539:	    //	{pj+1}[01;31m-[00m>pj + alphaj*dj
minimizer.cc:1547:	pjNext[01;31m-[00m>XPlusYTimesScalar(pj,dj,alphaj);
minimizer.cc:1548:	LOG(BF("pjNext angle with force=%lf(deg)") % pjNext[01;31m-[00m>angleWithVector(force)/0.0174533 ); // vp0(( "pjNext angle with force=%lf(deg)",pjNext[01;31m-[00m>angleWithVector(force)/0.0174533));
minimizer.cc:1549:	forceDotpjNext = force[01;31m-[00m>dotProduct(pjNext);
minimizer.cc:1552:		pj[01;31m-[00m>copyIntoMe(force);
minimizer.cc:1554:		// pk[01;31m-[00m>copy(pj);  pk is pj
minimizer.cc:1556:	    if ( this[01;31m-[00m>_DebugOn ) {
minimizer.cc:1557:		this[01;31m-[00m>_Log[01;31m-[00m>addMessage("_truncatedNewtonInnerLoop>>Descent direction test was true\n" );
minimizer.cc:1564:	    // Compute rjNext = rj [01;31m-[00m (alphaj)(qj)
minimizer.cc:1570:	rj[01;31m-[00m>inPlaceAddTimesScalar(qj,[01;31m-[00malphaj);
minimizer.cc:1571:	rmsRjMag = rj[01;31m-[00m>rmsMagnitude();
minimizer.cc:1574:	    pj[01;31m-[00m>copyIntoMe(pjNext);
minimizer.cc:1575:	    if ( this[01;31m-[00m>_DebugOn ) {
minimizer.cc:1576:		this[01;31m-[00m>_Log[01;31m-[00m>addMessage("_truncatedNewtonInnerLoop>>Truncation test was true\n" );
minimizer.cc:1583:	    pj[01;31m-[00m>copyIntoMe(pjNext);
minimizer.cc:1584:	    if ( this[01;31m-[00m>_DebugOn ) {
minimizer.cc:1585:		this[01;31m-[00m>_Log[01;31m-[00m>addMessage("_truncatedNewtonInnerLoop>>Step limit test was true\n" );
minimizer.cc:1599:	rjDotzjNext = rj[01;31m-[00m>dotProduct(zj);
minimizer.cc:1602:	dj[01;31m-[00m>XPlusYTimesScalar(zj,dj,betaj);
minimizer.cc:1604:	pj[01;31m-[00m>copyIntoMe(pjNext);
minimizer.cc:1613:#define	EPSILONF	1.0e[01;31m-[00m10
minimizer.cc:1614:#define	EPSILONG	1.0e[01;31m-[00m8
minimizer.cc:1615:#define	SQRT_EPSILONF	1.0e[01;31m-[00m5
minimizer.cc:1616:#define	CUBERT_EPSILONF	4.6416e[01;31m-[00m4
minimizer.cc:1622:{_F(this[01;31m-[00m>lisp());
minimizer.cc:1623:RPStepReport		stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1634:#define	TENEMINUS8	10.0e[01;31m-[00m8
minimizer.cc:1638:    if ( this[01;31m-[00m>_Status == minimizerError ) return;
minimizer.cc:1639:    this[01;31m-[00m>_Status = truncatedNewtonRunning;
minimizer.cc:1640:    this[01;31m-[00m>_CurrentPreconditioner = this[01;31m-[00m>_TruncatedNewtonPreconditioner;
minimizer.cc:1644:    iDimensions = xK[01;31m-[00m>size();
minimizer.cc:1645:    forceK = O_NVector::create(iDimensions,this[01;31m-[00m>lisp());
minimizer.cc:1647:    xKNext = O_NVector::create(iDimensions,this[01;31m-[00m>lisp());
minimizer.cc:1649:    pK = O_NVector::create(iDimensions,this[01;31m-[00m>lisp());
minimizer.cc:1651:    pK[01;31m-[00m>zero();
minimizer.cc:1653:    pjNext = O_NVector::create(iDimensions,this[01;31m-[00m>lisp());
minimizer.cc:1655:    rj = O_NVector::create(iDimensions,this[01;31m-[00m>lisp());
minimizer.cc:1656:    dj = O_NVector::create(iDimensions,this[01;31m-[00m>lisp());
minimizer.cc:1657:    zj = O_NVector::create(iDimensions,this[01;31m-[00m>lisp());
minimizer.cc:1658:    qj = O_NVector::create(iDimensions,this[01;31m-[00m>lisp());
minimizer.cc:1659:    kSum = O_NVector::create(iDimensions,this[01;31m-[00m>lisp());
minimizer.cc:1660:    mprecon = O_SparseLargeSquareMatrix::create(this[01;31m-[00m>lisp(),iDimensions,SymmetricUpperDiagonal);
minimizer.cc:1661:    ldlt=O_SparseLargeSquareMatrix::create(this[01;31m-[00m>lisp(),iDimensions,SymmetricUpperDiagonal);
minimizer.cc:1662:    mprecon[01;31m-[00m>fill(0.0);
minimizer.cc:1663:    ldlt[01;31m-[00m>fill(0.0);
minimizer.cc:1669:    rmsForceMag = forceK[01;31m-[00m>rmsMagnitude();
minimizer.cc:1675:    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>setupHessianPreconditioner(xK,mprecon);
minimizer.cc:1679:    if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1680://	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("======= Starting Steepest Descent Minimizer\nn" );
minimizer.cc:1681://	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "======= Starting Conjugate Gradient Minimizer" ));
minimizer.cc:1682:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "======= Starting Truncated Newton Minimizer" ));
minimizer.cc:1690:	    if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1692:		stepReport = O_StepReport::create(this[01;31m-[00m>lisp());
minimizer.cc:1693:		stepReport[01;31m-[00m>_Iteration = this[01;31m-[00m>_Iteration;
minimizer.cc:1709:	    if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1710:		dirMag = pK[01;31m-[00m>magnitude();
minimizer.cc:1711:		forceMag = forceK[01;31m-[00m>magnitude();
minimizer.cc:1716:		    cosAngle = forceK[01;31m-[00m>dotProduct(pK)/(forceMag*dirMag);
minimizer.cc:1720:		if ( this[01;31m-[00m>_PrintIntermediateResults )
minimizer.cc:1722:		    this[01;31m-[00m>_displayIntermediateMessage(prevAlphaK,energyXkNext,forceMag,rmsForceMag,cosAngle,false);
minimizer.cc:1727:	    this[01;31m-[00m>lineSearch( &alphaK, &energyXkNext, xK, pK, forceK,
minimizer.cc:1729:	    xKNext[01;31m-[00m>XPlusYTimesScalar(xK,pK,alphaK);
minimizer.cc:1734:	    if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1736:		this[01;31m-[00m>stepReport(stepReport,fp,forceK);
minimizer.cc:1743:	    b1aTest=fabs(energyXkNext[01;31m-[00menergyXk)<EPSILONF*(1.0+fabs(energyXk));
minimizer.cc:1747:	    LOG(BF("fabs[energyXkNext[01;31m-[00menergyXk]=%le") % fabs(energyXkNext[01;31m-[00menergyXk) ); // vp0(( "fabs[energyXkNext[01;31m-[00menergyXk]=%le",fabs(energyXkNext[01;31m-[00menergyXk)));
minimizer.cc:1750:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1751:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "terminating due to b1aTest" ));
minimizer.cc:1755:	    delta = xKNext[01;31m-[00m>rmsDistanceFrom(xK);
minimizer.cc:1756:	    rmsMagXKNext = xKNext[01;31m-[00m>rmsMagnitude();
minimizer.cc:1759:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1760:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "terminating due to b1bTest" ));
minimizer.cc:1765:	    rmsForceMag = forceK[01;31m-[00m>rmsMagnitude();
minimizer.cc:1767:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1768:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "terminating due to absolute force test" ));
minimizer.cc:1778:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1779:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "terminating due to b1cTest" ));
minimizer.cc:1785:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:1786:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF( "terminating due to b1dTest" ));
minimizer.cc:1797:	    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>setupHessianPreconditioner(xK,mprecon);
minimizer.cc:1799:	    xK[01;31m-[00m>copyIntoMe(xKNext);
minimizer.cc:1801:	    this[01;31m-[00m>_Iteration++;
minimizer.cc:1802:	    if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1804:		ASSERT_NOT_NULL(this[01;31m-[00m>_Log);
minimizer.cc:1805:		this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1806:		stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1814:	    if ( this[01;31m-[00m>_StepCallback[01;31m-[00m>notNil() )
minimizer.cc:1815:		this[01;31m-[00m>_StepCallback[01;31m-[00m>invoke(this[01;31m-[00m>sharedThis<O_Minimizer>());
minimizer.cc:1818:	if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1820:	    if ( stepReport[01;31m-[00m>notNil() )
minimizer.cc:1822:		stepReport[01;31m-[00m>prematureTermination("ExceededNumSteps");
minimizer.cc:1823:		this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1824:		stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1832:	this[01;31m-[00m>_EnergyFunction[01;31m-[00m>writeCoordinatesAndForceToAtoms(xK,forceK);
minimizer.cc:1833:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("%s")%fail.message()));
minimizer.cc:1836:    xK[01;31m-[00m>copyIntoMe(xKNext);
minimizer.cc:1838:    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>writeCoordinatesAndForceToAtoms(xK,forceK);
minimizer.cc:1839:    if ( this[01;31m-[00m>_DebugOn )
minimizer.cc:1841:	if ( stepReport[01;31m-[00m>notNil() )
minimizer.cc:1843:	    stepReport[01;31m-[00m>prematureTermination("Stuck");
minimizer.cc:1844:	    this[01;31m-[00m>_Log[01;31m-[00m>addReport(stepReport);
minimizer.cc:1845:	    stepReport = O_StepReport::nil(this[01;31m-[00m>lisp());
minimizer.cc:1865:[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
minimizer.cc:1866:[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
minimizer.cc:1867:[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
minimizer.cc:1872:{_F(this[01;31m-[00m>lisp());
minimizer.cc:1884:    iSize = nvPos[01;31m-[00m>size();
minimizer.cc:1885:    nvDir       = O_NVector::create( iSize ,this[01;31m-[00m>lisp());
minimizer.cc:1886:    nvNewPos    = O_NVector::create( iSize ,this[01;31m-[00m>lisp());
minimizer.cc:1887:    nvNewForce = O_NVector::create( iSize ,this[01;31m-[00m>lisp());
minimizer.cc:1888:    nvTempPos   = O_NVector::create( iSize ,this[01;31m-[00m>lisp());
minimizer.cc:1889:    nvTempForce= O_NVector::create( iSize ,this[01;31m-[00m>lisp());
minimizer.cc:1892:    this[01;31m-[00m>_Iteration = 1;
minimizer.cc:1894:        dEnergy = this[01;31m-[00m>dTotalEnergyForce( nvPos, nvNewForce);
minimizer.cc:1896:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Evaluating energy step#%d") % iCount );
minimizer.cc:1909:    if ( this[01;31m-[00m>_DebugOn ) {
minimizer.cc:1910:        report = this[01;31m-[00m>_EnergyFunction[01;31m-[00m>checkIfAnalyticalForceMatchesNumericalForce(pos,force);
minimizer.cc:1911:        this[01;31m-[00m>_Log[01;31m-[00m>addReport(report);
minimizer.cc:1938:    this[01;31m-[00m>Base::initialize();
minimizer.cc:1940:    this[01;31m-[00m>bFCallback   = NULL;
minimizer.cc:1942:    this[01;31m-[00m>_DebugOn = false;
minimizer.cc:1943:    this[01;31m-[00m>useDefaultSettings();
minimizer.cc:1944:    this[01;31m-[00m>restart();
minimizer.cc:1945:    this[01;31m-[00m>_StepCallback = O_LispCallback::nil(this[01;31m-[00m>lisp());
minimizer.cc:1952:    this[01;31m-[00m>_InitialLineSearchStep = 0.01;
minimizer.cc:1953:    this[01;31m-[00m>_NumberOfSteepestDescentSteps = MAXSTEEPESTDESCENTSTEPS;
minimizer.cc:1954:    this[01;31m-[00m>_SteepestDescentTolerance = 2000.0;
minimizer.cc:1955:    this[01;31m-[00m>_NumberOfConjugateGradientSteps = MAXCONJUGATEGRADIENTSTEPS;
minimizer.cc:1956:    this[01;31m-[00m>_ConjugateGradientTolerance = 10.0;		//	Use this for now, later add TN minimizer and switch to that when this is <10.0
minimizer.cc:1957:    this[01;31m-[00m>_NumberOfTruncatedNewtonSteps = MAXTRUNCATEDNEWTONSTEPS;
minimizer.cc:1958:    this[01;31m-[00m>_TruncatedNewtonTolerance = 0.00000001;
minimizer.cc:1959:    this[01;31m-[00m>_TruncatedNewtonPreconditioner = hessianPreconditioner;
minimizer.cc:1960:    this[01;31m-[00m>_PrintIntermediateResults = false;
minimizer.cc:1961:    LOG(BF("_PrintIntermediateResults = %d") % this[01;31m-[00m>_PrintIntermediateResults  ); // vp0(("_PrintIntermediateResults = %d",this[01;31m-[00m>_PrintIntermediateResults ));
minimizer.cc:1962:    this[01;31m-[00m>_ReportEverySteps = [01;31m-[00m1;
minimizer.cc:1963:    this[01;31m-[00m>_Status = minimizerIdle;
minimizer.cc:1964:    this[01;31m-[00m>_ShowElapsedTime = true;
minimizer.cc:1967:    this[01;31m-[00m>iPythonCallbackEverySteps = 1;
minimizer.cc:1968:    this[01;31m-[00m>POPythonCallback = NULL;
minimizer.cc:1971:    this[01;31m-[00m>_MinGradientMean = MIN_GRADIENT_MEAN;
minimizer.cc:1979:{_F(this[01;31m-[00m>lisp());
minimizer.cc:1980:    this[01;31m-[00m>_PrintIntermediateResults = true;
minimizer.cc:1987:{_F(this[01;31m-[00m>lisp());
minimizer.cc:1988:    this[01;31m-[00m>_PrintIntermediateResults = false;
minimizer.cc:1996:    this[01;31m-[00m>_EnergyFunction = f;
minimizer.cc:1997:    this[01;31m-[00m>_Iteration = 1;
minimizer.cc:2003:    if ( this[01;31m-[00m>_EnergyFunction[01;31m-[00m>isNil() )
minimizer.cc:2005:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must define an energy function to minimize"));
minimizer.cc:2007:    this[01;31m-[00m>_Iteration = 1;
minimizer.cc:2008:    pos = O_NVector::create(this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
minimizer.cc:2009:    this[01;31m-[00m>_EnergyFunction[01;31m-[00m>extractCoordinatesFromAtoms(pos);
minimizer.cc:2010:    this[01;31m-[00m>_evaluateEnergyAndForceManyTimes(numSteps,pos);
minimizer.cc:2020:    this[01;31m-[00m>_StartTime = O_PosixTime::createNow(this[01;31m-[00m>lisp());
minimizer.cc:2021:    if ( this[01;31m-[00m>_EnergyFunction[01;31m-[00m>isNil() )
minimizer.cc:2023:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must define an energy function to minimize"));
minimizer.cc:2025:    pos = O_NVector::create(this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
minimizer.cc:2031:		this[01;31m-[00m>_EnergyFunction[01;31m-[00m>extractCoordinatesFromAtoms(pos);
minimizer.cc:2032:		this[01;31m-[00m>_steepestDescent(this[01;31m-[00m>_NumberOfSteepestDescentSteps,pos,
minimizer.cc:2033:					this[01;31m-[00m>_SteepestDescentTolerance );
minimizer.cc:2035:		this[01;31m-[00m>_EnergyFunction[01;31m-[00m>dealWithProblem(ld);
minimizer.cc:2036:		retries[01;31m-[00m[01;31m-[00m;
minimizer.cc:2038:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:2039:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Dealt with problem(%s)") % ld._Message.c_str());
minimizer.cc:2044:	this[01;31m-[00m>_Message.str("");
minimizer.cc:2045:	this[01;31m-[00m>_Message<<"Steepest descent minimizer exceeded max("
minimizer.cc:2047:	this[01;31m-[00m>_Status = minimizerError;
minimizer.cc:2050:	this[01;31m-[00m>_Status = minimizerError;
minimizer.cc:2051:	this[01;31m-[00m>_Message << "There was a persistant interaction problem";
minimizer.cc:2062:    this[01;31m-[00m>_StartTime = O_PosixTime::createNow(this[01;31m-[00m>lisp());
minimizer.cc:2063:    if ( this[01;31m-[00m>_EnergyFunction[01;31m-[00m>isNil() )
minimizer.cc:2065:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must define an energy function to minimize"));
minimizer.cc:2067:    pos = O_NVector::create(this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
minimizer.cc:2073:		this[01;31m-[00m>_EnergyFunction[01;31m-[00m>extractCoordinatesFromAtoms(pos);
minimizer.cc:2074:		this[01;31m-[00m>_conjugateGradient(this[01;31m-[00m>_NumberOfConjugateGradientSteps,pos,
minimizer.cc:2075:					this[01;31m-[00m>_ConjugateGradientTolerance );
minimizer.cc:2077:		this[01;31m-[00m>_EnergyFunction[01;31m-[00m>dealWithProblem(ld);
minimizer.cc:2078:		retries[01;31m-[00m[01;31m-[00m;
minimizer.cc:2080:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:2081:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Dealt with problem(%s)") % ld._Message.c_str());
minimizer.cc:2086:	this[01;31m-[00m>_Message.str("");
minimizer.cc:2087:	this[01;31m-[00m>_Message<<"Conjugate gradient minimizer exceeded max("
minimizer.cc:2089:	this[01;31m-[00m>_Status = minimizerError;
minimizer.cc:2091:	this[01;31m-[00m>_Message.str("");
minimizer.cc:2092:	this[01;31m-[00m>_Message<< fail.message() ;
minimizer.cc:2093:	this[01;31m-[00m>_Status = minimizerError;
minimizer.cc:2096:	this[01;31m-[00m>_Status = minimizerError;
minimizer.cc:2097:	this[01;31m-[00m>_Message << "There was a persistant interaction problem";
minimizer.cc:2103:{_F(this[01;31m-[00m>lisp());
minimizer.cc:2104:    this[01;31m-[00m>_Status = minimizerIdle;
minimizer.cc:2105:    this[01;31m-[00m>minimize();
minimizer.cc:2110:{_F(this[01;31m-[00m>lisp());
minimizer.cc:2114:    this[01;31m-[00m>_StartTime = O_PosixTime::createNow(this[01;31m-[00m>lisp());
minimizer.cc:2115:    if ( this[01;31m-[00m>_EnergyFunction[01;31m-[00m>isNil() )
minimizer.cc:2117:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must define an energy function to minimize"));
minimizer.cc:2119:    pos = O_NVector::create(this[01;31m-[00m>_EnergyFunction[01;31m-[00m>getNVectorSize(),this[01;31m-[00m>lisp());
minimizer.cc:2125:		this[01;31m-[00m>_EnergyFunction[01;31m-[00m>extractCoordinatesFromAtoms(pos);
minimizer.cc:2126:		if ( this[01;31m-[00m>_NumberOfSteepestDescentSteps > 0 ) {
minimizer.cc:2127:		    this[01;31m-[00m>_steepestDescent( this[01;31m-[00m>_NumberOfSteepestDescentSteps,
minimizer.cc:2128:					pos, this[01;31m-[00m>_SteepestDescentTolerance );
minimizer.cc:2130:		if ( this[01;31m-[00m>_NumberOfConjugateGradientSteps > 0 ) {
minimizer.cc:2131:		    this[01;31m-[00m>_conjugateGradient( this[01;31m-[00m>_NumberOfConjugateGradientSteps,
minimizer.cc:2132:					pos, this[01;31m-[00m>_ConjugateGradientTolerance );
minimizer.cc:2134:		if ( this[01;31m-[00m>_NumberOfTruncatedNewtonSteps > 0 ) {
minimizer.cc:2135:		    this[01;31m-[00m>_truncatedNewton( this[01;31m-[00m>_NumberOfTruncatedNewtonSteps,
minimizer.cc:2136:					pos, this[01;31m-[00m>_TruncatedNewtonTolerance );
minimizer.cc:2139:		this[01;31m-[00m>_EnergyFunction[01;31m-[00m>dealWithProblem(ld);
minimizer.cc:2140:		retries[01;31m-[00m[01;31m-[00m;
minimizer.cc:2142:		if ( this[01;31m-[00m>_PrintIntermediateResults ) {
minimizer.cc:2143:		    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Dealt with problem(%s)") % ld._Message.c_str());
minimizer.cc:2148:	this[01;31m-[00m>_Message.str("");
minimizer.cc:2149:	this[01;31m-[00m>_Message<<"Minimizer exceeded max("
minimizer.cc:2151:	this[01;31m-[00m>_Status = minimizerError;
minimizer.cc:2153:	this[01;31m-[00m>_Message.str("");
minimizer.cc:2154:	this[01;31m-[00m>_Message<< fail.message();
minimizer.cc:2155:	this[01;31m-[00m>_Status = minimizerError;
minimizer.cc:2158:	this[01;31m-[00m>_Status = minimizerError;
minimizer.cc:2159:	this[01;31m-[00m>_Message << "There was a persistant interaction problem";
minimizer.cc:2167:    xml = O_QDomNode::create(this[01;31m-[00m>lisp(),"Minimizer");
minimizer.cc:2168:    xml[01;31m-[00m>addAttributeDoubleScientific("InitialLineSearchStep",this[01;31m-[00m>_InitialLineSearchStep);
minimizer.cc:2169:    xml[01;31m-[00m>addAttributeInt("MaximumNumberOfSteepestDescentSteps",this[01;31m-[00m>_NumberOfSteepestDescentSteps);
minimizer.cc:2170:    xml[01;31m-[00m>addAttributeInt("MaximumNumberOfConjugateGradientSteps",this[01;31m-[00m>_NumberOfConjugateGradientSteps);
minimizer.cc:2171:    xml[01;31m-[00m>addAttributeInt("MaximumNumberOfTruncatedNewtonSteps",this[01;31m-[00m>_NumberOfTruncatedNewtonSteps);
minimizer.cc:2172:    xml[01;31m-[00m>addAttributeDoubleScientific("SteepestDescentTolerance",this[01;31m-[00m>_SteepestDescentTolerance);
minimizer.cc:2173:    xml[01;31m-[00m>addAttributeDoubleScientific("ConjugateGradientTolerance",this[01;31m-[00m>_ConjugateGradientTolerance);
minimizer.cc:2174:    xml[01;31m-[00m>addAttributeDoubleScientific("TruncatedNewtonTolerance",this[01;31m-[00m>_TruncatedNewtonTolerance);
minimizer.cc:2175:    xml[01;31m-[00m>addAttributeString("TruncatedNewtonPreconditioner",stringForPreconditionerType(this[01;31m-[00m>_TruncatedNewtonPreconditioner));
minimizer.cc:2185:    ss << "InitialLineSearchStep:                 " <<this[01;31m-[00m>_InitialLineSearchStep << endl;
minimizer.cc:2186:    ss << "MaximumNumberOfSteepestDescentSteps:   "<<this[01;31m-[00m>_NumberOfSteepestDescentSteps << endl;
minimizer.cc:2187:    ss << "SteepestDescentTolerance:              "<<this[01;31m-[00m>_SteepestDescentTolerance << endl;
minimizer.cc:2188:    ss << "MaximumNumberOfConjugateGradientSteps: "<<this[01;31m-[00m>_NumberOfConjugateGradientSteps << endl;
minimizer.cc:2189:    ss << "ConjugateGradientTolerance:            "<<this[01;31m-[00m>_ConjugateGradientTolerance << endl;
minimizer.cc:2190:    ss << "MaximumNumberOfTruncatedNewtonSteps: "<<this[01;31m-[00m>_NumberOfTruncatedNewtonSteps << endl;
minimizer.cc:2191:    ss << "TruncatedNewtonTolerance:            "<<this[01;31m-[00m>_TruncatedNewtonTolerance << endl;
minimizer.cc:2192:    ss << "TruncatedNewtonPreconditioner:       "<<stringForPreconditionerType(this[01;31m-[00m>_TruncatedNewtonPreconditioner)<<endl;
minimizer.cc:2198:    this[01;31m-[00m>_Status = minimizerIdle;
minimizer.cc:2199:    this[01;31m-[00m>_Message.str("");
minimizer.cc:2200:    this[01;31m-[00m>_Iteration = 1;
minimizer.cc:2223:    class_<O_Minimizer>(this[01;31m-[00m>lisp())
minimizer.cc:2252:    this[01;31m-[00m>lisp()[01;31m-[00m>installGlobalInitializationCallback(&O_Minimizer::initializeGlobals);
minimizerLog.cc:23:	this[01;31m-[00m>Base::initialize();
minimizerLog.cc:24:	this[01;31m-[00m>_Time = (unsigned long)std::time(0);
minimizerLog.cc:28:{_F(this[01;31m-[00m>lisp());
minimizerLog.cc:29:    node[01;31m-[00m>attribute("time",this[01;31m-[00m>_Time);
minimizerLog.cc:33:{_F(this[01;31m-[00m>lisp());
minimizerLog.cc:34:    this[01;31m-[00m>archiveBase(node);
minimizerLog.cc:35:    node[01;31m-[00m>archiveString("message",this[01;31m-[00m>_Message);
minimizerLog.cc:39:{_F(this[01;31m-[00m>lisp());
minimizerLog.cc:40:    this[01;31m-[00m>archiveBase(node);
minimizerLog.cc:41:    node[01;31m-[00m>archiveString("message",this[01;31m-[00m>_Message);
minimizerLog.cc:42:    node[01;31m-[00m>archiveObject("analyticalForce",this[01;31m-[00m>_AnalyticalForce);
minimizerLog.cc:43:    node[01;31m-[00m>archiveObject("numericalForce",this[01;31m-[00m>_NumericalForce);
minimizerLog.cc:49:    this[01;31m-[00m>Base::initialize();
minimizerLog.cc:50:    this[01;31m-[00m>_PrematureTermination = false;
minimizerLog.cc:51:    this[01;31m-[00m>_LineSearchPosition = O_NVector::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:52:    this[01;31m-[00m>_LineSearchDirection = O_NVector::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:53:    this[01;31m-[00m>_LineSearchForce = O_NVector::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:54:    this[01;31m-[00m>_TotalEnergyFn = O_NumericalFunction::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:55:    this[01;31m-[00m>_StretchEnergyFn = O_NumericalFunction::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:56:    this[01;31m-[00m>_AngleEnergyFn = O_NumericalFunction::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:57:    this[01;31m-[00m>_DihedralEnergyFn = O_NumericalFunction::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:58:    this[01;31m-[00m>_NonbondEnergyFn = O_NumericalFunction::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:59:    this[01;31m-[00m>_ImproperEnergyFn = O_NumericalFunction::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:60:    this[01;31m-[00m>_ChiralRestraintEnergyFn = O_NumericalFunction::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:61:    this[01;31m-[00m>_AnchorRestraintEnergyFn = O_NumericalFunction::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:62:    this[01;31m-[00m>_ImproperRestraintEnergyFn = O_NumericalFunction::nil(this[01;31m-[00m>lisp());
minimizerLog.cc:67:{_F(this[01;31m-[00m>lisp());
minimizerLog.cc:68:    this[01;31m-[00m>archiveBase(node);
minimizerLog.cc:69:    node[01;31m-[00m>attribute("_Iteration",this[01;31m-[00m>_Iteration);
minimizerLog.cc:71:    node[01;31m-[00m>attribute("_Iteration", this[01;31m-[00m>_Iteration);
minimizerLog.cc:73:    node[01;31m-[00m>attribute("_Xa", this[01;31m-[00m>_Xa);
minimizerLog.cc:74:    node[01;31m-[00m>attribute("_Xb", this[01;31m-[00m>_Xb);
minimizerLog.cc:75:    node[01;31m-[00m>attribute("_Xc", this[01;31m-[00m>_Xc);
minimizerLog.cc:76:    node[01;31m-[00m>attribute("_Fa", this[01;31m-[00m>_Fa);
minimizerLog.cc:77:    node[01;31m-[00m>attribute("_Fb", this[01;31m-[00m>_Fb);
minimizerLog.cc:78:    node[01;31m-[00m>attribute("_Fc", this[01;31m-[00m>_Fc);
minimizerLog.cc:79:    node[01;31m-[00m>attribute("_MinBracketSteps", this[01;31m-[00m>_MinBracketSteps);
minimizerLog.cc:80:    node[01;31m-[00m>attribute("_EnergyTermsEnabled", this[01;31m-[00m>_EnergyTermsEnabled);
minimizerLog.cc:81:    node[01;31m-[00m>attribute("_TotalEnergy", this[01;31m-[00m>_TotalEnergy);
minimizerLog.cc:82:    node[01;31m-[00m>attribute("_DirectionMagnitude", this[01;31m-[00m>_DirectionMagnitude);
minimizerLog.cc:83:    node[01;31m-[00m>attribute("_ForceMagnitude", this[01;31m-[00m>_ForceMagnitude);
minimizerLog.cc:85:    node[01;31m-[00m>attribute("_MinimizerStatus", this[01;31m-[00m>_MinimizerStatus);
minimizerLog.cc:87:    node[01;31m-[00m>attribute("_Direction", this[01;31m-[00m>_Direction);
minimizerLog.cc:90:    node[01;31m-[00m>archiveObjectIfDefined("_LineSearchPosition", this[01;31m-[00m>_LineSearchPosition );
minimizerLog.cc:92:    LOG(BF("this[01;31m-[00m>_LineSearchPosition use_count=%d") % this[01;31m-[00m>_LineSearchPosition.use_count()  ); // vp0(("this[01;31m-[00m>_LineSearchPosition use_count=%d",this[01;31m-[00m>_LineSearchPosition.use_count() ));
minimizerLog.cc:93:    ANN(this[01;31m-[00m>_LineSearchPosition);
minimizerLog.cc:94:    if ( this[01;31m-[00m>_LineSearchPosition[01;31m-[00m>notNil() )
minimizerLog.cc:96:	LOG(BF("this[01;31m-[00m>_LineSearchPosition size=%d") % this[01;31m-[00m>_LineSearchPosition[01;31m-[00m>size()  ); // vp0(("this[01;31m-[00m>_LineSearchPosition size=%d",this[01;31m-[00m>_LineSearchPosition[01;31m-[00m>size() ));
minimizerLog.cc:100:    node[01;31m-[00m>archiveObjectIfDefined("_LineSearchDirection", this[01;31m-[00m>_LineSearchDirection);
minimizerLog.cc:102:    ASSERT_NOT_NULL(this[01;31m-[00m>_LineSearchForce);
minimizerLog.cc:103:    node[01;31m-[00m>archiveObjectIfDefined("_LineSearchForce", this[01;31m-[00m>_LineSearchForce);
minimizerLog.cc:106:    ASSERT_NOT_NULL(this[01;31m-[00m>_TotalEnergyFn);
minimizerLog.cc:107:    node[01;31m-[00m>archiveObjectIfDefined("_TotalEnergyFn",  this[01;31m-[00m>_TotalEnergyFn);
minimizerLog.cc:109:    ASSERT_NOT_NULL(this[01;31m-[00m>_StretchEnergyFn);
minimizerLog.cc:110:    node[01;31m-[00m>archiveObjectIfDefined("_StretchEnergyFn",  this[01;31m-[00m>_StretchEnergyFn);
minimizerLog.cc:112:    ASSERT_NOT_NULL(this[01;31m-[00m>_AngleEnergyFn);
minimizerLog.cc:113:    node[01;31m-[00m>archiveObjectIfDefined("_AngleEnergyFn",  this[01;31m-[00m>_AngleEnergyFn);
minimizerLog.cc:115:    ASSERT_NOT_NULL(this[01;31m-[00m>_DihedralEnergyFn);
minimizerLog.cc:116:    node[01;31m-[00m>archiveObjectIfDefined("_DihedralEnergyFn",  this[01;31m-[00m>_DihedralEnergyFn);
minimizerLog.cc:118:    ASSERT_NOT_NULL(this[01;31m-[00m>_NonbondEnergyFn);
minimizerLog.cc:119:    node[01;31m-[00m>archiveObjectIfDefined("_NonbondEnergyFn",  this[01;31m-[00m>_NonbondEnergyFn);
minimizerLog.cc:121:    ASSERT_NOT_NULL(this[01;31m-[00m>_ImproperEnergyFn);
minimizerLog.cc:122:    node[01;31m-[00m>archiveObjectIfDefined("_ImproperEnergyFn",  this[01;31m-[00m>_ImproperEnergyFn);
minimizerLog.cc:124:    ASSERT_NOT_NULL(this[01;31m-[00m>_ChiralRestraintEnergyFn);
minimizerLog.cc:125:    node[01;31m-[00m>archiveObjectIfDefined("_ChiralRestraintEnergyFn",  this[01;31m-[00m>_ChiralRestraintEnergyFn);
minimizerLog.cc:127:    ASSERT_NOT_NULL(this[01;31m-[00m>_AnchorRestraintEnergyFn);
minimizerLog.cc:128:    node[01;31m-[00m>archiveObjectIfDefined("_AnchorRestraintEnergyFn",  this[01;31m-[00m>_AnchorRestraintEnergyFn);
minimizerLog.cc:129:    ASSERT_NOT_NULL(this[01;31m-[00m>_ImproperRestraintEnergyFn);
minimizerLog.cc:130:    node[01;31m-[00m>archiveObjectIfDefined("_ImproperRestraintEnergyFn",  this[01;31m-[00m>_ImproperRestraintEnergyFn);
minimizerLog.cc:132:    node[01;31m-[00m>attribute("_DbrentSteps", this[01;31m-[00m>_DbrentSteps);
minimizerLog.cc:134:    node[01;31m-[00m>attribute("_EnergyEvals", this[01;31m-[00m>_EnergyEvals);
minimizerLog.cc:136:    node[01;31m-[00m>attribute("_ForceEvals", this[01;31m-[00m>_ForceEvals);
minimizerLog.cc:137:    node[01;31m-[00m>attribute("_Step", this[01;31m-[00m>_Step);
minimizerLog.cc:138:    node[01;31m-[00m>attribute("_FMin", this[01;31m-[00m>_FMin);
minimizerLog.cc:139:    node[01;31m-[00m>attribute("_ForceMag", this[01;31m-[00m>_ForceMag);
minimizerLog.cc:140:    node[01;31m-[00m>attribute("_StepEnergy", this[01;31m-[00m>_StepEnergy);
minimizerLog.cc:141:    node[01;31m-[00m>attribute("_IterationMessages", this[01;31m-[00m>_IterationMessages);
minimizerLog.cc:142:    node[01;31m-[00m>attribute("_AngleBetweenDirectionAndForceDeg", this[01;31m-[00m>_AngleBetweenDirectionAndForceDeg);
minimizerLog.cc:143:    node[01;31m-[00m>attribute("_PrematureTermination", this[01;31m-[00m>_PrematureTermination);
minimizerLog.cc:144:    node[01;31m-[00m>attribute("_PrematureTerminationMessage", this[01;31m-[00m>_PrematureTerminationMessage);
minimizerLog.cc:152:{_F(this[01;31m-[00m>lisp());
minimizerLog.cc:153:    node[01;31m-[00m>archiveObject( "_Minimizer",this[01;31m-[00m>_Minimizer );
minimizerLog.cc:154:    node[01;31m-[00m>archiveList( "_Reports",this[01;31m-[00m>_Reports );
model.cc:38:    this[01;31m-[00m>_HoldSignals = false;
model.cc:43:    this[01;31m-[00m>_HoldSignals = mod._HoldSignals;
model.cc:44:    this[01;31m-[00m>_SignalsToHold = mod._SignalsToHold;
model.cc:51:{ _F(this[01;31m-[00m>lisp());
model.cc:53:    this[01;31m-[00m>Base::archiveBase(node);
model.cc:54:    if ( node[01;31m-[00m>saving() )
model.cc:56:	this[01;31m-[00m>cleanupListeners();
model.cc:59:	if ( this[01;31m-[00m>_Listeners.size() > 0 )
model.cc:61:	    LOG(BF("serializing Model: %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("serializing Model: %s",this[01;31m-[00m>description().c_str() ));
model.cc:62:	    LOG(BF("Serializing(save) %d listeners") % this[01;31m-[00m>_Listeners.size()  ); // vp0(("Serializing(save) %d listeners",this[01;31m-[00m>_Listeners.size() ));
model.cc:63:	    for ( it=this[01;31m-[00m>_Listeners.begin(); it!=this[01;31m-[00m>_Listeners.end(); it++ )
model.cc:65:		tempListeners.insert(signalIdToName(it[01;31m-[00m>first),it[01;31m-[00m>second);
model.cc:67:	    node[01;31m-[00m>archiveWeakMultiMapIgnoreBrokenWeakPointers("_listeners",tempListeners);
model.cc:68:	    node[01;31m-[00m>setRecognized(true);
model.cc:71:	    LOG(BF("There are NO listeners for Model: %s") % this[01;31m-[00m>description().c_str() ); // vp0(("There are NO listeners for Model: %s",this[01;31m-[00m>description().c_str()));
model.cc:77:	node[01;31m-[00m>archiveWeakMultiMapIfDefined("_listeners",tempListeners);
model.cc:78:	this[01;31m-[00m>_Listeners.clear();
model.cc:83:		this[01;31m-[00m>_Listeners.insert(pair<uint,WPObject>(signalNameToId(wmmi[01;31m-[00m>first),wmmi[01;31m-[00m>second));
model.cc:92:    this[01;31m-[00m>cleanupListeners();
model.cc:97:{_F(this[01;31m-[00m>lisp());
model.cc:98:    ASSERT(!this[01;31m-[00m>_HoldSignals);
model.cc:99:    this[01;31m-[00m>_HoldSignals = true;
model.cc:100:    this[01;31m-[00m>_SignalsToHold.clear();
model.cc:105:{_F(this[01;31m-[00m>lisp());
model.cc:107:    ASSERT(this[01;31m-[00m>_HoldSignals);
model.cc:108:    this[01;31m-[00m>_HoldSignals = false;
model.cc:109:    for ( it=this[01;31m-[00m>_SignalsToHold.begin(); it!=this[01;31m-[00m>_SignalsToHold.end(); it++ )
model.cc:111:        this[01;31m-[00m>signal(*it);
model.cc:113:    this[01;31m-[00m>_SignalsToHold.clear();
model.cc:120:{_F(this[01;31m-[00m>lisp());
model.cc:122:    realListener = listener[01;31m-[00m>sharedThis<O_Object>();
model.cc:123:    LOG(BF("Model %s is adding %s to its list of watchers for signal(%s)") % this[01;31m-[00m>description().c_str() % listener[01;31m-[00m>description().c_str() % signalIdToName(signal).c_str()  ); // vp0(("Model %s is adding %s to its list of watchers for signal(%s)",this[01;31m-[00m>description().c_str(),listener[01;31m-[00m>description().c_str(),signalIdToName(signal).c_str() ));
model.cc:125:    if ( this[01;31m-[00m>recognizesListenerAndSignal(realListener,signal) )
model.cc:131:	ss << realListener[01;31m-[00m>description();
model.cc:133:	ss << ") from " << this[01;31m-[00m>description();
model.cc:134:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
model.cc:137:    LOG(BF("Adding listener: %s") % realListener[01;31m-[00m>description().c_str()  ); // vp0(("Adding listener: %s",realListener[01;31m-[00m>description().c_str() ));
model.cc:138:    this[01;31m-[00m>_Listeners.insert(pair<uint,WPObject>(signal,realListener));
model.cc:143:{_F(this[01;31m-[00m>lisp());
model.cc:146:    for ( it=this[01;31m-[00m>_Listeners.begin(); it!=this[01;31m-[00m>_Listeners.end(); it++ )
model.cc:148:        if ( NotUndefined(it[01;31m-[00m>second) && it[01;31m-[00m>second.lock()[01;31m-[00m>notNil() )
model.cc:150:	    match = it[01;31m-[00m>second.lock();
model.cc:162:{_F(this[01;31m-[00m>lisp());
model.cc:165:    for ( it=this[01;31m-[00m>_Listeners.lower_bound(signal); it!=this[01;31m-[00m>_Listeners.upper_bound(signal); it++ )
model.cc:167:	if ( IsUndefined(it[01;31m-[00m>second) ) continue;
model.cc:168:        if ( it[01;31m-[00m>second.lock()[01;31m-[00m>notNil() )
model.cc:170:	    match = it[01;31m-[00m>second.lock();
model.cc:186:{_F(this[01;31m-[00m>lisp());
model.cc:192:    this[01;31m-[00m>_PythonObjects.insert(pair<uint,PythonObjectMethod>(signal,pyObjMeth));
model.cc:199:{_F(this[01;31m-[00m>lisp());
model.cc:203:    for ( it=this[01;31m-[00m>_Listeners.lower_bound(signal); it!=this[01;31m-[00m>_Listeners.upper_bound(signal); it++ )
model.cc:205:	if ( it[01;31m-[00m>second.lock()[01;31m-[00m>notNil() )
model.cc:207:	    match = it[01;31m-[00m>second.lock();
model.cc:217:	this[01;31m-[00m>_Listeners.erase(it);
model.cc:224:{_F(this[01;31m-[00m>lisp());
model.cc:229:    for ( it=this[01;31m-[00m>_Listeners.begin(); it!=this[01;31m-[00m>_Listeners.end(); it++ )
model.cc:231:        if ( it[01;31m-[00m>second.lock()[01;31m-[00m>notNil() )
model.cc:233:	    match = it[01;31m-[00m>second.lock();
model.cc:242:	this[01;31m-[00m>_Listeners.erase(*tt);
model.cc:248:{_F(this[01;31m-[00m>lisp());
model.cc:252:    res = O_ObjectList::create(this[01;31m-[00m>lisp());
model.cc:253:    for ( it=this[01;31m-[00m>_Listeners.lower_bound(signal); it!=this[01;31m-[00m>_Listeners.upper_bound(signal); it++ )
model.cc:255:	if ( it[01;31m-[00m>second.lock()[01;31m-[00m>notNil())
model.cc:257:	    obj = it[01;31m-[00m>second.lock();
model.cc:258:	    res[01;31m-[00m>append(obj);
model.cc:266:{_F(this[01;31m-[00m>lisp());
model.cc:270:    for ( it=this[01;31m-[00m>_Listeners.begin(); it!=this[01;31m-[00m>_Listeners.end(); it++ )
model.cc:272:	if ( IsUndefined(it[01;31m-[00m>second) || it[01;31m-[00m>second.lock()[01;31m-[00m>isNil() )
model.cc:279:	this[01;31m-[00m>_Listeners.erase(*tt);
model.cc:287:{_F(this[01;31m-[00m>lisp());
model.cc:296:    if ( this[01;31m-[00m>_HoldSignals )
model.cc:299:        this[01;31m-[00m>_SignalsToHold.insert(sig);
model.cc:307:    VP_SIGNAL(("%s(%s) from %s",signalType.c_str(),signalIdToName(sig).c_str(),this[01;31m-[00m>description().c_str() ));
model.cc:310:    LOG(BF("There are %d c++ listeners total [01;31m-[00m[01;31m-[00m list follows") % this[01;31m-[00m>_Listeners.size()  ); // vp0(("There are %d c++ listeners total [01;31m-[00m[01;31m-[00m list follows",this[01;31m-[00m>_Listeners.size() ));
model.cc:313:    for ( ztt=this[01;31m-[00m>_Listeners.begin(),zzi=0; ztt!=this[01;31m-[00m>_Listeners.end(); ztt++,zzi++ )
model.cc:315:	if ( ztt[01;31m-[00m>second.lock()[01;31m-[00m>notNil() )
model.cc:318:	    zmod = ztt[01;31m-[00m>second.lock();
model.cc:319:	    LOG(BF(" Listener #%03d signal(%[01;31m-[00m20s) %s") % zzi % signalIdToName(ztt[01;31m-[00m>first).c_str() % (zmod)[01;31m-[00m>description().c_str()  ); // vp0((" Listener #%03d signal(%[01;31m-[00m20s) %s", zzi, signalIdToName(ztt[01;31m-[00m>first).c_str(),(zmod)[01;31m-[00m>description().c_str() ));
model.cc:322:	    LOG(BF(" Listener #%03d signal(%[01;31m-[00m20s) %s") % zzi % signalIdToName(ztt[01;31m-[00m>first).c_str() % "[01;31m-[00m[01;31m-[00m[01;31m-[00mWeakPointer[01;31m-[00mNULL[01;31m-[00m[01;31m-[00m[01;31m-[00m"  ); // vp0((" Listener #%03d signal(%[01;31m-[00m20s) %s", zzi, signalIdToName(ztt[01;31m-[00m>first).c_str(),"[01;31m-[00m[01;31m-[00m[01;31m-[00mWeakPointer[01;31m-[00mNULL[01;31m-[00m[01;31m-[00m[01;31m-[00m" ));
model.cc:325:    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m list done[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m") ); // vp0(("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m list done[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m"));
model.cc:328:    for ( it=this[01;31m-[00m>_Listeners.lower_bound(sig); it!=this[01;31m-[00m>_Listeners.upper_bound(sig); it++ )
model.cc:330:	if ( (it[01;31m-[00m>second).lock()[01;31m-[00m>notNil() )
model.cc:332:	    target = (it[01;31m-[00m>second).lock();
model.cc:337:    VP_SIGNAL(("%s(%s) about to be caught by %s",signalType.c_str(),signalIdToName(sig).c_str(),target[01;31m-[00m>description().c_str() ));
model.cc:339:	    LOG(BF("Sending signal to listener: %s") % target[01;31m-[00m>description().c_str()  ); // vp0(("Sending signal to listener: %s",target[01;31m-[00m>description().c_str() ));
model.cc:340:	    target[01;31m-[00m>catchSignal(sig,this[01;31m-[00m>sharedThis<O_Model>());
model.cc:341:	    target[01;31m-[00m>propagateSignal(sig);
model.cc:355:    LOG(BF("There are %d PythonObjects listening for signals") % this[01;31m-[00m>_PythonObjects.size() ); // vp0(("There are %d PythonObjects listening for signals",this[01;31m-[00m>_PythonObjects.size()));
model.cc:357:    for ( zpi=this[01;31m-[00m>_PythonObjects.begin();zpi!=this[01;31m-[00m>_PythonObjects.end();zpi++)
model.cc:359:	obj = zpi[01;31m-[00m>second._Object;
model.cc:360:	objType = obj[01;31m-[00m>ob_type;
model.cc:361:        LOG(BF("   Python watching for signal(%s)  object(%s) method(%s)") % signalIdToName(zpi[01;31m-[00m>first).c_str() % objType[01;31m-[00m>tp_name % zpi[01;31m-[00m>second._Method.c_str() ); // vp0(("   Python watching for signal(%s)  object(%s) method(%s)",signalIdToName(zpi[01;31m-[00m>first).c_str(),objType[01;31m-[00m>tp_name,zpi[01;31m-[00m>second._Method.c_str()));
model.cc:363:    LOG(BF(" [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m python object list done") ); // vp0((" [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m python object list done"));
model.cc:366:    for ( pi=this[01;31m-[00m>_PythonObjects.lower_bound(sig);pi!=this[01;31m-[00m>_PythonObjects.upper_bound(sig);pi++)
model.cc:368:        obj = pi[01;31m-[00m>second._Object;
model.cc:369:	objType = obj[01;31m-[00m>ob_type;
model.cc:375:    VP_SIGNAL(("%s(%s) about to be caught by Python %s:%s",signalType.c_str(),signalIdToName(sig).c_str(),pi[01;31m-[00m>second._Comment.c_str(),pi[01;31m-[00m>second._Method.c_str() ));
model.cc:377:        boost::python::call_method<void,uint,RPModel>(obj,pi[01;31m-[00m>second._Method.c_str(),sig,this[01;31m-[00m>sharedThis<O_Model>());
model.cc:384:{_F(this[01;31m-[00m>lisp());
model.cc:385:    this[01;31m-[00m>_signal("signal",sig);
model.cc:390:{_F(this[01;31m-[00m>lisp());
model.cc:391:    this[01;31m-[00m>_signal("propagate",sig);
model.cc:399:	class_<O_Model>(this[01;31m-[00m>lisp());
moe.cc:62:		ParaValue(TYPE a) {this[01;31m-[00m>val=a;};
moe.cc:63:	void	setValue(TYPE v) {this[01;31m-[00m>val = v;};
moe.cc:64:	TYPE&	getValue()	{return this[01;31m-[00m>val;};
moe.cc:75:	    this[01;31m-[00m>erase();
moe.cc:76://	    for (i=this[01;31m-[00m>vals.begin();i!=this[01;31m-[00m>vals.end();i++) {
moe.cc:80:	void	push_back(ParaPrimValue* p) {this[01;31m-[00m>vals.push_back(p);};
moe.cc:81:	ParaPrimValue*	operator[](int i)	{return this[01;31m-[00m>vals[i];};
moe.cc:82:	int	size()	{return this[01;31m-[00m>vals.size();};
moe.cc:83:	void	erase()	{this[01;31m-[00m>vals.erase(this[01;31m-[00m>vals.begin(),this[01;31m-[00m>vals.end());};
moe.cc:89:	void	push_back(TYPE p) {this[01;31m-[00m>vals.push_back(p);};
moe.cc:90:	TYPE	operator[](int i)	{return this[01;31m-[00m>vals[i];};
moe.cc:91:	int	size()	{return this[01;31m-[00m>vals.size();};
moe.cc:92:	void	erase()	{this[01;31m-[00m>vals.erase(this[01;31m-[00m>vals.begin(),
moe.cc:93:						this[01;31m-[00m>vals.end());};
moe.cc:115:	void	addFieldVector(string f,ParaVector& v) { this[01;31m-[00m>fieldIndices[f]=this[01;31m-[00m>vectors.size(); this[01;31m-[00m>vectors.push_back(v); };
moe.cc:117:	ParaVector&	getVector(int f) {return this[01;31m-[00m>vectors[f];};
moe.cc:119:	ParaVector&	getFieldVector(string f) {return this[01;31m-[00m>vectors[this[01;31m-[00m>fieldIndices[f]];};
moe.cc:120:	int	getFieldIndex(string f) {return this[01;31m-[00m>fieldIndices[f];};
moe.cc:125:	void	erase()	{ this[01;31m-[00m>vectors.erase(this[01;31m-[00m>vectors.begin(),
moe.cc:126:					this[01;31m-[00m>vectors.end());
moe.cc:127:			  this[01;31m-[00m>fieldIndices.erase(this[01;31m-[00m>fieldIndices.begin(),
moe.cc:128:						this[01;31m-[00m>fieldIndices.end() );};
moe.cc:161:    RPLisp lisp() { return this[01;31m-[00m>_Lisp;};
moe.cc:165:	bool		nextParaTableExists() {return !this[01;31m-[00m>done;};
moe.cc:166:	string		nextParaTableName() {return this[01;31m-[00m>paraName;};
moe.cc:167:	int		nextParaTableRows() {return this[01;31m-[00m>paraRows;};
moe.cc:168:	int		nextParaTableFieldCount() {return this[01;31m-[00m>paraFieldNames.size();};
moe.cc:169:	string		nextParaTableFieldName(int i) {return this[01;31m-[00m>paraFieldNames[i];};
moe.cc:170:	string		nextParaTableFieldType(int i) {return this[01;31m-[00m>paraFieldTypes[i];};
moe.cc:194:{_F(rest[01;31m-[00m>lisp());
moe.cc:196:    if ( rest[01;31m-[00m>isOfClass<O_RestraintDistance>() )
moe.cc:200:		<< distRest[01;31m-[00m>getAtomA()[01;31m-[00m>getTempFileId() << " "
moe.cc:201:		<< distRest[01;31m-[00m>getAtomB()[01;31m-[00m>getTempFileId() << " "
moe.cc:203:		<< distRest[01;31m-[00m>getMin() << " "
moe.cc:204:		<< distRest[01;31m-[00m>getMax() << " "
moe.cc:205:		<< distRest[01;31m-[00m>getWeight() << endl;
moe.cc:208:    if ( rest[01;31m-[00m>isOfClass<O_RestraintAngle>() )
moe.cc:212:		<< distAngle[01;31m-[00m>getAtomA()[01;31m-[00m>getTempFileId() << " "
moe.cc:213:		<< distAngle[01;31m-[00m>getAtomB()[01;31m-[00m>getTempFileId() << " "
moe.cc:214:		<< distAngle[01;31m-[00m>getAtomC()[01;31m-[00m>getTempFileId() << " "
moe.cc:216:		<< distAngle[01;31m-[00m>getMin() << " "
moe.cc:217:		<< distAngle[01;31m-[00m>getMax() << " "
moe.cc:218:		<< distAngle[01;31m-[00m>getWeight() << endl;
moe.cc:223:	    << distDih[01;31m-[00m>getAtomA()[01;31m-[00m>getTempFileId() << " "
moe.cc:224:	    << distDih[01;31m-[00m>getAtomB()[01;31m-[00m>getTempFileId() << " "
moe.cc:225:	    << distDih[01;31m-[00m>getAtomC()[01;31m-[00m>getTempFileId() << " "
moe.cc:226:	    << distDih[01;31m-[00m>getAtomD()[01;31m-[00m>getTempFileId() << " "
moe.cc:228:	    << distDih[01;31m-[00m>getMinDegrees() << " "
moe.cc:229:	    << distDih[01;31m-[00m>getMaxDegrees() << " "
moe.cc:230:	    << distDih[01;31m-[00m>getWeight() << endl;
moe.cc:277:    if ( c == '[01;31m-[00m' ) return true;
moe.cc:322:    this[01;31m-[00m>_Lisp = lisp;
moe.cc:328:    if ( this[01;31m-[00m>mustDestroy_fMoe) {
moe.cc:329:	delete this[01;31m-[00m>fMoe;
moe.cc:339:{_F(this[01;31m-[00m>lisp());
moe.cc:365:		    *copy = ((prefix [01;31m-[00m 1)<<6) | ((encode[01;31m-[00m1)&0x3F);
moe.cc:407:{_F(this[01;31m-[00m>lisp());
moe.cc:413:    strcpy( line, this[01;31m-[00m>nextLine );
moe.cc:417:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Invalid moe header"));
moe.cc:419:    this[01;31m-[00m>splitLine( words, line );
moe.cc:420:    this[01;31m-[00m>paraName = words.front();
moe.cc:421:    this[01;31m-[00m>paraRows = 0;
moe.cc:423:    if ( this[01;31m-[00m>paraName == "moe" ) {
moe.cc:424:	this[01;31m-[00m>moeFileVersion = words.front();
moe.cc:434:	this[01;31m-[00m>paraRows = atoi(buf);
moe.cc:437:    this[01;31m-[00m>paraFieldNames.erase(this[01;31m-[00m>paraFieldNames.begin(),
moe.cc:438:				this[01;31m-[00m>paraFieldNames.end() );
moe.cc:439:    this[01;31m-[00m>paraFieldTypes.erase(this[01;31m-[00m>paraFieldTypes.begin(),
moe.cc:440:				this[01;31m-[00m>paraFieldTypes.end() );
moe.cc:442:	this[01;31m-[00m>paraFieldNames.push_back( words.front() );
moe.cc:444:	this[01;31m-[00m>paraFieldTypes.push_back( words.front() );
moe.cc:459:{_F(this[01;31m-[00m>lisp());
moe.cc:463:    if ( this[01;31m-[00m>fMoe[01;31m-[00m>eof() ) {
moe.cc:464:	this[01;31m-[00m>done = true;
moe.cc:467:    cPPut = this[01;31m-[00m>nextLine;
moe.cc:468:    iSize = sizeof(this[01;31m-[00m>nextLine)[01;31m-[00m1;
moe.cc:469:    while ( !this[01;31m-[00m>fMoe[01;31m-[00m>eof() && (c=this[01;31m-[00m>fMoe[01;31m-[00m>get()) && iSize>0 ) 
moe.cc:474:	    iSize[01;31m-[00m[01;31m-[00m;
moe.cc:479:    if ( this[01;31m-[00m>fMoe[01;31m-[00m>eof() ) {
moe.cc:480:	this[01;31m-[00m>done = true;
moe.cc:493:{_F(this[01;31m-[00m>lisp());
moe.cc:499:	if ( stat(sFileName,&buf)==[01;31m-[00m1 ) {
moe.cc:502:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Could not open MOE file: %s") % errStr ));
moe.cc:506:	fIn[01;31m-[00m>open(sFileName);
moe.cc:508:	this[01;31m-[00m>fileName = sFileName;
moe.cc:509:	this[01;31m-[00m>fMoe = fIn;
moe.cc:510:	this[01;31m-[00m>mustDestroy_fMoe = true;
moe.cc:511:	this[01;31m-[00m>done = false;
moe.cc:512:	this[01;31m-[00m>readNextLine();
moe.cc:513:	this[01;31m-[00m>parseHeader();
moe.cc:522:    {_F(this[01;31m-[00m>lisp());
moe.cc:523:	this[01;31m-[00m>fileName = "";
moe.cc:524:	this[01;31m-[00m>fMoe = fIn;
moe.cc:525:	this[01;31m-[00m>mustDestroy_fMoe= false;
moe.cc:526:	this[01;31m-[00m>done = false;
moe.cc:527:	this[01;31m-[00m>readNextLine();
moe.cc:528:	this[01;31m-[00m>parseHeader();
moe.cc:538:    {_F(this[01;31m-[00m>lisp());
moe.cc:561:	    LOG(BF("readParaTable[01;31m-[00m[01;31m-[00m reading next line") ); // vp0(( "readParaTable[01;31m-[00m[01;31m-[00m reading next line" ));
moe.cc:562:	    this[01;31m-[00m>readNextLine();
moe.cc:563:	    LOG(BF("Read line: %s") % this[01;31m-[00m>nextLine  ); // vp0(( "Read line: %s", this[01;31m-[00m>nextLine ));
moe.cc:564:	    if ( !this[01;31m-[00m>done && this[01;31m-[00m>nextLine[0] != '#' ) {
moe.cc:566:		this[01;31m-[00m>splitLine( words, this[01;31m-[00m>nextLine );
moe.cc:569:	} while ( !this[01;31m-[00m>done && this[01;31m-[00m>nextLine[0] != '#' );
moe.cc:573:	table[01;31m-[00m>erase();
moe.cc:574:	for ( field=0; field<this[01;31m-[00m>nextParaTableFieldCount(); field++ ) {
moe.cc:575:	    LOG(BF("Adding  fieldVector name: %s") % this[01;31m-[00m>nextParaTableFieldName(field).c_str()  ); // vp0(( "Adding  fieldVector name: %s", this[01;31m-[00m>nextParaTableFieldName(field).c_str() ));
moe.cc:576:	    table[01;31m-[00m>addFieldVector( this[01;31m-[00m>nextParaTableFieldName(field), col );
moe.cc:581:	for ( row=0; row<this[01;31m-[00m>nextParaTableRows(); row++ ) {
moe.cc:583:	    for ( field = 0; field < this[01;31m-[00m>nextParaTableFieldCount(); field++ ) {
moe.cc:585:		type = this[01;31m-[00m>nextParaTableFieldType(field);
moe.cc:593:		    table[01;31m-[00m>getVector(field).push_back(paraInt);
moe.cc:598:		    num = type.substr(2,type.length()[01;31m-[00m2);
moe.cc:603:		    table[01;31m-[00m>getVector(field).push_back(paraInt);
moe.cc:608:		    num = type.substr(2,type.length()[01;31m-[00m2);
moe.cc:613:		    table[01;31m-[00m>getVector(field).push_back(paraReal);
moe.cc:630:			paraArrayInt[01;31m-[00m>push_back(ddd);
moe.cc:632:		    table[01;31m-[00m>getVector(field).push_back(paraArrayInt);
moe.cc:649:			paraArrayDbl[01;31m-[00m>push_back(ddd);
moe.cc:651:		    table[01;31m-[00m>getVector(field).push_back(paraArrayDbl);
moe.cc:661:		    table[01;31m-[00m>getVector(field).push_back(paraHex);
moe.cc:671:		    table[01;31m-[00m>getVector(field).push_back(paraReal);
moe.cc:679:		    table[01;31m-[00m>getVector(field).push_back(paraChar);
moe.cc:687:		    table[01;31m-[00m>getVector(field).push_back(paraToken);
moe.cc:695:		    table[01;31m-[00m>getVector(field).push_back(paraString);
moe.cc:701:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(err.str()));
moe.cc:705:	if ( !this[01;31m-[00m>done && this[01;31m-[00m>nextLine[0] == '#' ) {
moe.cc:707:	    this[01;31m-[00m>parseHeader();
moe.cc:720:    {_F(this[01;31m-[00m>lisp());
moe.cc:722:	    this[01;31m-[00m>readNextLine();
moe.cc:723:	} while ( !this[01;31m-[00m>done && this[01;31m-[00m>nextLine[0] != '#' );
moe.cc:724:	if ( !this[01;31m-[00m>done && this[01;31m-[00m>nextLine[0] == '#' ) {
moe.cc:725:	    this[01;31m-[00m>parseHeader();
moe.cc:753:    {_F(agg[01;31m-[00m>lisp());
moe.cc:840:			TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown bond order type: "+f.nextParaTableFieldType(2)));
moe.cc:843:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Invalid bond entry in moe file" ));
moe.cc:883:		if ( f.nextParaTableFieldType(1)=="i=[01;31m-[00m1" ) {
moe.cc:884:		    LOG(BF("Reading aForceRS i=[01;31m-[00m1 ParaTable") ); // vp0(( "Reading aForceRS i=[01;31m-[00m1 ParaTable" ));
moe.cc:893:		    cerr << "should be... aForceRS [i=[01;31m-[00m1/i=1]" << endl;
moe.cc:932:	    mol = RP_Create<O_Molecule>(agg[01;31m-[00m>lisp());
moe.cc:934:	    agg[01;31m-[00m>addMolecule(mol);
moe.cc:936:	    numResidues = dynamic_cast<ParaInteger*>(ptMolecules.getVector(index_cResidueCount)[im])[01;31m-[00m>getValue();
moe.cc:940:		res = RP_Create<O_Residue>(agg[01;31m-[00m>lisp());
moe.cc:941:		res[01;31m-[00m>setTempFileId(ir+1);
moe.cc:942:		mol[01;31m-[00m>addMatter(res);
moe.cc:944:		numAtoms = dynamic_cast<ParaInteger*>(ptResidues.getVector(index_rAtomCount)[tir])[01;31m-[00m>getValue();
moe.cc:946:		str = dynamic_cast<ParaToken*>(ptResidues.getVector(index_rName)[tir])[01;31m-[00m>getValue();
moe.cc:947:		res[01;31m-[00m>setName( str );
moe.cc:952:		    a = RP_Create<O_Atom>(agg[01;31m-[00m>lisp());
moe.cc:953:		    a[01;31m-[00m>setMoeIndex( dynamic_cast<ParaInteger*>(ptAtoms.getVector(index_ID)[ia])[01;31m-[00m>getValue() );
moe.cc:954:		    a[01;31m-[00m>setName( dynamic_cast<ParaToken*>(ptAtoms
moe.cc:955:							 .getVector(index_aName)[ia])[01;31m-[00m>getValue() );
moe.cc:956:		    a[01;31m-[00m>setElementFromString( dynamic_cast<ParaToken*>(ptAtoms
moe.cc:957:								      .getVector(index_aElement)[ia])[01;31m-[00m>getValue() );
moe.cc:958:		    a[01;31m-[00m>setHybridizationFromString( dynamic_cast<ParaToken*>(ptAtoms
moe.cc:959:									    .getVector(index_aGeometry)[ia])[01;31m-[00m>getValue() );
moe.cc:961:						.getVector(index_aPosX)[ia])[01;31m-[00m>getValue();
moe.cc:963:						.getVector(index_aPosY)[ia])[01;31m-[00m>getValue();
moe.cc:965:						.getVector(index_aPosZ)[ia])[01;31m-[00m>getValue();
moe.cc:967:		    a[01;31m-[00m>setPosition(pos);
moe.cc:968:		    a[01;31m-[00m>resetFlags();
moe.cc:970:		    LOG(BF("Created atom: %s") % a[01;31m-[00m>getName().c_str()  ); // vp0(( "Created atom: %s", a[01;31m-[00m>getName().c_str() ));
moe.cc:971:		    res[01;31m-[00m>addAtom(a);
moe.cc:992:		aid = dynamic_cast<ParaInteger*>(ptFixed.getVector(i_id)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:994:		fixed = dynamic_cast<ParaInteger*>(ptFixed.getVector(i_fixed)[i])[01;31m-[00m>getValue();
moe.cc:998:		    atoms[aid][01;31m-[00m>modifyFlags(ATOMFLAG_ON,ATOM_FIXED);
moe.cc:1000:		    atoms[aid][01;31m-[00m>modifyFlags(ATOMFLAG_OFF,ATOM_FIXED);
moe.cc:1021:		aid = dynamic_cast<ParaInteger*>(ptCharges.getVector(i_id)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1023:		charge = dynamic_cast<ParaReal*>(ptCharges.getVector(i_charge)[i])[01;31m-[00m>getValue();
moe.cc:1026:		atoms[aid][01;31m-[00m>setCharge(charge);
moe.cc:1045:		aid = dynamic_cast<ParaInteger*>(ptMMTypes.getVector(index_mmTypeId)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1047:		type = dynamic_cast<ParaToken*>(ptMMTypes.getVector(index_mmTypes)[i])[01;31m-[00m>getValue();
moe.cc:1050:		atoms[aid][01;31m-[00m>setMoeType(type);
moe.cc:1062:		    from = dynamic_cast<ParaInteger*>(ptBonds.getVector(index_a)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1063:		    to = dynamic_cast<ParaInteger*>(ptBonds.getVector(index_b)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1064:		    LOG(BF("Read bond between atom indices %d[01;31m-[00m%d") % from+1 % to+1  ); // vp0(( "Read bond between atom indices %d[01;31m-[00m%d", from+1, to+1 ));
moe.cc:1065:		    if ( atoms[from][01;31m-[00m>getHybridization()==hybridization_sp2 &&
moe.cc:1066:			 atoms[to][01;31m-[00m>getHybridization()==hybridization_sp2 ) 
moe.cc:1069:			atoms[from][01;31m-[00m>bondTo( atoms[to], bo );
moe.cc:1070:			DEBUG_ASSERTP(!atoms[from][01;31m-[00m>invalid(),
moe.cc:1071:				      "Bond I just formed is invalid atom:"+atoms[from][01;31m-[00m>getName());
moe.cc:1072:			DEBUG_ASSERTP(!atoms[to][01;31m-[00m>invalid(),
moe.cc:1073:				      "Bond I just formed is invalid atom:"+atoms[to][01;31m-[00m>getName());
moe.cc:1076:			atoms[from][01;31m-[00m>bondTo( atoms[to], bo );
moe.cc:1077:			DEBUG_ASSERTP(!atoms[from][01;31m-[00m>invalid(),
moe.cc:1078:				      "Bond I just formed is invalid atom:"+atoms[from][01;31m-[00m>getName());
moe.cc:1079:			DEBUG_ASSERTP(!atoms[to][01;31m-[00m>invalid(),
moe.cc:1080:				      "Bond I just formed is invalid atom:"+atoms[to][01;31m-[00m>getName());
moe.cc:1082:		    LOG(BF("Installed bond between atoms: %s [01;31m-[00m %s") % atoms[from][01;31m-[00m>description().c_str() % atoms[to][01;31m-[00m>description().c_str()  ); // vp0(( "Installed bond between atoms: %s [01;31m-[00m %s", atoms[from][01;31m-[00m>description().c_str(), atoms[to][01;31m-[00m>description().c_str() ));
moe.cc:1090:		    from = dynamic_cast<ParaInteger*>(ptBondsO1.getVector(index_a)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1091:		    to = dynamic_cast<ParaInteger*>(ptBondsO1.getVector(index_b)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1092:		    LOG(BF("Read bond between atom indices %d[01;31m-[00m%d") % from+1 % to+1  ); // vp0(( "Read bond between atom indices %d[01;31m-[00m%d", from+1, to+1 ));
moe.cc:1094:		    atoms[from][01;31m-[00m>bondTo( atoms[to], bo );
moe.cc:1095:		    DEBUG_ASSERTP(!atoms[from][01;31m-[00m>invalid(),
moe.cc:1096:				  "Bond I just formed is invalid atom:"+atoms[from][01;31m-[00m>getName());
moe.cc:1097:		    DEBUG_ASSERTP(!atoms[to][01;31m-[00m>invalid(),
moe.cc:1098:				  "Bond I just formed is invalid atom:"+atoms[to][01;31m-[00m>getName());
moe.cc:1099:		    LOG(BF("Installed bond between atoms: %s [01;31m-[00m %s") % atoms[from][01;31m-[00m>description().c_str() % atoms[to][01;31m-[00m>description().c_str()  ); // vp0(( "Installed bond between atoms: %s [01;31m-[00m %s", atoms[from][01;31m-[00m>description().c_str(), atoms[to][01;31m-[00m>description().c_str() ));
moe.cc:1107:		    from = dynamic_cast<ParaInteger*>(ptBondsO2.getVector(index_a)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1108:		    to = dynamic_cast<ParaInteger*>(ptBondsO2.getVector(index_b)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1109:		    LOG(BF("Read bond between atom indices %d[01;31m-[00m%d") % from+1 % to+1  ); // vp0(( "Read bond between atom indices %d[01;31m-[00m%d", from+1, to+1 ));
moe.cc:1111:		    atoms[from][01;31m-[00m>bondTo( atoms[to], bo );
moe.cc:1112:		    DEBUG_ASSERTP(!atoms[from][01;31m-[00m>invalid(),
moe.cc:1113:				  "Bond I just formed is invalid atom:"+atoms[from][01;31m-[00m>getName());
moe.cc:1114:		    DEBUG_ASSERTP(!atoms[to][01;31m-[00m>invalid(),
moe.cc:1115:				  "Bond I just formed is invalid atom:"+atoms[to][01;31m-[00m>getName());
moe.cc:1116:		    LOG(BF("Installed bond between atoms: %s [01;31m-[00m %s") % atoms[from][01;31m-[00m>description().c_str() % atoms[to][01;31m-[00m>description().c_str()  ); // vp0(( "Installed bond between atoms: %s [01;31m-[00m %s", atoms[from][01;31m-[00m>description().c_str(), atoms[to][01;31m-[00m>description().c_str() ));
moe.cc:1124:		    from = dynamic_cast<ParaInteger*>(ptBondsO3.getVector(index_a)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1125:		    to = dynamic_cast<ParaInteger*>(ptBondsO3.getVector(index_b)[i])[01;31m-[00m>getValue()[01;31m-[00m1;
moe.cc:1126:		    LOG(BF("Read bond between atom indices %d[01;31m-[00m%d") % from+1 % to+1  ); // vp0(( "Read bond between atom indices %d[01;31m-[00m%d", from+1, to+1 ));
moe.cc:1128:		    atoms[from][01;31m-[00m>bondTo( atoms[to], bo );
moe.cc:1129:		    DEBUG_ASSERTP(!atoms[from][01;31m-[00m>invalid(),
moe.cc:1130:				  "Bond I just formed is invalid atom:"+atoms[from][01;31m-[00m>getName());
moe.cc:1131:		    DEBUG_ASSERTP(!atoms[to][01;31m-[00m>invalid(),
moe.cc:1132:				  "Bond I just formed is invalid atom:"+atoms[to][01;31m-[00m>getName());
moe.cc:1133:		    LOG(BF("Installed bond between atoms: %s [01;31m-[00m %s") % atoms[from][01;31m-[00m>description().c_str() % atoms[to][01;31m-[00m>description().c_str()  ); // vp0(( "Installed bond between atoms: %s [01;31m-[00m %s", atoms[from][01;31m-[00m>description().c_str(), atoms[to][01;31m-[00m>description().c_str() ));
moe.cc:1142:		aggRestraints = agg[01;31m-[00m>getRestraints();
moe.cc:1145:		aid = ( dynamic_cast<ParaInteger*>(ptForceRSm1.getVector(index_ID)[i])[01;31m-[00m>getValue()[01;31m-[00m1 );
moe.cc:1150:			cerr << "Atom RS[01;31m-[00m1: " << rsAtom << "  moe ID: " << rsAtom[01;31m-[00m>getMoeIndex()<< endl;
moe.cc:1152:		    restrainChiral[01;31m-[00m>setAtomA(rsAtom);
moe.cc:1153:		restrainChiral[01;31m-[00m>setChirality([01;31m-[00m1);
moe.cc:1154:		aggRestraints[01;31m-[00m>addRestraint(restrainChiral);
moe.cc:1159:		aggRestraints = agg[01;31m-[00m>getRestraints();
moe.cc:1162:		aid = ( dynamic_cast<ParaInteger*>(ptForceRSp1.getVector(index_ID)[i])[01;31m-[00m>getValue()[01;31m-[00m1 );
moe.cc:1167:			cerr << "Atom RS+1: " << rsAtom << "moe ID: " << rsAtom[01;31m-[00m>getMoeIndex()<< endl;
moe.cc:1169:		    restrainChiral[01;31m-[00m>setAtomA(rsAtom);
moe.cc:1170:		restrainChiral[01;31m-[00m>setChirality(1);
moe.cc:1171:		aggRestraints[01;31m-[00m>addRestraint(restrainChiral);
moe.cc:1179:		aid = (dynamic_cast<ParaInteger*>(ptHintLP.getVector(index_ID)[i])[01;31m-[00m>getValue()[01;31m-[00m1 );
moe.cc:1181:		LOG(BF("Setting HintLP=True for atom(%s)") % lpAtom[01;31m-[00m>getName().c_str() ); // vp0(( "Setting HintLP=True for atom(%s)",lpAtom[01;31m-[00m>getName().c_str()));
moe.cc:1182:		lpAtom[01;31m-[00m>setHintLP(true);
moe.cc:1189:		aggRestraints = agg[01;31m-[00m>getRestraints();
moe.cc:1196:		    (ptRestraints.getVector(index_type)[i])[01;31m-[00m>getValue();
moe.cc:1202:		    (ptRestraints.getVector(index_weight)[i])[01;31m-[00m>getValue();
moe.cc:1216:				 << atoms[(*resAtoms)[0][01;31m-[00m1][01;31m-[00m>getMoeIndex() << " "
moe.cc:1217:				 << atoms[(*resAtoms)[1][01;31m-[00m1][01;31m-[00m>getMoeIndex() << " "
moe.cc:1218:				 << atoms[(*resAtoms)[2][01;31m-[00m1][01;31m-[00m>getMoeIndex() << " "
moe.cc:1219:				 << atoms[(*resAtoms)[3][01;31m-[00m1][01;31m-[00m>getMoeIndex() << " " << endl;
moe.cc:1221:			restraint[01;31m-[00m>setAtomA(atoms[(*resAtoms)[0][01;31m-[00m1]);
moe.cc:1222:		    restraint[01;31m-[00m>setAtomB(atoms[(*resAtoms)[1][01;31m-[00m1]);
moe.cc:1223:		    restraint[01;31m-[00m>setAtomC(atoms[(*resAtoms)[2][01;31m-[00m1]);
moe.cc:1224:		    restraint[01;31m-[00m>setAtomD(atoms[(*resAtoms)[3][01;31m-[00m1]);
moe.cc:1225:		    restraint[01;31m-[00m>setParameters( (*target)[0], (*target)[1], weight );
moe.cc:1226:		    aggRestraints[01;31m-[00m>addRestraint(restraint);
moe.cc:1230:		    restraint[01;31m-[00m>setAtomA(atoms[(*resAtoms)[0][01;31m-[00m1]);
moe.cc:1231:		    restraint[01;31m-[00m>setAtomB(atoms[(*resAtoms)[1][01;31m-[00m1]);
moe.cc:1232:		    restraint[01;31m-[00m>setAtomC(atoms[(*resAtoms)[2][01;31m-[00m1]);
moe.cc:1233:		    restraint[01;31m-[00m>setParameters( (*target)[0], (*target)[1], weight );
moe.cc:1234:		    aggRestraints[01;31m-[00m>addRestraint(restraint);
moe.cc:1238:		    restraint[01;31m-[00m>setAtomA(atoms[(*resAtoms)[0][01;31m-[00m1]);
moe.cc:1239:		    restraint[01;31m-[00m>setAtomB(atoms[(*resAtoms)[1][01;31m-[00m1]);
moe.cc:1240:		    restraint[01;31m-[00m>setParameters( (*target)[0], (*target)[1], weight );
moe.cc:1241:		    aggRestraints[01;31m-[00m>addRestraint(restraint);
moe.cc:1282:		if ( a[01;31m-[00m>getMoeType() != "" ) {
moe.cc:1283:		    a[01;31m-[00m>setTypeString(a[01;31m-[00m>getMoeType() );
moe.cc:1284://		setType( ps, a, a[01;31m-[00m>getMoeType() );
moe.cc:1288:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>( "moeReadAggregateWithAtomTypesFromFileName[01;31m-[00m[01;31m-[00m there were no types in the file" ));
moe.cc:1354:    {_F(agg[01;31m-[00m>lisp());
moe.cc:1386:		    a[01;31m-[00m>setTempFileId(count);
moe.cc:1391:		residueNames.push_back(r[01;31m-[00m>getPdbName());  // PDBNAME
moe.cc:1392:		r[01;31m-[00m>setTempFileId(resId);
moe.cc:1409:	fout << "ViewOrientationY r* 3 [01;31m-[00m0.6040875 0.7739065 0.1901233 ViewOrientationZ r*" << endl;
moe.cc:1410:	fout << "3 0.7362871 0.4507356 0.5046968 ViewLookAt r* 3 [01;31m-[00m0.4651223 0.3664901" << endl;
moe.cc:1411:	fout << "[01;31m-[00m0.2553613 ViewScale r 21.1468887" << endl;
moe.cc:1419:	    fout << a[01;31m-[00m>getTempFileId() << " " << b[01;31m-[00m>getTempFileId() << endl;
moe.cc:1427:	    fout << a[01;31m-[00m>getTempFileId() << " ";
moe.cc:1428:	    fout << a[01;31m-[00m>getName() << " ";
moe.cc:1429:	    fout << a[01;31m-[00m>getElement() << " ";
moe.cc:1432:	    if ( a[01;31m-[00m>getHybridization() != hybridization_undefined)
moe.cc:1434:		fout << a[01;31m-[00m>getHybridizationAsString() << " ";
moe.cc:1439:	    fout << a[01;31m-[00m>getPosition().getX() << " ";
moe.cc:1440:	    fout << a[01;31m-[00m>getPosition().getY() << " ";
moe.cc:1441:	    fout << a[01;31m-[00m>getPosition().getZ() << endl;
moe.cc:1442:	    if ( a[01;31m-[00m>getFlags()&ATOM_FIXED ) fixedCount++;
moe.cc:1443:	    if ( a[01;31m-[00m>getHintLP() ) hintLPCount++;
moe.cc:1451:		if ( a[01;31m-[00m>getFlags()&ATOM_FIXED ) {
moe.cc:1452:		    fout << a[01;31m-[00m>getTempFileId();
moe.cc:1453:		    if ((ai[01;31m-[00matoms.begin())%16!=15 ) fout << " ";
moe.cc:1465:		if ( a[01;31m-[00m>getHintLP() ) {
moe.cc:1466:		    fout << a[01;31m-[00m>getTempFileId();
moe.cc:1467:		    if ((ai[01;31m-[00matoms.begin())%16!=15 ) fout << " ";
moe.cc:1480:	    fout << resOffset+i[01;31m-[00m1 << " " << (*vii) << " " ;
moe.cc:1481:	    if ( residueNames[i[01;31m-[00m1] == "" ) {
moe.cc:1484:		fout << residueNames[i[01;31m-[00m1];
moe.cc:1504:	restTotal = agg[01;31m-[00m>getRestraints()[01;31m-[00m>size();
moe.cc:1510:		restraint = agg[01;31m-[00m>getRestraints()[01;31m-[00m>getRestraintIndex(i);
moe.cc:1511:		if ( restraint[01;31m-[00m>getType()==RESTRAINT_CHIRALITY ) 
moe.cc:1513:		    if ( restraint[01;31m-[00m>getChirality() > 0 ) rsp1Count++;
moe.cc:1514:		    if ( restraint[01;31m-[00m>getChirality() < 0 ) rsm1Count++;
moe.cc:1522:		restraint = agg[01;31m-[00m>getRestraints()[01;31m-[00m>getRestraintIndex(i);
moe.cc:1523:		if ( restraint[01;31m-[00m>getType() == RESTRAINT_CHIRALITY ) {
moe.cc:1524:		    if ( restraint[01;31m-[00m>getChirality() > 0 ) {
moe.cc:1525:			fout << restraint[01;31m-[00m>getAtomA()[01;31m-[00m>getTempFileId() << endl;
moe.cc:1530:	// Handle ForceRS[01;31m-[00m1 restraints
moe.cc:1532:	    fout << "#attr " << rsm1Count << " ID i aForceRS i=[01;31m-[00m1" << endl;
moe.cc:1534:		restraint = agg[01;31m-[00m>getRestraints()[01;31m-[00m>getRestraintIndex(i);
moe.cc:1535:		if ( restraint[01;31m-[00m>getType() == RESTRAINT_CHIRALITY ) {
moe.cc:1536:		    if ( restraint[01;31m-[00m>getChirality() < 0 ) {
moe.cc:1537:			fout << restraint[01;31m-[00m>getAtomA()[01;31m-[00m>getTempFileId() << endl;
moe.cc:1545:	// Handle non[01;31m-[00mchiral restraints
moe.cc:1549:		restraint = agg[01;31m-[00m>getRestraints()[01;31m-[00m>getRestraintIndex(i);
moe.cc:1550:		if ( restraint[01;31m-[00m>getType() != RESTRAINT_CHIRALITY ) {
moe.cc:1565:    {_F(agg[01;31m-[00m>lisp());
moe.cc:1578:    {_F(agg[01;31m-[00m>lisp());
moe.cc:1596:    {_F(a[01;31m-[00m>lisp());
moeForceField.cc:57:                this[01;31m-[00m>sval = *(mffp_lval.sval);
moeForceField.cc:60:                this[01;31m-[00m>sval = *(mffp_lval.sval);
moeForceField.cc:63:                this[01;31m-[00m>dval = (mffp_lval.dval);
moeForceField.cc:84:    LOG(BF("moeDebugForceFieldParser[01;31m-[00m[01;31m-[00m entered") ); // vp0(( "moeDebugForceFieldParser[01;31m-[00m[01;31m-[00m entered" ));
moeForceField.cc:93:    LOG(BF("moeDebugForceFieldParser[01;31m-[00m[01;31m-[00m exiting") ); // vp0(( "moeDebugForceFieldParser[01;31m-[00m[01;31m-[00m exiting" ));
mol2.cc:53:	this[01;31m-[00m>mLine.str("");
mol2.cc:65:		    this[01;31m-[00m>mLine.put(c);
mol2.cc:70:    stringstream&	line() { return this[01;31m-[00m>mLine; };
mol2.cc:73:	queueSplitString(this[01;31m-[00m>mLine.str(), qWords, " \t" );
mol2.cc:77:	if ( this[01;31m-[00m>eof() ) return false;
mol2.cc:78:	if ( this[01;31m-[00m>mLine.str().size() == 0 ) return false;
mol2.cc:79:	if ( this[01;31m-[00m>mLine.str()[0] != '@' ) return true;
mol2.cc:84:	this[01;31m-[00m>fIn.open(fileName.c_str(), ios::in);
mol2.cc:85:	if ( this[01;31m-[00m>fIn.fail() ) {
mol2.cc:86:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Mol2 file doesn't exist: %s" ) % fileName ));
mol2.cc:88:	this[01;31m-[00m>advanceLine();
mol2.cc:90:    RPLisp lisp() { return this[01;31m-[00m>_Lisp;};
mol2.cc:91:    Mol2File(RPLisp lisp) {this[01;31m-[00m>_Lisp=lisp;};
mol2.cc:153:        seqNum = [01;31m-[00m1;
mol2.cc:181:    nm = a[01;31m-[00m>getName();
mol2.cc:213:    neighbors = a[01;31m-[00m>numberOfBonds();
mol2.cc:232:    a[01;31m-[00m>setElement(el);
mol2.cc:233:    a[01;31m-[00m>setHybridization(geom);
mol2.cc:261:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Mol2 file encountered data line when expecting command line in top level: %s") % fIn.line().str() ));
mol2.cc:282:	        TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Mol2 file encountered cmd line when expecting data line: %s") % fIn.line().str() ));
mol2.cc:347:	    lastmId = [01;31m-[00m1;
mol2.cc:359:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("First entry of SUBSTRUCTURE records are not valid"));
mol2.cc:407:	    _lisp[01;31m-[00m>print(BF("Ignoring mol2 command: %s") % line.c_str() );
mol2.cc:419:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There can be only one @<TRIPOS>MOLECULE entry"));
mol2.cc:422:    aggregate[01;31m-[00m>setName(mi[01;31m-[00m>mMoleculeName);
mol2.cc:432:	a = RP_Create<O_Atom>(aggregate[01;31m-[00m>lisp()); // new_RPAtom();
mol2.cc:433:	a[01;31m-[00m>setName(ai[01;31m-[00m>second.atom_name);
mol2.cc:435:	LOG(BF("Creating atom with id: %d name: %s element: %s charge: %8.2f") % ai[01;31m-[00m>second.mIndex % ai[01;31m-[00m>second.atom_name.c_str() % el.c_str() % ai[01;31m-[00m>second.mCharge  ); // vp0(( "Creating atom with id: %d name: %s element: %s charge: %8.2f", ai[01;31m-[00m>second.mIndex, ai[01;31m-[00m>second.atom_name.c_str(), el.c_str(), ai[01;31m-[00m>second.mCharge ));
mol2.cc:436:	pos.set(ai[01;31m-[00m>second.mX,ai[01;31m-[00m>second.mY,ai[01;31m-[00m>second.mZ);
mol2.cc:437:	a[01;31m-[00m>setPosition(pos);
mol2.cc:438:	a[01;31m-[00m>setTypeString(ai[01;31m-[00m>second.mType);
mol2.cc:439:	a[01;31m-[00m>setCharge(ai[01;31m-[00m>second.mCharge);
mol2.cc:440:	LOG(BF(" atom info: %s") % a[01;31m-[00m>description().c_str()  ); // vp0(( " atom info: %s", a[01;31m-[00m>description().c_str() ));
mol2.cc:441:	ai[01;31m-[00m>second.mAtom = a;
mol2.cc:446:	if ( residues.count(ai[01;31m-[00m>second.mSubstId)==0 ) {
mol2.cc:447:	    res = RP_Create<O_Residue>(aggregate[01;31m-[00m>lisp()); // new_RPResidue();
mol2.cc:453:	    res[01;31m-[00m>setName(ai[01;31m-[00m>second.mSubstName);
mol2.cc:454:	    res[01;31m-[00m>setPdbName(ai[01;31m-[00m>second.mSubstName);
mol2.cc:455:	    LOG(BF("Creating residue with id(%d) and name(%s)") % ai[01;31m-[00m>second.mSubstId % ai[01;31m-[00m>second.mSubstName.c_str()  ); // vp0(( "Creating residue with id(%d) and name(%s)", ai[01;31m-[00m>second.mSubstId, ai[01;31m-[00m>second.mSubstName.c_str() ));
mol2.cc:456:	    residues[ai[01;31m-[00m>second.mSubstId] = res;
mol2.cc:457:	    LOG(BF("New residue %s") % res[01;31m-[00m>description().c_str()  ); // vp0(( "New residue %s",res[01;31m-[00m>description().c_str() ));
mol2.cc:459:	    res = residues[ai[01;31m-[00m>second.mSubstId];
mol2.cc:460:	    LOG(BF("Reusing residue with mSubstId=%d %s") % ai[01;31m-[00m>second.mSubstId % res[01;31m-[00m>description().c_str()  ); // vp0(( "Reusing residue with mSubstId=%d %s",ai[01;31m-[00m>second.mSubstId, res[01;31m-[00m>description().c_str() ));
mol2.cc:462:	LOG(BF("Adding atom(%s) to residue(%s) SubstId(%d)") % a[01;31m-[00m>getName().c_str() % res[01;31m-[00m>getPdbName().c_str() % ai[01;31m-[00m>second.mSubstId  ); // vp0(( "Adding atom(%s) to residue(%s) SubstId(%d)", a[01;31m-[00m>getName().c_str(), res[01;31m-[00m>getPdbName().c_str(), ai[01;31m-[00m>second.mSubstId ));
mol2.cc:463:	res[01;31m-[00m>addAtom(a);
mol2.cc:473:	LOG(BF("Creating bond between atom id: %d [01;31m-[00m %d") % bi[01;31m-[00m>mAtom1Id % bi[01;31m-[00m>mAtom2Id  ); // vp0(( "Creating bond between atom id: %d [01;31m-[00m %d", bi[01;31m-[00m>mAtom1Id, bi[01;31m-[00m>mAtom2Id ));
mol2.cc:474:	a1 = atoms[bi[01;31m-[00m>mAtom1Id].mAtom;
mol2.cc:475:	a2 = atoms[bi[01;31m-[00m>mAtom2Id].mAtom;
mol2.cc:476:	LOG(BF("Creating bond between %s [01;31m-[00m %s") % a1[01;31m-[00m>description().c_str() % a2[01;31m-[00m>description().c_str()  ); // vp0(( "Creating bond between %s [01;31m-[00m %s", a1[01;31m-[00m>description().c_str(), a2[01;31m-[00m>description().c_str() ));
mol2.cc:477:	if ( bi[01;31m-[00m>mOrder=="1" ) bo = singleBond;
mol2.cc:478:	else if ( bi[01;31m-[00m>mOrder=="2" ) bo = doubleBond;
mol2.cc:479:	else if ( bi[01;31m-[00m>mOrder=="3" ) bo = tripleBond;
mol2.cc:480:	else if ( bi[01;31m-[00m>mOrder=="ar" ) bo = aromaticBond;
mol2.cc:482:	a1[01;31m-[00m>bondTo(a2,bo);
mol2.cc:494:		if ( chains.count(si[01;31m-[00m>chain) == 0 ) {
mol2.cc:495:		    LOG(BF("Creating molecule: %s") % si[01;31m-[00m>chain.c_str()  ); // vp0(( "Creating molecule: %s", si[01;31m-[00m>chain.c_str() ));
mol2.cc:496:		    m = RP_Create<O_Molecule>(aggregate[01;31m-[00m>lisp());
mol2.cc:498:		    m[01;31m-[00m>setName(si[01;31m-[00m>chain);
mol2.cc:500:		    aggregate[01;31m-[00m>addMolecule(m);
mol2.cc:501:		    LOG(BF("setting chains index=%s") % si[01;31m-[00m>chain.c_str() ); // vp0(( "setting chains index=%s", si[01;31m-[00m>chain.c_str()));
mol2.cc:502:		    chains[si[01;31m-[00m>chain] = m;
mol2.cc:505:		m = chains[si[01;31m-[00m>chain];
mol2.cc:506:		if ( m[01;31m-[00m>isNil() )
mol2.cc:508:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Could not find molecule with chain=%s") % si[01;31m-[00m>chain.c_str()));
mol2.cc:510:		LOG(BF("Looking up residue with mId=%d") % si[01;31m-[00m>mId ); // vp0(( "Looking up residue with mId=%d", si[01;31m-[00m>mId));
mol2.cc:511:		res = residues[si[01;31m-[00m>mId];
mol2.cc:512:		if ( res[01;31m-[00m>isNil() )
mol2.cc:515:		    serr << "Could not find residue with si[01;31m-[00m>mId=";
mol2.cc:516:		    serr << si[01;31m-[00m>mId;
mol2.cc:518:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
mol2.cc:520:		LOG(BF("Adding residue(use_count=%d) to molecule(use_count=%d)") % residues[si[01;31m-[00m>mId].use_count() % m.use_count() ); // vp0(( "Adding residue(use_count=%d) to molecule(use_count=%d)", residues[si[01;31m-[00m>mId].use_count(),m.use_count()));
mol2.cc:521:		m[01;31m-[00m>addMatter(residues[si[01;31m-[00m>mId]);
mol2.cc:522:		LOG(BF("Setting residue name at index: %d") % si[01;31m-[00m>mId  ); // vp0(( "Setting residue name at index: %d", si[01;31m-[00m>mId ));
mol2.cc:523:		LOG(BF("Setting residue name to: %s") % si[01;31m-[00m>subst_name.c_str()  ); // vp0(("Setting residue name to: %s",si[01;31m-[00m>subst_name.c_str() ));
mol2.cc:524:		residues[si[01;31m-[00m>mId][01;31m-[00m>setName(si[01;31m-[00m>subst_name);
mol2.cc:525:		LOG(BF("Setting residue PDB name to: %s") % si[01;31m-[00m>sub_type.c_str()  ); // vp0(("Setting residue PDB name to: %s",si[01;31m-[00m>sub_type.c_str() ));
mol2.cc:526:		residues[si[01;31m-[00m>mId][01;31m-[00m>setPdbName(si[01;31m-[00m>sub_type);
mol2.cc:527:		LOG(BF("Setting residue file_sequence_number(%d)") % si[01;31m-[00m>file_sequence_number ); // vp0(("Setting residue file_sequence_number(%d)",si[01;31m-[00m>file_sequence_number));
mol2.cc:528:		residues[si[01;31m-[00m>mId][01;31m-[00m>setFileSequenceNumber(si[01;31m-[00m>file_sequence_number);
mol2.cc:529:		LOG(BF("Adding residue number: %d name(%s) pdbName(%s) to molecule: %s") % si[01;31m-[00m>mId % residues[si[01;31m-[00m>mId][01;31m-[00m>getName().c_str() % residues[si[01;31m-[00m>mId][01;31m-[00m>getPdbName().c_str() % si[01;31m-[00m>chain.c_str()  ); // vp0(( "Adding residue number: %d name(%s) pdbName(%s) to molecule: %s", si[01;31m-[00m>mId, residues[si[01;31m-[00m>mId][01;31m-[00m>getName().c_str(), residues[si[01;31m-[00m>mId][01;31m-[00m>getPdbName().c_str(), si[01;31m-[00m>chain.c_str() ));
mol2.cc:537:	mol = RP_Create<O_Molecule>(aggregate[01;31m-[00m>lisp());
mol2.cc:541:	    mol[01;31m-[00m>addMatter(rit[01;31m-[00m>second);
mol2.cc:543:	aggregate[01;31m-[00m>addMolecule(mol);
mol2.cc:550:	_calculateElementAndHybridization(ai[01;31m-[00m>second.mAtom);
mol2.cc:585:    atomCount = agg[01;31m-[00m>numberOfAtoms();
mol2.cc:602:    out << agg[01;31m-[00m>getName() << endl;
mol2.cc:620:	r[01;31m-[00m>setTempFileId(resId);
mol2.cc:628:	    a[01;31m-[00m>setTempFileId(atomId);
mol2.cc:630:	    one._SybylType = sybylRules[01;31m-[00m>calculateType(a);
mol2.cc:646:	m[01;31m-[00m>setName(nameId);
mol2.cc:658:	a = ai[01;31m-[00m>_Atom;
mol2.cc:659:	out << a[01;31m-[00m>getTempFileId() << " ";
mol2.cc:660:	out << a[01;31m-[00m>getName() << " ";
mol2.cc:661:	pos = a[01;31m-[00m>getPosition();
mol2.cc:665:	LOG(BF("Writing mol2 atom(%s) pos(%s)") % a[01;31m-[00m>description() % a[01;31m-[00m>getPosition().asString() );
mol2.cc:666:	out << ai[01;31m-[00m>_SybylType << " ";
mol2.cc:667:	out << a[01;31m-[00m>containedBy().lock()[01;31m-[00m>getTempFileId() << " ";
mol2.cc:668:	out << a[01;31m-[00m>containedBy().lock()[01;31m-[00m>getName() << "_"
mol2.cc:669:		<< a[01;31m-[00m>containedBy().lock()[01;31m-[00m>getTempFileId() << " ";
mol2.cc:673:	out << a[01;31m-[00m>getCharge() << endl;
mol2.cc:694:	out << a1[01;31m-[00m>getTempFileId() << " ";
mol2.cc:695:	out << a2[01;31m-[00m>getTempFileId() << " ";
mol2.cc:708:	r = ri[01;31m-[00m>res;
mol2.cc:710:	out << r[01;31m-[00m>getTempFileId() << " ";
mol2.cc:711:	out << r[01;31m-[00m>getName() << "_" << r[01;31m-[00m>getTempFileId() << " ";
mol2.cc:712:	out << ri[01;31m-[00m>firstAtom << " ";
mol2.cc:714:	out << downcast<O_Molecule>(r[01;31m-[00m>containedBy().lock())[01;31m-[00m>getName() << " ";
mol2.cc:715:	out << r[01;31m-[00m>getName() << " 1";
mol2.cc:724:{_F(agg[01;31m-[00m>lisp());
mol2.cc:727:    mol2WriteAggregateStream( agg, fout,agg[01;31m-[00m>lisp() );
mol2.cc:734:{_F(matter[01;31m-[00m>lisp());
mol2.cc:735:    if ( matter[01;31m-[00m>isOfClass<O_Aggregate>() )
mol2.cc:741:    if ( matter[01;31m-[00m>isOfClass<O_Molecule>() )
mol2.cc:744:	RPAggregate agg = O_Aggregate::create(matter[01;31m-[00m>lisp());
mol2.cc:745:	agg[01;31m-[00m>addMolecule(mol);
mol2.cc:749:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>("You must pass a Molecule or Aggregate"));
mol2.cc:761:    wilds[01;31m-[00m>addWildName("XX");
mol2.cc:762:    wilds[01;31m-[00m>addWildNameMap("XX","C");
mol2.cc:763:    wilds[01;31m-[00m>addWildNameMap("XX","N");
mol2.cc:764:    wilds[01;31m-[00m>addWildNameMap("XX","O");
mol2.cc:765:    wilds[01;31m-[00m>addWildNameMap("XX","S");
mol2.cc:766:    wilds[01;31m-[00m>addWildNameMap("XX","P");
mol2.cc:768:    wilds[01;31m-[00m>addWildName("XA");
mol2.cc:769:    wilds[01;31m-[00m>addWildNameMap("XA","O");
mol2.cc:770:    wilds[01;31m-[00m>addWildNameMap("XA","S");
mol2.cc:772:    wilds[01;31m-[00m>addWildName("XB");
mol2.cc:773:    wilds[01;31m-[00m>addWildNameMap("XB","N");
mol2.cc:774:    wilds[01;31m-[00m>addWildNameMap("XB","P");
mol2.cc:776:    wilds[01;31m-[00m>addWildName("XC");
mol2.cc:777:    wilds[01;31m-[00m>addWildNameMap("XC","F");
mol2.cc:778:    wilds[01;31m-[00m>addWildNameMap("XC","Cl");
mol2.cc:779:    wilds[01;31m-[00m>addWildNameMap("XC","Br");
mol2.cc:780:    wilds[01;31m-[00m>addWildNameMap("XC","I");
mol2.cc:782:    wilds[01;31m-[00m>addWildName("XD");
mol2.cc:783:    wilds[01;31m-[00m>addWildNameMap("XD","S");
mol2.cc:784:    wilds[01;31m-[00m>addWildNameMap("XD","P");
mol2.cc:785:    sybylRules[01;31m-[00m>setWildElementDict(wilds);
mol2.cc:861:	match[01;31m-[00m>compileAntechamber(typeRuleString,wilds);
mol2.cc:862:	rule[01;31m-[00m>setAssignTypeName(match[01;31m-[00m>getAssignType());
mol2.cc:863:	rule[01;31m-[00m>setCode(match);
mol2.cc:864:	sybylRules[01;31m-[00m>appendRule(rule);
molecule.cc:29:    lr.loopTopMoleculeGoal( this[01;31m-[00m>sharedThis<O_Molecule>(), RESIDUES );
molecule.cc:42:    this[01;31m-[00m>Base::initialize();
molecule.cc:43:    this[01;31m-[00m>_Restraints = O_RestraintList::create(this[01;31m-[00m>lisp());
molecule.cc:48:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
molecule.cc:53:    return this[01;31m-[00m>Base::__repr__();
molecule.cc:57:{_F(this[01;31m-[00m>lisp());
molecule.cc:65:    this[01;31m-[00m>O_Matter::archiveBase(node);
molecule.cc:66:    node[01;31m-[00m>archiveContainerIfNotEmpty("Restraints",this[01;31m-[00m>_Restraints);
molecule.cc:67:    if ( node[01;31m-[00m>saving() ) {
molecule.cc:69:        _BLOCK_TRACE("Xmling inter[01;31m-[00mresidue bonds");
molecule.cc:70:	bondList = RP_Create<O_BondList>(this[01;31m-[00m>lisp());
molecule.cc:73:	    lb.loopTopMoleculeGoal( this[01;31m-[00m>sharedThis<O_Molecule>(), BONDS );
molecule.cc:77:		// LOG(BF("bond with atom1=%s") % a1[01;31m-[00m>description().c_str()  ); // vp0(( "bond with atom1=%s", a1[01;31m-[00m>description().c_str() ));
molecule.cc:78:		// LOG(BF("bond with atom2=%s") % a2[01;31m-[00m>description().c_str()  ); // vp0(( "bond with atom2=%s", a2[01;31m-[00m>description().c_str() ));
molecule.cc:80:		bond = RP_Create<O_Bond>(this[01;31m-[00m>lisp());
molecule.cc:81:		bond[01;31m-[00m>setOrder(o);
molecule.cc:82:		bond[01;31m-[00m>setFrom(a1);
molecule.cc:83:		bond[01;31m-[00m>setTo(a2);
molecule.cc:84:		if ( bond[01;31m-[00m>isInterResidueBond() ) {
molecule.cc:85:		    LOG(BF("Adding bond between atom1(%s) and atom2(%s)") % a1[01;31m-[00m>description().c_str() % a2[01;31m-[00m>description().c_str()  ); // vp0(( "Adding bond between atom1(%s) and atom2(%s)", a1[01;31m-[00m>description().c_str(), a2[01;31m-[00m>description().c_str() ));
molecule.cc:86:		    bondList[01;31m-[00m>addBond(bond);
molecule.cc:90:	node[01;31m-[00m>archiveObject<O_BondList>("bl",bondList);
molecule.cc:93:	bondList = O_BondList::nil(this[01;31m-[00m>lisp());
molecule.cc:94:	node[01;31m-[00m>archiveObject<O_BondList>("bl",bondList);
molecule.cc:96:	bondList[01;31m-[00m>imposeYourself();
molecule.cc:130:{_F(this[01;31m-[00m>lisp());
molecule.cc:131:    this[01;31m-[00m>addMatter( r );
molecule.cc:132:    LOG(BF("Added %s to %s") % r[01;31m-[00m>description().c_str() % this[01;31m-[00m>description().c_str()  ); // vp0(( "Added %s to %s", r[01;31m-[00m>description().c_str(), this[01;31m-[00m>description().c_str() ));
molecule.cc:142:    LOG(BF("Adding %s to %s") % r[01;31m-[00m>description().c_str() % this[01;31m-[00m>description().c_str()  ); // vp0(( "Adding %s to %s", r[01;31m-[00m>description().c_str(), this[01;31m-[00m>description().c_str() ));
molecule.cc:143:    this[01;31m-[00m>addMatterRetainId( r );
molecule.cc:158:    for ( it=this[01;31m-[00m>getContents().begin(); it!= this[01;31m-[00m>getContents().end(); it++ ) {
molecule.cc:160:	    this[01;31m-[00m>eraseContent(it);
molecule.cc:164:    TOSS(_lisp[01;31m-[00m>create<O_LispError>( "removeResidue: Molecule does not contain residue: %s", a[01;31m-[00m>getName() ) );
molecule.cc:169:{_F(this[01;31m-[00m>lisp());
molecule.cc:170:    if ( this[01;31m-[00m>eqV(obj) ) return true;
molecule.cc:171:    if ( !obj[01;31m-[00m>isOfClass<O_Molecule>() ) return false;
molecule.cc:172:    RPMolecule other = obj[01;31m-[00m>as<O_Molecule>();
molecule.cc:173:    if ( other[01;31m-[00m>getName() != this[01;31m-[00m>getName() ) return false;
molecule.cc:174:    if ( other[01;31m-[00m>_contents.size() != this[01;31m-[00m>_contents.size() ) return false;
molecule.cc:176:    for ( tit=this[01;31m-[00m>_contents.begin(), oit=other[01;31m-[00m>_contents.begin();
molecule.cc:177:	    tit!=this[01;31m-[00m>_contents.end(); tit++, oit++ )
molecule.cc:179:	if ( ! (*tit)[01;31m-[00m>equal(*oit) ) return false;
molecule.cc:184:{_F(this[01;31m-[00m>lisp());
molecule.cc:185:    if ( !obj[01;31m-[00m>isOfClass<O_Molecule>() ) 
molecule.cc:187:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You can only transfer coordinates to a Molecule from another Molecule"));
molecule.cc:189:    RPMolecule other = obj[01;31m-[00m>as<O_Molecule>();
molecule.cc:190:    if ( other[01;31m-[00m>_contents.size() != this[01;31m-[00m>_contents.size() )
molecule.cc:192:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You can only transfer coordinates if the two Molecules have the same number of contents"));
molecule.cc:195:    for ( tit=this[01;31m-[00m>_contents.begin(), oit=other[01;31m-[00m>_contents.begin();
molecule.cc:196:	    tit!=this[01;31m-[00m>_contents.end(); tit++, oit++ )
molecule.cc:198:	(*tit)[01;31m-[00m>transferCoordinates(*oit);
molecule.cc:207:    rHead = this[01;31m-[00m>getContents().begin();
molecule.cc:209:    for ( r=rRest;r!=this[01;31m-[00m>getContents().end(); ) {
molecule.cc:210:	for ( a = (*r)[01;31m-[00m>getContents().begin(); a!= (*r)[01;31m-[00m>getContents().end();) {
molecule.cc:211:	    (*a)[01;31m-[00m>reparent(*rHead);
molecule.cc:212:	    a = (*r)[01;31m-[00m>eraseContent(a);
molecule.cc:215:	r = this[01;31m-[00m>eraseContent(r);
molecule.cc:234://    rPNew[01;31m-[00m>duplicate(this);	// *rPNew = *this;
molecule.cc:235:    rPNew[01;31m-[00m>eraseContents();
molecule.cc:237:    for ( a=this[01;31m-[00m>getContents().begin(); a!=this[01;31m-[00m>getContents().end(); a++ ) {
molecule.cc:239:	rPNew[01;31m-[00m>addMatter(RPMatter(res[01;31m-[00m>copyDontRedirectBonds()));
molecule.cc:242:    rPNew[01;31m-[00m>_Restraints = this[01;31m-[00m>_Restraints[01;31m-[00m>copyDontRedirectAtoms();
molecule.cc:253:    for ( a=this[01;31m-[00m>getContents().begin(); a!=this[01;31m-[00m>getContents().end(); a++ ) {
molecule.cc:255:	res[01;31m-[00m>redirectBonds();
molecule.cc:257:    this[01;31m-[00m>_Restraints[01;31m-[00m>redirectAtoms();
molecule.cc:266:    rPNew = this[01;31m-[00m>copyDontRedirectBonds();
molecule.cc:267:    rPNew[01;31m-[00m>redirectBonds();
molecule.cc:276:    printf( "Molecule: %s at: 0x%lx contains %d residues\n", this[01;31m-[00m>getName().c_str(), this, this[01;31m-[00m>getContents().size() );
molecule.cc:277:    for ( rit=this[01;31m-[00m>getContents().begin();
molecule.cc:278:	    rit!=this[01;31m-[00m>getContents().end(); rit++ ) {
molecule.cc:280:	res[01;31m-[00m>dump();
molecule.cc:291:    allRestraints = RP_Create<O_RestraintList>(this[01;31m-[00m>lisp());
molecule.cc:292:    for ( ci=this[01;31m-[00m>begin_residues(); ci!=this[01;31m-[00m>end_residues(); ci++ ) {
molecule.cc:293:	resRestraints = (downcast<O_Residue>(*ci))[01;31m-[00m>getRestraints();
molecule.cc:294:	allRestraints[01;31m-[00m>merge(resRestraints);
molecule.cc:303:    lr.loopTopMoleculeGoal( this[01;31m-[00m>sharedThis<O_Molecule>(), RESIDUES );
molecule.cc:305:	if ( lr.getResidue()[01;31m-[00m>getName() == name ) {
molecule.cc:317:    residues = this[01;31m-[00m>getResiduesWithName(name);
molecule.cc:322:{_F(this[01;31m-[00m>lisp());
molecule.cc:324:    residues = this[01;31m-[00m>getResiduesWithName(name);
molecule.cc:328:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("getFirstResidueWithName: Molecule does not contain residues with name: %s")% name ));
molecule.cc:334:{_F(this[01;31m-[00m>lisp());
molecule.cc:336:    rend = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderMatter>();
molecule.cc:337:    rend[01;31m-[00m>setFromMatter(this[01;31m-[00m>sharedThis<O_Molecule>());
molecule.cc:347:    lb.loopTopMoleculeGoal( this[01;31m-[00m>sharedThis<O_Molecule>(), RESIDUES);
molecule.cc:350:	numberOfAtoms += lb.getResidue()[01;31m-[00m>numberOfAtoms();
molecule.cc:360:    class_<O_Molecule>(this[01;31m-[00m>lisp())
moleculeReferencer.cc:22:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
moleculeReferencer.cc:27:    this[01;31m-[00m>Base::initialize();
moleculeReferencer.cc:28:    this[01;31m-[00m>_Molecule = O_Molecule::nil(this[01;31m-[00m>lisp());
moleculeReferencer.cc:29:    this[01;31m-[00m>_OligomerAndSequenceChangeCounter = 0;
moleculeReferencer.cc:43:    this[01;31m-[00m>_OligomerAndSequenceChangeCounter++;
moleculeReferencer.cc:44:    if ( this[01;31m-[00m>_OligomerAndSequenceChangeCounter == UndefinedUnsignedInt )
moleculeReferencer.cc:46:	this[01;31m-[00m>_OligomerAndSequenceChangeCounter = 0;
moleculeReferencer.cc:48:    this[01;31m-[00m>_Molecule = mol;
moleculeReferencer.cc:49:    this[01;31m-[00m>_Residues.clear();
moleculeReferencer.cc:51:    this[01;31m-[00m>_ResidueAliasMap.clear();
moleculeReferencer.cc:52:    for ( it=mol[01;31m-[00m>begin_contents(); it!=mol[01;31m-[00m>end_contents(); it++ )
moleculeReferencer.cc:54:	RPResidue res = (*it)[01;31m-[00m>as<O_Residue>();
moleculeReferencer.cc:55:	RPStringSet monomerAliases = res[01;31m-[00m>getMonomerAliases();
moleculeReferencer.cc:56:	if ( !monomerAliases[01;31m-[00m>isNil() )
moleculeReferencer.cc:61:	    uint residueIndex = this[01;31m-[00m>_Residues.size();
moleculeReferencer.cc:66:	    for ( si=monomerAliases[01;31m-[00m>begin(); si!=monomerAliases[01;31m-[00m>end(); si++ )
moleculeReferencer.cc:68:		this[01;31m-[00m>_ResidueAliasMap.insert(pair<string,uint>(*si,residueIndex));
moleculeReferencer.cc:74:	    for ( ai=res[01;31m-[00m>begin_contents(); ai!=res[01;31m-[00m>end_contents(); ai++ )
moleculeReferencer.cc:76:		RPAtom aa = (*ai)[01;31m-[00m>as<O_Atom>();
moleculeReferencer.cc:77:		if ( aa[01;31m-[00m>getAlias() != "" )
moleculeReferencer.cc:79:		    rh._AliasAtoms[aa[01;31m-[00m>getAlias()] = this[01;31m-[00m>_Atoms.size();
moleculeReferencer.cc:80:		    this[01;31m-[00m>_Atoms.push_back(aa);
moleculeReferencer.cc:83:	    this[01;31m-[00m>_Residues.push_back(rh);
moleculeReferencer.cc:86:    selector[01;31m-[00m>builderChanged(this[01;31m-[00m>sharedThis<O_AliasReferencer>());
moleculeReferencer.cc:92:{_F(this[01;31m-[00m>lisp());
moleculeReferencer.cc:93:    uint numberOfOccurances = this[01;31m-[00m>_ResidueAliasMap.count(alias[01;31m-[00m>getMonomerAlias());
moleculeReferencer.cc:96:    lower = this[01;31m-[00m>_ResidueAliasMap.lower_bound(alias[01;31m-[00m>getMonomerAlias());
moleculeReferencer.cc:97:    upper = this[01;31m-[00m>_ResidueAliasMap.upper_bound(alias[01;31m-[00m>getMonomerAlias());
moleculeReferencer.cc:100:        return lower[01;31m-[00m>second;
moleculeReferencer.cc:108:	if ( this[01;31m-[00m>_Residues[cur[01;31m-[00m>second]._AliasAtoms.count(alias[01;31m-[00m>getAtomAlias()) )
moleculeReferencer.cc:110:	    return cur[01;31m-[00m>second;
moleculeReferencer.cc:113:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is no monomer with the alias("+alias[01;31m-[00m>__repr__()+")"));
moleculeReferencer.cc:118:{_F(this[01;31m-[00m>lisp());
moleculeReferencer.cc:119:    ASSERT_lt(monomerIndex,this[01;31m-[00m>_Residues.size());
moleculeReferencer.cc:120:    ResidueHolder& rh = this[01;31m-[00m>_Residues[monomerIndex];
moleculeReferencer.cc:121:    return rh._AliasAtoms.count(alias[01;31m-[00m>getAtomAlias())>0;
moleculeReferencer.cc:125:{_F(this[01;31m-[00m>lisp());
moleculeReferencer.cc:126:    ASSERT_lt(monomerIndex,this[01;31m-[00m>_Residues.size());
moleculeReferencer.cc:127:    ResidueHolder& rh = this[01;31m-[00m>_Residues[monomerIndex];
moleculeReferencer.cc:128:    ASSERT(rh._AliasAtoms.count(alias[01;31m-[00m>getAtomAlias())>0);
moleculeReferencer.cc:129:    return rh._AliasAtoms[alias[01;31m-[00m>getAtomAlias()];
moleculeReferencer.cc:133:{_F(this[01;31m-[00m>lisp());
moleculeReferencer.cc:136:    ASSERT_lt(idx,this[01;31m-[00m>_Atoms.size());
moleculeReferencer.cc:137:    RPAtom a = this[01;31m-[00m>_Atoms[idx];
moleculeReferencer.cc:138:    if ( state[01;31m-[00m>isScoreTransformSet() )
moleculeReferencer.cc:140:        return state[01;31m-[00m>scoreTransform().multiplyByVector3(a[01;31m-[00m>getPosition());
moleculeReferencer.cc:142:    return a[01;31m-[00m>getPosition();
moleculeReferencer.cc:148:{_F(this[01;31m-[00m>lisp());
moleculeReferencer.cc:149:    ASSERT_lt(idx,this[01;31m-[00m>_Atoms.size());
moleculeReferencer.cc:150:    RPAtom a = this[01;31m-[00m>_Atoms[idx];
moleculeReferencer.cc:157:    if ( ctr != this[01;31m-[00m>_OligomerAndSequenceChangeCounter )
moleculeReferencer.cc:161:	ss << this[01;31m-[00m>getOligomerChangeCounter();
moleculeReferencer.cc:163:	ss << obj[01;31m-[00m>description();
moleculeReferencer.cc:164:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
moleculeReferencer.cc:171:    if ( ctr != this[01;31m-[00m>_OligomerAndSequenceChangeCounter )
moleculeReferencer.cc:175:	ss << this[01;31m-[00m>getSequenceChangeCounter();
moleculeReferencer.cc:177:	ss << obj[01;31m-[00m>description();
moleculeReferencer.cc:178:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
moleculeReferencer.cc:188:	class_<O_MoleculeReferencer>(this[01;31m-[00m>lisp())
monomer.cc:45:    this[01;31m-[00m>_SpanningBackToRoot = info[01;31m-[00m>_SpanningBackToRoot;
monomer.cc:46:    this[01;31m-[00m>_SpanningNext = info[01;31m-[00m>_SpanningNext;
monomer.cc:47:    this[01;31m-[00m>_SpanningTouched = info[01;31m-[00m>_SpanningTouched;
monomer.cc:48:    this[01;31m-[00m>_CouplingBackToRoot = info[01;31m-[00m>_CouplingBackToRoot;
monomer.cc:65:{_F(this[01;31m-[00m>lisp());
monomer.cc:66:    this[01;31m-[00m>Base::archiveBase(node);
monomer.cc:67:    node[01;31m-[00m>archiveWeakPointer("oligomer",this[01;31m-[00m>_WeakOligomer);
monomer.cc:68:    node[01;31m-[00m>archiveWeakPointer("tempResidue",this[01;31m-[00m>_WeakTempResidue);
monomer.cc:69:    node[01;31m-[00m>archiveWeakMultiMap<O_Coupling>("couplings",this[01;31m-[00m>_WeakCouplings);
monomer.cc:70:    node[01;31m-[00m>attribute("comment", this[01;31m-[00m>_Comment);
monomer.cc:71:    node[01;31m-[00m>attributeIfNotDefault<string>("id", this[01;31m-[00m>_Id, "");
monomer.cc:72:    node[01;31m-[00m>archiveObjectIfDefined("aliases", this[01;31m-[00m>_Aliases);
monomer.cc:73:    node[01;31m-[00m>attribute("verbose", this[01;31m-[00m>_Verbose);
monomer.cc:74:    node[01;31m-[00m>attributeIfNotDefault("tempInt", this[01;31m-[00m>_TemporaryInt,0);
monomer.cc:75:    node[01;31m-[00m>attribute("sequenceNumber",this[01;31m-[00m>_SequenceNumber);
monomer.cc:76:    node[01;31m-[00m>archiveObjectIfDefined("status",this[01;31m-[00m>_Status);
monomer.cc:77:    node[01;31m-[00m>archivePlainObject<Vector2>( "pos2","Vector2",
monomer.cc:78:				       this[01;31m-[00m>_Position2D );
monomer.cc:79:    node[01;31m-[00m>attribute("selected",this[01;31m-[00m>_Selected );
monomer.cc:80:    if ( node[01;31m-[00m>loading() )
monomer.cc:82:	if ( this[01;31m-[00m>_Status[01;31m-[00m>isNil() )	
monomer.cc:84:	    this[01;31m-[00m>_Status = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_StatusTracker>();
monomer.cc:91:{_F(this[01;31m-[00m>lisp());
monomer.cc:92:    this[01;31m-[00m>Base::oldLispInitialize(keyed,env);
monomer.cc:93:    ASSERTP(this[01;31m-[00m>lisp()[01;31m-[00m>notNil(),"Environment is nil in new Monomer or subclass");
monomer.cc:100:{_F(this[01;31m-[00m>lisp());
monomer.cc:107:  context = O_MonomerContext::nil(this[01;31m-[00m>lisp());
monomer.cc:108:  if ( !this[01;31m-[00m>isMonomerContextValid() )
monomer.cc:110:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer context is invalid", this[01;31m-[00m>sharedThis<O_Monomer>()[01;31m-[00m>description() ));
monomer.cc:112:  db = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:113:  context = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_MonomerContext>();
monomer.cc:114:  selfRecognizer = O_MonomerGrouper::create(this[01;31m-[00m>lisp()); //,db);
monomer.cc:115:  selfRecognizer[01;31m-[00m>addGroupName(this[01;31m-[00m>getGroupName());
monomer.cc:116:  context[01;31m-[00m>setFocus(selfRecognizer);
monomer.cc:117:  for ( ci=this[01;31m-[00m>begin_WeakCouplings(); ci!=this[01;31m-[00m>end_WeakCouplings(); ci++ )
monomer.cc:119:      coupling = (ci[01;31m-[00m>second).lock();
monomer.cc:123:      if ( coupling[01;31m-[00m>isAssignableTo<O_RingCoupling>() ) continue;
monomer.cc:124:      neighborRecognizer = O_MonomerGrouper::create(this[01;31m-[00m>lisp()); //,db);
monomer.cc:125:      neighborMonomer = coupling[01;31m-[00m>getOtherSideMonomer(this[01;31m-[00m>sharedThis<O_Monomer>());
monomer.cc:126:      neighborRecognizer[01;31m-[00m>addGroupName(neighborMonomer[01;31m-[00m>getGroupName());
monomer.cc:127:      context[01;31m-[00m>addNeighbor(ci[01;31m-[00m>first,neighborRecognizer);
monomer.cc:132:void	O_Monomer::clearError()	{_OF();ASSERT_NOT_NULL(this[01;31m-[00m>_Status);this[01;31m-[00m>_Status[01;31m-[00m>reset();};
monomer.cc:133:bool	O_Monomer::getHasError()	{ return this[01;31m-[00m>_Status[01;31m-[00m>hasError();};
monomer.cc:134:string	O_Monomer::getStatusMessage() { return this[01;31m-[00m>_Status[01;31m-[00m>getStatus();};
monomer.cc:135:void	O_Monomer::addErrorMessage(const string& s) { this[01;31m-[00m>_Status[01;31m-[00m>addError(s);};
monomer.cc:136:void	O_Monomer::addStatusMessage(const string& s) {this[01;31m-[00m>_Status[01;31m-[00m>addMessage(s);};
monomer.cc:137:RPStatusTracker	O_Monomer::getStatusTracker() { return this[01;31m-[00m>_Status;};
monomer.cc:140:{_F(this[01;31m-[00m>lisp());
monomer.cc:141:  RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
monomer.cc:144:  for ( ci=this[01;31m-[00m>begin_WeakCouplings(); ci!=this[01;31m-[00m>end_WeakCouplings(); ci++ )
monomer.cc:146:      RPCoupling coupling = (ci[01;31m-[00m>second).lock();
monomer.cc:147:      RPCons oneOne = O_Cons::createList(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(ci[01;31m-[00m>first),coupling,this[01;31m-[00m>lisp());
monomer.cc:148:      RPCons one = O_Cons::create(oneOne,this[01;31m-[00m>lisp());
monomer.cc:149:      cur[01;31m-[00m>setCdr(one);
monomer.cc:152:  return first[01;31m-[00m>cdr();
monomer.cc:158:{_F(this[01;31m-[00m>lisp());
monomer.cc:159:    this[01;31m-[00m>_Aliases[01;31m-[00m>clear();
monomer.cc:160:    this[01;31m-[00m>_Aliases[01;31m-[00m>insertConsStrings(aliases);
monomer.cc:166:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakTempResidue);
monomer.cc:167:    return this[01;31m-[00m>_WeakTempResidue.lock()[01;31m-[00m>notNil();
monomer.cc:174:{_F(this[01;31m-[00m>lisp());
monomer.cc:175:    if ( !this[01;31m-[00m>hasInCoupling() )
monomer.cc:177:	return O_AtomBoundFrame::nil(this[01;31m-[00m>lisp());
monomer.cc:179:    RPDirectionalCoupling coupling = this[01;31m-[00m>getInCoupling();
monomer.cc:180:    RPOutPlug preceedingPlug = coupling[01;31m-[00m>getPlugForOtherMonomer(this[01;31m-[00m>sharedThis<O_Monomer>())[01;31m-[00m>as<O_OutPlug>();
monomer.cc:181:    RPMonomer preceedingMonomer = coupling[01;31m-[00m>getOtherSideMonomer(this[01;31m-[00m>sharedThis<O_Monomer>());
monomer.cc:182:    RPFrame frame = preceedingPlug[01;31m-[00m>getExportFrame();
monomer.cc:183:    if ( frame[01;31m-[00m>isNil() )
monomer.cc:187:	ss << this[01;31m-[00m>description() << endl;
monomer.cc:188:	ss << " coupling = " << coupling[01;31m-[00m>description() << endl;
monomer.cc:189:	ss << " preceeding monomer is = " << preceedingMonomer[01;31m-[00m>description() << endl;
monomer.cc:190:	ss << " preceeding plug = " << preceedingPlug[01;31m-[00m>description() << endl;
monomer.cc:192:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
monomer.cc:194:    RPBoundFrame bound = frame[01;31m-[00m>getBoundFrame(preceedingMonomer);
monomer.cc:195:    if ( !bound[01;31m-[00m>isOfClass<O_AtomBoundFrame>() )
monomer.cc:197:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The frame must return an AtomBoundFrame but instead it returned a "+bound[01;31m-[00m>description()));
monomer.cc:199:    return bound[01;31m-[00m>as<O_AtomBoundFrame>();
monomer.cc:206:{_F(this[01;31m-[00m>lisp());
monomer.cc:207:    this[01;31m-[00m>_Aliases[01;31m-[00m>clear();
monomer.cc:208:    this[01;31m-[00m>_Aliases[01;31m-[00m>insertStringList(aliases);
monomer.cc:212:{_F(this[01;31m-[00m>lisp());
monomer.cc:217:    LOG(BF("Check for bad connections %s") % this[01;31m-[00m>description().c_str() ); // vp0(("Check for bad connections %s",this[01;31m-[00m>description().c_str()));
monomer.cc:218:    for ( it=this[01;31m-[00m>begin_WeakCouplings(); it!=this[01;31m-[00m>end_WeakCouplings(); it++ )
monomer.cc:220:    	if ( it[01;31m-[00m>second.lock()[01;31m-[00m>isNil() )
monomer.cc:222:	    this[01;31m-[00m>addErrorMessage("Coupling with plug("+it[01;31m-[00m>first+") is Null");
monomer.cc:226:	coup = it[01;31m-[00m>second.lock();
monomer.cc:227:	if ( !coup[01;31m-[00m>containsMonomer(this[01;31m-[00m>sharedThis<O_Monomer>()) )
monomer.cc:229:	    this[01;31m-[00m>addErrorMessage("The coupling through plug("+it[01;31m-[00m>first+") doesn't contain me");
monomer.cc:237:{_F(this[01;31m-[00m>lisp());
monomer.cc:238:    if ( this[01;31m-[00m>checkForBadConnections() )
monomer.cc:240:        LOG(BF("Found bad connections in %s  error: %s") % this[01;31m-[00m>description().c_str() % this[01;31m-[00m>getStatusMessage().c_str()  ); // vp0(("Found bad connections in %s  error: %s",this[01;31m-[00m>description().c_str(),this[01;31m-[00m>getStatusMessage().c_str() ));
monomer.cc:241:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Bad connections for monomer", this[01;31m-[00m>sharedThis<O_Monomer>()[01;31m-[00m>description()));
monomer.cc:249:{_F(this[01;31m-[00m>lisp());
monomer.cc:253:    this[01;31m-[00m>clearError();
monomer.cc:254:    this[01;31m-[00m>checkForBadConnections();
monomer.cc:259:{_F(this[01;31m-[00m>lisp());
monomer.cc:266:    context = O_MonomerContext::nil(this[01;31m-[00m>lisp());
monomer.cc:267:    if ( !this[01;31m-[00m>isMonomerContextValid() )
monomer.cc:269:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Monomer context is invalid", this[01;31m-[00m>sharedThis<O_Monomer>()[01;31m-[00m>description() ));
monomer.cc:271:    db = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:272:    context = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_MonomerContext>();
monomer.cc:273:    selfRecognizer = O_MonomerSet::create(this[01;31m-[00m>lisp());
monomer.cc:274:    selfRecognizer[01;31m-[00m>setMonomerNameOrPdb(this[01;31m-[00m>getName());
monomer.cc:275:    context[01;31m-[00m>setFocus(selfRecognizer);
monomer.cc:276:    for ( ci=this[01;31m-[00m>begin_WeakCouplings(); ci!=this[01;31m-[00m>end_WeakCouplings(); ci++ )
monomer.cc:278:	coupling = (ci[01;31m-[00m>second).lock();
monomer.cc:279:	if ( coupling[01;31m-[00m>isOfClass<O_DirectionalCoupling>() )
monomer.cc:281:	    neighborRecognizer = O_MonomerSet::create(this[01;31m-[00m>lisp());
monomer.cc:282:	    neighborMonomer = coupling[01;31m-[00m>getOtherSideMonomer(this[01;31m-[00m>sharedThis<O_Monomer>());
monomer.cc:283:	    neighborRecognizer[01;31m-[00m>setMonomerNameOrPdb(neighborMonomer[01;31m-[00m>getName());
monomer.cc:284:	    context[01;31m-[00m>addNeighbor(ci[01;31m-[00m>first,neighborRecognizer);
monomer.cc:287:	    RPRingCoupling rc = coupling[01;31m-[00m>as<O_RingCoupling>();
monomer.cc:288:	    LOG(BF("Ignoring out coupling for RingCoupling: %s") % rc[01;31m-[00m>getName().c_str()  ); // vp0(( "Ignoring out coupling for RingCoupling: %s", rc[01;31m-[00m>getName().c_str() ));
monomer.cc:298:{_F(this[01;31m-[00m>lisp());
monomer.cc:303:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:304:    constitution = bdb[01;31m-[00m>constitutionForNameOrPdb(this[01;31m-[00m>getName());
monomer.cc:305:    return constitution[01;31m-[00m>getMissingRingClosingPlug(this[01;31m-[00m>sharedThis<O_Monomer>());
monomer.cc:310:{_F(this[01;31m-[00m>lisp());
monomer.cc:315:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:316:    constitution = bdb[01;31m-[00m>constitutionForNameOrPdb(this[01;31m-[00m>getName());
monomer.cc:318:    ASSERT(constitution[01;31m-[00m>notNil());
monomer.cc:319:    topology = constitution[01;31m-[00m>getTopologyForMonomerEnvironment(this[01;31m-[00m>sharedThis<O_Monomer>());
monomer.cc:328:{_F(this[01;31m-[00m>lisp());
monomer.cc:329:    this[01;31m-[00m>_WeakOligomer = o[01;31m-[00m>sharedThis<O_Oligomer>();
monomer.cc:334:    this[01;31m-[00m>Base::initialize();
monomer.cc:335:    this[01;31m-[00m>_WeakOligomer = O_Oligomer::nil(this[01;31m-[00m>lisp());
monomer.cc:336:    this[01;31m-[00m>_WeakTempResidue = O_Residue::nil(this[01;31m-[00m>lisp());
monomer.cc:337:    this[01;31m-[00m>setComment("");
monomer.cc:338:    this[01;31m-[00m>_Id = "";
monomer.cc:339:    this[01;31m-[00m>_Aliases = O_StringSet::create(this[01;31m-[00m>lisp());
monomer.cc:340:    this[01;31m-[00m>_Verbose = false;
monomer.cc:341:    this[01;31m-[00m>_TemporaryInt = 0;
monomer.cc:342:    this[01;31m-[00m>_SequenceNumber = 0;
monomer.cc:343:    this[01;31m-[00m>_Status = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_StatusTracker>();
monomer.cc:344:    this[01;31m-[00m>_Status[01;31m-[00m>reset();
monomer.cc:345:    this[01;31m-[00m>_Selected = false;
monomer.cc:346:    this[01;31m-[00m>setPosition2D_xy(0.0,0.0);
monomer.cc:356:{_F(this[01;31m-[00m>lisp());
monomer.cc:359:    for ( it=this[01;31m-[00m>begin_WeakCouplings(); it!=this[01;31m-[00m>end_WeakCouplings(); it++ ) {
monomer.cc:360:        if ( O_DirectionalCoupling::isInPlugName(it[01;31m-[00m>first,_lisp) )
monomer.cc:362:	    ASSERT_NOT_NULL(it[01;31m-[00m>second);
monomer.cc:363:	    coup = it[01;31m-[00m>second.lock()[01;31m-[00m>as<O_DirectionalCoupling>();
monomer.cc:367:    return O_DirectionalCoupling::nil(this[01;31m-[00m>lisp());
monomer.cc:375:{_F(this[01;31m-[00m>lisp());
monomer.cc:377:    for ( it=this[01;31m-[00m>begin_WeakCouplings(); it!=this[01;31m-[00m>end_WeakCouplings(); it++ ) 
monomer.cc:379:        ASSERT_NOT_NULL(it[01;31m-[00m>second);
monomer.cc:380:	RPCoupling coup = it[01;31m-[00m>second.lock();
monomer.cc:381:	if ( coup[01;31m-[00m>isOfClass<O_DirectionalCoupling>() )
monomer.cc:383:	    RPDirectionalCoupling dc = coup[01;31m-[00m>as<O_DirectionalCoupling>();
monomer.cc:384:            if ( dc[01;31m-[00m>isInCouplingToMonomer(this[01;31m-[00m>sharedThis<O_Monomer>()) ) return it[01;31m-[00m>first;
monomer.cc:392:{_F(this[01;31m-[00m>lisp());
monomer.cc:394:    coup = this[01;31m-[00m>getInCoupling();
monomer.cc:395:    return (coup[01;31m-[00m>notNil() );
monomer.cc:402:    coup = this[01;31m-[00m>getInCoupling();
monomer.cc:403:    return (coup[01;31m-[00m>notNil());
monomer.cc:409:{_F(this[01;31m-[00m>lisp());
monomer.cc:412:    ASSERT(this[01;31m-[00m>notNil());
monomer.cc:413:    con = this[01;31m-[00m>getBuilderDatabase()[01;31m-[00m>constitutionForNameOrPdb(this[01;31m-[00m>getName());
monomer.cc:415:    if ( !con[01;31m-[00m>hasPlugNamed(pn) )
monomer.cc:418:	ss << "Constitution(" << con[01;31m-[00m>getName();
monomer.cc:420:	ss << "  available plugs(" << con[01;31m-[00m>getPlugNames()[01;31m-[00m>asString() << ")";
monomer.cc:421:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
monomer.cc:423:    plug = con[01;31m-[00m>getPlugNamed(pn);
monomer.cc:430:{_F(this[01;31m-[00m>lisp());
monomer.cc:434:    db = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:436:    nm = this[01;31m-[00m>getName();
monomer.cc:439:    return db[01;31m-[00m>constitutionForNameOrPdb(nm);
monomer.cc:448:    if ( this[01;31m-[00m>_WeakCouplings.contains(s) ) {
monomer.cc:450:	coup = this[01;31m-[00m>_WeakCouplings.get(s,_lisp);
monomer.cc:454:    return O_Coupling::nil(this[01;31m-[00m>lisp());
monomer.cc:460:    c = this[01;31m-[00m>getCouplingWithPlugName(s);
monomer.cc:461:    return c[01;31m-[00m>notNil();
monomer.cc:466:{_F(this[01;31m-[00m>lisp());
monomer.cc:472:    LOG(BF("Looking for plug name: %s and coupling: %s") % plugName.c_str() % coup[01;31m-[00m>description().c_str()  ); // vp0(("Looking for plug name: %s and coupling: %s",plugName.c_str(),coup[01;31m-[00m>description().c_str() ));
monomer.cc:475:    range = this[01;31m-[00m>_WeakCouplings.equal_range(plugName);
monomer.cc:479:        ASSERT_NOT_NULLP(it[01;31m-[00m>second,"Coupling is undefined");
monomer.cc:480:	myCoup = it[01;31m-[00m>second.lock();
monomer.cc:481:        LOG(BF("Looking at coupling: %s") % myCoup[01;31m-[00m>description().c_str()  ); // vp0(("Looking at coupling: %s",myCoup[01;31m-[00m>description().c_str() ));
monomer.cc:496:{_F(this[01;31m-[00m>lisp());
monomer.cc:497:    LOG(BF("add coupling to %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("add coupling to %s",this[01;31m-[00m>description().c_str() ));
monomer.cc:498:    LOG(BF("Adding plug(%s) coupling: %s") % plugName.c_str() % coup[01;31m-[00m>description().c_str()  ); // vp0(("Adding plug(%s) coupling: %s",plugName.c_str(),coup[01;31m-[00m>description().c_str() ));
monomer.cc:499:    this[01;31m-[00m>_WeakCouplings.insert(plugName, coup[01;31m-[00m>sharedThis<O_Coupling>());
monomer.cc:500:    LOG(BF("After add monomer is %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("After add monomer is %s",this[01;31m-[00m>description().c_str() ));
monomer.cc:506:{_F(this[01;31m-[00m>lisp());
monomer.cc:507:    LOG(BF("resetting in coupling of %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("resetting in coupling of %s",this[01;31m-[00m>description().c_str() ));
monomer.cc:509:    if ( this[01;31m-[00m>hasInCoupling() ) {
monomer.cc:512:	inCoup = this[01;31m-[00m>getInCoupling();
monomer.cc:513:	this[01;31m-[00m>removeCoupling(inCoup);
monomer.cc:519:{_F(this[01;31m-[00m>lisp());
monomer.cc:521:    LOG(BF("setting in coupling of %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("setting in coupling of %s",this[01;31m-[00m>description().c_str() ));
monomer.cc:523:    this[01;31m-[00m>resetInCoupling();
monomer.cc:524:    LOG(BF("Adding in coupling: %s") % coup[01;31m-[00m>description().c_str() ); // vp0(("Adding in coupling: %s",coup[01;31m-[00m>description().c_str()));
monomer.cc:525:    inCoupName = O_DirectionalCoupling::inPlugName(coup[01;31m-[00m>getName(),_lisp);
monomer.cc:526:    this[01;31m-[00m>addCoupling( inCoupName, coup );
monomer.cc:532:{_F(this[01;31m-[00m>lisp());
monomer.cc:534:    LOG(BF("adding out coupling to %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("adding out coupling to %s",this[01;31m-[00m>description().c_str() ));
monomer.cc:535:    string outPlugName = O_DirectionalCoupling::outPlugName(coup[01;31m-[00m>getName(),_lisp);
monomer.cc:536:    LOG(BF("Adding out coupling: %s") % coup[01;31m-[00m>description().c_str()  ); // vp0(("Adding out coupling: %s",coup[01;31m-[00m>description().c_str() ));
monomer.cc:537:    this[01;31m-[00m>addCoupling( outPlugName, coup );
monomer.cc:542:{_F(this[01;31m-[00m>lisp());
monomer.cc:548:    for ( wci=this[01;31m-[00m>begin_value_WeakCouplings(); wci!=this[01;31m-[00m>end_value_WeakCouplings(); wci++ )
monomer.cc:551:	otherMonomer = coup[01;31m-[00m>getOtherSideMonomer(this[01;31m-[00m>sharedThis<O_Monomer>());
monomer.cc:560:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Could not find coupling to monomer: "+mon[01;31m-[00m>description(), this[01;31m-[00m>sharedThis<O_Monomer>()[01;31m-[00m>description() ));
monomer.cc:562:    LOG(BF("Removing coupling: %s") % coup[01;31m-[00m>description().c_str()  ); // vp0(("Removing coupling: %s",coup[01;31m-[00m>description().c_str() ));
monomer.cc:563:    this[01;31m-[00m>_WeakCouplings.erase(wci);
monomer.cc:570:{_F(this[01;31m-[00m>lisp());
monomer.cc:577:    for ( wci=this[01;31m-[00m>begin_WeakCouplings(); wci!=this[01;31m-[00m>end_WeakCouplings(); wci++ )
monomer.cc:579:	myCoup = (wci[01;31m-[00m>second).lock();
monomer.cc:583:	    isInPlug = O_DirectionalCoupling::isInPlugName(wci[01;31m-[00m>first,_lisp);
monomer.cc:584:	    LOG(BF("Original plug name: %s") % wci[01;31m-[00m>first.c_str()  ); // vp0(("Original plug name: %s",wci[01;31m-[00m>first.c_str() ));
monomer.cc:590:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Could not find coupling : "+coup[01;31m-[00m>description(), this[01;31m-[00m>sharedThis<O_Monomer>()[01;31m-[00m>description() ));
monomer.cc:592:    LOG(BF("Fixing the PlugName key for coupling: %s") % coup[01;31m-[00m>description().c_str()  ); // vp0(("Fixing the PlugName key for coupling: %s",coup[01;31m-[00m>description().c_str() ));
monomer.cc:593:    this[01;31m-[00m>_WeakCouplings.erase(wci);
monomer.cc:596:        plugName = O_DirectionalCoupling::inPlugName(coup[01;31m-[00m>getName(),_lisp);
monomer.cc:599:	plugName = O_DirectionalCoupling::outPlugName(coup[01;31m-[00m>getName(),_lisp);
monomer.cc:602:    this[01;31m-[00m>addCoupling( plugName, coup );
monomer.cc:617:{_F(this[01;31m-[00m>lisp());
monomer.cc:622:    for ( wci=this[01;31m-[00m>_WeakCouplings.begin(); wci!=this[01;31m-[00m>_WeakCouplings.end(); wci++ )
monomer.cc:633:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Could not find coupling: "+coup[01;31m-[00m>description(), this[01;31m-[00m>sharedThis<O_Monomer>()[01;31m-[00m>description() ));
monomer.cc:635:    LOG(BF("Removing coupling: %s") % myCoup[01;31m-[00m>description().c_str()  ); // vp0(("Removing coupling: %s",myCoup[01;31m-[00m>description().c_str() ));
monomer.cc:636:    this[01;31m-[00m>_WeakCouplings.erase(wci);
monomer.cc:641://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
monomer.cc:642://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
monomer.cc:643://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
monomer.cc:644://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
monomer.cc:647:{_F(this[01;31m-[00m>lisp());
monomer.cc:648:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
monomer.cc:651://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
monomer.cc:652://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
monomer.cc:653://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
monomer.cc:654://[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
monomer.cc:659:    this[01;31m-[00m>Base::initialize();
monomer.cc:660:    this[01;31m-[00m>_Monomers.clear();
monomer.cc:661:    this[01;31m-[00m>_CurrentMonomerIndex = [01;31m-[00m1;
monomer.cc:668:{_F(this[01;31m-[00m>lisp());
monomer.cc:669:    this[01;31m-[00m>Base::oldLispInitialize(keyed,env);
monomer.cc:670:    string name = keyed[01;31m-[00m>getStringAndRemoveOrDefault("name","");
monomer.cc:671:    if ( name != "" ) this[01;31m-[00m>setGroupName(name);
monomer.cc:672:    string comment = keyed[01;31m-[00m>getStringAndRemoveOrDefault("comment","");
monomer.cc:673:    if ( comment != "" ) this[01;31m-[00m>setComment(comment);
monomer.cc:678:{_F(this[01;31m-[00m>lisp());
monomer.cc:679:   this[01;31m-[00m>O_Monomer::archiveBase(node);
monomer.cc:680:   node[01;31m-[00m>attribute("currentMonomerIndex",this[01;31m-[00m>_CurrentMonomerIndex );
monomer.cc:681:   node[01;31m-[00m>attribute("groupName",this[01;31m-[00m>_GroupName);
monomer.cc:682:   node[01;31m-[00m>archiveList("monomers",this[01;31m-[00m>_Monomers);
monomer.cc:687:{_F(this[01;31m-[00m>lisp());
monomer.cc:692:    name = this[01;31m-[00m>_GroupName;
monomer.cc:693:    this[01;31m-[00m>_Monomers.clear();
monomer.cc:694:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:695:    this[01;31m-[00m>clearError();
monomer.cc:696:    if ( !bdb[01;31m-[00m>recognizesSetOrConstitutionOrMonomerName(name) )
monomer.cc:699:        this[01;31m-[00m>addErrorMessage("Illegal group name: "+name);
monomer.cc:703:    monomerNames = bdb[01;31m-[00m>getMonomersForSetOrConstitutionOrMonomerName(name);
monomer.cc:704:    LOG(BF("Got %d monomer names") % monomerNames[01;31m-[00m>size() ); // vp0(("Got %d monomer names",monomerNames[01;31m-[00m>size()));
monomer.cc:706:    for ( si=monomerNames[01;31m-[00m>begin(); si!=monomerNames[01;31m-[00m>end(); si++ )
monomer.cc:709:        this[01;31m-[00m>addMonomerName(*si);
monomer.cc:711:    if ( this[01;31m-[00m>_CurrentMonomerIndex < 0 )
monomer.cc:713:        this[01;31m-[00m>_CurrentMonomerIndex = 0;
monomer.cc:715:    if ( this[01;31m-[00m>_CurrentMonomerIndex >= this[01;31m-[00m>_Monomers.size() )
monomer.cc:717:        this[01;31m-[00m>_CurrentMonomerIndex = 0;
monomer.cc:725:{_F(this[01;31m-[00m>lisp());
monomer.cc:728:    this[01;31m-[00m>_GroupName = name;
monomer.cc:729:    this[01;31m-[00m>_expandGroupName();
monomer.cc:736:{_F(this[01;31m-[00m>lisp());
monomer.cc:741:    this[01;31m-[00m>addStatusMessage("O_MultiMonomer::checkForErrorsAndUnknownContexts");
monomer.cc:743:    this[01;31m-[00m>O_Monomer::checkForErrorsAndUnknownContexts(cdb);
monomer.cc:744:    if ( this[01;31m-[00m>getHasError() ) return;
monomer.cc:745:    if ( this[01;31m-[00m>numberOfPossibleMonomers() == 0 )
monomer.cc:747:	this[01;31m-[00m>addErrorMessage("This MultiMonomer is empty");
monomer.cc:750:    if ( !this[01;31m-[00m>isMonomerContextValid() )
monomer.cc:752:        this[01;31m-[00m>addErrorMessage("The MonomerContext is invalid");
monomer.cc:755:    context = this[01;31m-[00m>getGeneralMonomerContext();
monomer.cc:756:    allSpecificContextKeys = context[01;31m-[00m>getAllSpecificKeys();
monomer.cc:759:    ss << "There are " << allSpecificContextKeys[01;31m-[00m>size() << " specific contexts" << endl;
monomer.cc:760:    this[01;31m-[00m>addStatusMessage(ss.str());
monomer.cc:761:    if ( allSpecificContextKeys[01;31m-[00m>size() == 0 )
monomer.cc:763:        this[01;31m-[00m>addErrorMessage("There are no legal specific contexts");
monomer.cc:766:	for ( sit=allSpecificContextKeys[01;31m-[00m>begin(); sit!=allSpecificContextKeys[01;31m-[00m>end(); sit++ )
monomer.cc:768:	    if ( !cdb[01;31m-[00m>recognizesMonomerCoordinatesKey(*sit) )
monomer.cc:770:		this[01;31m-[00m>addErrorMessage("Monomer[01;31m-[00m>Unrecognized context: "+*sit);
monomer.cc:777:	    this[01;31m-[00m>addStatusMessage("All contexts are recognized.");
monomer.cc:788:    om = RP_Create<O_OneMonomer>(this[01;31m-[00m>lisp());
monomer.cc:789:    om[01;31m-[00m>setName(name);
monomer.cc:790:    this[01;31m-[00m>_Monomers.push_back(om);
monomer.cc:797:{_F(this[01;31m-[00m>lisp());
monomer.cc:798:    ASSERT(this[01;31m-[00m>_Monomers.size()>=1);
monomer.cc:799:    if ( this[01;31m-[00m>_Monomers.size()==1 ) return;
monomer.cc:800:    this[01;31m-[00m>_CurrentMonomerIndex = randomNumber01(_lisp)*this[01;31m-[00m>_Monomers.size();
monomer.cc:801:    LOG(BF("Randomized monomer(%s) to %d out of %d") % this[01;31m-[00m>getComment().c_str() % this[01;31m-[00m>_CurrentMonomerIndex % this[01;31m-[00m>_Monomers.size()  ); // vp0(("Randomized monomer(%s) to %d out of %d",this[01;31m-[00m>getComment().c_str(),this[01;31m-[00m>_CurrentMonomerIndex,this[01;31m-[00m>_Monomers.size() ));
monomer.cc:808:{_F(this[01;31m-[00m>lisp());
monomer.cc:809:    if ( this[01;31m-[00m>_Monomers.size() < 1 ) {
monomer.cc:810:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("There are no monomers defined for MultiMonomer group("+this[01;31m-[00m>_GroupName+")"));
monomer.cc:812:    if ( this[01;31m-[00m>_CurrentMonomerIndex < 0 ) {
monomer.cc:813:        this[01;31m-[00m>_CurrentMonomerIndex = 0;
monomer.cc:815:    LOG(BF("Looking up monomer: %d") % this[01;31m-[00m>_CurrentMonomerIndex  ); // vp0(( "Looking up monomer: %d", this[01;31m-[00m>_CurrentMonomerIndex ));
monomer.cc:816:    return this[01;31m-[00m>_Monomers[this[01;31m-[00m>_CurrentMonomerIndex];
monomer.cc:821:{_F(this[01;31m-[00m>lisp());
monomer.cc:825:    monName = this[01;31m-[00m>getName();
monomer.cc:826:    con = this[01;31m-[00m>getBuilderDatabase()[01;31m-[00m>constitutionForNameOrPdb(monName);
monomer.cc:827:    RPResidue res = con[01;31m-[00m>createResidueForStereoisomerName(monName);
monomer.cc:828:    RPConstitution residueConstitution = res[01;31m-[00m>getConstitution();
monomer.cc:831:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Residue created with a different constitution(%s) from the one it was created from constitution(%s)") % residueConstitution[01;31m-[00m>__repr__() % con[01;31m-[00m>__repr__() ));
monomer.cc:840:    res[01;31m-[00m>setMonomerAliases(this[01;31m-[00m>_Aliases);
monomer.cc:841:    res[01;31m-[00m>setUniqueLabel(this[01;31m-[00m>_Id);
monomer.cc:842:    if ( this[01;31m-[00m>getBuilderDatabase()[01;31m-[00m>recognizesUserMonomerPack(this[01;31m-[00m>_GroupName) )
monomer.cc:844:	RPMonomerSet monomerPack = this[01;31m-[00m>getBuilderDatabase()[01;31m-[00m>getUserMonomerPack(this[01;31m-[00m>_GroupName);
monomer.cc:845:	if ( monomerPack[01;31m-[00m>supportsInterestingAtomAliases() )
monomer.cc:847:	    RPStringList atomAliases = monomerPack[01;31m-[00m>getInterestingAtomAliases();
monomer.cc:848:	    RPAtomIndexer aliasAtoms = monomerPack[01;31m-[00m>getAtomIndexerForMonomerName(this[01;31m-[00m>getName());
monomer.cc:849:	    ASSERTP(atomAliases[01;31m-[00m>size() == aliasAtoms[01;31m-[00m>numberOfAtomNames(), "The number of atom names has to match the number of atom aliases");
monomer.cc:852:	    for ( ii = aliasAtoms[01;31m-[00m>begin_AtomNames(), ai=atomAliases[01;31m-[00m>begin();
monomer.cc:853:	    		ii != aliasAtoms[01;31m-[00m>end_AtomNames(); ii++, ai++ )
monomer.cc:855:		RPAtom atom = res[01;31m-[00m>atomWithName(*ii);
monomer.cc:856:		atom[01;31m-[00m>setAlias(*ai);
monomer.cc:862:	    ss << "    The _GroupName is ("<<this[01;31m-[00m>_GroupName<<") and the monomer has the aliases("<<this[01;31m-[00m>_Aliases[01;31m-[00m>asString()<< ")"<< endl;
monomer.cc:863:	    ss << "    The monomer name is ("<<this[01;31m-[00m>getName()<<")"<<endl;
monomer.cc:864:	    ss << "    The atoms interesting atom names are ("<<monomerPack[01;31m-[00m>getInterestingAtomNamesForMonomerName(this[01;31m-[00m>getName())<<")"<<endl;
monomer.cc:865:	    ss << "    The atom aliases are ("<<monomerPack[01;31m-[00m>getInterestingAtomAliasesAsString() <<")"<<endl;
monomer.cc:866:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("%s", ss.str().c_str());
monomer.cc:870:    this[01;31m-[00m>setTempResidue(res);
monomer.cc:877:{//_F(this[01;31m-[00m>lisp());
monomer.cc:882:    ss << "["<<this[01;31m-[00m>getGroupName()<<" id:" << this[01;31m-[00m>_Id << "]=";
monomer.cc:885:    for ( ci=this[01;31m-[00m>const_begin_WeakCouplings(); ci!=this[01;31m-[00m>const_end_WeakCouplings(); ci++ )
monomer.cc:887:	ss << ci[01;31m-[00m>first << ",";
monomer.cc:895:{_F(this[01;31m-[00m>lisp());
monomer.cc:898:    keys = this[01;31m-[00m>_WeakCouplings.keys(this[01;31m-[00m>lisp());
monomer.cc:901:    if ( keys[01;31m-[00m>size() < this[01;31m-[00m>_WeakCouplings.size() )
monomer.cc:912:{_F(this[01;31m-[00m>lisp());
monomer.cc:914:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
monomer.cc:916:        if ( (*mi)[01;31m-[00m>getName() == name ) return *mi;
monomer.cc:918:    return O_OneMonomer::nil(this[01;31m-[00m>lisp());
monomer.cc:924:{_F(this[01;31m-[00m>lisp());
monomer.cc:928:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:929:    if ( bdb[01;31m-[00m>recognizesMonomerSetName(this[01;31m-[00m>getGroupName()) )
monomer.cc:931:        monomerSet = bdb[01;31m-[00m>getMonomerSet(this[01;31m-[00m>getGroupName());
monomer.cc:932:	if ( monomerSet[01;31m-[00m>supportsInterestingAtomAliases() )
monomer.cc:934:	    atomIndexer = monomerSet[01;31m-[00m>getAtomIndexerForMonomerName(this[01;31m-[00m>getName());
monomer.cc:938:    atomIndexer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_AtomIndexer>();
monomer.cc:945:{_F(this[01;31m-[00m>lisp());
monomer.cc:948:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:950:    ASSERTP(bdb[01;31m-[00m>notNil(),"Can't get atom aliases because the BuilderDatabase is undefined");
monomer.cc:951:    if ( bdb[01;31m-[00m>recognizesMonomerSetName(this[01;31m-[00m>getGroupName()) )
monomer.cc:953:	LOG(BF("Recognized the MonomerSetName(%s)")% this[01;31m-[00m>getGroupName() );
monomer.cc:954:        monomerSet = bdb[01;31m-[00m>getMonomerSet(this[01;31m-[00m>getGroupName());
monomer.cc:955:	RPStringList aliases = monomerSet[01;31m-[00m>getInterestingAtomAliases();
monomer.cc:956:	LOG(BF("Returning with aliases(%s)")% aliases[01;31m-[00m>asString() );
monomer.cc:960:	LOG(BF("Did not recognize the MonomerSetName(%s)")% this[01;31m-[00m>getGroupName());
monomer.cc:963:    return O_StringList::nil(this[01;31m-[00m>lisp());
monomer.cc:967:{_F(this[01;31m-[00m>lisp());
monomer.cc:968:    ASSERT_NOT_NULL(this[01;31m-[00m>_Aliases);
monomer.cc:969:    if ( this[01;31m-[00m>_Aliases[01;31m-[00m>size() == 0 )
monomer.cc:971:	if ( this[01;31m-[00m>allAtomAliases()[01;31m-[00m>size() != 0 )
monomer.cc:973:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("The monomer doesn't have monomer aliases but it has atom aliases("+this[01;31m-[00m>allAtomAliases()[01;31m-[00m>asString()+") this should never happen"));
monomer.cc:975:	return O_StringSet::nil(this[01;31m-[00m>lisp());
monomer.cc:977:    ASSERT_gt(this[01;31m-[00m>_Aliases[01;31m-[00m>size(),0);
monomer.cc:978:    RPStringSet atomAliases = O_StringSet::create(this[01;31m-[00m>lisp());
monomer.cc:979:    RPStringList atomAliasesList = this[01;31m-[00m>allAtomAliases();
monomer.cc:980:    atomAliases[01;31m-[00m>insertStringList(atomAliasesList);
monomer.cc:981:    RPStringSet allAliases = this[01;31m-[00m>_Aliases[01;31m-[00m>cartesianProductInsert("/",atomAliases);
monomer.cc:986:{_F(this[01;31m-[00m>lisp());
monomer.cc:990:    LOG(BF("Checking if %s recognizes alias(%s)") % this[01;31m-[00m>description().c_str() % alias[01;31m-[00m>__repr__().c_str()  ); // vp0(("Checking if %s recognizes alias(%s)",this[01;31m-[00m>description().c_str(),alias[01;31m-[00m>__repr__().c_str() ));
monomer.cc:991:    if ( !this[01;31m-[00m>_Aliases[01;31m-[00m>contains(alias[01;31m-[00m>getMonomerAlias()) )
monomer.cc:994:	LOG(BF("The monomer aliases that it recognizes are: %s") % this[01;31m-[00m>_Aliases[01;31m-[00m>asString().c_str()  ); // vp0(("The monomer aliases that it recognizes are: %s", this[01;31m-[00m>_Aliases[01;31m-[00m>asString().c_str() ));
monomer.cc:997:    LOG(BF("%s does recognize monomer alias(%s)") % this[01;31m-[00m>description().c_str() % alias[01;31m-[00m>__repr__().c_str() ); // vp0(("%s does recognize monomer alias(%s)",this[01;31m-[00m>description().c_str(),alias[01;31m-[00m>__repr__().c_str()));
monomer.cc:998:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:999:    if ( bdb[01;31m-[00m>recognizesMonomerSetName(this[01;31m-[00m>getGroupName()) )
monomer.cc:1001:    	LOG(BF("Checking if represents a MonomerSet with interesting atom alias(%s)") % alias[01;31m-[00m>getAtomAlias().c_str()  ); // vp0(("Checking if represents a MonomerSet with interesting atom alias(%s)",alias[01;31m-[00m>getAtomAlias().c_str() ));
monomer.cc:1002:        monomerSet = bdb[01;31m-[00m>getMonomerSet(this[01;31m-[00m>getGroupName());
monomer.cc:1003:	if ( monomerSet[01;31m-[00m>hasInterestingAtomAlias( alias ) )
monomer.cc:1005:	    LOG(BF("MonomerSet does have interesting atom with alias(%s)") % alias[01;31m-[00m>getAtomAlias().c_str()  ); // vp0(("MonomerSet does have interesting atom with alias(%s)",alias[01;31m-[00m>getAtomAlias().c_str() ));
monomer.cc:1009:	    LOG(BF("MonomerSet does not have interesting atom with alias(%s)") % alias[01;31m-[00m>getAtomAlias().c_str()  ); // vp0(("MonomerSet does not have interesting atom with alias(%s)",alias[01;31m-[00m>getAtomAlias().c_str() ));
monomer.cc:1020:{_F(this[01;31m-[00m>lisp());
monomer.cc:1026:	bdb = this[01;31m-[00m>getBuilderDatabase();
monomer.cc:1027:	lastPack = bdb[01;31m-[00m>getWeakLastUserMonomerPackToChange();
monomer.cc:1029:	if ( lastPack.lock()[01;31m-[00m>notNil() )
monomer.cc:1031:	    if ( lastPack.lock()[01;31m-[00m>getName() == this[01;31m-[00m>getGroupName() )
monomer.cc:1033:		LOG(BF("My MonomerPack(%s) changed so I'll update myself") % this[01;31m-[00m>getGroupName().c_str() ); // vp0(("My MonomerPack(%s) changed so I'll update myself",this[01;31m-[00m>getGroupName().c_str()));
monomer.cc:1034:		this[01;31m-[00m>_expandGroupName();
monomer.cc:1051:{_F(this[01;31m-[00m>lisp());
monomer.cc:1052:    this[01;31m-[00m>O_Monomer::setBuilderDatabase(db);
monomer.cc:1053://    db[01;31m-[00m>connectListener(this[01;31m-[00m>sharedThis<O_MultiMonomer>(),BuilderDatabase_MonomerPack_contentsChanged );
monomer.cc:1060:{_F(this[01;31m-[00m>lisp());
monomer.cc:1061:    this[01;31m-[00m>_CurrentMonomerIndex++;
monomer.cc:1062:    if ( this[01;31m-[00m>_CurrentMonomerIndex == this[01;31m-[00m>_Monomers.size() )
monomer.cc:1064:        LOG(BF("Increment overflow [01;31m-[00m[01;31m-[00m resetting to zero") ); // vp0(("Increment overflow [01;31m-[00m[01;31m-[00m resetting to zero"));
monomer.cc:1065:        this[01;31m-[00m>_CurrentMonomerIndex = 0;
monomer.cc:1068:    LOG(BF("After increment index(%d)  monomer=%s") % this[01;31m-[00m>_CurrentMonomerIndex % this[01;31m-[00m>description().c_str()  ); // vp0(("After increment index(%d)  monomer=%s",this[01;31m-[00m>_CurrentMonomerIndex,this[01;31m-[00m>description().c_str() ));
monomer.cc:1079:    for ( wci=this[01;31m-[00m>begin_WeakCouplings();
monomer.cc:1080:    		wci!=this[01;31m-[00m>end_WeakCouplings(); wci++ ) {
monomer.cc:1081:	if ( O_DirectionalCoupling::isOutPlugName(wci[01;31m-[00m>first,_lisp) )
monomer.cc:1083:	    ASSERT_NOT_NULL(wci[01;31m-[00m>second);
monomer.cc:1084:	    coup = wci[01;31m-[00m>second.lock();
monomer.cc:1097:    for ( wci=this[01;31m-[00m>begin_WeakCouplings();
monomer.cc:1098:    		wci!=this[01;31m-[00m>end_WeakCouplings(); wci++ ) {
monomer.cc:1099:	if ( O_Coupling::isOutPlugName(wci[01;31m-[00m>first) )
monomer.cc:1101:	    ASSERT_NOT_NULL(wci[01;31m-[00m>second);
monomer.cc:1102:	    coup = wci[01;31m-[00m>second.lock();
monomer.cc:1115:    for ( wci=this[01;31m-[00m>begin_WeakCouplings();
monomer.cc:1116:    		wci!=this[01;31m-[00m>end_WeakCouplings(); wci++ ) {
monomer.cc:1117:	ASSERT_NOT_NULL(wci[01;31m-[00m>second);
monomer.cc:1118:	coup = wci[01;31m-[00m>second.lock();
monomer.cc:1119:	mon = coup[01;31m-[00m>getOtherSideMonomer(this[01;31m-[00m>sharedThis<O_Monomer>());
monomer.cc:1134:	this[01;31m-[00m>addMonomerName(x);
monomer.cc:1147:    class_<O_Monomer>(this[01;31m-[00m>lisp())
monomer.cc:1252:    class_<O_OneMonomer>(this[01;31m-[00m>lisp());
monomer.cc:1272:    class_<O_MultiMonomer>(this[01;31m-[00m>lisp())
monomerContext.cc:34:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:37:    this[01;31m-[00m>_Self = RP_Copy<O_MonomerSetBase>(mc._Self);
monomerContext.cc:39:	rec = RP_Copy<O_MonomerSetBase>(mi[01;31m-[00m>second);
monomerContext.cc:40:	this[01;31m-[00m>_Neighbors.set(mi[01;31m-[00m>first,rec);
monomerContext.cc:50:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:51:    this[01;31m-[00m>Base::oldLispInitialize(keyed,env);
monomerContext.cc:58:    if ( node[01;31m-[00m>saving() )
monomerContext.cc:61:        for ( mi=this[01;31m-[00m>_Neighbors.begin(); mi!=this[01;31m-[00m>_Neighbors.end(); mi++ )
monomerContext.cc:63:	    ASSERTF(O_DirectionalCoupling::isPlugName(mi[01;31m-[00m>first,_lisp),BF("About to save Bad plug name in MonomerContext Neighbor: %s")% mi[01;31m-[00m>first );
monomerContext.cc:67:    node[01;31m-[00m>archiveObject("self",this[01;31m-[00m>_Self);
monomerContext.cc:68:    node[01;31m-[00m>archiveMap("neighbors", this[01;31m-[00m>_Neighbors );
monomerContext.cc:70:    if ( node[01;31m-[00m>loading() )
monomerContext.cc:73:        for ( mi=this[01;31m-[00m>_Neighbors.begin(); mi!=this[01;31m-[00m>_Neighbors.end(); mi++ )
monomerContext.cc:75:	    ASSERTF(O_DirectionalCoupling::isPlugName(mi[01;31m-[00m>first,_lisp), BF("Loaded Bad plug name in MonomerContext Neighbor: %s")% mi[01;31m-[00m>first );
monomerContext.cc:85:    desc << this[01;31m-[00m>O_Object::description();
monomerContext.cc:93:    r[01;31m-[00m>getBuilderDatabase();
monomerContext.cc:95:    ASSERTF(this[01;31m-[00m>_Neighbors.count(cn) == 0, BF("MonomerContext already has a key: %s")% cn );
monomerContext.cc:96:    this[01;31m-[00m>_Neighbors.set(cn,r);
monomerContext.cc:105:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:107:    if ( mit==this[01;31m-[00m>_Neighbors.end() ) {
monomerContext.cc:108:	RPSpecificContext final = name[01;31m-[00m>copy();
monomerContext.cc:109:	list[01;31m-[00m>add(final);
monomerContext.cc:111:	if ( mit[01;31m-[00m>second[01;31m-[00m>getOptional() )
monomerContext.cc:116:	    this[01;31m-[00m>expandOutsSpecificContexts(mitNext, list, name );
monomerContext.cc:119:	name[01;31m-[00m>pushNeighbor(mit[01;31m-[00m>first,"");
monomerContext.cc:121:	RPStringSet ss = mit[01;31m-[00m>second[01;31m-[00m>getMonomerNames();
monomerContext.cc:122:	LOG(BF("There are %d equivalent names") % ss[01;31m-[00m>size() ); // vp0(("There are %d equivalent names",ss[01;31m-[00m>size()));
monomerContext.cc:123://	ASSERTP(ss[01;31m-[00m>size()!=0,"Problem, there are no equivalent names");
monomerContext.cc:124:	if ( ss[01;31m-[00m>size() == 0 )
monomerContext.cc:126:	    ss = O_StringSet::create(this[01;31m-[00m>lisp());
monomerContext.cc:127:	    ss[01;31m-[00m>insert("undef");
monomerContext.cc:129:	for (O_StringSet::iterator it=ss[01;31m-[00m>begin(); it!=ss[01;31m-[00m>end(); it++ ) 
monomerContext.cc:131:	    name[01;31m-[00m>setLastNeighborName(*it);
monomerContext.cc:135:	    this[01;31m-[00m>expandOutsSpecificContexts(mitNext, list, name );
monomerContext.cc:137:	name[01;31m-[00m>popNeighbor();
monomerContext.cc:147:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:151:    if ( mit==this[01;31m-[00m>_Neighbors.end() ) {
monomerContext.cc:153:	list[01;31m-[00m>insert(name.all());
monomerContext.cc:156:	name.push(mit[01;31m-[00m>first);
monomerContext.cc:159:	ss = mit[01;31m-[00m>second[01;31m-[00m>getMonomerNames();
monomerContext.cc:160:	LOG(BF("There are %d equivalent names") % ss[01;31m-[00m>size() ); // vp0(("There are %d equivalent names",ss[01;31m-[00m>size()));
monomerContext.cc:161://	ASSERTP(ss[01;31m-[00m>size()!=0,"Problem, there are no equivalent names");
monomerContext.cc:162:	if ( ss[01;31m-[00m>size() == 0 )
monomerContext.cc:164:	    ss = O_StringSet::create(this[01;31m-[00m>lisp());
monomerContext.cc:165:	    ss[01;31m-[00m>insert("undef");
monomerContext.cc:167:	for ( it=ss[01;31m-[00m>begin(); it!=ss[01;31m-[00m>end(); it++ ) {
monomerContext.cc:174:	    this[01;31m-[00m>expandOuts(mitNext, list, name );
monomerContext.cc:186:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:192:	<< this[01;31m-[00m>_Self[01;31m-[00m>getKey();
monomerContext.cc:193:    for ( ci=this[01;31m-[00m>_Neighbors.begin(); ci!=this[01;31m-[00m>_Neighbors.end(); ci++ ) {
monomerContext.cc:194:	ss << ci[01;31m-[00m>first << COUPLING_CHAR << ci[01;31m-[00m>second[01;31m-[00m>getKey();
monomerContext.cc:203:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:208:    LOG(BF("Getting context strings for context: %s") % this[01;31m-[00m>asXmlString().c_str()  ); // vp0(( "Getting context strings for context: %s", this[01;31m-[00m>asXmlString().c_str() ));
monomerContext.cc:209:    expandedList = O_StringSet::create(this[01;31m-[00m>lisp());
monomerContext.cc:211:    selfNames = this[01;31m-[00m>_Self[01;31m-[00m>getMonomerNames();
monomerContext.cc:212:    LOG(BF("There are %d selfNames") % selfNames[01;31m-[00m>size()  ); // vp0(("There are %d selfNames",selfNames[01;31m-[00m>size() ));
monomerContext.cc:213:    for ( si=selfNames[01;31m-[00m>begin(); si!=selfNames[01;31m-[00m>end(); si++ ) 
monomerContext.cc:215:	LOG(BF("Push self name: %s") % si[01;31m-[00m>c_str()  ); // vp0(( "Push self name: %s", si[01;31m-[00m>c_str() ));
monomerContext.cc:219:	this[01;31m-[00m>expandOuts(this[01;31m-[00m>_Neighbors.begin(), expandedList, name );
monomerContext.cc:228:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:232:    LOG(BF("Getting context strings for context: %s") % this[01;31m-[00m>asXmlString().c_str()  ); // vp0(( "Getting context strings for context: %s", this[01;31m-[00m>asXmlString().c_str() ));
monomerContext.cc:233:    RPSpecificContextSet expandedList = O_SpecificContextSet::create(this[01;31m-[00m>lisp());
monomerContext.cc:234:    RPSpecificContext one = O_SpecificContext::create(this[01;31m-[00m>lisp());
monomerContext.cc:235:    one[01;31m-[00m>clear();
monomerContext.cc:236:    selfNames = this[01;31m-[00m>_Self[01;31m-[00m>getMonomerNames();
monomerContext.cc:237:    LOG(BF("There are %d selfNames") % selfNames[01;31m-[00m>size()  ); // vp0(("There are %d selfNames",selfNames[01;31m-[00m>size() ));
monomerContext.cc:238:    for ( si=selfNames[01;31m-[00m>begin(); si!=selfNames[01;31m-[00m>end(); si++ ) 
monomerContext.cc:240:	LOG(BF("Push self name: %s") % si[01;31m-[00m>c_str()  ); // vp0(( "Push self name: %s", si[01;31m-[00m>c_str() ));
monomerContext.cc:241:	one[01;31m-[00m>setSelfName(*si);
monomerContext.cc:242:	this[01;31m-[00m>expandOutsSpecificContexts(this[01;31m-[00m>_Neighbors.begin(), expandedList, one );
monomerContext.cc:252:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:261:    expandedList = O_StringSet::create(this[01;31m-[00m>lisp());
monomerContext.cc:262:    expandedList = this[01;31m-[00m>getAllSpecificKeys();
monomerContext.cc:263:    res = *(expandedList[01;31m-[00m>begin());
monomerContext.cc:277:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:281:    if ( !this[01;31m-[00m>_Self[01;31m-[00m>recognizesNameOrPdb(
monomerContext.cc:282:			testSub[01;31m-[00m>_Self[01;31m-[00m>getMonomerNames()[01;31m-[00m>first()) ) {
monomerContext.cc:286:    if ( this[01;31m-[00m>_Neighbors.size() != testSub[01;31m-[00m>_Neighbors.size() ) {
monomerContext.cc:290:    for ( ti = this[01;31m-[00m>_Neighbors.begin();
monomerContext.cc:291:    		ti != this[01;31m-[00m>_Neighbors.end(); ti++ ) 
monomerContext.cc:293:        if ( !testSub[01;31m-[00m>_Neighbors.contains(ti[01;31m-[00m>first) ) {
monomerContext.cc:294:	    LOG(BF("testSub doesn't have a neighbor: %s") % ti[01;31m-[00m>first.c_str()  ); // vp0(( "testSub doesn't have a neighbor: %s", ti[01;31m-[00m>first.c_str() ));
monomerContext.cc:297:	testSubRecognizer = testSub[01;31m-[00m>_Neighbors.get(ti[01;31m-[00m>first);
monomerContext.cc:298:	RPStringSet myNames = ti[01;31m-[00m>second[01;31m-[00m>getMonomerNames();
monomerContext.cc:299:	RPStringSet testSubNames = testSubRecognizer[01;31m-[00m>getMonomerNames();
monomerContext.cc:300:	if ( !myNames[01;31m-[00m>containsSubset(testSubNames) )
monomerContext.cc:303:	    LOG(BF("I recognize (%s)[01;31m-[00m> names: %s") % ti[01;31m-[00m>first.c_str() % myNames[01;31m-[00m>asString().c_str()  ); // vp0(( "I recognize (%s)[01;31m-[00m> names: %s", ti[01;31m-[00m>first.c_str(), myNames[01;31m-[00m>asString().c_str() ));
monomerContext.cc:304:	    LOG(BF("testSub recognizes (%s)[01;31m-[00m> names: %s") % ti[01;31m-[00m>first.c_str() % testSubNames[01;31m-[00m>asString().c_str()  ); // vp0(( "testSub recognizes (%s)[01;31m-[00m> names: %s", ti[01;31m-[00m>first.c_str(), testSubNames[01;31m-[00m>asString().c_str() ));
monomerContext.cc:315:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:318:    if ( !this[01;31m-[00m>_Self[01;31m-[00m>recognizesNameOrPdb(mon[01;31m-[00m>getName() )) {
monomerContext.cc:319:	LOG(BF("MonomerContext doesn't recognize central monomer: %s") % (mon[01;31m-[00m>getName().c_str() ) ); // vp0(( "MonomerContext doesn't recognize central monomer: %s", mon[01;31m-[00m>getName().c_str() ));
monomerContext.cc:323:    if ( this[01;31m-[00m>_Neighbors.size() != mon[01;31m-[00m>numberOfCouplings() ) {
monomerContext.cc:327:    LOG(BF("STATUS monomer = %s") % (mon[01;31m-[00m>getName().c_str() ) ); // vp0(("STATUS monomer = %s", mon[01;31m-[00m>getName().c_str() ));
monomerContext.cc:328:    LOG(BF("Monomer has %d couplings") % (mon[01;31m-[00m>numberOfCouplings() ) ); // vp0(( "Monomer has %d couplings", mon[01;31m-[00m>numberOfCouplings() ));
monomerContext.cc:329:    LOG(BF("MonomerContext has %d neighbors") % (this[01;31m-[00m>_Neighbors.size() ) ); // vp0(( "MonomerContext has %d neighbors", this[01;31m-[00m>_Neighbors.size() ));
monomerContext.cc:332:    for ( oi=mon[01;31m-[00m>begin_WeakCouplings(); oi!=mon[01;31m-[00m>end_WeakCouplings(); oi++ )
monomerContext.cc:334:	RPCoupling coup = (oi[01;31m-[00m>second).lock();
monomerContext.cc:335:	if (coup[01;31m-[00m>isOfClass<O_DirectionalCoupling>() )
monomerContext.cc:337:	    RPDirectionalCoupling dc = coup[01;31m-[00m>as<O_DirectionalCoupling>();
monomerContext.cc:338:	    LOG(BF("Looking at dc[01;31m-[00m>getName()= %s") % (dc[01;31m-[00m>getName().c_str() ) ); // vp0(( "Looking at dc[01;31m-[00m>getName()= %s", dc[01;31m-[00m>getName().c_str() ));
monomerContext.cc:339:	    if ( !this[01;31m-[00m>_Neighbors.contains(dc[01;31m-[00m>getName()) )
monomerContext.cc:341:		LOG(BF("MonomerContext doesn't recognize out.coupling=%s ") % dc[01;31m-[00m>getName().c_str()  ); // vp0(( "MonomerContext doesn't recognize out.coupling=%s ", dc[01;31m-[00m>getName().c_str() ));
monomerContext.cc:346:	    RPRingCoupling rc = coup[01;31m-[00m>as<O_RingCoupling>();
monomerContext.cc:347:	    LOG(BF("Ignoring out coupling for RingCoupling: %s") % rc[01;31m-[00m>getName().c_str()  ); // vp0(( "Ignoring out coupling for RingCoupling: %s", rc[01;31m-[00m>getName().c_str() ));
monomerContext.cc:356:{_F(this[01;31m-[00m>lisp());
monomerContext.cc:358:    ss = O_MonomerSet::create(this[01;31m-[00m>lisp());
monomerContext.cc:360:    ss[01;31m-[00m>setMonomerNameOrPdb(mon[01;31m-[00m>getName());
monomerContext.cc:362:    this[01;31m-[00m>_Self = ss;
monomerContext.cc:384:    class_<O_MonomerContext>(this[01;31m-[00m>lisp())
monomerCoordinates.cc:40:    this[01;31m-[00m>_TrainerName = "";
monomerCoordinates.cc:45:{_F(this[01;31m-[00m>lisp());
monomerCoordinates.cc:46:    node[01;31m-[00m>attribute("comment",this[01;31m-[00m>_Comment);
monomerCoordinates.cc:47:    node[01;31m-[00m>attributeIfNotDefault<string>("trainerName",this[01;31m-[00m>_TrainerName, "" );
monomerCoordinates.cc:48:    node[01;31m-[00m>archiveObject("context",this[01;31m-[00m>_Context);
monomerCoordinates.cc:49:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_FragmentCoordinates);
monomerCoordinates.cc:50:    node[01;31m-[00m>archiveOnlyObjectOfClass<O_ScaffoldList>(this[01;31m-[00m>_ScaffoldList);
monomerCoordinates.cc:54:{_F(this[01;31m-[00m>lisp());
monomerCoordinates.cc:56:    for ( fit=this[01;31m-[00m>_FragmentCoordinates.begin();
monomerCoordinates.cc:57:    		fit!=this[01;31m-[00m>_FragmentCoordinates.end(); fit++ )
monomerCoordinates.cc:59:	if ( (*fit)[01;31m-[00m>getFragmentName() == name ) return *fit;
monomerCoordinates.cc:61:    return O_FragmentCoordinates::nil(this[01;31m-[00m>lisp());
monomerCoordinates.cc:65:{_F(this[01;31m-[00m>lisp());
monomerCoordinates.cc:66:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
monomerCoordinates.cc:69:    for ( fit=this[01;31m-[00m>_FragmentCoordinates.begin();
monomerCoordinates.cc:70:    		fit!=this[01;31m-[00m>_FragmentCoordinates.end(); fit++ )
monomerCoordinates.cc:72:	RPCons one = O_Cons::create(*fit,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
monomerCoordinates.cc:73:	cur[01;31m-[00m>setCdr(one);
monomerCoordinates.cc:76:    return first[01;31m-[00m>cdr();
monomerCoordinates.cc:80:{_F(this[01;31m-[00m>lisp());
monomerCoordinates.cc:82:    for ( fit=this[01;31m-[00m>_FragmentCoordinates.begin();
monomerCoordinates.cc:83:    		fit!=this[01;31m-[00m>_FragmentCoordinates.end(); fit++ )
monomerCoordinates.cc:85:	LOG(BF("Looking at FragmentCoordinates(%s) for atom named(%s)") % (*fit)[01;31m-[00m>getFragmentName().c_str() % name.c_str()  ); // vp0(( "Looking at FragmentCoordinates(%s) for atom named(%s)", (*fit)[01;31m-[00m>getFragmentName().c_str(), name.c_str() ));
monomerCoordinates.cc:86:	if ( (*fit)[01;31m-[00m>recognizesAtomName(name) ) 
monomerCoordinates.cc:88:	    LOG(BF("Found it! FragmentCoordinates for fragment named(%s)") % (*fit)[01;31m-[00m>getFragmentName().c_str()  ); // vp0(( "Found it! FragmentCoordinates for fragment named(%s)", (*fit)[01;31m-[00m>getFragmentName().c_str() ));
monomerCoordinates.cc:92:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There is no FragmentCoordinates in MonomerCoordinates("+this[01;31m-[00m>getComment()+") that contains atom with name("+name+")"));
monomerCoordinates.cc:96:{_F(this[01;31m-[00m>lisp());
monomerCoordinates.cc:97:    this[01;31m-[00m>Base::oldLispInitialize(keyed,env);
monomerCoordinates.cc:98:    RPMonomerContext context = keyed[01;31m-[00m>getAndRemove("context")[01;31m-[00m>as<O_MonomerContext>();
monomerCoordinates.cc:99:    this[01;31m-[00m>setContext(context);
monomerCoordinates.cc:105:{_F(this[01;31m-[00m>lisp());
monomerCoordinates.cc:111:    return this[01;31m-[00m>_ScaffoldList[01;31m-[00m>hasAnchorOrigin();
monomerCoordinates.cc:126:{_F(this[01;31m-[00m>lisp());
monomerCoordinates.cc:145:	    extractFragment = topology[01;31m-[00m>getExtractCoreFragment();
monomerCoordinates.cc:146:	    LOG(BF("Got core fragment: %s") % extractFragment[01;31m-[00m>description().c_str() ); // vp0(("Got core fragment: %s",extractFragment[01;31m-[00m>description().c_str()));
monomerCoordinates.cc:147:	    uniqueStructures = extractFragment[01;31m-[00m>isolateUniqueStructures(
monomerCoordinates.cc:151:	    extractScaffold = topology[01;31m-[00m>getExtractScaffold();
monomerCoordinates.cc:152:	    RPAnchor anchor = extractScaffold[01;31m-[00m>getAnchor();
monomerCoordinates.cc:157:	    if ( anchor[01;31m-[00m>isOfClass<O_AnchorOrigin>() )
monomerCoordinates.cc:162:		agg = uniqueStructures[01;31m-[00m>getMatter()[01;31m-[00m>as<O_Aggregate>();
monomerCoordinates.cc:169:		ASSERT(extractScaffold[01;31m-[00m>numberOfExtractCompleteFrames()>0);
monomerCoordinates.cc:170:		firstExtractFrame = *(extractScaffold[01;31m-[00m>begin_ExtractCompleteFrames());
monomerCoordinates.cc:171:		firstFrame = firstExtractFrame[01;31m-[00m>getFrame();
monomerCoordinates.cc:175:		for ( sli=uniqueStructures[01;31m-[00m>begin_Entries();
monomerCoordinates.cc:176:				sli!=uniqueStructures[01;31m-[00m>end_Entries(); sli++ )
monomerCoordinates.cc:178:		    (*sli)[01;31m-[00m>writeCoordinatesToMatter(agg);
monomerCoordinates.cc:181:		        coordSys = firstFrame[01;31m-[00m>getCoordinateSystem(focusMonomer);
monomerCoordinates.cc:184:			if ( !e.conditionObject()[01;31m-[00m>isAssignableTo<O_MathException>() )
monomerCoordinates.cc:192:			coordSys = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
monomerCoordinates.cc:194:		    toOriginTransform = coordSys[01;31m-[00m>matrixToCanonical();
monomerCoordinates.cc:195:		    agg[01;31m-[00m>applyTransformToAtoms(toOriginTransform);
monomerCoordinates.cc:196:		    (*sli)[01;31m-[00m>extractCoordinatesFromMatter(agg);
monomerCoordinates.cc:200:	    if ( !extractFragment[01;31m-[00m>sharesAtomsWithExtractScaffold(extractScaffold,
monomerCoordinates.cc:205:		ss << "ExtractFragment fragment name:("+extractFragment[01;31m-[00m>getFragment()[01;31m-[00m>getName()+") atoms: [" << extractFragment[01;31m-[00m>getFragment()[01;31m-[00m>getAtomNames()[01;31m-[00m>asString() << "]" << endl;
monomerCoordinates.cc:207:		TOSS(_lisp[01;31m-[00m>create<O_ContentException>(ss.str()));
monomerCoordinates.cc:211:	    coreFragmentCoordinates = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_FragmentCoordinates>();
monomerCoordinates.cc:212:	    coreFragmentCoordinates[01;31m-[00m>defineFromConformationCollection(extractFragment,
monomerCoordinates.cc:216:	    this[01;31m-[00m>_FragmentCoordinates.clear();
monomerCoordinates.cc:217:	    this[01;31m-[00m>_FragmentCoordinates.push_back(coreFragmentCoordinates);
monomerCoordinates.cc:220:	    scaffoldList = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ScaffoldList>();
monomerCoordinates.cc:221:	    scaffoldList[01;31m-[00m>defineFromExtractScaffoldAndConformationCollection( extractScaffold,
monomerCoordinates.cc:227:	    this[01;31m-[00m>_ScaffoldList = scaffoldList;
monomerCoordinates.cc:233:    {_BLOCK_TRACE("Extract the non[01;31m-[00mcore fragments");
monomerCoordinates.cc:235:	for ( fi = topology[01;31m-[00m>begin_ExtractFragments();
monomerCoordinates.cc:236:		    fi!=topology[01;31m-[00m>end_ExtractFragments(); fi++ )
monomerCoordinates.cc:238:	    uniqueStructures = (*fi)[01;31m-[00m>isolateUniqueStructures(conformationExplorer,
monomerCoordinates.cc:240:	    fragmentCoordinates = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_FragmentCoordinates>();
monomerCoordinates.cc:241:	    fragmentCoordinates[01;31m-[00m>defineFromConformationCollection(*fi,
monomerCoordinates.cc:246:	    this[01;31m-[00m>_FragmentCoordinates.push_back(fragmentCoordinates);
monomerCoordinates.cc:249:    LOG(BF("MonomerCoordinates defined: %s") % this[01;31m-[00m>asXmlString().c_str()  ); // vp0(("MonomerCoordinates defined: %s",this[01;31m-[00m>asXmlString().c_str() ));
monomerCoordinates.cc:258:{_F(this[01;31m-[00m>lisp());
monomerCoordinates.cc:259:    this[01;31m-[00m>_defineFromConformationExplorerOrDebug(topology, conformationExplorer, focusMonomer, false,
monomerCoordinates.cc:275:{_F(this[01;31m-[00m>lisp());
monomerCoordinates.cc:276:    RPConformationExplorer conformationExplorer = O_ConformationExplorer::create(this[01;31m-[00m>lisp());
monomerCoordinates.cc:277:    conformationExplorer[01;31m-[00m>setMatter(aggregate);
monomerCoordinates.cc:278:    conformationExplorer[01;31m-[00m>superposeAllHeavyAtoms();
monomerCoordinates.cc:279:    RPConformationExplorerEntry entry = conformationExplorer[01;31m-[00m>createEntry();
monomerCoordinates.cc:280:    RPConformationExplorerEntryStage stage = entry[01;31m-[00m>createEntryStage();
monomerCoordinates.cc:282:    stage[01;31m-[00m>setStageName("test");
monomerCoordinates.cc:283:    stage[01;31m-[00m>setExternalInterfaceName("testPackage");
monomerCoordinates.cc:284:    stage[01;31m-[00m>setModel("testModel");
monomerCoordinates.cc:285:    stage[01;31m-[00m>setEnergyKCal(987654321.0);
monomerCoordinates.cc:286:    entry[01;31m-[00m>setSelectedStage(stage);
monomerCoordinates.cc:287:    stage[01;31m-[00m>extractCoordinatesFromMatter(aggregate);
monomerCoordinates.cc:288:    stage[01;31m-[00m>setComplete(true);
monomerCoordinates.cc:289:    entry[01;31m-[00m>appendEntryStage(stage);
monomerCoordinates.cc:290:    conformationExplorer[01;31m-[00m>appendEntry(entry);
monomerCoordinates.cc:292:    RPStringStream problems = O_StringStream::create(this[01;31m-[00m>lisp());
monomerCoordinates.cc:295:        this[01;31m-[00m>_defineFromConformationExplorerOrDebug(topology,conformationExplorer,focusMonomer,true,UndefinedUnsignedInt);
monomerCoordinates.cc:298:	if ( !e.conditionObject()[01;31m-[00m>isAssignableTo<O_MathException>() )
monomerCoordinates.cc:300:	    RETOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("A MathException was caught in O_MonomerCoordinates::testExtraction but it should have been caught earlier [01;31m-[00m here it is: %s") % e.message() ) );
monomerCoordinates.cc:304:	problems[01;31m-[00m>write(e.message());
monomerCoordinates.cc:306:    RPCons results = O_Cons::createList(this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword("sawProblems"),this[01;31m-[00m>lisp()[01;31m-[00m>_boolean(sawProblem),this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword("problems"),problems,this[01;31m-[00m>lisp());
monomerCoordinates.cc:324:    class_<O_MonomerCoordinates>(this[01;31m-[00m>lisp())
monomerGroup.cc:19:    this[01;31m-[00m>Base::initialize();
monomerGroup.cc:20:    this[01;31m-[00m>_Representative = "";
monomerGroup.cc:21:    LOG(BF("Creating %s") % this[01;31m-[00m>description()  );
monomerGroup.cc:30://    this[01;31m-[00m>_IsConstitutionGroup = ss._IsConstitutionGroup;
monomerGroup.cc:31:    this[01;31m-[00m>_Representative = ss._Representative;
monomerGroup.cc:37:    ss << "[" << this[01;31m-[00m>className() << "@" << std::hex << this
monomerGroup.cc:38:        << " name(" << this[01;31m-[00m>_Name 
monomerGroup.cc:39:  	<< ") representative:" <<this[01;31m-[00m>_Representative;
monomerGroup.cc:40:    ss << " contents: '[" << this[01;31m-[00m>_ContainedNames[01;31m-[00m>asString() << "] ]";
monomerGroup.cc:48:{_F(this[01;31m-[00m>lisp());
monomerGroup.cc:49:    return this[01;31m-[00m>_Representative;
monomerGroup.cc:53:{_F(this[01;31m-[00m>lisp());
monomerGroup.cc:54:    this[01;31m-[00m>_Representative = cc;
monomerGroup.cc:58:{_F(this[01;31m-[00m>lisp());
monomerGroup.cc:59:    return this[01;31m-[00m>_Representative != "";
monomerGroup.cc:64:{_F(this[01;31m-[00m>lisp());
monomerGroup.cc:67:    newGroup = RP_Copy<O_MonomerGroup>(this[01;31m-[00m>sharedThis<O_MonomerGroup>());
monomerGroup.cc:68:    newGroup[01;31m-[00m>_ContainedNames = O_StringSet::create(this[01;31m-[00m>lisp());
monomerGroup.cc:69:    newGroup[01;31m-[00m>_ContainedNames[01;31m-[00m>insert(this[01;31m-[00m>_Name);
monomerGroup.cc:77:{_F(this[01;31m-[00m>lisp());
monomerGroup.cc:78:    this[01;31m-[00m>Base::archiveBase(node);
monomerGroup.cc:80:    node[01;31m-[00m>attributeIfNotDefault("representative", this[01;31m-[00m>_Representative, strDef );
monomerGroup.cc:81://    node[01;31m-[00m>attributeIfNotDefault("isConstitutionGroup", this[01;31m-[00m>_IsConstitutionGroup, false );
monomerGroup.cc:86:{_F(this[01;31m-[00m>lisp());
monomerGroup.cc:87:    this[01;31m-[00m>archiveBase(node);
monomerGroup.cc:93:{_F(this[01;31m-[00m>lisp());
monomerGroup.cc:97:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerGroup.cc:98:    if ( this[01;31m-[00m>_Representative == "" )
monomerGroup.cc:100:        return this[01;31m-[00m>Base::expandedRepresentativeList();
monomerGroup.cc:102:    ASSERTP(bdb[01;31m-[00m>recognizesEntityName(this[01;31m-[00m>_Representative),
monomerGroup.cc:103:    		"builderDatabase does not recognize entity name("+this[01;31m-[00m>_Representative+")");
monomerGroup.cc:104:    obj = bdb[01;31m-[00m>getEntity(this[01;31m-[00m>_Representative);
monomerGroup.cc:105:    ASSERTF(obj[01;31m-[00m>isTerminalName(), BF("Representatives must always be terminal names, this representative(%s) is NOT")% obj[01;31m-[00m>getName() );
monomerGroup.cc:106:    objList = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectList>();
monomerGroup.cc:107:    objList[01;31m-[00m>append(this[01;31m-[00m>sharedThis<O_MonomerGroup>());
monomerGroup.cc:112:{_F(this[01;31m-[00m>lisp());
monomerGroup.cc:113:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
monomerGroup.cc:114:    this[01;31m-[00m>_Representative = dict[01;31m-[00m>getStringAndRemoveOrDefault("representativeName","");
monomerGroup.cc:125:    this[01;31m-[00m>Base::initialize();
monomerGroup.cc:132:    ss << this[01;31m-[00m>className() <<"("<<me[01;31m-[00m>getName()<<") representative("<<me[01;31m-[00m>getRepresentative()<<")@" << std::hex << this;
monomerGroup.cc:147:    this[01;31m-[00m>O_MonomerGroup::archive(node);
monomerGroup.cc:160:    class_<O_MonomerGroup>(this[01;31m-[00m>lisp())
monomerGroup.cc:193:    class_<O_BuiltInGroup>(this[01;31m-[00m>lisp())
monomerPack.cc:47:    int numArgs = args[01;31m-[00m>length();
monomerPack.cc:50:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide 2 or 3 arguments"));
monomerPack.cc:52:    packName = args[01;31m-[00m>listref<O_Text>(0);
monomerPack.cc:53:    parts = args[01;31m-[00m>listref<O_Cons>(1);
monomerPack.cc:56:        atomAliases = args[01;31m-[00m>listref<O_Cons>(2);
monomerPack.cc:61:    bdb = lisp[01;31m-[00m>getBuilderDatabase();
monomerPack.cc:64:    if ( bdb[01;31m-[00m>recognizesUserMonomerPack(packName[01;31m-[00m>get()) )
monomerPack.cc:65:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("monomerPack("+packName[01;31m-[00m>get()+") is already defined"));
monomerPack.cc:67:    RPMonomerPack monomerPack = lisp[01;31m-[00m>create<O_MonomerPack>();
monomerPack.cc:68:    monomerPack[01;31m-[00m>setName(packName[01;31m-[00m>get());
monomerPack.cc:69:    monomerPack[01;31m-[00m>defineContentsFromCons(atomAliases, parts);
monomerPack.cc:73:    bdb[01;31m-[00m>defineUserMonomerPack(monomerPack);
monomerPack.cc:102:    int numArgs = args[01;31m-[00m>length();
monomerPack.cc:105:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide 3 arguments"));
monomerPack.cc:107:    RPText packName = args[01;31m-[00m>listref<O_Text>(0);
monomerPack.cc:108:    RPCons parts = args[01;31m-[00m>listref<O_Cons>(1);
monomerPack.cc:109:    RPCons atomAliases = args[01;31m-[00m>listref<O_Cons>(2);
monomerPack.cc:110:    bdb = lisp[01;31m-[00m>getBuilderDatabase();
monomerPack.cc:112:    if ( !bdb[01;31m-[00m>recognizesUserMonomerPack(packName[01;31m-[00m>get()) )
monomerPack.cc:113:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("monomerPack("+packName[01;31m-[00m>get()+") has not been defined"));
monomerPack.cc:114:    RPMonomerPack monomerPack = bdb[01;31m-[00m>getUserMonomerPack(packName[01;31m-[00m>get())[01;31m-[00m>as<O_MonomerPack>();
monomerPack.cc:115:    monomerPack[01;31m-[00m>extendAliases(atomAliases, parts);
monomerPack.cc:145:    RPSymbol sym = lisp[01;31m-[00m>intern(pack[01;31m-[00m>getName());
monomerPack.cc:146:    environ[01;31m-[00m>extend(sym,opack);
monomerPack.cc:165:    this[01;31m-[00m>Base::initialize();
monomerPack.cc:166:    this[01;31m-[00m>_InterestingAtomAliases = O_StringList::create(this[01;31m-[00m>lisp());
monomerPack.cc:167:    this[01;31m-[00m>_AtomIndexers = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_MapOfMonomerNamesToAtomIndexers>();
monomerPack.cc:176:    this[01;31m-[00m>O_MonomerSet::archive(node);
monomerPack.cc:177:    node[01;31m-[00m>archiveObject("interestingAtomAliases",this[01;31m-[00m>_InterestingAtomAliases);
monomerPack.cc:178:    node[01;31m-[00m>archiveObject("atomIndexers",this[01;31m-[00m>_AtomIndexers);
monomerPack.cc:184:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:189:    aliases = O_StringList::create(this[01;31m-[00m>lisp());
monomerPack.cc:190:    for ( p=atomAliases; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() )
monomerPack.cc:192:	name = p[01;31m-[00m>car<O_Text>();
monomerPack.cc:193:	aliases[01;31m-[00m>append(name[01;31m-[00m>get());
monomerPack.cc:195:    this[01;31m-[00m>setInterestingAtomAliasesFromStringList(aliases);
monomerPack.cc:196:    for ( p=parts; p[01;31m-[00m>notNil(); p = p[01;31m-[00m>cdr() )
monomerPack.cc:198:	RPCons entry = p[01;31m-[00m>car<O_Cons>();
monomerPack.cc:199:	if ( entry[01;31m-[00m>length() <1 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("monomerPack Entry contains no monomer name"));
monomerPack.cc:200:	RPText monomerName = entry[01;31m-[00m>car<O_Text>();
monomerPack.cc:201:	this[01;31m-[00m>addMonomerName(monomerName[01;31m-[00m>get());
monomerPack.cc:202:	if ( aliases[01;31m-[00m>size() > 0 )
monomerPack.cc:204:	    if ( entry[01;31m-[00m>length() < 2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You defined atom aliases to each monomer must have interesting atom names"));
monomerPack.cc:205:	    RPCons interestingAtomNames = entry[01;31m-[00m>listref<O_Cons>(1);
monomerPack.cc:206:	    this[01;31m-[00m>setInterestingAtomNamesForMonomerNameFromCons(monomerName[01;31m-[00m>get(),interestingAtomNames);
monomerPack.cc:216:    RPStringSet extendMonomers = O_StringSet::create(this[01;31m-[00m>lisp());
monomerPack.cc:217:    uint numberOfAtomAliases = atomAliases[01;31m-[00m>length();
monomerPack.cc:218:    this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>appendConsOfStrings(atomAliases);
monomerPack.cc:219:    for ( RPCons cur = parts; cur[01;31m-[00m>notNil(); cur=cur[01;31m-[00m>cdr() )
monomerPack.cc:221:	RPCons oneExtend = cur[01;31m-[00m>car<O_Cons>();
monomerPack.cc:222:	if ( oneExtend[01;31m-[00m>length() != 2 )
monomerPack.cc:224:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Each extendAliases entry must have two elements: "+oneExtend[01;31m-[00m>__repr__() ));
monomerPack.cc:226:	RPText monomerName = oneExtend[01;31m-[00m>car<O_Text>();
monomerPack.cc:227:	RPCons aliasAtoms = oneExtend[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
monomerPack.cc:228:	extendMonomers[01;31m-[00m>insert(monomerName[01;31m-[00m>get());
monomerPack.cc:229:	if ( !this[01;31m-[00m>_AtomIndexers[01;31m-[00m>recognizesMonomerName(monomerName[01;31m-[00m>get()) )
monomerPack.cc:231:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("MonomerPack("+this[01;31m-[00m>getName()+") does not recognize monomer name("+monomerName[01;31m-[00m>get()+")"));
monomerPack.cc:233:	RPAtomIndexer indexer = this[01;31m-[00m>_AtomIndexers[01;31m-[00m>getAtomIndexerForMonomerName(monomerName[01;31m-[00m>get());
monomerPack.cc:234:	if ( aliasAtoms[01;31m-[00m>length() != numberOfAtomAliases )
monomerPack.cc:238:	    ss << aliasAtoms[01;31m-[00m>__repr__();
monomerPack.cc:239:	    ss << " for monomer(" << monomerName[01;31m-[00m>get();
monomerPack.cc:241:	    ss << atomAliases[01;31m-[00m>__repr__() ;
monomerPack.cc:242:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
monomerPack.cc:244:	indexer[01;31m-[00m>appendConsOfTexts(aliasAtoms);
monomerPack.cc:246:    if ( !extendMonomers[01;31m-[00m>equal(this[01;31m-[00m>_ContainedNames) )
monomerPack.cc:249:	ss << "There is a mismatch between the monomers in this extendAliases command in the MonomerPack(" << this[01;31m-[00m>getName() << ")" << endl;
monomerPack.cc:250:	ss << "extendAliases monomer names: " << extendMonomers[01;31m-[00m>__repr__() <<endl;
monomerPack.cc:251:	ss << "MonomerPack names: " << this[01;31m-[00m>_ContainedNames[01;31m-[00m>__repr__();
monomerPack.cc:252:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
monomerPack.cc:260:{ _F(this[01;31m-[00m>lisp());
monomerPack.cc:265:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerPack.cc:266:    ASSERT_NOT_NULL(this[01;31m-[00m>_AtomIndexers);
monomerPack.cc:267:    if ( !this[01;31m-[00m>recognizesMonomerName(monomerName) )
monomerPack.cc:269:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("Unrecognized monomer name: %s %s") % monomerName % this[01;31m-[00m>description() ));
monomerPack.cc:271:    indexer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_AtomIndexer>();
monomerPack.cc:272:    indexer[01;31m-[00m>setFromAtomNames(atomIndexerNames);
monomerPack.cc:273:    this[01;31m-[00m>_AtomIndexers[01;31m-[00m>set(monomerName,indexer);
monomerPack.cc:274:    this[01;31m-[00m>_checkAtomIndexers();
monomerPack.cc:281:{ _F(this[01;31m-[00m>lisp());
monomerPack.cc:286:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerPack.cc:287:    ASSERT_NOT_NULL(this[01;31m-[00m>_AtomIndexers);
monomerPack.cc:288:    if ( !this[01;31m-[00m>recognizesMonomerName(monomerName) )
monomerPack.cc:290:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("Unrecognized monomer name: %s %s") % monomerName % this[01;31m-[00m>description() ));
monomerPack.cc:292:    indexer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_AtomIndexer>();
monomerPack.cc:293:    indexer[01;31m-[00m>setFromStringList(names);
monomerPack.cc:294:    this[01;31m-[00m>_AtomIndexers[01;31m-[00m>set(monomerName,indexer);
monomerPack.cc:295:    this[01;31m-[00m>_checkAtomIndexers();
monomerPack.cc:301:{ _F(this[01;31m-[00m>lisp());
monomerPack.cc:306:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerPack.cc:307:    ASSERT_NOT_NULL(this[01;31m-[00m>_AtomIndexers);
monomerPack.cc:308:    if ( !this[01;31m-[00m>recognizesMonomerName(monomerName) )
monomerPack.cc:310:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("Unrecognized monomer name: %s %s") % monomerName % this[01;31m-[00m>sharedThis<O_BuilderDatabase>()[01;31m-[00m>description() ));
monomerPack.cc:312:    indexer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_AtomIndexer>();
monomerPack.cc:313:    for ( RPCons p=names; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() )
monomerPack.cc:315:	RPText	interest = p[01;31m-[00m>car<O_Text>();
monomerPack.cc:316:	indexer[01;31m-[00m>addAtomName(interest[01;31m-[00m>get());
monomerPack.cc:318:    this[01;31m-[00m>_AtomIndexers[01;31m-[00m>set(monomerName,indexer);
monomerPack.cc:319:    this[01;31m-[00m>_checkAtomIndexers();
monomerPack.cc:324:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:325:    this[01;31m-[00m>O_MonomerSet::setMonomerNameOrPdb(nm);
monomerPack.cc:326:    this[01;31m-[00m>setInterestingAtomNamesForMonomerName(nm,"");
monomerPack.cc:332:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:333:    this[01;31m-[00m>O_MonomerSet::addMonomerName(nm);
monomerPack.cc:334:    this[01;31m-[00m>setInterestingAtomNamesForMonomerName(nm,"");
monomerPack.cc:339:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:340:    this[01;31m-[00m>_removeMonomerName(nm);
monomerPack.cc:341:    this[01;31m-[00m>_AtomIndexers[01;31m-[00m>eraseEntryForMonomer(nm);
monomerPack.cc:346:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:349:    if ( this[01;31m-[00m>_AtomIndexers[01;31m-[00m>recognizesMonomerName(nm) )
monomerPack.cc:351:        s = this[01;31m-[00m>_AtomIndexers[01;31m-[00m>getAtomIndexerForMonomerName(nm)[01;31m-[00m>asString();
monomerPack.cc:361:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:362:    this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>setFromString(names);
monomerPack.cc:368:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:369:    this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>clear();
monomerPack.cc:370:    this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>appendStringList(names);
monomerPack.cc:371:    LOG(BF("For MonomerPack(%s) setting aliases(%s)") % this[01;31m-[00m>getName().c_str() % this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>asString().c_str()  ); // vp0(("For MonomerPack(%s) setting aliases(%s)",this[01;31m-[00m>getName().c_str(),this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>asString().c_str() ));
monomerPack.cc:378:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:379:    return this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>asString();
monomerPack.cc:384:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:385:    ASSERT(this[01;31m-[00m>_AtomIndexers[01;31m-[00m>recognizesMonomerName(monomerName));
monomerPack.cc:386:    return this[01;31m-[00m>_AtomIndexers[01;31m-[00m>getAtomIndexerForMonomerName(monomerName);
monomerPack.cc:397:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:403:    if ( this[01;31m-[00m>_AtomIndexers[01;31m-[00m>isNil() ) return;
monomerPack.cc:404:    ais = this[01;31m-[00m>_AtomIndexers;
monomerPack.cc:406:    for ( ii = ais[01;31m-[00m>begin(); ii != ais[01;31m-[00m>end(); ii++ )
monomerPack.cc:408:	if ( ii[01;31m-[00m>second[01;31m-[00m>numberOfAtomNames() > mostNumberOfAtoms )
monomerPack.cc:410:	    mostNumberOfAtoms = ii[01;31m-[00m>second[01;31m-[00m>numberOfAtomNames();
monomerPack.cc:416:	this[01;31m-[00m>_AtomIndexers = O_MapOfMonomerNamesToAtomIndexers::nil(this[01;31m-[00m>lisp());
monomerPack.cc:422:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:425:    ASSERT_NOT_NULL(this[01;31m-[00m>_AtomIndexers);
monomerPack.cc:428:    if ( !this[01;31m-[00m>recognizesMonomerName(nm) )
monomerPack.cc:430:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(boost::format("Unrecognized monomer name: %s %s")% nm % this[01;31m-[00m>sharedThis<O_BuilderDatabase>()[01;31m-[00m>description() ));
monomerPack.cc:432:    if ( this[01;31m-[00m>_AtomIndexers[01;31m-[00m>recognizesMonomerName(nm) )
monomerPack.cc:434:        atomIndexer = this[01;31m-[00m>_AtomIndexers[01;31m-[00m>getAtomIndexerForMonomerName(nm);
monomerPack.cc:435:        ss << " [" << atomIndexer[01;31m-[00m>asString() << "]";
monomerPack.cc:443:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:444:    LOG(BF("MonomerPack: %s") % this[01;31m-[00m>getName().c_str() ); // vp0(("MonomerPack: %s",this[01;31m-[00m>getName().c_str()));
monomerPack.cc:445:    LOG(BF("Checking to see if it recognizes atom alias: %s") % alias[01;31m-[00m>getAtomAlias().c_str()  ); // vp0(("Checking to see if it recognizes atom alias: %s",alias[01;31m-[00m>getAtomAlias().c_str() ));
monomerPack.cc:446:    LOG(BF("The interesting atom aliases I recognize are(%s)") % this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>asString().c_str()  ); // vp0(("The interesting atom aliases I recognize are(%s)",this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>asString().c_str() ));
monomerPack.cc:447:    return this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>contains(alias[01;31m-[00m>getAtomAlias());
monomerPack.cc:452:{_F(this[01;31m-[00m>lisp());
monomerPack.cc:454:    return this[01;31m-[00m>_InterestingAtomAliases[01;31m-[00m>indexOf(alias[01;31m-[00m>getAtomAlias());
monomerPack.cc:463:    class_<O_MonomerPack>(this[01;31m-[00m>lisp())
monomerPack.cc:467:    defNoWrapPackage(MbbPackage,"defineMonomerPack",&prim_defineMonomerPack, this[01;31m-[00m>lisp() );
monomerPack.cc:468:    defNoWrapPackage(MbbPackage,"extendAliases",&prim_extendAliases, this[01;31m-[00m>lisp());
monomerPack.cc:469:    defNoWrapPackage(MbbPackage,"setMonomerPack",&prim_setMonomerPack , this[01;31m-[00m>lisp());
monomerSet.cc:20:#define	IN_CHAR		"[01;31m-[00m"
monomerSet.cc:40:    equiv = this[01;31m-[00m>getMonomerNames();
monomerSet.cc:41:    for ( ei=equiv[01;31m-[00m>begin(); ei!=equiv[01;31m-[00m>end(); ei++ ) {
monomerSet.cc:57:    rec[01;31m-[00m>setMonomerNameOrPdb(nm);
monomerSet.cc:67:    this[01;31m-[00m>Base::initialize();
monomerSet.cc:68:    this[01;31m-[00m>_ContainedNames = O_StringSet::create(this[01;31m-[00m>lisp());
monomerSet.cc:69:    this[01;31m-[00m>_StatusTracker = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_StatusTracker>();
monomerSet.cc:70:    this[01;31m-[00m>_Optional = false;
monomerSet.cc:75:    return this[01;31m-[00m>_ContainedNames;
monomerSet.cc:79:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:80:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
monomerSet.cc:81:    RPCons members = dict[01;31m-[00m>getAndRemoveOrDefault("groupNames",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
monomerSet.cc:82:    this[01;31m-[00m>_Optional = dict[01;31m-[00m>getBoolAndRemoveOrDefault("optional",false);
monomerSet.cc:83:    this[01;31m-[00m>_ContainedNames = O_StringSet::create(this[01;31m-[00m>lisp())[01;31m-[00m>insertConsStrings(members);
monomerSet.cc:90:    ss << " contains:(" << this[01;31m-[00m>_ContainedNames[01;31m-[00m>asString() << ")";
monomerSet.cc:96:    this[01;31m-[00m>_StatusTracker = emr._StatusTracker[01;31m-[00m>copy();
monomerSet.cc:97:    this[01;31m-[00m>_ContainedNames = RP_Copy<O_StringSet>(emr._ContainedNames);
monomerSet.cc:102:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:103:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Subclass must implement for alias: "+alias[01;31m-[00m>__repr__()));
monomerSet.cc:108:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:109:    this[01;31m-[00m>O_BuilderDatabaseDependent::setBuilderDatabase(bdb);
monomerSet.cc:115:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:118:    newCopy = RP_Copy<O_MonomerSetBase>(this[01;31m-[00m>sharedThis<O_MonomerSetBase>());
monomerSet.cc:119:    bdb = newCopy[01;31m-[00m>getBuilderDatabase();
monomerSet.cc:120:    bdb[01;31m-[00m>connectListener(this[01;31m-[00m>sharedThis<O_MonomerSetBase>(),BuilderDatabase_replaceMe );
monomerSet.cc:127:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:133:    allNames = O_StringSet::create(this[01;31m-[00m>lisp());
monomerSet.cc:134:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerSet.cc:135:    for ( ni=this[01;31m-[00m>_ContainedNames[01;31m-[00m>begin(); ni!=this[01;31m-[00m>_ContainedNames[01;31m-[00m>end(); ni++ )
monomerSet.cc:137:        names = bdb[01;31m-[00m>expandEntityName(*ni);
monomerSet.cc:138:	allNames[01;31m-[00m>insertStringSet(names);
monomerSet.cc:144:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:150:    allRepresentatives = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectList>();
monomerSet.cc:151:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerSet.cc:152:    for ( ni=this[01;31m-[00m>_ContainedNames[01;31m-[00m>begin(); ni!=this[01;31m-[00m>_ContainedNames[01;31m-[00m>end(); ni++ )
monomerSet.cc:154:        objs = bdb[01;31m-[00m>expandEntityNameToListOfRepresentatives(*ni);
monomerSet.cc:155:	allRepresentatives[01;31m-[00m>extend(objs);
monomerSet.cc:161:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:164:    ASSERT_NOT_NULL(this[01;31m-[00m>_ContainedNames);
monomerSet.cc:165:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerSet.cc:166:    for ( si=ss[01;31m-[00m>begin(); si!=ss[01;31m-[00m>end(); si++ )
monomerSet.cc:168:	if ( !bdb[01;31m-[00m>recognizesMonomerName(*si) )
monomerSet.cc:170:	    this[01;31m-[00m>_StatusTracker[01;31m-[00m>addError("Tried to add unknown monomer name: "+*si);
monomerSet.cc:172:	    this[01;31m-[00m>_ContainedNames[01;31m-[00m>insert(*si);
monomerSet.cc:182:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:185:    ASSERT_NOT_NULL(this[01;31m-[00m>_ContainedNames);
monomerSet.cc:186:    if ( this[01;31m-[00m>recognizesMonomerName(nm) ) return;
monomerSet.cc:187:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerSet.cc:188:    if ( !bdb[01;31m-[00m>recognizesEntityName(nm) )
monomerSet.cc:190:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown monomer name: "+nm));
monomerSet.cc:191:        this[01;31m-[00m>_StatusTracker[01;31m-[00m>addError("Tried to add unknown monomer name: "+nm);
monomerSet.cc:193:    this[01;31m-[00m>_ContainedNames[01;31m-[00m>insert(nm);
monomerSet.cc:200:    this[01;31m-[00m>_ContainedNames = s;
monomerSet.cc:205:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:206:    ASSERT_NOT_NULL(this[01;31m-[00m>_ContainedNames);
monomerSet.cc:207:    this[01;31m-[00m>_ContainedNames[01;31m-[00m>insert(nm);
monomerSet.cc:213:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:214:    ASSERT_NOT_NULL(this[01;31m-[00m>_ContainedNames);
monomerSet.cc:215:    if ( !this[01;31m-[00m>recognizesMonomerName(nm) ) return;
monomerSet.cc:216:    this[01;31m-[00m>_ContainedNames[01;31m-[00m>remove(nm);
monomerSet.cc:222:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:225:    s1 = this[01;31m-[00m>getMonomerNames();
monomerSet.cc:226:    s2 = e[01;31m-[00m>getMonomerNames();
monomerSet.cc:228:    s3 = s1[01;31m-[00m>cartesianProductInsert(ins,s2);
monomerSet.cc:235:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:244:    expanded = this[01;31m-[00m>expandedNameList();
monomerSet.cc:245:    ASSERTF(expanded[01;31m-[00m>size()>0,BF("There must be at least one monomer name in the MonomerSetBase %s")% this[01;31m-[00m>description() );
monomerSet.cc:246:    for ( si=expanded[01;31m-[00m>begin(); si!=expanded[01;31m-[00m>end();si++ ) {
monomerSet.cc:267:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:270:    names = this[01;31m-[00m>expandedNameList();
monomerSet.cc:272://    ASSERT_NOT_NULL(this[01;31m-[00m>_MonomerNames);
monomerSet.cc:273://    return this[01;31m-[00m>_MonomerNames;
monomerSet.cc:277:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:278:    if ( this[01;31m-[00m>_StatusTracker[01;31m-[00m>hasError() ) {
monomerSet.cc:281:	errorMessage << this[01;31m-[00m>_StatusTracker[01;31m-[00m>getStatus();
monomerSet.cc:285:    names = this[01;31m-[00m>expandedNameList();
monomerSet.cc:286:    return names[01;31m-[00m>asString();
monomerSet.cc:287:// OLD   return this[01;31m-[00m>_MonomerNames[01;31m-[00m>asString();
monomerSet.cc:291:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:293:    names = this[01;31m-[00m>expandedNameList();
monomerSet.cc:294:    if ( names[01;31m-[00m>size() != 1 ) {
monomerSet.cc:295:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There must be only one equivalent name"));
monomerSet.cc:297:    return names[01;31m-[00m>first();
monomerSet.cc:305:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:307:    this[01;31m-[00m>_StatusTracker[01;31m-[00m>reset();
monomerSet.cc:308://    this[01;31m-[00m>setName(mn);
monomerSet.cc:310:    if ( this[01;31m-[00m>getBuilderDatabase()[01;31m-[00m>recognizesNameOrPdb(mn) ) {
monomerSet.cc:311:	db = this[01;31m-[00m>getBuilderDatabase();
monomerSet.cc:313:	string full = db[01;31m-[00m>getMonomerNameForNameOrPdb(mn);
monomerSet.cc:314:	this[01;31m-[00m>_ContainedNames[01;31m-[00m>clear();
monomerSet.cc:315:	this[01;31m-[00m>_ContainedNames[01;31m-[00m>insert(full);
monomerSet.cc:318:	this[01;31m-[00m>_StatusTracker[01;31m-[00m>reset();
monomerSet.cc:324:	this[01;31m-[00m>_StatusTracker[01;31m-[00m>addError(serr.str());
monomerSet.cc:336:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:339:    names = this[01;31m-[00m>expandedNameList();
monomerSet.cc:340:    return names[01;31m-[00m>contains(nm);
monomerSet.cc:350:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:352:    if ( this[01;31m-[00m>_StatusTracker[01;31m-[00m>hasError() ) return false;
monomerSet.cc:353:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerSet.cc:354:    ASSERT(bdb[01;31m-[00m>recognizesNameOrPdb(nm));
monomerSet.cc:355:    string name = bdb[01;31m-[00m>getMonomerNameForNameOrPdb(nm);
monomerSet.cc:356:    RPStringSet names = this[01;31m-[00m>expandedNameList();
monomerSet.cc:357:    return names[01;31m-[00m>contains(name);
monomerSet.cc:363:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:364:    this[01;31m-[00m>Base::archiveBase(node);
monomerSet.cc:365:    node[01;31m-[00m>archiveObjectIfDefined("names",this[01;31m-[00m>_ContainedNames);
monomerSet.cc:366:    node[01;31m-[00m>attributeIfNotDefault("optional",this[01;31m-[00m>_Optional,false);
monomerSet.cc:370:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:371:    this[01;31m-[00m>archiveBase(node);
monomerSet.cc:382:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerSet.cc:383:    allNames = bdb[01;31m-[00m>allMonomerNamesOrdered();
monomerSet.cc:384:    res = O_StringList::create(this[01;31m-[00m>lisp());
monomerSet.cc:385:    for(sli=allNames[01;31m-[00m>begin();sli!=allNames[01;31m-[00m>end();sli++ )
monomerSet.cc:387:        if ( !this[01;31m-[00m>_MonomerNames[01;31m-[00m>contains(*sli) )
monomerSet.cc:389:	    res[01;31m-[00m>append(*sli);
monomerSet.cc:397:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:410:    bdb = this[01;31m-[00m>getBuilderDatabase();
monomerSet.cc:411:    allNames = bdb[01;31m-[00m>allMonomerNamesOrdered();
monomerSet.cc:412:    res = O_StringList::create(this[01;31m-[00m>lisp());
monomerSet.cc:413:    for(sli=allNames[01;31m-[00m>begin();sli!=allNames[01;31m-[00m>end();sli++ )
monomerSet.cc:415:        if ( this[01;31m-[00m>_MonomerNames[01;31m-[00m>contains(*sli) )
monomerSet.cc:417:	    res[01;31m-[00m>append(*sli);
monomerSet.cc:431:    rec[01;31m-[00m>setMonomerNameOrPdb(nm);
monomerSet.cc:441:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:445:    obj[01;31m-[00m>setBuilderDatabase(db[01;31m-[00m>sharedThis<O_BuilderDatabase>());
monomerSet.cc:460:    this[01;31m-[00m>Base::initialize();
monomerSet.cc:461:    this[01;31m-[00m>_Name = "undefinedMonomerSetName";
monomerSet.cc:466:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:467:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
monomerSet.cc:468:    this[01;31m-[00m>_Name = dict[01;31m-[00m>getAndRemove("name")[01;31m-[00m>as<O_Text>()[01;31m-[00m>get();
monomerSet.cc:473:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:474:    this[01;31m-[00m>_Name = emr._Name;
monomerSet.cc:482:    ss << "MonomerSet("<<this[01;31m-[00m>_Name<<")@" << std::hex << this;
monomerSet.cc:483:    ss << " contains:(" << this[01;31m-[00m>_ContainedNames[01;31m-[00m>asString() << ")";
monomerSet.cc:489:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:490:    this[01;31m-[00m>Base::archiveBase(node);
monomerSet.cc:491:    node[01;31m-[00m>attributeIfNotDefault<string>("name",this[01;31m-[00m>_Name,"");
monomerSet.cc:495:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:496:    this[01;31m-[00m>archiveBase(node);
monomerSet.cc:511:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:519:	this[01;31m-[00m>addGroupName(x);
monomerSet.cc:529:    this[01;31m-[00m>Base::initialize();
monomerSet.cc:539:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:540:    this[01;31m-[00m>O_MonomerSetBase::setBuilderDatabase(bdb);
monomerSet.cc:546:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:547:    this[01;31m-[00m>Base::archiveBase(node);
monomerSet.cc:548://    if ( node[01;31m-[00m>loading() )
monomerSet.cc:550://        this[01;31m-[00m>_IsFinalized = false;
monomerSet.cc:552://    node[01;31m-[00m>needsFinalization();
monomerSet.cc:557:    this[01;31m-[00m>archiveBase(node);
monomerSet.cc:566:    ss << "MonomerGrouper("<<me[01;31m-[00m>getName()<<")@" << std::hex << this;
monomerSet.cc:571:{_F(this[01;31m-[00m>lisp());
monomerSet.cc:574:    this[01;31m-[00m>addMonomerName(nm);
monomerSet.cc:590:    class_<O_MonomerSetBase>(this[01;31m-[00m>lisp())
monomerSet.cc:675:    class_<O_MonomerSet>(this[01;31m-[00m>lisp())
monomerSet.cc:742:    class_<O_MonomerGrouper>(this[01;31m-[00m>lisp())
msmartsParse.tab.cc:3:/* Skeleton implementation for Bison's Yacc[01;31m-[00mlike parsers in C
msmartsParse.tab.cc:21:   Boston, MA 02110[01;31m-[00m1301, USA.  */
msmartsParse.tab.cc:37:   simplifying the original so[01;31m-[00mcalled "semantic" parser.  */
msmartsParse.tab.cc:313:#define YYSIZE_MAXIMUM ((YYSIZE_T) [01;31m-[00m1)
msmartsParse.tab.cc:319:#   define YY_(msgid) dgettext ("bison[01;31m-[00mruntime", msgid)
msmartsParse.tab.cc:327:/* Suppress unused[01;31m-[00mvariable warnings by "using" E.  */
msmartsParse.tab.cc:381:   /* Pacify GCC's `empty if[01;31m-[00mbody' warning.  */
msmartsParse.tab.cc:387:       to allow for a few compiler[01;31m-[00mallocated temporary stack slots.  */
msmartsParse.tab.cc:434:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) [01;31m-[00m 1)
msmartsParse.tab.cc:469:	YYCOPY (&yyptr[01;31m-[00m>Stack, Stack, yysize);				\
msmartsParse.tab.cc:470:	Stack = &yyptr[01;31m-[00m>Stack;						\
msmartsParse.tab.cc:478:/* YYFINAL [01;31m-[00m[01;31m-[00m State number of the termination state.  */
msmartsParse.tab.cc:480:/* YYLAST [01;31m-[00m[01;31m-[00m Last index in YYTABLE.  */
msmartsParse.tab.cc:483:/* YYNTOKENS [01;31m-[00m[01;31m-[00m Number of terminals.  */
msmartsParse.tab.cc:485:/* YYNNTS [01;31m-[00m[01;31m-[00m Number of nonterminals.  */
msmartsParse.tab.cc:487:/* YYNRULES [01;31m-[00m[01;31m-[00m Number of rules.  */
msmartsParse.tab.cc:489:/* YYNRULES [01;31m-[00m[01;31m-[00m Number of states.  */
msmartsParse.tab.cc:492:/* YYTRANSLATE(YYLEX) [01;31m-[00m[01;31m-[00m Bison symbol number corresponding to YYLEX.  */
msmartsParse.tab.cc:499:/* YYTRANSLATE[YYLEX] [01;31m-[00m[01;31m-[00m Bison symbol number corresponding to YYLEX.  */
msmartsParse.tab.cc:535:/* YYPRHS[YYN] [01;31m-[00m[01;31m-[00m Index of the first RHS symbol of rule number YYN in
msmartsParse.tab.cc:548:/* YYRHS [01;31m-[00m[01;31m-[00m A `[01;31m-[00m1'[01;31m-[00mseparated list of the rules' RHS.  */
msmartsParse.tab.cc:551:      46,     0,    [01;31m-[00m1,    47,    [01;31m-[00m1,    [01;31m-[00m1,    51,    [01;31m-[00m1,    51,    48,
msmartsParse.tab.cc:552:      [01;31m-[00m1,    49,    48,    [01;31m-[00m1,    52,    48,    [01;31m-[00m1,    49,    [01;31m-[00m1,    52,
msmartsParse.tab.cc:553:      [01;31m-[00m1,     4,    51,    [01;31m-[00m1,    51,    [01;31m-[00m1,    27,    54,     8,    [01;31m-[00m1,
msmartsParse.tab.cc:554:      16,    [01;31m-[00m1,    55,    [01;31m-[00m1,    50,    26,    [01;31m-[00m1,    50,    [01;31m-[00m1,    28,
msmartsParse.tab.cc:555:      48,     9,    [01;31m-[00m1,    44,    [01;31m-[00m1,    11,    [01;31m-[00m1,    11,    56,    [01;31m-[00m1,
msmartsParse.tab.cc:556:      39,    [01;31m-[00m1,    39,    56,    [01;31m-[00m1,    22,    [01;31m-[00m1,    22,    56,    [01;31m-[00m1,
msmartsParse.tab.cc:557:      12,    26,    [01;31m-[00m1,    13,    26,    [01;31m-[00m1,    37,    [01;31m-[00m1,    37,    56,
msmartsParse.tab.cc:558:      [01;31m-[00m1,    38,    [01;31m-[00m1,    38,    56,    [01;31m-[00m1,    43,    [01;31m-[00m1,    43,    56,
msmartsParse.tab.cc:559:      [01;31m-[00m1,    10,    [01;31m-[00m1,    10,    56,    [01;31m-[00m1,    20,    56,    [01;31m-[00m1,    18,
msmartsParse.tab.cc:560:      [01;31m-[00m1,    21,    [01;31m-[00m1,    21,    56,    [01;31m-[00m1,    24,    56,    [01;31m-[00m1,    24,
msmartsParse.tab.cc:561:      [01;31m-[00m1,    24,    24,    [01;31m-[00m1,    24,    24,    24,    [01;31m-[00m1,    35,    56,
msmartsParse.tab.cc:562:      [01;31m-[00m1,    35,    [01;31m-[00m1,    35,    35,    [01;31m-[00m1,    35,    35,    35,    [01;31m-[00m1,
msmartsParse.tab.cc:563:      42,    56,    [01;31m-[00m1,    34,    56,    [01;31m-[00m1,    33,    [01;31m-[00m1,     5,    56,
msmartsParse.tab.cc:564:      [01;31m-[00m1,     6,    [01;31m-[00m1,     7,    [01;31m-[00m1,    56,    [01;31m-[00m1,    16,    [01;31m-[00m1,    17,
msmartsParse.tab.cc:565:      [01;31m-[00m1,    23,    [01;31m-[00m1,    23,    56,    [01;31m-[00m1,    55,    [01;31m-[00m1,    53,    [01;31m-[00m1,
msmartsParse.tab.cc:566:      31,    54,    [01;31m-[00m1,    54,    29,    54,    [01;31m-[00m1,    54,    32,    54,
msmartsParse.tab.cc:567:      [01;31m-[00m1,    54,    30,    54,    [01;31m-[00m1,    14,    28,    47,     9,    [01;31m-[00m1,
msmartsParse.tab.cc:568:      26,    [01;31m-[00m1
msmartsParse.tab.cc:571:/* YYRLINE[YYN] [01;31m-[00m[01;31m-[00m source line where rule number YYN was defined.  */
msmartsParse.tab.cc:585:/* YYTNAME[SYMBOL[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m String name of the symbol SYMBOL[01;31m-[00mNUM.
msmartsParse.tab.cc:608:/* YYTOKNUM[YYLEX[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m Internal token number corresponding to
msmartsParse.tab.cc:609:   token YYLEX[01;31m-[00mNUM.  */
msmartsParse.tab.cc:620:/* YYR1[YYN] [01;31m-[00m[01;31m-[00m Symbol number of symbol that rule YYN derives.  */
msmartsParse.tab.cc:632:/* YYR2[YYN] [01;31m-[00m[01;31m-[00m Number of symbols composing right hand side of rule YYN.  */
msmartsParse.tab.cc:644:/* YYDEFACT[STATE[01;31m-[00mNAME] [01;31m-[00m[01;31m-[00m Default rule to reduce with in state
msmartsParse.tab.cc:645:   STATE[01;31m-[00mNUM when YYTABLE doesn't specify something else to do.  Zero
msmartsParse.tab.cc:660:/* YYDEFGOTO[NTERM[01;31m-[00mNUM].  */
msmartsParse.tab.cc:663:      [01;31m-[00m1,     4,     5,    44,    45,     6,    46,    47,    36,    37,
msmartsParse.tab.cc:667:/* YYPACT[STATE[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m Index in YYTABLE of the portion describing
msmartsParse.tab.cc:668:   STATE[01;31m-[00mNUM.  */
msmartsParse.tab.cc:669:#define YYPACT_NINF [01;31m-[00m41
msmartsParse.tab.cc:672:      21,   [01;31m-[00m20,   [01;31m-[00m41,    65,    15,   [01;31m-[00m41,   [01;31m-[00m12,    27,   [01;31m-[00m41,    21,
msmartsParse.tab.cc:673:      [01;31m-[00m5,   [01;31m-[00m41,   [01;31m-[00m41,    [01;31m-[00m5,    [01;31m-[00m5,     6,    23,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,
msmartsParse.tab.cc:674:      [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,    14,   [01;31m-[00m41,    65,   [01;31m-[00m41,    [01;31m-[00m5,   [01;31m-[00m22,
msmartsParse.tab.cc:675:      [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,    [01;31m-[00m5,   [01;31m-[00m41,   [01;31m-[00m41,     4,   [01;31m-[00m41,   [01;31m-[00m41,
msmartsParse.tab.cc:676:     [01;31m-[00m41,   [01;31m-[00m41,    21,    27,   [01;31m-[00m41,    27,   [01;31m-[00m41,    27,    13,   [01;31m-[00m41,
msmartsParse.tab.cc:677:     [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,    26,   [01;31m-[00m41,
msmartsParse.tab.cc:678:     [01;31m-[00m41,   [01;31m-[00m41,    16,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,
msmartsParse.tab.cc:679:      65,    65,    65,   [01;31m-[00m41,    43,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m41,
msmartsParse.tab.cc:680:     [01;31m-[00m41,    10,    24,   [01;31m-[00m41
msmartsParse.tab.cc:683:/* YYPGOTO[NTERM[01;31m-[00mNUM].  */
msmartsParse.tab.cc:686:     [01;31m-[00m41,   [01;31m-[00m41,    47,   [01;31m-[00m40,   [01;31m-[00m41,   [01;31m-[00m41,     2,   [01;31m-[00m41,   [01;31m-[00m41,   [01;31m-[00m25,
msmartsParse.tab.cc:687:      [01;31m-[00m3,    [01;31m-[00m4
msmartsParse.tab.cc:690:/* YYTABLE[YYPACT[STATE[01;31m-[00mNUM]].  What to do in state STATE[01;31m-[00mNUM.  If
msmartsParse.tab.cc:694:#define YYTABLE_NINF [01;31m-[00m1
msmartsParse.tab.cc:717:      24,    35,     9,    29,    27,    28,     9,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,
msmartsParse.tab.cc:718:      [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    70,    71,    72,
msmartsParse.tab.cc:719:       5,     6,     7,    [01;31m-[00m1,    [01;31m-[00m1,    10,    11,    12,    13,    14,
msmartsParse.tab.cc:720:      [01;31m-[00m1,    16,    17,    18,    [01;31m-[00m1,    20,    21,    22,    23,    24,
msmartsParse.tab.cc:721:      [01;31m-[00m1,    26,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    [01;31m-[00m1,    31,    [01;31m-[00m1,    33,    34,
msmartsParse.tab.cc:722:      35,    [01;31m-[00m1,    37,    38,    39,    [01;31m-[00m1,    [01;31m-[00m1,    42,    43,    44
msmartsParse.tab.cc:725:/* YYSTOS[STATE[01;31m-[00mNUM] [01;31m-[00m[01;31m-[00m The (internal number of the) accessing
msmartsParse.tab.cc:726:   symbol of state STATE[01;31m-[00mNUM.  */
msmartsParse.tab.cc:742:#define YYEMPTY		([01;31m-[00m2)
msmartsParse.tab.cc:780:/* YYLLOC_DEFAULT [01;31m-[00m[01;31m-[00m Set CURRENT to span from RHS[1] to RHS[N].
msmartsParse.tab.cc:806:/* YY_LOCATION_PRINT [01;31m-[00m[01;31m-[00m Print the location on the stream.
msmartsParse.tab.cc:813:     fprintf (File, "%d.%d[01;31m-[00m%d.%d",			\
msmartsParse.tab.cc:822:/* YYLEX [01;31m-[00m[01;31m-[00m calling `yylex' with the right arguments.  */
msmartsParse.tab.cc:856:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:858:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:889:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:891:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:914:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:915:| yy_stack_print [01;31m-[00m[01;31m-[00m Print the state stack from its BOTTOM up to its |
msmartsParse.tab.cc:917:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:943:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:945:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:962:	     yyrule [01;31m-[00m 1, yylno);
msmartsParse.tab.cc:968:		       &(yyvsp[(yyi + 1) [01;31m-[00m (yynrhs)])
msmartsParse.tab.cc:991:/* YYINITDEPTH [01;31m-[00m[01;31m-[00m initial size of the parser's stacks.  */
msmartsParse.tab.cc:996:/* YYMAXDEPTH [01;31m-[00m[01;31m-[00m maximum size the stacks can grow to (effective only
msmartsParse.tab.cc:997:   if the built[01;31m-[00min stack extension method is used).
msmartsParse.tab.cc:1001:   evaluated with infinite[01;31m-[00mprecision integer arithmetic.  */
msmartsParse.tab.cc:1057:  return yyd [01;31m-[00m 1;
msmartsParse.tab.cc:1065:   heuristic is that double[01;31m-[00mquoting is unnecessary unless the string
msmartsParse.tab.cc:1067:   backslash[01;31m-[00mbackslash).  YYSTR is taken from yytname.  If YYRES is
msmartsParse.tab.cc:1106:  return yystpcpy (yyres, yystr) [01;31m-[00m yyres;
msmartsParse.tab.cc:1150:		    + sizeof yyexpecting [01;31m-[00m 1
msmartsParse.tab.cc:1151:		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM [01;31m-[00m 2)
msmartsParse.tab.cc:1152:		       * (sizeof yyor [01;31m-[00m 1))];
msmartsParse.tab.cc:1155:      /* Start YYX at [01;31m-[00mYYN if negative to avoid negative indexes in
msmartsParse.tab.cc:1157:      int yyxbegin = yyn < 0 ? [01;31m-[00myyn : 0;
msmartsParse.tab.cc:1160:      int yychecklim = YYLAST [01;31m-[00m yyn + 1;
msmartsParse.tab.cc:1174:		yyformat[sizeof yyunexpected [01;31m-[00m 1] = '\0';
msmartsParse.tab.cc:1220:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:1222:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:1247:	{ if ((yyvaluep[01;31m-[00m>smartsRoot)!=NULL) delete ((yyvaluep[01;31m-[00m>smartsRoot));};
msmartsParse.tab.cc:1252:	{ if ((yyvaluep[01;31m-[00m>bondListMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>bondListMatchNode)); };
msmartsParse.tab.cc:1257:	{ if ((yyvaluep[01;31m-[00m>bondTest)!=NULL) delete ((yyvaluep[01;31m-[00m>bondTest)); };
msmartsParse.tab.cc:1262:	{ if ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)); };
msmartsParse.tab.cc:1267:	{ if ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)); };
msmartsParse.tab.cc:1272:	{ if ((yyvaluep[01;31m-[00m>bondListMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>bondListMatchNode)); };
msmartsParse.tab.cc:1277:	{ if ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)!=NULL) delete ((yyvaluep[01;31m-[00m>atomOrBondMatchNode)); };
msmartsParse.tab.cc:1282:	{ if ((yyvaluep[01;31m-[00m>logical)!=NULL) delete ((yyvaluep[01;31m-[00m>logical)); };
msmartsParse.tab.cc:1287:	{ if ((yyvaluep[01;31m-[00m>root)!=NULL) delete ((yyvaluep[01;31m-[00m>root)); };
msmartsParse.tab.cc:1297:/* Prevent warnings from [01;31m-[00mWmissing[01;31m-[00mprototypes.  */
msmartsParse.tab.cc:1315:/* The look[01;31m-[00mahead symbol.  */
msmartsParse.tab.cc:1318:/* The semantic value of the look[01;31m-[00mahead symbol.  */
msmartsParse.tab.cc:1326:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:1328:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:1358:  /* Look[01;31m-[00mahead token as an internal (translated) token number.  */
msmartsParse.tab.cc:1387:#define YYPOPSTACK(N)   (yyvsp [01;31m-[00m= (N), yyssp [01;31m-[00m= (N))
msmartsParse.tab.cc:1417:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:1418:| yynewstate [01;31m-[00m[01;31m-[00m Push a new state, which is found in yystate.  |
msmartsParse.tab.cc:1419:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:1428:  if (yyss + yystacksize [01;31m-[00m 1 <= yyssp)
msmartsParse.tab.cc:1431:      YYSIZE_T yysize = yyssp [01;31m-[00m yyss + 1;
msmartsParse.tab.cc:1482:      yyssp = yyss + yysize [01;31m-[00m 1;
msmartsParse.tab.cc:1483:      yyvsp = yyvs + yysize [01;31m-[00m 1;
msmartsParse.tab.cc:1489:      if (yyss + yystacksize [01;31m-[00m 1 <= yyssp)
msmartsParse.tab.cc:1497:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:1499:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:1503:     look[01;31m-[00mahead token if we need one and don't already have one.  */
msmartsParse.tab.cc:1505:  /* First try to decide what to do without reference to look[01;31m-[00mahead token.  */
msmartsParse.tab.cc:1510:  /* Not known => get a look[01;31m-[00mahead token if don't already have one.  */
msmartsParse.tab.cc:1512:  /* YYCHAR is either YYEMPTY or YYEOF or a valid look[01;31m-[00mahead symbol.  */
msmartsParse.tab.cc:1540:      yyn = [01;31m-[00myyn;
msmartsParse.tab.cc:1550:    yyerrstatus[01;31m-[00m[01;31m-[00m;
msmartsParse.tab.cc:1552:  /* Shift the look[01;31m-[00mahead token.  */
msmartsParse.tab.cc:1565:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:1566:| yydefault [01;31m-[00m[01;31m-[00m do the default action for the current state.  |
msmartsParse.tab.cc:1567:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:1575:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:1576:| yyreduce [01;31m-[00m[01;31m-[00m Do a reduction.  |
msmartsParse.tab.cc:1577:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:1590:  yyval = yyvsp[1[01;31m-[00myylen];
msmartsParse.tab.cc:1599:	    chemInfoTree = (yyvsp[(1) [01;31m-[00m (1)].smartsRoot)[01;31m-[00m>_obj; 
msmartsParse.tab.cc:1611:		    (yyval.smartsRoot) = new Hold<chemInfo::O_SmartsRoot>(chemInfo::O_SmartsRoot::create((yyvsp[(1) [01;31m-[00m (1)].atomOrBondMatchNode)[01;31m-[00m>_obj,msmartsEnv)); 
msmartsParse.tab.cc:1618:		    (yyval.smartsRoot) = new Hold<chemInfo::O_SmartsRoot>(chemInfo::O_SmartsRoot::create((yyvsp[(1) [01;31m-[00m (2)].atomOrBondMatchNode)[01;31m-[00m>_obj,(yyvsp[(2) [01;31m-[00m (2)].bondListMatchNode)[01;31m-[00m>_obj,msmartsEnv)); 
msmartsParse.tab.cc:1625:	(yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Chain::create( (yyvsp[(1) [01;31m-[00m (2)].bondTest)[01;31m-[00m>_obj, (yyvsp[(2) [01;31m-[00m (2)].bondListMatchNode)[01;31m-[00m>_obj,msmartsEnv)); 
msmartsParse.tab.cc:1632:	(yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Branch::create( (yyvsp[(1) [01;31m-[00m (2)].bondListMatchNode)[01;31m-[00m>_obj, (yyvsp[(2) [01;31m-[00m (2)].bondListMatchNode)[01;31m-[00m>_obj,msmartsEnv)); 
msmartsParse.tab.cc:1639:	(yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Chain::create( (yyvsp[(1) [01;31m-[00m (1)].bondTest)[01;31m-[00m>_obj,msmartsEnv)); 
msmartsParse.tab.cc:1646:	(yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>(chemInfo::O_Branch::create( (yyvsp[(1) [01;31m-[00m (1)].bondListMatchNode)[01;31m-[00m>_obj,msmartsEnv)); 
msmartsParse.tab.cc:1653:			    (yyval.bondTest) = new Hold<chemInfo::O_BondTest>(chemInfo::O_BondTest::create( (yyvsp[(1) [01;31m-[00m (2)].benum), (yyvsp[(2) [01;31m-[00m (2)].atomOrBondMatchNode)[01;31m-[00m>_obj,msmartsEnv )); 
msmartsParse.tab.cc:1660:			    (yyval.bondTest) = new Hold<chemInfo::O_BondTest>(chemInfo::O_BondTest::create( chemInfo::SABSingleOrAromaticBond, (yyvsp[(1) [01;31m-[00m (1)].atomOrBondMatchNode)[01;31m-[00m>_obj,msmartsEnv)); 
msmartsParse.tab.cc:1667:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((yyvsp[(2) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj);
msmartsParse.tab.cc:1674:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((chemInfo::O_AtomTest::create(chemInfo::SAPElement, 0, 0, (yyvsp[(1) [01;31m-[00m (1)].eval) ,msmartsEnv))); 
msmartsParse.tab.cc:1681:	    		    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((yyvsp[(1) [01;31m-[00m (1)].root)[01;31m-[00m>_obj); 
msmartsParse.tab.cc:1687:  { _BLOCK_TRACEF(BF("atomTest: acyclicAtomTest APNumber   // atomTag==(%s)  ") (yyvsp[(2) [01;31m-[00m (2)].cval));
msmartsParse.tab.cc:1688:	(yyval.atomOrBondMatchNode)=new Hold<chemInfo::O_AtomOrBondMatchNode>(chemInfo::O_TagSet::create(chemInfo::SABAnyBond,(yyvsp[(1) [01;31m-[00m (2)].atomOrBondMatchNode)[01;31m-[00m>_obj,(yyvsp[(2) [01;31m-[00m (2)].cval),msmartsEnv));
msmartsParse.tab.cc:1695:	(yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((yyvsp[(1) [01;31m-[00m (1)].atomOrBondMatchNode)[01;31m-[00m>_obj); 
msmartsParse.tab.cc:1701:    { (yyval.bondListMatchNode) = new Hold<chemInfo::O_BondListMatchNode>((yyvsp[(2) [01;31m-[00m (3)].bondListMatchNode)[01;31m-[00m>_obj); ;}
msmartsParse.tab.cc:1724:			chemInfo::O_AtomTest::create( chemInfo::SAPDegree,(yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv)); 
msmartsParse.tab.cc:1740:				chemInfo::O_AtomTest::create( chemInfo::SAPTotalHCount, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1757:						chemInfo::SAPImplicitHCount, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1765:					chemInfo::O_AtomTest::create(chemInfo::SAPRingTest,(yyvsp[(2) [01;31m-[00m (2)].cval),msmartsEnv));
msmartsParse.tab.cc:1773:					chemInfo::O_AtomTest::create(chemInfo::SAPResidueTest,(yyvsp[(2) [01;31m-[00m (2)].cval),msmartsEnv));
msmartsParse.tab.cc:1787:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPRingMembershipCount, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1801:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPRingSize, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1815:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPValence, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1829:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPConnectivity, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1836:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPGroupNumber, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv)); 
msmartsParse.tab.cc:1857:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPHeavyAtomTotalBond, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv)); 
msmartsParse.tab.cc:1864:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPNegativeCharge, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1871:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPNegativeCharge, [01;31m-[00m1,msmartsEnv));
msmartsParse.tab.cc:1878:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPNegativeCharge, [01;31m-[00m2,msmartsEnv));
msmartsParse.tab.cc:1885:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPNegativeCharge, [01;31m-[00m3,msmartsEnv));
msmartsParse.tab.cc:1892:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPPositiveCharge, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1920:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPTransitionMetal, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv)); 
msmartsParse.tab.cc:1927:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPAromaticPiElectron , (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1941:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPAtomicNumber, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1962:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPAtomicMass, (yyvsp[(1) [01;31m-[00m (1)].ival),msmartsEnv));
msmartsParse.tab.cc:1969:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPElement, (yyvsp[(1) [01;31m-[00m (1)].eval) ,msmartsEnv)); 
msmartsParse.tab.cc:1976:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPElement, (yyvsp[(1) [01;31m-[00m (1)].eval) ,msmartsEnv)); 
msmartsParse.tab.cc:1990:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>( chemInfo::O_AtomTest::create( chemInfo::SAPLonePair, (yyvsp[(2) [01;31m-[00m (2)].ival),msmartsEnv));
msmartsParse.tab.cc:1997:	    (yyval.atomOrBondMatchNode) = new Hold<chemInfo::O_AtomOrBondMatchNode>((yyvsp[(1) [01;31m-[00m (1)].root)[01;31m-[00m>_obj); 
msmartsParse.tab.cc:2005:	    		chemInfo::O_Logical::create( chemInfo::logIdentity, (yyvsp[(1) [01;31m-[00m (1)].atomOrBondMatchNode)[01;31m-[00m>_obj ,msmartsEnv)); 
msmartsParse.tab.cc:2013:	    		chemInfo::O_Logical::create( chemInfo::logNot, (yyvsp[(2) [01;31m-[00m (2)].logical)[01;31m-[00m>_obj ,msmartsEnv)); 
msmartsParse.tab.cc:2021:	    		chemInfo::O_Logical::create( chemInfo::logHighPrecedenceAnd, (yyvsp[(1) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj ,msmartsEnv)); 
msmartsParse.tab.cc:2029:	    		chemInfo::O_Logical::create( chemInfo::logOr, (yyvsp[(1) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj ,msmartsEnv)); 
msmartsParse.tab.cc:2037:	    		chemInfo::O_Logical::create( chemInfo::logLowPrecedenceAnd, (yyvsp[(1) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj, (yyvsp[(3) [01;31m-[00m (3)].logical)[01;31m-[00m>_obj ,msmartsEnv)); 
msmartsParse.tab.cc:2043:    { (yyval.root) = new Hold<chemInfo::O_Root>((yyvsp[(3) [01;31m-[00m (4)].smartsRoot)[01;31m-[00m>_obj); ;}
msmartsParse.tab.cc:2048:    { (yyval.ival) = atoi((yyvsp[(1) [01;31m-[00m (1)].cval)); ;}
msmartsParse.tab.cc:2056:  YY_SYMBOL_PRINT ("[01;31m-[00m> $$ =", yyr1[yyn], &yyval, &yyloc);
msmartsParse.tab.cc:2071:  yystate = yypgoto[yyn [01;31m-[00m YYNTOKENS] + *yyssp;
msmartsParse.tab.cc:2075:    yystate = yydefgoto[yyn [01;31m-[00m YYNTOKENS];
msmartsParse.tab.cc:2080:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:2081:| yyerrlab [01;31m-[00m[01;31m-[00m here on detecting error |
msmartsParse.tab.cc:2082:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:2129:      /* If just tried and failed to reuse look[01;31m-[00mahead token after an
msmartsParse.tab.cc:2146:  /* Else will try to reuse look[01;31m-[00mahead token after shifting the error
msmartsParse.tab.cc:2151:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:2152:| yyerrorlab [01;31m-[00m[01;31m-[00m error raised explicitly by YYERROR.  |
msmartsParse.tab.cc:2153:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:2171:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:2172:| yyerrlab1 [01;31m-[00m[01;31m-[00m common code for both syntax error and YYERROR.  |
msmartsParse.tab.cc:2173:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:2216:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:2217:| yyacceptlab [01;31m-[00m[01;31m-[00m YYACCEPT comes here.  |
msmartsParse.tab.cc:2218:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:2223:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:2224:| yyabortlab [01;31m-[00m[01;31m-[00m YYABORT comes here.  |
msmartsParse.tab.cc:2225:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:2231:/*[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m.
msmartsParse.tab.cc:2232:| yyexhaustedlab [01;31m-[00m[01;31m-[00m memory exhaustion comes here.  |
msmartsParse.tab.cc:2233:`[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m*/
msmartsParse.tab.cc:2351:	ichar = lexStream[01;31m-[00m>get();	 // Read one character
msmartsParse.tab.cc:2354:    } while (!lexStream[01;31m-[00m>eof() && ichar < ' ' );
msmartsParse.tab.cc:2355:    if ( lexStream[01;31m-[00m>eof() ) return 0;
msmartsParse.tab.cc:2385:		if ( elementTable[i][1] == lexStream[01;31m-[00m>peek() ) 
msmartsParse.tab.cc:2387:		    lexStream[01;31m-[00m>get();
msmartsParse.tab.cc:2416:		if ( organicElementTable[i][1] == lexStream[01;31m-[00m>peek() )
msmartsParse.tab.cc:2418:		    cout<<"Peek char: "<<lexStream[01;31m-[00m>peek()<<endl;
msmartsParse.tab.cc:2419:		    lexStream[01;31m-[00m>get();
msmartsParse.tab.cc:2513:		    if (lexStream[01;31m-[00m>peek() >= '0' && lexStream[01;31m-[00m>peek() <= '9' ) 
msmartsParse.tab.cc:2518:		    } else if (lexStream[01;31m-[00m>peek() == 'G')
msmartsParse.tab.cc:2520:			    lexStream[01;31m-[00m>get();
msmartsParse.tab.cc:2521:			    if (lexStream[01;31m-[00m>peek() >= '0' && lexStream[01;31m-[00m>peek() <= '9')
msmartsParse.tab.cc:2528:		    } else if (lexStream[01;31m-[00m>peek() == 'T')
msmartsParse.tab.cc:2530:			    lexStream[01;31m-[00m>get();
msmartsParse.tab.cc:2531:			    if (lexStream[01;31m-[00m>peek() >= '0' && lexStream[01;31m-[00m>peek() <= '9')
msmartsParse.tab.cc:2538:		    } else if (lexStream[01;31m-[00m>peek() == 'N')
msmartsParse.tab.cc:2540:			    lexStream[01;31m-[00m>get();
msmartsParse.tab.cc:2541:			    if (lexStream[01;31m-[00m>peek() >= '0' && lexStream[01;31m-[00m>peek() <= '9')
msmartsParse.tab.cc:2554:		    if (lexStream[01;31m-[00m>peek() == '?') 
msmartsParse.tab.cc:2556:			lexStream[01;31m-[00m>get();
msmartsParse.tab.cc:2566:	    case '[01;31m-[00m':
msmartsParse.tab.cc:2567:		    if (lexStream[01;31m-[00m>peek() >= '0' && lexStream[01;31m-[00m>peek() <= '9'  ) 
msmartsParse.tab.cc:2583:		    if (lexStream[01;31m-[00m>peek() == '?') 
msmartsParse.tab.cc:2585:			lexStream[01;31m-[00m>get();
msmartsParse.tab.cc:2596:		    if ( lexStream[01;31m-[00m>peek() == '@' ) {
msmartsParse.tab.cc:2597:			lexStream[01;31m-[00m>get(); // pull the second @ out of the stream
msmartsParse.tab.cc:2608:		    if ( lexStream[01;31m-[00m>peek() >= '0' && lexStream[01;31m-[00m>peek() <= '9') {
msmartsParse.tab.cc:2627:		    if (lexStream[01;31m-[00m>peek() >= '0' && lexStream[01;31m-[00m>peek() <= '9')
msmartsParse.tab.cc:2668:    if (ichar == 'L' && lexStream[01;31m-[00m>peek() == 'p')
msmartsParse.tab.cc:2670:        lexStream[01;31m-[00m>get();	
msmartsParse.tab.cc:2682:	    while ( lexStream[01;31m-[00m>peek()>='0' && lexStream[01;31m-[00m>peek()<='9' ) 
msmartsParse.tab.cc:2684:		    ichar = lexStream[01;31m-[00m>get();
msmartsParse.tab.cc:2687:		        TOSS(_lisp[01;31m-[00m>create<O_LispError>("Exceeded max number of digits in Number"));
msmartsParse.tab.cc:2725:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:26:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:27:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
multiScorer.cc:28:    RPCons scorers = args[01;31m-[00m>getAndRemoveOrDefault("scorers",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
multiScorer.cc:29:    this[01;31m-[00m>_MultiScoreCalculator = args[01;31m-[00m>getAndRemoveOrDefault("calculator",
multiScorer.cc:30:    				O_ScoreSum::create(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_ScoreSum>();
multiScorer.cc:32:    for ( cur=scorers; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
multiScorer.cc:34:	RPScorer scorer = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Scorer>();
multiScorer.cc:35:	this[01;31m-[00m>addScorer(scorer);
multiScorer.cc:51:    this[01;31m-[00m>Base::initialize();
multiScorer.cc:52:    this[01;31m-[00m>_MultiScoreCalculator = O_ScoreSum::nil(this[01;31m-[00m>lisp());
multiScorer.cc:57:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:58:    ASSERT_lt(i,this[01;31m-[00m>_SubScorers.size());
multiScorer.cc:59:    return this[01;31m-[00m>_SubScorers[i];
multiScorer.cc:64:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:65:    this[01;31m-[00m>Base::archiveBase(node);
multiScorer.cc:66:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_SubScorers);
multiScorer.cc:67:    node[01;31m-[00m>archiveObject("calculator",this[01;31m-[00m>_MultiScoreCalculator);
multiScorer.cc:72:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:73:    this[01;31m-[00m>Base::oligomerChanged(builder);
multiScorer.cc:74:    ASSERT(builder[01;31m-[00m>notNil());
multiScorer.cc:79:    for ( superposerIterator = this[01;31m-[00m>_SubScorers.begin();
multiScorer.cc:80:    		 superposerIterator != this[01;31m-[00m>_SubScorers.end();
multiScorer.cc:83:	(*superposerIterator)[01;31m-[00m>oligomerChanged(builder);
multiScorer.cc:85:    if ( this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>notNil() )
multiScorer.cc:87:	if ( builder[01;31m-[00m>notNil() )
multiScorer.cc:89:            this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>oligomerChanged(builder);
multiScorer.cc:96:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:97:    bool needs = this[01;31m-[00m>Base::needsAllAtomsBuilt();
multiScorer.cc:100:    for ( superposerIterator = this[01;31m-[00m>_SubScorers.begin();
multiScorer.cc:101:    		 superposerIterator != this[01;31m-[00m>_SubScorers.end();
multiScorer.cc:105:	if ( (*superposerIterator)[01;31m-[00m>needsAllAtomsBuilt() ) return true;
multiScorer.cc:107:    return this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>needsAllAtomsBuilt();
multiScorer.cc:112:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:113:    this[01;31m-[00m>Base::sequenceChanged(builder);
multiScorer.cc:114:    ASSERT(builder[01;31m-[00m>notNil());
multiScorer.cc:119:    for ( superposerIterator = this[01;31m-[00m>_SubScorers.begin();
multiScorer.cc:120:    		 superposerIterator != this[01;31m-[00m>_SubScorers.end();
multiScorer.cc:123:	(*superposerIterator)[01;31m-[00m>sequenceChanged(builder);
multiScorer.cc:125:    if ( this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>notNil() )
multiScorer.cc:127:	if ( builder[01;31m-[00m>notNil() )
multiScorer.cc:129:            this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>sequenceChanged(builder);
multiScorer.cc:137:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:141:    uint scorerIdentifier = this[01;31m-[00m>_SubScorers.size();
multiScorer.cc:143:    scorer[01;31m-[00m>setScorerIdentifier(scorerIdentifier);
multiScorer.cc:144:    this[01;31m-[00m>_SubScorers.push_back(scorer);
multiScorer.cc:150:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:152:    if ( this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>isNil() )
multiScorer.cc:154:	this[01;31m-[00m>_MultiScoreCalculator = O_ScoreSum::create(this[01;31m-[00m>lisp());
multiScorer.cc:156:    this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>addOperation(op);
multiScorer.cc:161:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:163:    for ( superposerIterator = this[01;31m-[00m>_SubScorers.begin();
multiScorer.cc:164:    		 superposerIterator != this[01;31m-[00m>_SubScorers.end();
multiScorer.cc:167:	(*superposerIterator)[01;31m-[00m>addToCalculator(op);
multiScorer.cc:173:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:180:    this[01;31m-[00m>throwIfBuilderOutOfSync(builder);
multiScorer.cc:183:    bestScorerState[01;31m-[00m>clear();
multiScorer.cc:184:    oneScorerState = O_ScorerState::create(this[01;31m-[00m>lisp());
multiScorer.cc:185:    ASSERT(builder[01;31m-[00m>notNil());
multiScorer.cc:188:    RPScorer bestScorer = O_Scorer::nil(this[01;31m-[00m>lisp());
multiScorer.cc:189:    ASSERT_greaterThan(this[01;31m-[00m>_SubScorers.size(),0);
multiScorer.cc:197:    for ( subScorerIterator = this[01;31m-[00m>_SubScorers.begin(), ssidx=0;
multiScorer.cc:198:    		 subScorerIterator != this[01;31m-[00m>_SubScorers.end();
multiScorer.cc:201:    		% (*subScorerIterator)[01;31m-[00m>getScorerIdentifier() 
multiScorer.cc:202:		% this[01;31m-[00m>_SubScorers.size() 
multiScorer.cc:203:		% builder[01;31m-[00m>stateIdentifier() );
multiScorer.cc:206:	    (*subScorerIterator)[01;31m-[00m>evaluate(builder,oneScorerState);
multiScorer.cc:209:	    (*subScorerIterator)[01;31m-[00m>evaluateWithoutSuperposing(builder,oneScorerState);
multiScorer.cc:213:		(*subScorerIterator)[01;31m-[00m>getScorerIdentifier() 
multiScorer.cc:214:		% oneScorerState[01;31m-[00m>summary().c_str());
multiScorer.cc:216:	builder[01;31m-[00m>streamDump(sdebug);
multiScorer.cc:218:		builder[01;31m-[00m>stateIdentifier()
multiScorer.cc:219:		% oneScorerState[01;31m-[00m>getScore()
multiScorer.cc:222:	if ( oneScorerState[01;31m-[00m>isBetterThan(bestScorerState) )
multiScorer.cc:224:				% oneScorerState[01;31m-[00m>getScore() 
multiScorer.cc:225:				% bestScorerState[01;31m-[00m>getScore() );
multiScorer.cc:227:	    bestScorerState[01;31m-[00m>copyFromOtherState(oneScorerState);
multiScorer.cc:228:    	    ASSERT(bestScorerState[01;31m-[00m>isScoreSet());
multiScorer.cc:229:	    LOG(BF("Current best scorer: %s") % bestScorerState[01;31m-[00m>summary().c_str() ); // vp0(( "Current best scorer: %s", bestScorerState[01;31m-[00m>summary().c_str()));
multiScorer.cc:236:    LOG(BF("Telling builder bestScore: %s") % bestScorerState[01;31m-[00m>summary().c_str() ); // vp0(("Telling builder bestScore: %s", bestScorerState[01;31m-[00m>summary().c_str()));
multiScorer.cc:237:    if ( this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>notNil() )
multiScorer.cc:240:	double score = this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>evaluate(bestScorerState,this[01;31m-[00m>sharedThis<O_MultiScorer>(),builder);
multiScorer.cc:241:	bestScorerState[01;31m-[00m>addToScore(score);
multiScorer.cc:243:	LOG_SCORE(bestScorerState,BF("final score = %lf")% bestScorerState[01;31m-[00m>getScore() );
multiScorer.cc:251:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:252:    this[01;31m-[00m>_evaluate(builder,scorerState,true);
multiScorer.cc:256:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:257:    this[01;31m-[00m>_evaluate(builder,scorerState,false);
multiScorer.cc:262:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:267:    this[01;31m-[00m>throwIfBuilderOutOfSync(builder);
multiScorer.cc:269:    ASSERT(builder[01;31m-[00m>notNil());
multiScorer.cc:270:    ASSERT_greaterThan(this[01;31m-[00m>_SubScorers.size(),0);
multiScorer.cc:271:    ASSERT_lt(scorerState[01;31m-[00m>getScorerIdentifier(),this[01;31m-[00m>_SubScorers.size());
multiScorer.cc:277:    uint ssidx = scorerState[01;31m-[00m>getScorerIdentifier();
multiScorer.cc:279:    subScorerIterator = this[01;31m-[00m>_SubScorers.begin()+ssidx;
multiScorer.cc:281:    		% (*subScorerIterator)[01;31m-[00m>getScorerIdentifier() 
multiScorer.cc:282:		% this[01;31m-[00m>_SubScorers.size() 
multiScorer.cc:283:		% builder[01;31m-[00m>stateIdentifier() );
multiScorer.cc:284:	(*subScorerIterator)[01;31m-[00m>evaluate(builder,scorerState);
multiScorer.cc:287:		(*subScorerIterator)[01;31m-[00m>getScorerIdentifier() 
multiScorer.cc:288:		% scorerState[01;31m-[00m>summary().c_str());
multiScorer.cc:290:	builder[01;31m-[00m>streamDump(sdebug);
multiScorer.cc:292:		builder[01;31m-[00m>stateIdentifier()
multiScorer.cc:293:		% scorerState[01;31m-[00m>getScore()
multiScorer.cc:297:    LOG(BF("Telling builder bestScore: %s") % scorerState[01;31m-[00m>summary().c_str() ); // vp0(("Telling builder bestScore: %s", scorerState[01;31m-[00m>summary().c_str()));
multiScorer.cc:298:    if ( this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>notNil() )
multiScorer.cc:301:	double score = this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>evaluate(scorerState,this[01;31m-[00m>sharedThis<O_MultiScorer>(),builder);
multiScorer.cc:302:	scorerState[01;31m-[00m>addToScore(score);
multiScorer.cc:304:	LOG_SCORE(scorerState,BF("final score = %lf")% scorerState[01;31m-[00m>getScore() );
multiScorer.cc:311:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:312:    this[01;31m-[00m>throwIfBuilderOutOfSync(builder);
multiScorer.cc:315:    ASSERT_lessThan(scorerState[01;31m-[00m>getScorerIdentifier(),this[01;31m-[00m>_SubScorers.size());
multiScorer.cc:316:    LOG(BF("scorerState[01;31m-[00m>getScorerIdentifier() = %d") % scorerState[01;31m-[00m>getScorerIdentifier()  ); // vp0(("scorerState[01;31m-[00m>getScorerIdentifier() = %d", scorerState[01;31m-[00m>getScorerIdentifier() ));
multiScorer.cc:317:    scorer = this[01;31m-[00m>_SubScorers[scorerState[01;31m-[00m>getScorerIdentifier()];
multiScorer.cc:318:    return scorer[01;31m-[00m>getRenderForScore(builder,scorerState);
multiScorer.cc:323:    return O_ScorerState::create(this[01;31m-[00m>lisp());
multiScorer.cc:329:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:330:    ASSERT_NOT_NULL(this[01;31m-[00m>_MultiScoreCalculator);
multiScorer.cc:333:	// Evaluate the sub[01;31m-[00mscorers first to figure out which one is the best
multiScorer.cc:335:    RPScorerState scorerState = this[01;31m-[00m>createState();
multiScorer.cc:336:    this[01;31m-[00m>evaluate(builder,scorerState);
multiScorer.cc:337:    uint bestScorerIdentifier = scorerState[01;31m-[00m>getScorerIdentifier();
multiScorer.cc:338:    RPScorerBase bestScorer = this[01;31m-[00m>_SubScorers[bestScorerIdentifier];
multiScorer.cc:339:    bestScorer[01;31m-[00m>insertScoreOperationsIntoRestraintList(builder,restraints);
multiScorer.cc:340:    this[01;31m-[00m>_MultiScoreCalculator[01;31m-[00m>insertRestraints(builder,this[01;31m-[00m>sharedThis<O_MultiScorer>(),restraints);
multiScorer.cc:345:{_F(this[01;31m-[00m>lisp());
multiScorer.cc:346:    RPCons restraints = O_Cons::nil(this[01;31m-[00m>lisp());
multiScorer.cc:347:    this[01;31m-[00m>insertScoreOperationsIntoRestraintList(builder,restraints);
multiScorer.cc:359:    class_<O_MultiScorer>(this[01;31m-[00m>lisp())
multiStringBuffer.cc:20:    this[01;31m-[00m>_BlockId = blockId;
multiStringBuffer.cc:22:    this[01;31m-[00m>_BlockStart = (char*)malloc(MultiStringBlockSize);
multiStringBuffer.cc:23:    LOG(BF("Allocating MultiStringBlock@%p")% this[01;31m-[00m>_BlockStart );
multiStringBuffer.cc:24:    if ( this[01;31m-[00m>_BlockStart == NULL )
multiStringBuffer.cc:26:	THROW_HARD_ERROR("Could not allocate MultiStringBlock [01;31m-[00m ran out of memory");
multiStringBuffer.cc:28:    this[01;31m-[00m>_NextStringIndex = 0;
multiStringBuffer.cc:29:    this[01;31m-[00m>_NumberOfStrings = 0;
multiStringBuffer.cc:35:    LOG(BF( "About to free MultiStringBlock@%p")% this[01;31m-[00m>_BlockStart );
multiStringBuffer.cc:36:    free(this[01;31m-[00m>_BlockStart);
multiStringBuffer.cc:37:    this[01;31m-[00m>_BlockStart = NULL;
multiStringBuffer.cc:43:    uint nextStringIndex = this[01;31m-[00m>_NextStringIndex+len+1; // \0 terminated string
multiStringBuffer.cc:49:    uint index = this[01;31m-[00m>_NextStringIndex;
multiStringBuffer.cc:50:    strcpy(this[01;31m-[00m>_BlockStart+this[01;31m-[00m>_NextStringIndex,str);
multiStringBuffer.cc:51:    this[01;31m-[00m>_NextStringIndex = nextStringIndex;
multiStringBuffer.cc:58:    uint nextStringIndex = this[01;31m-[00m>_NextStringIndex+len+1; // \0 terminated string
multiStringBuffer.cc:63:    uint index = this[01;31m-[00m>_NextStringIndex;
multiStringBuffer.cc:64:    strncpy(this[01;31m-[00m>_BlockStart+this[01;31m-[00m>_NextStringIndex,str,len);
multiStringBuffer.cc:65:    this[01;31m-[00m>_BlockStart[nextStringIndex[01;31m-[00m1] = '\0';
multiStringBuffer.cc:66:    this[01;31m-[00m>_NextStringIndex = nextStringIndex;
multiStringBuffer.cc:73:    return this[01;31m-[00m>_BlockStart+localIndex;
multiStringBuffer.cc:79:    const char* cur = this[01;31m-[00m>_BlockStart;
multiStringBuffer.cc:81:    while ( cur [01;31m-[00m this[01;31m-[00m>_BlockStart < this[01;31m-[00m>_NextStringIndex )
multiStringBuffer.cc:84:	out << this[01;31m-[00m>_BlockId;
multiStringBuffer.cc:86:	out << (cur[01;31m-[00mthis[01;31m-[00m>_BlockStart+startIndex);
multiStringBuffer.cc:104:    class_<O_MultiStringBuffer>(e[01;31m-[00m>lisp())
multiStringBuffer.cc:125:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
multiStringBuffer.cc:131:    this[01;31m-[00m>Base::initialize();
multiStringBuffer.cc:132:    this[01;31m-[00m>_Blocks.clear();
multiStringBuffer.cc:137:    this[01;31m-[00m>Base::archiveBase(node);
multiStringBuffer.cc:143:    if ( this[01;31m-[00m>_Blocks.size() == 0 )
multiStringBuffer.cc:146:	this[01;31m-[00m>_Blocks.push_back(block);
multiStringBuffer.cc:148:    MultiStringBlock* curBlock = (this[01;31m-[00m>_Blocks.back());
multiStringBuffer.cc:150:    index = curBlock[01;31m-[00m>addNumberOfCharacters(str,num);
multiStringBuffer.cc:153:	MultiStringBlock* newBlock = new MultiStringBlock(this[01;31m-[00m>_Blocks.size());
multiStringBuffer.cc:154:	this[01;31m-[00m>_Blocks.push_back(newBlock);
multiStringBuffer.cc:155:	curBlock = (this[01;31m-[00m>_Blocks.back());
multiStringBuffer.cc:156:	index = curBlock[01;31m-[00m>addCharacters(str);
multiStringBuffer.cc:176:    uint blockIndex = MultiStringBlockSize*(this[01;31m-[00m>_Blocks.size()[01;31m-[00m1);
multiStringBuffer.cc:183:{_F(this[01;31m-[00m>lisp());
multiStringBuffer.cc:185:    if ( this[01;31m-[00m>_Blocks.size() == 0 )
multiStringBuffer.cc:188:	this[01;31m-[00m>_Blocks.push_back(block);
multiStringBuffer.cc:190:    MultiStringBlock* curBlock = (this[01;31m-[00m>_Blocks.back());
multiStringBuffer.cc:192:    index = curBlock[01;31m-[00m>addCharacters(str);
multiStringBuffer.cc:195:	MultiStringBlock* newBlock = new MultiStringBlock(this[01;31m-[00m>_Blocks.size());
multiStringBuffer.cc:196:	this[01;31m-[00m>_Blocks.push_back(newBlock);
multiStringBuffer.cc:197:	curBlock = (this[01;31m-[00m>_Blocks.back());
multiStringBuffer.cc:198:	index = curBlock[01;31m-[00m>addCharacters(str);
multiStringBuffer.cc:213:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(serr.str()));
multiStringBuffer.cc:216:    uint blockIndex = MultiStringBlockSize*(this[01;31m-[00m>_Blocks.size()[01;31m-[00m1);
multiStringBuffer.cc:224:    return this[01;31m-[00m>addCharacters(str.c_str());
multiStringBuffer.cc:233:    ASSERT_lt(blockIndex,this[01;31m-[00m>_Blocks.size());
multiStringBuffer.cc:234:    MultiStringBlock& block = *(this[01;31m-[00m>_Blocks[blockIndex]);
multiStringBuffer.cc:241:    const char* chars = this[01;31m-[00m>getCharacters(index);
multiStringBuffer.cc:253:    for ( vector<MultiStringBlock*>::iterator it=this[01;31m-[00m>_Blocks.begin();
multiStringBuffer.cc:254:    		it<this[01;31m-[00m>_Blocks.end(); it++ )
multiStringBuffer.cc:256:	(*it)[01;31m-[00m>dump(startIndex,ss);
multiStringBuffer.cc:264:    this[01;31m-[00m>dumpToStream(ss);
multiStringBuffer.cc:271:    uint headerMemory = (sizeof(MultiStringBlock)+sizeof(MultiStringBlock*))*this[01;31m-[00m>_Blocks.size();
multiStringBuffer.cc:272:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("MultiStringBlock storage = %d bytes") % headerMemory );
multiStringBuffer.cc:274:    LongLongInt storage = MultiStringBlockSize*this[01;31m-[00m>_Blocks.size();
multiStringBuffer.cc:275:    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("String storage = %d bytes") % storage );
myReadLine.cc:20:      lisp[01;31m-[00m>print(BF("%s")%prompt);
myReadLine.cc:31:	  _lisp[01;31m-[00m>print(BF("%s ") % prompt );
mySaxInterface.cc:25:    pos = this[01;31m-[00m>attributes;
mySaxInterface.cc:52:    pos = this[01;31m-[00m>attributes;
mySaxInterface.cc:71:    pos = this[01;31m-[00m>attributes;
mySaxInterface.cc:78:	ind[01;31m-[00m[01;31m-[00m;
mySaxInterface.cc:101://    XML_SetStartElementHandler( this[01;31m-[00m>parser, myExpatStartElement );
mySaxInterface.cc:109:    _F(parser[01;31m-[00m>lisp());
mySaxInterface.cc:111:    parser[01;31m-[00m>handler[01;31m-[00m>setLocalName(name);
mySaxInterface.cc:112:    parser[01;31m-[00m>handler[01;31m-[00m>setLineNumber(XML_GetCurrentLineNumber(parser[01;31m-[00m>getXMLParser()));
mySaxInterface.cc:113:    parser[01;31m-[00m>handler[01;31m-[00m>setAttributes(atts);
mySaxInterface.cc:114:    parser[01;31m-[00m>handler[01;31m-[00m>startElement(parser[01;31m-[00m>lisp());
mySaxInterface.cc:123:_F(parser[01;31m-[00m>lisp());
mySaxInterface.cc:125:    parser[01;31m-[00m>handler[01;31m-[00m>setLocalName(name);
mySaxInterface.cc:126:    parser[01;31m-[00m>handler[01;31m-[00m>setLineNumber(XML_GetCurrentLineNumber(parser[01;31m-[00m>getXMLParser()));
mySaxInterface.cc:127:    parser[01;31m-[00m>handler[01;31m-[00m>endElement();
mySaxInterface.cc:136:_F(parser[01;31m-[00m>lisp());
mySaxInterface.cc:143:    parser[01;31m-[00m>handler[01;31m-[00m>setData(myBuffer);
mySaxInterface.cc:144:    parser[01;31m-[00m>handler[01;31m-[00m>setDataLength(len);
mySaxInterface.cc:145:    parser[01;31m-[00m>handler[01;31m-[00m>characters();
mySaxInterface.cc:152:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
mySaxInterface.cc:153:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
mySaxInterface.cc:154:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
mySaxInterface.cc:161:    this[01;31m-[00m>pythonCallback = PythonCallback();
mySaxInterface.cc:163:    ASSERT(lisp[01;31m-[00m>notNil());
mySaxInterface.cc:164:    this[01;31m-[00m>setLisp(lisp);
mySaxInterface.cc:165://    this[01;31m-[00m>_Progress.setOn();
mySaxInterface.cc:173:    this[01;31m-[00m>parser= XML_ParserCreate( "UTF[01;31m-[00m8" );
mySaxInterface.cc:174:    XML_SetElementHandler( this[01;31m-[00m>parser, myExpatStartElement, myExpatEndElement );
mySaxInterface.cc:175:    XML_SetCharacterDataHandler( this[01;31m-[00m>parser, myExpatCharacterData );
mySaxInterface.cc:176:    XML_SetUserData( this[01;31m-[00m>parser, (void*)this );
mySaxInterface.cc:189:{ _F(this[01;31m-[00m>lisp());
mySaxInterface.cc:190:    XML_ParserFree(this[01;31m-[00m>parser);
mySaxInterface.cc:199:{_F(this[01;31m-[00m>lisp());
mySaxInterface.cc:201:    this[01;31m-[00m>handler = aHandler;
mySaxInterface.cc:254:{_F(this[01;31m-[00m>lisp());
mySaxInterface.cc:274://    this[01;31m-[00m>_Progress.setMax(fileSize);
mySaxInterface.cc:275://    this[01;31m-[00m>_Progress.setSteps(fileSize/10000);
mySaxInterface.cc:277:    this[01;31m-[00m>pythonCallback[01;31m-[00m>setLongVal1(fileSize);
mySaxInterface.cc:289://	this[01;31m-[00m>pythonCallback[01;31m-[00m>setLongVal0(filePos);
mySaxInterface.cc:290://	this[01;31m-[00m>pythonCallback[01;31m-[00m>callCallback();
mySaxInterface.cc:291://	if ( this[01;31m-[00m>pythonCallback[01;31m-[00m>getLongReturn()!=0 ) {
mySaxInterface.cc:298:	xmlStatus = XML_Parse( this[01;31m-[00m>parser, buffer, sz, done );
mySaxInterface.cc:301:	    err = XML_GetErrorCode(this[01;31m-[00m>parser);
mySaxInterface.cc:303:	    printf( "MySaxParser::expat:: line = %d\n", (int)(XML_GetCurrentLineNumber(this[01;31m-[00m>parser)) );
mySaxInterface.cc:308://    this[01;31m-[00m>_Progress.finish();
mySaxInterface.cc:321:{ _F(this[01;31m-[00m>lisp());
mySaxInterface.cc:325:    xmlStatus = XML_Parse( this[01;31m-[00m>parser, xmlContent,
nVector.cc:32:    nv[01;31m-[00m>setup(sz);
nVector.cc:46:{_F(this[01;31m-[00m>lisp());
nVector.cc:47:    this[01;31m-[00m>_Size = orig._Size;
nVector.cc:48:    this[01;31m-[00m>_Values.assign(orig._Values.begin(),orig._Values.end());
nVector.cc:56:    this[01;31m-[00m>setup(0);
nVector.cc:60:{_F(this[01;31m-[00m>lisp());
nVector.cc:61:    this[01;31m-[00m>_Size = iElements;
nVector.cc:62:    this[01;31m-[00m>_Values.resize(iElements,0.0);
nVector.cc:63:    LOG(BF("Created O_NVector@%0X with %d entries") % &(this[01;31m-[00m>_Values) % this[01;31m-[00m>_Size ); // vp0(( "Created O_NVector@%0X with %d entries", &(this[01;31m-[00m>_Values), this[01;31m-[00m>_Size));
nVector.cc:76:    ASSERTP(this[01;31m-[00m>_Size == orig[01;31m-[00m>_Size,"O_NVector::copy>>mismatched size");
nVector.cc:77:    this[01;31m-[00m>_Values.assign(orig[01;31m-[00m>_Values.begin(),orig[01;31m-[00m>_Values.end());
nVector.cc:82:{ _F(this[01;31m-[00m>lisp());
nVector.cc:84:    vv = RP_Copy<O_NVector>(this[01;31m-[00m>sharedThis<O_NVector>());
nVector.cc:97:    this[01;31m-[00m>_Values.assign(this[01;31m-[00m>_Size,0.0);
nVector.cc:111:    this[01;31m-[00m>_Values.assign(this[01;31m-[00m>_Size,dValue);
nVector.cc:123:    for ( dp=this[01;31m-[00m>_Values.begin(); dp!=this[01;31m-[00m>_Values.end(); dp++ ) {
nVector.cc:137:    for ( dp=this[01;31m-[00m>_Values.begin(); dp!=this[01;31m-[00m>_Values.end(); dp++ ) {
nVector.cc:152:    maxVal = [01;31m-[00m9.0e99;
nVector.cc:153:    for ( dp=this[01;31m-[00m>_Values.begin(); dp!=this[01;31m-[00m>_Values.end(); dp++ ) {
nVector.cc:167:    for ( dp=this[01;31m-[00m>_Values.begin(); dp!=this[01;31m-[00m>_Values.end(); dp++ ) {
nVector.cc:184:    cout << "O_NVector length= " << this[01;31m-[00m>_Size << endl;
nVector.cc:185:    for ( i=0; i<this[01;31m-[00m>_Size; i++ )
nVector.cc:186:        cout << "[01;31m-[00m[01;31m-[00m[01;31m-[00m[" << i << "] = " << this[01;31m-[00m>_Values[i] << endl;
nVector.cc:192:{ _F(this[01;31m-[00m>lisp());
nVector.cc:195:    for (uint i=0; i<this[01;31m-[00m>_Size; i++ ) {
nVector.cc:196:	ss << this[01;31m-[00m>_Values[i] << " ";
nVector.cc:219:    ASSERTP( this[01;31m-[00m>_Values.size() == x[01;31m-[00m>size(),"O_NVector::add>>mismatched size");
nVector.cc:220:    ASSERTP( this[01;31m-[00m>_Values.size() == y[01;31m-[00m>size(),"O_NVector::add>>mismatched size");
nVector.cc:221:    for ( resi = this[01;31m-[00m>_Values.begin(), xi=x[01;31m-[00m>_Values.begin(), yi=y[01;31m-[00m>_Values.begin();
nVector.cc:222:	    resi!=this[01;31m-[00m>_Values.end(); resi++, xi++, yi++ ) {
nVector.cc:232:{_F(this[01;31m-[00m>lisp());
nVector.cc:234:    LOG(BF("this[01;31m-[00m>_Values.size() = %d") % this[01;31m-[00m>_Values.size() ); // vp0(("this[01;31m-[00m>_Values.size() = %d", this[01;31m-[00m>_Values.size()));
nVector.cc:235:    LOG(BF("x[01;31m-[00m>size() = %d") % x[01;31m-[00m>size() ); // vp0(("x[01;31m-[00m>size() = %d", x[01;31m-[00m>size()));
nVector.cc:236:    LOG(BF("y[01;31m-[00m>size() = %d") % y[01;31m-[00m>size() ); // vp0(("y[01;31m-[00m>size() = %d", y[01;31m-[00m>size()));
nVector.cc:237:    ASSERTP( this[01;31m-[00m>_Values.size() == x[01;31m-[00m>size(),"O_NVector::addTimesScalar>>mismatched size");
nVector.cc:238:    ASSERT( this[01;31m-[00m>_Values.size() == y[01;31m-[00m>size());
nVector.cc:239:    for ( resi = this[01;31m-[00m>_Values.begin(), xi=x[01;31m-[00m>_Values.begin(), yi=y[01;31m-[00m>_Values.begin();
nVector.cc:240:	    resi!=this[01;31m-[00m>_Values.end(); resi++, xi++, yi++ ) {
nVector.cc:253:{_F(this[01;31m-[00m>lisp());
nVector.cc:255:    LOG(BF("this[01;31m-[00m>_Values.size() = %d") % this[01;31m-[00m>_Values.size() ); // vp0(("this[01;31m-[00m>_Values.size() = %d", this[01;31m-[00m>_Values.size()));
nVector.cc:256:    LOG(BF("x[01;31m-[00m>size() = %d") % x[01;31m-[00m>size() ); // vp0(("x[01;31m-[00m>size() = %d", x[01;31m-[00m>size()));
nVector.cc:257:    ASSERTP( this[01;31m-[00m>_Values.size() == x[01;31m-[00m>size(),"O_NVector::addTimesScalar>>mismatched size");
nVector.cc:258:    for ( resi = this[01;31m-[00m>_Values.begin(), xi=x[01;31m-[00m>_Values.begin();
nVector.cc:259:	    resi!=this[01;31m-[00m>_Values.end(); resi++, xi++ ) {
nVector.cc:268:    ASSERT( this[01;31m-[00m>_Values.size() == dir[01;31m-[00m>size());
nVector.cc:269:    for ( resi = this[01;31m-[00m>_Values.begin(), diri=dir[01;31m-[00m>_Values.begin();
nVector.cc:270:	    resi!=this[01;31m-[00m>_Values.end(); resi++, diri++ ) {
nVector.cc:287:    ASSERT( this[01;31m-[00m>_Values.size() == x[01;31m-[00m>size());
nVector.cc:288:    ASSERT( this[01;31m-[00m>_Values.size() == y[01;31m-[00m>size());
nVector.cc:289:    for ( resi = this[01;31m-[00m>_Values.begin(), xi=x[01;31m-[00m>_Values.begin(), yi=y[01;31m-[00m>_Values.begin();
nVector.cc:290:	    resi!=this[01;31m-[00m>_Values.end(); resi++, xi++, yi++ ) {
nVector.cc:291:	*resi = *xi[01;31m-[00m*yi;
nVector.cc:308:    for ( resi=this[01;31m-[00m>_Values.begin(),xi=x[01;31m-[00m>_Values.begin(); resi!=this[01;31m-[00m>_Values.end(); resi++,xi++ ) {
nVector.cc:331:    for ( resi=this[01;31m-[00m>_Values.begin(),xi=x[01;31m-[00m>_Values.begin(); resi!=this[01;31m-[00m>_Values.end(); resi++,xi++ ) {
nVector.cc:344:    for ( resi=this[01;31m-[00m>_Values.begin(); resi!=this[01;31m-[00m>_Values.end(); resi++ ) {
nVector.cc:355:    for ( resi=this[01;31m-[00m>_Values.begin(); resi!=this[01;31m-[00m>_Values.end(); resi++ ) {
nVector.cc:361:{_F(this[01;31m-[00m>lisp());
nVector.cc:362:    node[01;31m-[00m>archiveVectorDouble( "vec", this[01;31m-[00m>_Values );
nVector.cc:363:    LOG(BF("size of this[01;31m-[00m>_Values=%d") % this[01;31m-[00m>_Values.size()  ); // vp0(("size of this[01;31m-[00m>_Values=%d",this[01;31m-[00m>_Values.size() ));
nVector.cc:364:    if ( node[01;31m-[00m>loading() )
nVector.cc:366:       this[01;31m-[00m>_Size = this[01;31m-[00m>_Values.size();
nVector.cc:384:    dDot = this[01;31m-[00m>squared();
nVector.cc:393:    dDot = this[01;31m-[00m>squared();
nVector.cc:394:    dDot /= (double)this[01;31m-[00m>size();
nVector.cc:403: * List the term[01;31m-[00mby[01;31m-[00mterm differences and return as an XML object
nVector.cc:407:    RPQDomNode xml = O_QDomNode::create(this[01;31m-[00m>lisp(),"Differences");
nVector.cc:412:    resi = this[01;31m-[00m>_Values.begin();
nVector.cc:413:    ni = n[01;31m-[00m>_Values.begin();
nVector.cc:414:    for ( i=0; i<this[01;31m-[00m>_Size; i++, resi++, ni++ ) {
nVector.cc:417:	if ( fabs(*resi[01;31m-[00m*ni)/avg > 0.1 ) {
nVector.cc:418:	    part = O_QDomNode::create(this[01;31m-[00m>lisp(),"V");
nVector.cc:419:	    part[01;31m-[00m>addAttributeInt("i",i);
nVector.cc:420:	    part[01;31m-[00m>addAttributeDoubleScientific(thisName,*resi);
nVector.cc:421:	    part[01;31m-[00m>addAttributeDoubleScientific(otherName,*ni);
nVector.cc:422:	    xml[01;31m-[00m>addChild(part);
nVector.cc:438:    for ( y = 0; y<this[01;31m-[00m>_Size; y++ ) {
nVector.cc:442:	fout << this[01;31m-[00m>element(y);
nVector.cc:451:#define	VERY_SMALL 1.0e[01;31m-[00m6
nVector.cc:453:    lenThis = this[01;31m-[00m>magnitude();
nVector.cc:454:    lenOther = other[01;31m-[00m>magnitude();
nVector.cc:455:    dot = this[01;31m-[00m>dotProduct(other);
nVector.cc:459:	if ( dot < [01;31m-[00m1.0 ) dot = [01;31m-[00m1.0;
nVector.cc:470:    ASSERT(v[01;31m-[00m>size() == this[01;31m-[00m>size() );
nVector.cc:472:    for ( i=0; i<this[01;31m-[00m>size(); i++ ) {
nVector.cc:473:	e = this[01;31m-[00m>_Values[i][01;31m-[00mv[01;31m-[00m>_Values[i];
nVector.cc:476:    sum /= (float)(this[01;31m-[00m>size());
nonbondTerms_hand_optimized.cc:2:	tx1 = [01;31m-[00mx2; 		/* rule 1 */
nonbondTerms_hand_optimized.cc:3:	tx2 = [01;31m-[00my2; 		/* rule 2 */
nonbondTerms_hand_optimized.cc:4:	tx3 = [01;31m-[00mz2; 		/* rule 3 */
nonbondTerms_hand_optimized.cc:19:	tx14 = [01;31m-[00m(dC*tx12); 		/* rule 18 */
nonbondTerms_hand_optimized.cc:32:	tzz43 = [01;31m-[00mtzz42; 		/* rule 31 */
nonbondTerms_hand_optimized.cc:38:	tzz44 = [01;31m-[00mtzz40; 		/* rule 37 */
nonbondTerms_hand_optimized.cc:49:	fx1 = [01;31m-[00mdx1; 		/* rule 48 */
nonbondTerms_hand_optimized.cc:50:	fy1 = [01;31m-[00mdy1; 		/* rule 49 */
nonbondTerms_hand_optimized.cc:51:	fz1 = [01;31m-[00mdz1; 		/* rule 50 */
nonbondTerms_hand_optimized.cc:52:	fx2 = [01;31m-[00mfx1; 		/* rule 51 */
nonbondTerms_hand_optimized.cc:53:	fy2 = [01;31m-[00mfy1; 		/* rule 52 */
nonbondTerms_hand_optimized.cc:54:	fz2 = [01;31m-[00mfz1; 		/* rule 53 */
numericalFunction.cc:17:#define	ROUND(x) ((x)>0.0)?floor((x)+0.5):[01;31m-[00mfloor(([01;31m-[00mx)+0.5)
numericalFunction.cc:27:    this[01;31m-[00m>Base::initialize();
numericalFunction.cc:28:    this[01;31m-[00m>title = "";
numericalFunction.cc:29:    this[01;31m-[00m>xAxisName = "";
numericalFunction.cc:30:    this[01;31m-[00m>yAxisName = "";
numericalFunction.cc:31:    this[01;31m-[00m>values.clear();
numericalFunction.cc:40:    this[01;31m-[00m>xAxisName = ss.xAxisName;
numericalFunction.cc:41:    this[01;31m-[00m>yAxisName = ss.yAxisName;
numericalFunction.cc:42:    this[01;31m-[00m>xStart = ss.xStart;
numericalFunction.cc:43:    this[01;31m-[00m>xInc = ss.xInc;
numericalFunction.cc:44:    this[01;31m-[00m>values = ss.values;
numericalFunction.cc:54:{_F(this[01;31m-[00m>lisp());
numericalFunction.cc:55:    node[01;31m-[00m>attribute("title",this[01;31m-[00m>title);
numericalFunction.cc:56:    node[01;31m-[00m>attribute("xAxisName",this[01;31m-[00m>xAxisName);
numericalFunction.cc:57:    node[01;31m-[00m>attribute("yAxisName",this[01;31m-[00m>yAxisName);
numericalFunction.cc:58:    node[01;31m-[00m>attribute("xInc",this[01;31m-[00m>xInc);
numericalFunction.cc:59:    node[01;31m-[00m>archiveVectorDouble("values",this[01;31m-[00m>values);
numericalFunction.cc:67:/*! Return the index of the entry with the largest x[01;31m-[00mvalue smaller than or equal to
numericalFunction.cc:74:    if ( this[01;31m-[00m>values.size()== 0 ) {
numericalFunction.cc:77:    if ( this[01;31m-[00m>xInc == 0 ) {
numericalFunction.cc:80:    index = (int)ROUND((double)((x [01;31m-[00m this[01;31m-[00m>xStart)/this[01;31m-[00m>xInc));
numericalFunction.cc:88:    x = this[01;31m-[00m>xStart+this[01;31m-[00m>xInc*index;
numericalFunction.cc:98:	this[01;31m-[00m>values.insert( this[01;31m-[00m>values.begin(), [01;31m-[00mi, 0.0 );
numericalFunction.cc:99:	this[01;31m-[00m>xStart = this[01;31m-[00m>xStart + (i*this[01;31m-[00m>xInc);
numericalFunction.cc:100:	this[01;31m-[00m>values[0] = v;
numericalFunction.cc:101:    } else if ( i >= (int)(this[01;31m-[00m>values.size()) ) {
numericalFunction.cc:102:	this[01;31m-[00m>values.insert( this[01;31m-[00m>values.end(), i[01;31m-[00mthis[01;31m-[00m>values.size()+1, 0.0 );
numericalFunction.cc:103:	this[01;31m-[00m>values[this[01;31m-[00m>values.size()[01;31m-[00m1] = v;
numericalFunction.cc:105:	this[01;31m-[00m>values[i] = v;
numericalFunction.cc:114:    } else if ( i >= (int)(this[01;31m-[00m>values.size()) ) {
numericalFunction.cc:117:    return this[01;31m-[00m>values[i];
numericalFunction.cc:129:    fprintf( fOut, "# %s %s\n", this[01;31m-[00m>xAxisName.c_str(), this[01;31m-[00m>yAxisName.c_str() );
numericalFunction.cc:131:    for (dp=this[01;31m-[00m>values.begin(); dp!=this[01;31m-[00m>values.end(); dp++ ) {
numericalFunction.cc:132:	fprintf( fOut, "%10.9lf %10.9lf\n", this[01;31m-[00m>xValue(dp[01;31m-[00mthis[01;31m-[00m>values.begin()), *dp );
numericalFunction.cc:145:    fprintf( fOut, "# %s %s\n", this[01;31m-[00m>xAxisName.c_str(), this[01;31m-[00m>yAxisName.c_str() );
numericalFunction.cc:147:    for (dp=this[01;31m-[00m>values.begin(); dp!=this[01;31m-[00m>values.end(); dp++ ) {
numericalFunction.cc:148:	fprintf( fOut, "%10.9lf %10.9lf\n", this[01;31m-[00m>xValue(dp[01;31m-[00mthis[01;31m-[00m>values.begin()), *dp );
numericalFunction.cc:164:    return this[01;31m-[00m>xStart;
numericalFunction.cc:170:    return this[01;31m-[00m>xStart+this[01;31m-[00m>xInc*this[01;31m-[00m>values.size();
numericalFunction.cc:178:    for (dp=this[01;31m-[00m>values.begin(); dp!=this[01;31m-[00m>values.end(); dp++ ) {
numericalFunction.cc:188:    highY = [01;31m-[00m99999999.0;
numericalFunction.cc:189:    for (dp=this[01;31m-[00m>values.begin(); dp!=this[01;31m-[00m>values.end(); dp++ ) {
numericalFunction.cc:211:    this[01;31m-[00m>reset();
numericalFunction.cc:221:	if ( xindex[01;31m-[00m1 < n ) {
numericalFunction.cc:222:	    x = values[xindex[01;31m-[00m1];
numericalFunction.cc:224:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Index beyond the end of line" ));
numericalFunction.cc:226:	if ( yindex[01;31m-[00m1 < n ) {
numericalFunction.cc:227:	    y = values[yindex[01;31m-[00m1];
numericalFunction.cc:229:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Index beyond the end of line" ));
numericalFunction.cc:235:    this[01;31m-[00m>xInc = xv[1][01;31m-[00mxv[0];
numericalFunction.cc:236:    this[01;31m-[00m>xStart = ROUND(xv[0]/this[01;31m-[00m>xInc)*this[01;31m-[00m>xInc;
numericalFunction.cc:237:    this[01;31m-[00m>values.clear();
numericalFunction.cc:239:	this[01;31m-[00m>values.push_back(*dp);
numericalFunction.cc:246:    this[01;31m-[00m>values.clear();
numericalFunction.cc:257:    if ( this[01;31m-[00m>xInc != fn[01;31m-[00m>xInc ) {
numericalFunction.cc:259:	ss << "xInc values must be identical this[01;31m-[00m>xInc("
numericalFunction.cc:260:		<< this[01;31m-[00m>xInc << ") != fn[01;31m-[00m>xInc("
numericalFunction.cc:261:		<< fn[01;31m-[00m>xInc << ")";
numericalFunction.cc:262:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
numericalFunction.cc:264:    if ( this[01;31m-[00m>values.size() == 0 ) {
numericalFunction.cc:265:	xMin = fn[01;31m-[00m>xStart;
numericalFunction.cc:266:	xMax = fn[01;31m-[00m>xStart+fn[01;31m-[00m>xInc*(fn[01;31m-[00m>values.size());
numericalFunction.cc:267:    } else if ( fn[01;31m-[00m>values.size() == 0 ) {
numericalFunction.cc:268:	xMin = this[01;31m-[00m>xStart;
numericalFunction.cc:269:	xMax = this[01;31m-[00m>xStart+fn[01;31m-[00m>xInc*(fn[01;31m-[00m>values.size());
numericalFunction.cc:271:        xMin = min(this[01;31m-[00m>xStart,fn[01;31m-[00m>xStart);
numericalFunction.cc:272:        xMax = max(this[01;31m-[00m>xStart+this[01;31m-[00m>xInc*(this[01;31m-[00m>values.size()),
numericalFunction.cc:273:		fn[01;31m-[00m>xStart+fn[01;31m-[00m>xInc*(fn[01;31m-[00m>values.size()));
numericalFunction.cc:275:    vals = (int)((xMax[01;31m-[00mxMin)/this[01;31m-[00m>xInc);
numericalFunction.cc:276:    newFunc = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_NumericalFunction>();
numericalFunction.cc:277:    newFunc[01;31m-[00m>setXStart(xMin);
numericalFunction.cc:278:    newFunc[01;31m-[00m>setXInc(this[01;31m-[00m>xInc);
numericalFunction.cc:279:    newFunc[01;31m-[00m>values.assign(vals,0.0);
numericalFunction.cc:280:    LOG(BF("resulting NumericalFunction has %d vals") % (newFunc[01;31m-[00m>values.size()) ); // vp0(("resulting NumericalFunction has %d vals", newFunc[01;31m-[00m>values.size()));
numericalFunction.cc:281:    for ( dp=newFunc[01;31m-[00m>values.begin(); dp!=newFunc[01;31m-[00m>values.end(); dp++ ) {
numericalFunction.cc:282:	x = newFunc[01;31m-[00m>getXValueAtIndex(dp[01;31m-[00mnewFunc[01;31m-[00m>values.begin());
numericalFunction.cc:284:	thisIndex = this[01;31m-[00m>findIndex(x);
numericalFunction.cc:285:	LOG(BF("   thisIndex = %d value=%lf") % (thisIndex) % (this[01;31m-[00m>getYValueAtIndex(thisIndex) ) ); // vp0(("   thisIndex = %d value=%lf", thisIndex,this[01;31m-[00m>getYValueAtIndex(thisIndex) ));
numericalFunction.cc:286:	fnIndex = fn[01;31m-[00m>findIndex(x);
numericalFunction.cc:287:	LOG(BF("     fnIndex = %d valut=%lf") % (fnIndex) % (fn[01;31m-[00m>getYValueAtIndex(fnIndex) ) ); // vp0(("     fnIndex = %d valut=%lf", fnIndex, fn[01;31m-[00m>getYValueAtIndex(fnIndex) ));
numericalFunction.cc:288:	*dp = this[01;31m-[00m>getYValueAtIndex(thisIndex) + fn[01;31m-[00m>getYValueAtIndex(fnIndex);
numericalFunction.cc:289:	LOG(BF("  Wrote value(%lf) to index(%d)") % (*dp) % (dp[01;31m-[00mnewFunc[01;31m-[00m>values.begin()) ); // vp0(("  Wrote value(%lf) to index(%d)",*dp,dp[01;31m-[00mnewFunc[01;31m-[00m>values.begin()));
numericalFunction.cc:300:    if ( this[01;31m-[00m>xInc != fn[01;31m-[00m>xInc ) {
numericalFunction.cc:302:	ss << "xInc values must be identical this[01;31m-[00m>xInc("
numericalFunction.cc:303:		<< this[01;31m-[00m>xInc << ") != fn[01;31m-[00m>xInc("
numericalFunction.cc:304:		<< fn[01;31m-[00m>xInc << ")";
numericalFunction.cc:305:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
numericalFunction.cc:307:    if ( this[01;31m-[00m>values.size() == 0 ) {
numericalFunction.cc:308:	xMin = fn[01;31m-[00m>xStart;
numericalFunction.cc:309:	xMax = fn[01;31m-[00m>xStart+fn[01;31m-[00m>xInc*(fn[01;31m-[00m>values.size());
numericalFunction.cc:310:    } else if ( fn[01;31m-[00m>values.size() == 0 ) {
numericalFunction.cc:311:	xMin = this[01;31m-[00m>xStart;
numericalFunction.cc:312:	xMax = this[01;31m-[00m>xStart+fn[01;31m-[00m>xInc*(fn[01;31m-[00m>values.size());
numericalFunction.cc:314:        xMin = min(this[01;31m-[00m>xStart,fn[01;31m-[00m>xStart);
numericalFunction.cc:315:        xMax = max(this[01;31m-[00m>xStart+this[01;31m-[00m>xInc*(this[01;31m-[00m>values.size()),
numericalFunction.cc:316:		fn[01;31m-[00m>xStart+fn[01;31m-[00m>xInc*(fn[01;31m-[00m>values.size()));
numericalFunction.cc:318:    vals = (int)((xMax[01;31m-[00mxMin)/this[01;31m-[00m>xInc);
numericalFunction.cc:319:    newFunc = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_NumericalFunction>();
numericalFunction.cc:320:    newFunc[01;31m-[00m>setXStart(xMin);
numericalFunction.cc:321:    newFunc[01;31m-[00m>setXInc(this[01;31m-[00m>xInc);
numericalFunction.cc:322:    newFunc[01;31m-[00m>values.assign(vals,0.0);
numericalFunction.cc:323:    LOG(BF("resulting NumericalFunction has %d vals") % (newFunc[01;31m-[00m>values.size()) ); // vp0(("resulting NumericalFunction has %d vals", newFunc[01;31m-[00m>values.size()));
numericalFunction.cc:324:    for ( dp=newFunc[01;31m-[00m>values.begin(); dp!=newFunc[01;31m-[00m>values.end(); dp++ ) {
numericalFunction.cc:325:	x = newFunc[01;31m-[00m>getXValueAtIndex(dp[01;31m-[00mnewFunc[01;31m-[00m>values.begin());
numericalFunction.cc:327:	thisIndex = this[01;31m-[00m>findIndex(x);
numericalFunction.cc:328:	LOG(BF("   thisIndex = %d value=%lf") % (thisIndex) % (this[01;31m-[00m>getYValueAtIndex(thisIndex) ) ); // vp0(("   thisIndex = %d value=%lf", thisIndex,this[01;31m-[00m>getYValueAtIndex(thisIndex) ));
numericalFunction.cc:329:	fnIndex = fn[01;31m-[00m>findIndex(x);
numericalFunction.cc:330:	LOG(BF("     fnIndex = %d valut=%lf") % (fnIndex) % (fn[01;31m-[00m>getYValueAtIndex(fnIndex) ) ); // vp0(("     fnIndex = %d valut=%lf", fnIndex, fn[01;31m-[00m>getYValueAtIndex(fnIndex) ));
numericalFunction.cc:331:	*dp = this[01;31m-[00m>getYValueAtIndex(thisIndex) [01;31m-[00m fn[01;31m-[00m>getYValueAtIndex(fnIndex);
numericalFunction.cc:332:	LOG(BF("  Wrote value(%lf) to index(%d)") % (*dp) % (dp[01;31m-[00mnewFunc[01;31m-[00m>values.begin()) ); // vp0(("  Wrote value(%lf) to index(%d)",*dp,dp[01;31m-[00mnewFunc[01;31m-[00m>values.begin()));
numericalFunction.cc:342:    LOG(BF("addValueToHistogram value = %lf    xInc = %lf") % (x) % (this[01;31m-[00m>xInc ) ); // vp0(( "addValueToHistogram value = %lf    xInc = %lf", x, this[01;31m-[00m>xInc ));
numericalFunction.cc:343:    if ( this[01;31m-[00m>values.size() == 0 ) {
numericalFunction.cc:344:	rnd = ROUND(x/this[01;31m-[00m>xInc);
numericalFunction.cc:346:	this[01;31m-[00m>xStart = this[01;31m-[00m>xInc*rnd;
numericalFunction.cc:347:	LOG(BF("addValueToHistogram xStart = %lf") % (this[01;31m-[00m>xStart ) ); // vp0(( "addValueToHistogram xStart = %lf", this[01;31m-[00m>xStart ));
numericalFunction.cc:348:	this[01;31m-[00m>values.push_back(1.0);
numericalFunction.cc:351:    index = this[01;31m-[00m>findIndex(x);
numericalFunction.cc:353:    cnt = this[01;31m-[00m>getYValueAtIndex(index) + 1.0;
numericalFunction.cc:354:    this[01;31m-[00m>setYValueAtIndex(index,cnt);
numericalFunction.cc:366:    newFunc = this[01;31m-[00m>sub(fn);
numericalFunction.cc:368:    for ( dp=newFunc[01;31m-[00m>values.begin(); dp!=newFunc[01;31m-[00m>values.end(); dp++ ) {
numericalFunction.cc:371:    rms /= this[01;31m-[00m>values.size();
numericalFunction.cc:377:    this[01;31m-[00m>xStart *= scale;
numericalFunction.cc:378:    this[01;31m-[00m>xInc *= scale;
numericalFunction.cc:386:    for (ip=this[01;31m-[00m>values.begin(); ip!=this[01;31m-[00m>values.end(); ip++ ) {
numericalFunction.cc:395:    for (ip=this[01;31m-[00m>values.begin(); ip!=this[01;31m-[00m>values.end(); ip++ ) {
numericalFunction.cc:463:    if ( i < 0 || i >= this[01;31m-[00m>values.size() ) {
numericalFunction.cc:466:    res = boost::python::make_tuple(this[01;31m-[00m>values[i].x,this[01;31m-[00m>values[i].y);
numericalFunction.cc:475:    for ( vi=this[01;31m-[00m>values.begin(); vi!=this[01;31m-[00m>values.end(); vi++ ) {
numericalFunction.cc:476:	res.append(boost::python::make_tuple(this[01;31m-[00m>getXValueAtIndex(vi[01;31m-[00mthis[01;31m-[00m>values.begin()),*vi));
numericalFunction.cc:484:    this[01;31m-[00m>values.clear();
numericalFunction.cc:487:        this[01;31m-[00m>xStart = boost::python::extract<double>(inp[0][0]);
numericalFunction.cc:490:    	    this[01;31m-[00m>xInc = x1 [01;31m-[00m xStart;
numericalFunction.cc:495:	this[01;31m-[00m>values.push_back(y);
numerics.cc:21:    if ( ( LongLongMax [01;31m-[00m x ) < y )
numerics.cc:23:	TOSS(_lisp[01;31m-[00m>create<O_MathException>("longLongIntAdd>> LongLongInt is about to overflow"));
numerics.cc:31: * return [01;31m-[00m1.
numerics.cc:41:        TOSS(_lisp[01;31m-[00m>create<O_MathException>(ss.str() ));
numerics.cc:46:        return [01;31m-[00m1;
numerics.cc:82:/*! Convert a collection of positive mixed[01;31m-[00mbase digits to a LongLongInt index.
numerics.cc:83: * If the index can not be stored in a LongLongInt then return [01;31m-[00m1
numerics.cc:96:    digitIdx = digits.size()[01;31m-[00m1;
numerics.cc:97:    for ( bi=bases.rbegin(),di=digits.rbegin(); digitIdx>=0; bi++,di++,digitIdx[01;31m-[00m[01;31m-[00m )
numerics.cc:164:    if ( fabs(va[01;31m-[00mvb) < absEpsilon ) return true;
numerics.cc:166:	if ( fabs(va[01;31m-[00mvb) < vb*relEpsilon ) return true;
numerics.cc:168:	if ( fabs(va[01;31m-[00mvb) < va*relEpsilon ) return true;
objRef.cc:18:    this[01;31m-[00m>Base::initialize();
objRef.cc:19:    this[01;31m-[00m>_Selector = "";
objRef.cc:20:    this[01;31m-[00m>_Name = "";
objRef.cc:21:    this[01;31m-[00m>_SubRef = O_ObjRef::nil(this[01;31m-[00m>lisp());
objRef.cc:26:    node[01;31m-[00m>attribute("sel",this[01;31m-[00m>_Selector);
objRef.cc:27:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
objRef.cc:28:    node[01;31m-[00m>archiveObjectIfDefined("subRef",this[01;31m-[00m>_SubRef);
objRef.cc:32:{_F(this[01;31m-[00m>lisp());
objRef.cc:33:    RPObject obj = o[01;31m-[00m>oGetReference(this[01;31m-[00m>sharedThis<O_ObjRef>());
objRef.cc:34:    if ( this[01;31m-[00m>_SubRef[01;31m-[00m>notNil() )
objRef.cc:36:        obj = this[01;31m-[00m>_SubRef[01;31m-[00m>relativeTo(obj);
objRef.cc:46:    if ( this[01;31m-[00m>_Name != "" )
objRef.cc:48:        ss << this[01;31m-[00m>_Selector << "=" << this[01;31m-[00m>_Name;
objRef.cc:51:        ss << this[01;31m-[00m>_Selector;
objRef.cc:53:    if ( this[01;31m-[00m>_SubRef[01;31m-[00m>notNil() )
objRef.cc:55:	ss << "/" << this[01;31m-[00m>_SubRef[01;31m-[00m>asString();
objRef.cc:101:    ref[01;31m-[00m>setSelector(orSelector);
objRef.cc:102:    ref[01;31m-[00m>setName(orName);
objRef.cc:106:        ref[01;31m-[00m>setSubRef(subRef);
object.cc:26:This chapter describes the classes and methods available within Cando[01;31m-[00mScript.
object.cc:64:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Expected object(%s) of class(%s) to be subclass of class(%s)") % offendingObject[01;31m-[00m>__repr__() % lisp[01;31m-[00m>classNameFromClassId(foundTypeId) % lisp[01;31m-[00m>classNameFromClassId(expectedTypeId)));
object.cc:70:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(str));
object.cc:75:    TOSS(_lisp[01;31m-[00m>create<O_LispError>(fmt.str()));
object.cc:80:    bool ret = lisp[01;31m-[00m>debugLog().isOn(fileName);
object.cc:86:    return &(lisp[01;31m-[00m>debugLog());
object.cc:91:    RPMetaClass mc = lisp[01;31m-[00m>classFromClassId(classId);
object.cc:92:    RPArgumentHandler ah = mc[01;31m-[00m>__init__argumentHandler();
object.cc:93:    LOG(BF("Got argument handler for class(%s) ah[%s]") % mc[01;31m-[00m>instanceClassName() % ah[01;31m-[00m>asArgumentString() );
object.cc:97:    return ah[01;31m-[00m>createEnvironmentAndParseArgumentsIntoIt(args,environ);
object.cc:102:    return lisp[01;31m-[00m>_true();
object.cc:108:    return lisp[01;31m-[00m>_false();
object.cc:115:    return lisp[01;31m-[00m>CoreObjectClassesInitialized();
object.cc:120:    return lisp[01;31m-[00m>ObjectClassesInitialized();
object.cc:125:    return lisp[01;31m-[00m>NilsCreated();
object.cc:131:    return lisp[01;31m-[00m>numberOfClasses();
object.cc:139://    ASSERTP(lisp[01;31m-[00m>notNil(),"In lisp_exposeClass env can not be nil");
object.cc:143:	exposerObject[01;31m-[00m>_LispEnvironment = lisp;
object.cc:144:	exposerObject[01;31m-[00m>exposeCando();
object.cc:154:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("There was no call to class_ to expose the class(%s)") % className ));
object.cc:157:    if ( get_nextGlobalClassId() != lisp[01;31m-[00m>numberOfClasses() )
object.cc:159:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The class("+className+") was not exposed [01;31m-[00m check the exposer to make sure it calls class_<>"));
object.cc:167:    RPMetaClass mc = lisp[01;31m-[00m>classFromClassId(classId);
object.cc:168:    lisp[01;31m-[00m>addClassToEnvironment(packageName,name,mc);
object.cc:173:    RPMetaClass mc = lisp[01;31m-[00m>classFromClassId(classId);
object.cc:174:    mc[01;31m-[00m>__setArgumentHandlerString(argumentString);
object.cc:180:    lisp[01;31m-[00m>addClass(packageName,name,classId,baseClassId,cb);
object.cc:187:    lisp[01;31m-[00m>defineMethodWithNameAndClassId(name,classId,meth);
object.cc:191:    lisp[01;31m-[00m>throwIfObjectClassesNotInitialized();
object.cc:196:    return lisp[01;31m-[00m>classNameFromClassId(classId);
object.cc:201:    return lisp[01;31m-[00m>classFromClassId(classId);
object.cc:205:    RPSymbol sym = lisp[01;31m-[00m>intern(pkg,n);
object.cc:207:    lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(sym,i);
object.cc:212:    return lisp[01;31m-[00m>isClassName(n);
object.cc:217:    return lisp[01;31m-[00m>getClassIdForClassName(n);
object.cc:223:    RPMetaClass baseClass = lisp[01;31m-[00m>classFromClassId(baseClassId);
object.cc:224:    RPMetaClass testClass = lisp[01;31m-[00m>classFromClassId(classId);
object.cc:225:    return testClass[01;31m-[00m>isSubClassOf(baseClass);
object.cc:230:    RPSymbol sym = lisp[01;31m-[00m>intern(package,name);
object.cc:232:    lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>extendForm(sym,func);
object.cc:238:    return lisp[01;31m-[00m>internKeyword(name);
object.cc:243:    return s[01;31m-[00m>fullName();
object.cc:249:    lisp_LOG(lisp,BF("initialize_Object of class[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m\n%s") % mc[01;31m-[00m>dumpInfo() );
object.cc:250://    obj[01;31m-[00m>__setClass(mc);    // set in ctor
object.cc:251:    obj[01;31m-[00m>__setWeakThis(obj);
object.cc:252://    obj[01;31m-[00m>__resetInitializationOwner();
object.cc:258://    RPMetaClass mc = lisp[01;31m-[00m>classFromClassId(classId);
object.cc:259://    obj[01;31m-[00m>__setClass(mc);   // set in copy[01;31m-[00mctor
object.cc:260:    obj[01;31m-[00m>__setWeakThis(obj);
object.cc:261://    obj[01;31m-[00m>__resetInitializationOwner(); // Don't touch the InitializationOwner
object.cc:283:    this[01;31m-[00m>_ClassName = "[01;31m-[00mctor set to undef[01;31m-[00m";
object.cc:284:    this[01;31m-[00m>_ClassId = UndefinedUnsignedInt;
object.cc:285:    this[01;31m-[00m>_BaseClassId = UndefinedUnsignedInt;
object.cc:286:    this[01;31m-[00m>_Exposer = NULL;
object.cc:287:    this[01;31m-[00m>_ExposeCando = NULL;
object.cc:288:    this[01;31m-[00m>_ExposePython = NULL;
object.cc:289:    this[01;31m-[00m>_Exposed = false;
object.cc:299:    this[01;31m-[00m>_ClassName = ci._ClassName;
object.cc:300:    this[01;31m-[00m>_ClassId = ci._ClassId;
object.cc:301:    this[01;31m-[00m>_BaseClassId = ci._BaseClassId;
object.cc:302:    this[01;31m-[00m>_Exposer = ci._Exposer;
object.cc:303:    this[01;31m-[00m>_ExposeCando = ci._ExposeCando;
object.cc:304:    this[01;31m-[00m>_ExposePython = ci._ExposePython;
object.cc:305:    this[01;31m-[00m>_Exposed = ci._Exposed;
object.cc:311:    RPObject o = this[01;31m-[00m>_AllocatorCallback(lisp);
object.cc:312:    o[01;31m-[00m>initialize();
object.cc:321:    ss << "      _ClassName: " << this[01;31m-[00m>_ClassName << endl;
object.cc:322:    ss << "        _ClassId: " << this[01;31m-[00m>_ClassId << endl;
object.cc:323:    ss << "    _BaseClassId: " << this[01;31m-[00m>_BaseClassId;
object.cc:324:    if ( this[01;31m-[00m>_Exposer== NULL )
object.cc:337:    if ( this[01;31m-[00m>_Exposer != NULL )
object.cc:340:	this[01;31m-[00m>_Exposer[01;31m-[00m>_LispEnvironment = lisp;
object.cc:341:	this[01;31m-[00m>_Exposer[01;31m-[00m>exposeCando();
object.cc:344:	this[01;31m-[00m>_ExposeCando(lisp);
object.cc:351:    if ( this[01;31m-[00m>_Exposer != NULL ) return true;
object.cc:352:    if ( this[01;31m-[00m>_ExposeCando != NULL ) return true;
object.cc:359:    if ( this[01;31m-[00m>_ClassId != O_Object::static_classId() ) return true;
object.cc:365:    ClassInfo& baseInfo = (rootClassManager().get(this[01;31m-[00m>_BaseClassId));
object.cc:371:    return this[01;31m-[00m>_Exposed;
object.cc:376:    if ( this[01;31m-[00m>isExposed() ) return false;
object.cc:378:    if ( this[01;31m-[00m>canBeExposed() )
object.cc:383:	if ( this[01;31m-[00m>hasBaseClass() )
object.cc:385:	    int baseClassId = this[01;31m-[00m>_BaseClassId;
object.cc:390:	    ClassInfo& baseInfo = this[01;31m-[00m>baseClass();
object.cc:396:		ss << this[01;31m-[00m>className() << ") has an exposer";
object.cc:397:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str() ));
object.cc:406:	if ( !this[01;31m-[00m>isExposed() )
object.cc:408:	    LOG(BF("Exposing class: %s") % this[01;31m-[00m>_ClassName.c_str()  ); // vp0(("Exposing class: %s", this[01;31m-[00m>_ClassName.c_str() ));
object.cc:410:	    this[01;31m-[00m>_exposeYourselfToCando(lisp);
object.cc:413:    this[01;31m-[00m>_Exposed = exposedOne;
object.cc:428:    this[01;31m-[00m>_ClassIdsByName = man._ClassIdsByName;
object.cc:429:    this[01;31m-[00m>_ClassInfo = man._ClassInfo;
object.cc:440:    return this[01;31m-[00m>_ClassIdsByName.count(name)>0;
object.cc:445:    if ( !this[01;31m-[00m>recognizesClassName(name) )
object.cc:449:	this[01;31m-[00m>debugDump();
object.cc:451:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Class name("+name+") was not recognized"));
object.cc:453:    uint idx = this[01;31m-[00m>_ClassIdsByName[name];
object.cc:454:    return this[01;31m-[00m>get(idx);
object.cc:464:    return this[01;31m-[00m>_ClassInfo.size();
object.cc:473:    for ( uint i=0; i<this[01;31m-[00m>_ClassInfo.size(); i++ )
object.cc:475:	ClassInfo& cl = this[01;31m-[00m>_ClassInfo[i];
object.cc:476:	LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m index: %d") % (i ) ); // vp0(("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m index: %d", i ));
object.cc:484:    ASSERTP(this[01;31m-[00m>_ClassIdsByName.count(name) != 0,
object.cc:486:    return this[01;31m-[00m>_ClassIdsByName[name];
object.cc:491:    return (this[01;31m-[00m>_ClassIdsByName.count(cn) > 0);
object.cc:497:    if ( id >= this[01;31m-[00m>_ClassInfo.size() )
object.cc:499:        return "[01;31m-[00m[01;31m-[00mUNDEFINED CLASS[01;31m-[00m[01;31m-[00m";
object.cc:501:    return this[01;31m-[00m>_ClassInfo[id]._ClassName;
object.cc:508:    for ( vi=this[01;31m-[00m>begin(); vi!=this[01;31m-[00m>end(); vi++ ) {
object.cc:520:    return this[01;31m-[00m>_ClassInfo[childClassId]._BaseClassId;
object.cc:530:	cid = this[01;31m-[00m>baseClassId(cid);
object.cc:560:    this[01;31m-[00m>__setClass(mc);
object.cc:561:    this[01;31m-[00m>_WeakThis.reset();
object.cc:562:    this[01;31m-[00m>_InitializationOwner.reset();
object.cc:564:    this[01;31m-[00m>_TrackWhenDestructed = false;
object.cc:571:    this[01;31m-[00m>__setClassPointer(o._class().get());
object.cc:573:    this[01;31m-[00m>_TrackWhenDestructed = false;
object.cc:575:    this[01;31m-[00m>_InitializationOwner = o._InitializationOwner;
object.cc:591:	if ( this[01;31m-[00m>_TrackWhenDestructed )
object.cc:593:	    LOG(BF("A watched object is being destructed: %s") % this[01;31m-[00m>_TrackId.c_str()  ); // vp0(("A watched object is being destructed: %s",this[01;31m-[00m>_TrackId.c_str() ));
object.cc:602:    return this[01;31m-[00m>eqV(obj);
object.cc:606:{_F(this[01;31m-[00m>lisp());
object.cc:607:    bool b = this[01;31m-[00m>eqV(obj);
object.cc:608:    LOG(BF("Checking to see if this(%s) is equal to other(%s) result = %d") % this[01;31m-[00m>__repr__() % obj[01;31m-[00m>__repr__() % b );
object.cc:614:    return this[01;31m-[00m>equal(obj);
object.cc:620:    if ( this[01;31m-[00m>isNil() ) return false;
object.cc:621:    if ( this[01;31m-[00m>isAssignableTo<O_Bool>() )
object.cc:623:	return this[01;31m-[00m>as<O_Bool>()[01;31m-[00m>get();
object.cc:630:    if ( this[01;31m-[00m>isNil() ) return false;
object.cc:631:    return ( this == this[01;31m-[00m>lisp()[01;31m-[00m>_eof().get() );
object.cc:637:    if ( this[01;31m-[00m>eqV(mc) ) return true;
object.cc:638:    if (this[01;31m-[00m>isAssignableToByClassId(mc[01;31m-[00m>instanceClassId())) return true;
object.cc:644:    if ( this[01;31m-[00m>eq(obj) ) return true;
object.cc:645:    if ( this[01;31m-[00m>isOfClass<O_CandoClass>() && obj[01;31m-[00m>isOfClass<O_CandoClass>() )
object.cc:647:	return hier[01;31m-[00m>isADescendant(this[01;31m-[00m>sharedThis<O_Object>(),obj);
object.cc:649:    if ( this[01;31m-[00m>isAssignableToByClassId(obj[01;31m-[00m>static_classId()) ) return true;
object.cc:657:    return this[01;31m-[00m>_class()[01;31m-[00m>instanceClassName();
object.cc:663:    return this[01;31m-[00m>_class()[01;31m-[00m>getInstanceClassId();
object.cc:670:    HARD_ASSERT(this[01;31m-[00m>_Class!=NULL);
object.cc:671:    return this[01;31m-[00m>_Class[01;31m-[00m>lisp();
object.cc:676:    HARD_ASSERT(this[01;31m-[00m>_Class!=NULL);
object.cc:677:    return this[01;31m-[00m>_Class[01;31m-[00m>lisp();
object.cc:686:    return this[01;31m-[00m>_class()[01;31m-[00m>getInstanceBaseClass();
object.cc:694:    return this[01;31m-[00m>_class()[01;31m-[00m>getInstanceBaseClass();
object.cc:700:    this[01;31m-[00m>_InitializationOwner = obj;
object.cc:707:    this[01;31m-[00m>_InitializationOwner = obj;
object.cc:714:    return this[01;31m-[00m>lisp()[01;31m-[00m>getBuilderDatabase();
object.cc:721:    string s = this[01;31m-[00m>__str__();
object.cc:722:    _lisp[01;31m-[00m>print(BF("%s") % s.c_str() );
object.cc:728:    if ( this[01;31m-[00m>_InitializationOwner.use_count() == 0 ) 
object.cc:730:	return O_Object::nil(this[01;31m-[00m>lisp());
object.cc:733:        return this[01;31m-[00m>_InitializationOwner.lock();
object.cc:740:    return this[01;31m-[00m>owner();
object.cc:746:    if ( this[01;31m-[00m>isNil() && obj[01;31m-[00m>isNil() ) return true;
object.cc:752:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Only numbers respond to eqn"));
object.cc:758:    if ( this[01;31m-[00m>_class()[01;31m-[00m>isAssignableTo<O_ObjectClass>() )
object.cc:760:	LOG(BF("This object class(%s) is an ObjectClass") % this[01;31m-[00m>className() );
object.cc:761:	RPObjectClass oc = this[01;31m-[00m>_class()[01;31m-[00m>as<O_ObjectClass>();
object.cc:762:	RPArgumentHandler iah = oc[01;31m-[00m>__init__argumentHandler();
object.cc:764:	if ( iah[01;31m-[00m>notNil() )
object.cc:766:	    RPCons selfPrefixedArgs = O_Cons::create(this[01;31m-[00m>sharedThis<O_Object>(),args,lisp);
object.cc:767:	    this[01;31m-[00m>__init__(e,selfPrefixedArgs,environment,lisp);
object.cc:775:    RPKeyedArguments dict = args[01;31m-[00m>asKeyedArguments();
object.cc:776:    this[01;31m-[00m>oldLispInitialize(dict,lisp);
object.cc:782:{_F(this[01;31m-[00m>lisp());
object.cc:791:    return lisp[01;31m-[00m>onil();
object.cc:801:{_F(this[01;31m-[00m>lisp());
object.cc:803:    this[01;31m-[00m>_TrackWhenDestructed = true;
object.cc:804:    this[01;31m-[00m>_TrackId = msg;
object.cc:817:    this[01;31m-[00m>archiveBase(node);
object.cc:821:{_F(this[01;31m-[00m>lisp());
object.cc:835:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakThis);
object.cc:836:    if ( this[01;31m-[00m>isNil() )
object.cc:842:	ss<< me[01;31m-[00m>className() << "@" << std::hex << this << std::dec; 
object.cc:843:	ss<< " USE("<<this[01;31m-[00m>_WeakThis.use_count()<<")";
object.cc:844:	ss << this[01;31m-[00m>descriptionOfContents() << " ) ";
object.cc:852:    return this[01;31m-[00m>description();
object.cc:859:{_F(this[01;31m-[00m>lisp());
object.cc:861:    return this[01;31m-[00m>sharedThis<O_Object>();
object.cc:868:    RPObject o = this[01;31m-[00m>sharedThis<O_Object>();
object.cc:870:    while ( o[01;31m-[00m>notNil() )
object.cc:872:        if ( o[01;31m-[00m>classId() == classId ) return o;
object.cc:873:	o = o[01;31m-[00m>owner();
object.cc:876:    return O_Object::nil(this[01;31m-[00m>lisp());
object.cc:882:    RPObject o = this[01;31m-[00m>sharedThis<O_Object>();
object.cc:884:    while ( o[01;31m-[00m>notNil() )
object.cc:886:        if ( o[01;31m-[00m>isAssignableToByClassId(classId) ) return o;
object.cc:887:	o = o[01;31m-[00m>owner();
object.cc:890:    return O_Object::nil(this[01;31m-[00m>lisp());
object.cc:894:{_F(this[01;31m-[00m>lisp());
object.cc:896:    ar = RP_Create<O_XmlSaveArchive>(this[01;31m-[00m>lisp());
object.cc:897:    ar[01;31m-[00m>put("only",this[01;31m-[00m>_WeakThis.lock());
object.cc:898:    return ar[01;31m-[00m>asString();
object.cc:902:{_F(this[01;31m-[00m>lisp());
object.cc:904:    ar = RP_Create<O_XmlSaveArchive>(this[01;31m-[00m>lisp());
object.cc:905:    ar[01;31m-[00m>put("only",this[01;31m-[00m>_WeakThis.lock());
object.cc:906:    return ar[01;31m-[00m>asStringSubstituteRootNodeNameAndAttributes(nodeName,rawAttributes);
object.cc:912:    ASSERTP(this[01;31m-[00m>_Class!=NULL,"in _class _Class is NULL");
object.cc:913:    return this[01;31m-[00m>_Class[01;31m-[00m>sharedThis<O_MetaClass>();
object.cc:918:    ASSERTP(this[01;31m-[00m>_Class!=NULL,"An objects _Class was NULL!!!!");
object.cc:919:    return this[01;31m-[00m>_Class[01;31m-[00m>sharedThis<O_MetaClass>();
object.cc:928:    RPMetaClass ancestorClass = this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(ancestorClassId);
object.cc:929:    RPMetaClass myClass = this[01;31m-[00m>_class();
object.cc:931:    bool b = myClass[01;31m-[00m>isSubClassOf(ancestorClass);
object.cc:935:        LOG(BF("FAILED: instances of class(%s) are NOT assignable to variables of class(%s)")% myClass[01;31m-[00m>instanceClassName() % ancestorClass[01;31m-[00m>instanceClassName() );
object.cc:944:    return this[01;31m-[00m>isAssignableToByClassId(mc[01;31m-[00m>instanceClassId());
object.cc:952:    RPMetaClass myClass = this[01;31m-[00m>_class();
object.cc:959:{_F(this[01;31m-[00m>lisp());
object.cc:960:    RPMetaClass mc = this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassId(classId);
object.cc:961:    RPMetaClass myClass = this[01;31m-[00m>_class();
object.cc:963:    LOG(BF("Checking if this[01;31m-[00m>_class(%s) == other class(%s) [01;31m-[00m[01;31m-[00m> %d") % myClass[01;31m-[00m>instanceClassName() % mc[01;31m-[00m>instanceClassName() % sameClass );
object.cc:968:{_F(this[01;31m-[00m>lisp());
object.cc:970:    archive = O_XmlSaveArchive::create(this[01;31m-[00m>lisp());
object.cc:971:    archive[01;31m-[00m>put(uid,this[01;31m-[00m>sharedThis<O_Object>());
object.cc:972:    archive[01;31m-[00m>saveAs(fileName);
object.cc:978:    if ( this[01;31m-[00m>_Class == NULL )
object.cc:980:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("InvalidObject has NULL _Class pointer"));
object.cc:982:    if ( this[01;31m-[00m>_WeakThis.use_count() == 0 )
object.cc:984:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Invalid Object@%p has _WeakThis that is undefined")% this ) );
object.cc:986:    if ( this[01;31m-[00m>_WeakThis.lock().get() != this )
object.cc:988:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("InvalidObject WeakThis does not point to itself!"));
object.cc:998:{_F(this[01;31m-[00m>lisp());
object.cc:999:    return this[01;31m-[00m>rendered(O_KeyedArguments::nil(this[01;31m-[00m>lisp()));
object.cc:1004:{_F(this[01;31m-[00m>lisp());
object.cc:1005:     return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_OVector3>();
object.cc:1010:{_F(this[01;31m-[00m>lisp());
object.cc:1011:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("This class does not support slots"));
object.cc:1015:{_F(this[01;31m-[00m>lisp());
object.cc:1016:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("This class does not support slots"));
object.cc:1020:{_F(this[01;31m-[00m>lisp());
object.cc:1021:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("This class does not support slots"));
object.cc:1027:    ASSERTP(this[01;31m-[00m>_class()[01;31m-[00m>supportsSlots(), "This object does not support slots");
object.cc:1028:    for ( O_CandoClass::slotIterator si=candoClass[01;31m-[00m>begin(); si!=candoClass[01;31m-[00m>end(); si++ )
object.cc:1031:	this[01;31m-[00m>setSlot(slotSymbol,this[01;31m-[00m>lisp()[01;31m-[00m>onil());
object.cc:1037:{_F(this[01;31m-[00m>lisp());
object.cc:1038:    RPMetaClass mc = this[01;31m-[00m>_class();
object.cc:1039:    RPSymbol methodSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(methodName);
object.cc:1040:    LOG(BF("Invoking method(%s) on receiver with class(%s)") % methodSymbol[01;31m-[00m>__repr__() % args[01;31m-[00m>ocar()[01;31m-[00m>className() );
object.cc:1041:    RPObject result = eval::evaluateForm(methodSymbol,args,this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Environment>(),this[01;31m-[00m>lisp());
object.cc:1053:    archive[01;31m-[00m>parse(fileName);
object.cc:1054:    obj = archive[01;31m-[00m>get(uid);
object.cc:1066:    archive[01;31m-[00m>parse(fileName);
object.cc:1067:    objVec = archive[01;31m-[00m>getContents();
object.cc:1070:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Archive(_lisp,"+fileName+") must contain 1 and only 1 object"));
object.cc:1081:    		ci[01;31m-[00m>_ClassName.c_str(),
object.cc:1082:		ci[01;31m-[00m>_ClassId,
object.cc:1083:		ci[01;31m-[00m>_BaseClassId );
object.cc:1088:			mi[01;31m-[00m>first.c_str(), mi[01;31m-[00m>second );
object.cc:1091:    _lisp[01;31m-[00m>print(BF(" O_Atom className(%20s)  classId(%2d)") % O_Atom::static_className().c_str() % O_Atom::___classId );
object.cc:1093:    _lisp[01;31m-[00m>print(BF(" O_Matter className(%20s)  classId(%2d)" % O_Matter::static_className() % O_Matter::___classId );
object.cc:1103:    RPBool b = lisp[01;31m-[00m>create<O_Bool>(o[01;31m-[00m>ocar()[01;31m-[00m>isNil());
object.cc:1109:    RPBool b = lisp[01;31m-[00m>create<O_Bool>(o[01;31m-[00m>ocar()[01;31m-[00m>notNil());
object.cc:1119:    class_<O_Object>(this[01;31m-[00m>lisp())
object.cc:1172:    class_<O_ConditionBase>(lisp[01;31m-[00m>lisp())
object.cc:1180:    RPMetaClass mc = lisp[01;31m-[00m>classFromClassId(this[01;31m-[00m>virtual_classId());
object.cc:1181:    this[01;31m-[00m>__setClass(mc);
object.cc:1182:    LOG(BF("Creating a condition of class(%s)@%X") % mc[01;31m-[00m>instanceClassName() % this );
object.cc:1192:{_F(mc[01;31m-[00m>lisp());
object.cc:1203:    return "Condition<"+this[01;31m-[00m>className()+">";
object.cc:1209:    this[01;31m-[00m>_throwFileName = file;
object.cc:1210:    this[01;31m-[00m>_throwFunctionName = fn;
object.cc:1211:    this[01;31m-[00m>_throwLineNumber = lineNumber;
objectDictionary.cc:21:    RPCons entries = kargs[01;31m-[00m>getAndRemoveOrDefault("entries",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
objectDictionary.cc:23:    while ( cur[01;31m-[00m>notNil() )
objectDictionary.cc:25:	if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Cons>() )
objectDictionary.cc:27:	    RPCons entry = cur[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
objectDictionary.cc:28:	    if ( entry[01;31m-[00m>length()!= 2 )
objectDictionary.cc:30:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You must pass string/value pairs as entries for an ObjectDictionary [01;31m-[00m you passed: %s") % entry[01;31m-[00m>__repr__() ));
objectDictionary.cc:32:	    RPText key = entry[01;31m-[00m>ocar()[01;31m-[00m>as<O_Text>();
objectDictionary.cc:33:	    RPObject value = entry[01;31m-[00m>ocadr();
objectDictionary.cc:34:	    this[01;31m-[00m>set(key[01;31m-[00m>get(),value);
objectDictionary.cc:36:	cur = cur[01;31m-[00m>cdr();    
objectDictionary.cc:42:    LOG(BF("Create objectDictionary from: %s") % cons[01;31m-[00m>__repr__().c_str()  ); // vp0(("Create objectDictionary from: %s", cons[01;31m-[00m>__repr__().c_str() ));
objectDictionary.cc:45:    for ( cur=cons; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
objectDictionary.cc:47:	if ( cur[01;31m-[00m>ocar()[01;31m-[00m>isOfClass<O_KeyedObject>() )
objectDictionary.cc:49:	    RPKeyedObject ko = cur[01;31m-[00m>car<O_KeyedObject>();
objectDictionary.cc:50:	    dict[01;31m-[00m>set(ko[01;31m-[00m>getKeyName(),ko[01;31m-[00m>getValue());
objectDictionary.cc:53:    LOG(BF("Dictionary described:%s") % (dict[01;31m-[00m>__repr__().c_str() ) ); // vp0(("Dictionary described:%s", dict[01;31m-[00m>__repr__().c_str() ));
objectDictionary.cc:59:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:60:    LOG(BF("Creating an O_IterateObjectDictionary for %d entries") % this[01;31m-[00m>size()  ); // vp0(("Creating an O_IterateObjectDictionary for %d entries", this[01;31m-[00m>size() ));
objectDictionary.cc:61:    return O_IterateObjectDictionary::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>sharedThis<O_ObjectDictionary>());
objectDictionary.cc:68:    if ( this[01;31m-[00m>_Map.count(name) == 0 )
objectDictionary.cc:72:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
objectDictionary.cc:74:    return this[01;31m-[00m>_Map.get(name);
objectDictionary.cc:79:    if ( this[01;31m-[00m>_Map.count(name) == 0 ) 
objectDictionary.cc:83:    return this[01;31m-[00m>get(name);
objectDictionary.cc:91:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ )
objectDictionary.cc:93:	ss << "Entry{ " << vi[01;31m-[00m>first << ": ";
objectDictionary.cc:94:	ss << vi[01;31m-[00m>second[01;31m-[00m>className();
objectDictionary.cc:95:	if ( vi[01;31m-[00m>second[01;31m-[00m>isAssignableTo<O_Value>() )
objectDictionary.cc:97:	    ss <<":" <<vi[01;31m-[00m>second[01;31m-[00m>__repr__();
objectDictionary.cc:109:    if ( this[01;31m-[00m>_Map.count(name) == 0 )
objectDictionary.cc:113:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
objectDictionary.cc:115:    obj = this[01;31m-[00m>_Map.get(name);
objectDictionary.cc:116:    this[01;31m-[00m>_Map.remove(name);
objectDictionary.cc:123:    if ( this[01;31m-[00m>_Map.count(name) == 0 ) {
objectDictionary.cc:126:    obj = this[01;31m-[00m>_Map.get(name);
objectDictionary.cc:127:    this[01;31m-[00m>_Map.remove(name);
objectDictionary.cc:132:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:134:    sv = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(val);
objectDictionary.cc:135:    this[01;31m-[00m>set(key,sv);
objectDictionary.cc:139:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:141:    ASSERT(this[01;31m-[00m>contains(key));
objectDictionary.cc:142:    sv = downcast<O_String>(this[01;31m-[00m>get(key));
objectDictionary.cc:143:    return sv[01;31m-[00m>get();
objectDictionary.cc:147:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:149:    sv = this[01;31m-[00m>get(key)[01;31m-[00m>as<O_Text>();
objectDictionary.cc:150:    this[01;31m-[00m>_Map.remove(key);
objectDictionary.cc:151:    return sv[01;31m-[00m>get();
objectDictionary.cc:155:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:157:    if ( !this[01;31m-[00m>contains(key) ) return d;
objectDictionary.cc:158:    sv = this[01;31m-[00m>get(key)[01;31m-[00m>as<O_Text>();
objectDictionary.cc:159:    this[01;31m-[00m>_Map.remove(key);
objectDictionary.cc:160:    return sv[01;31m-[00m>get();
objectDictionary.cc:165:   if ( !this[01;31m-[00m>contains(key) ) return defVal;
objectDictionary.cc:166:   return this[01;31m-[00m>getString(key);
objectDictionary.cc:174:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:176:    sv = O_TextBlock::create(val,this[01;31m-[00m>lisp());
objectDictionary.cc:177:    this[01;31m-[00m>set(key,sv);
objectDictionary.cc:181:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:183:    ASSERT(this[01;31m-[00m>contains(key));
objectDictionary.cc:184:    sv = downcast<O_TextBlock>(this[01;31m-[00m>get(key));
objectDictionary.cc:185:    return sv[01;31m-[00m>get();
objectDictionary.cc:190:   if ( !this[01;31m-[00m>contains(key) ) return defVal;
objectDictionary.cc:191:   return this[01;31m-[00m>getTextBlock(key);
objectDictionary.cc:198:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:200:    sv = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Real>(val);
objectDictionary.cc:201:    this[01;31m-[00m>set(key,sv);
objectDictionary.cc:205:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:207:    ASSERT(this[01;31m-[00m>contains(key));
objectDictionary.cc:208:    sv = downcast<O_Real>(this[01;31m-[00m>get(key));
objectDictionary.cc:209:    return sv[01;31m-[00m>get();
objectDictionary.cc:214:   if ( !this[01;31m-[00m>contains(key) ) return defVal;
objectDictionary.cc:215:   return this[01;31m-[00m>getDouble(key);
objectDictionary.cc:221:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:223:    sv = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Int>(val);
objectDictionary.cc:224:    this[01;31m-[00m>set(key,sv);
objectDictionary.cc:228:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:230:    ASSERT(this[01;31m-[00m>contains(key));
objectDictionary.cc:231:    sv = downcast<O_Int>(this[01;31m-[00m>get(key));
objectDictionary.cc:232:    return sv[01;31m-[00m>get();
objectDictionary.cc:237:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:238:    if ( !this[01;31m-[00m>contains(key) ) return defVal;
objectDictionary.cc:239:    return this[01;31m-[00m>getInt(key);
objectDictionary.cc:244:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:248:    dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
objectDictionary.cc:249:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ )
objectDictionary.cc:251:	LOG(BF("Looking to render %s") % vi[01;31m-[00m>second[01;31m-[00m>description().c_str()  ); // vp0(("Looking to render %s",vi[01;31m-[00m>second[01;31m-[00m>description().c_str() ));
objectDictionary.cc:252:	if ( vi[01;31m-[00m>second[01;31m-[00m>canRender() )
objectDictionary.cc:255:	    dlOne = vi[01;31m-[00m>second[01;31m-[00m>rendered(opts);
objectDictionary.cc:256:	    dlOne[01;31m-[00m>setName(vi[01;31m-[00m>first);
objectDictionary.cc:257:	    dl[01;31m-[00m>append(dlOne);
objectDictionary.cc:267:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:271:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
objectDictionary.cc:272:        ss << vi[01;31m-[00m>first << " ";
objectDictionary.cc:278:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:281:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
objectDictionary.cc:283:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) 
objectDictionary.cc:285:	RPCons one = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(vi[01;31m-[00m>first),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
objectDictionary.cc:286:	cur[01;31m-[00m>setCdr(one);
objectDictionary.cc:289:    return first[01;31m-[00m>cdr();
objectDictionary.cc:294:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:297:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
objectDictionary.cc:299:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) 
objectDictionary.cc:301:	RPKeyedObject kobj = O_KeyedObject::create(this[01;31m-[00m>lisp(),vi[01;31m-[00m>first,vi[01;31m-[00m>second);
objectDictionary.cc:302:	RPCons one = O_Cons::create(kobj,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
objectDictionary.cc:303:	cur[01;31m-[00m>setCdr(one);
objectDictionary.cc:306:    return first[01;31m-[00m>cdr();
objectDictionary.cc:310:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:314:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
objectDictionary.cc:315:        ss << vi[01;31m-[00m>first << ":";
objectDictionary.cc:316:	ss << vi[01;31m-[00m>second[01;31m-[00m>description() << endl;
objectDictionary.cc:326:{_F(this[01;31m-[00m>lisp());
objectDictionary.cc:327:    if ( node[01;31m-[00m>saving() )
objectDictionary.cc:328:    { _BLOCK_TRACEF(BF("Saving ObjectDictionary [01;31m-[00m it contains %d objects") % this[01;31m-[00m>_Map.size() );
objectDictionary.cc:329:	if ( this[01;31m-[00m>_Map.size() != 0 )
objectDictionary.cc:334:	    for ( oi=this[01;31m-[00m>_Map.begin(); oi!=this[01;31m-[00m>_Map.end(); i++,oi++ )
objectDictionary.cc:336:	    	LOG(BF( "Archiving entry key(%s)")% oi[01;31m-[00m>first );
objectDictionary.cc:339:		node[01;31m-[00m>archiveObject(oi[01;31m-[00m>first,oi[01;31m-[00m>second);
objectDictionary.cc:343:    { _BLOCK_TRACEF(BF("Loading ObjectDictionary with uid(%s)") % node[01;31m-[00m>getUniqueIdCharacters().c_str() );
objectDictionary.cc:346:	this[01;31m-[00m>_Map.clear();
objectDictionary.cc:347:	for ( ci=node[01;31m-[00m>begin_Children(); ci!=node[01;31m-[00m>end_Children(); ci++ )
objectDictionary.cc:349:	    (*ci)[01;31m-[00m>setRecognized(true);
objectDictionary.cc:350:	    object = node[01;31m-[00m>getArchive()[01;31m-[00m>loadObjectDirectly((*ci));
objectDictionary.cc:352:	    LOG(BF( "Adding to the ObjectDictionary key(%s)")% (*ci)[01;31m-[00m>getUniqueIdCharacters() );
objectDictionary.cc:353:	    this[01;31m-[00m>_Map.set((*ci)[01;31m-[00m>getUniqueIdCharacters(),object);
objectDictionary.cc:363:RPCons	list = O_Cons::nil(this[01;31m-[00m>lisp());
objectDictionary.cc:365:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
objectDictionary.cc:366:        list = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(vi[01;31m-[00m>first),list,this[01;31m-[00m>lisp());
objectDictionary.cc:373:RPStringSet list = O_StringSet::create(this[01;31m-[00m>lisp());
objectDictionary.cc:375:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
objectDictionary.cc:376:	list[01;31m-[00m>insert(vi[01;31m-[00m>first);
objectDictionary.cc:387:    for ( vi=this[01;31m-[00m>_Map.begin(); vi!=this[01;31m-[00m>_Map.end(); vi++ ) {
objectDictionary.cc:388:	res.append(boost::python::str(vi[01;31m-[00m>first));
objectDictionary.cc:400:    class_<O_ObjectDictionary>(this[01;31m-[00m>lisp())
objectList.cc:19:    this[01;31m-[00m>Base::oldLispInitialize(keyed,env);
objectList.cc:20:    RPCons cons = keyed[01;31m-[00m>getAndRemoveOrDefault("fromCons",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
objectList.cc:21:    for ( ; cons[01;31m-[00m>notNil(); cons=cons[01;31m-[00m>cdr() )
objectList.cc:23:	this[01;31m-[00m>push_back(cons[01;31m-[00m>ocar());
objectList.cc:31:    ASSERT_lessThan(idx,this[01;31m-[00m>_List.size() );
objectList.cc:32:    return this[01;31m-[00m>_List[idx];
objectList.cc:36:{_F(this[01;31m-[00m>lisp());
objectList.cc:37:    LOG(BF("Creating an O_IterateObjectList for %d entries") % this[01;31m-[00m>size()  ); // vp0(("Creating an O_IterateObjectList for %d entries", this[01;31m-[00m>size() ));
objectList.cc:38:    return O_IterateObjectList::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>sharedThis<O_ObjectList>());
objectList.cc:43:{_F(this[01;31m-[00m>lisp());
objectList.cc:45:    for ( it=ll[01;31m-[00m>begin(); it!=ll[01;31m-[00m>end(); it++ )
objectList.cc:47:        this[01;31m-[00m>append(*it);
objectList.cc:54:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
objectList.cc:57:    for ( it=this[01;31m-[00m>begin(); it!=this[01;31m-[00m>end(); it++ )
objectList.cc:59:	RPCons one = O_Cons::create(*it,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
objectList.cc:60:	cur[01;31m-[00m>setCdr(one);
objectList.cc:63:    return first[01;31m-[00m>cdr();
objectList.cc:72:    for ( oi=this[01;31m-[00m>const_begin(); oi!=this[01;31m-[00m>const_end(); oi++ )
objectList.cc:74:	ss << (*oi)[01;31m-[00m>__repr__() << " ";
objectList.cc:82:    if ( node[01;31m-[00m>saving() )
objectList.cc:84:	if ( this[01;31m-[00m>_List.size() != 0 )
objectList.cc:89:	    for ( oi=this[01;31m-[00m>_List.begin(); oi!=this[01;31m-[00m>_List.end(); i++,oi++ )
objectList.cc:92:		suid << (oi[01;31m-[00mthis[01;31m-[00m>_List.begin());
objectList.cc:93:		node[01;31m-[00m>archiveObject(suid.str(),(*oi));
objectList.cc:100:	this[01;31m-[00m>_List.clear();
objectList.cc:101:	this[01;31m-[00m>_List.resize(node[01;31m-[00m>end_Children()[01;31m-[00mnode[01;31m-[00m>begin_Children());
objectList.cc:102:	for ( ci=node[01;31m-[00m>begin_Children(); ci!=node[01;31m-[00m>end_Children(); ci++ )
objectList.cc:104:	    object = node[01;31m-[00m>getArchive()[01;31m-[00m>loadObjectDirectly((*ci));
objectList.cc:106:	    this[01;31m-[00m>_List[(*ci)[01;31m-[00m>getUniqueIdNumeric()] = object;
objectList.cc:114:{_F(this[01;31m-[00m>lisp());
objectList.cc:116:    frames = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderFrameList>();
objectList.cc:118:    for ( si=this[01;31m-[00m>begin(); si!=this[01;31m-[00m>end(); si++ )
objectList.cc:120:	if ( (*si)[01;31m-[00m>canRender() )
objectList.cc:122:	    RPRender rend = (*si)[01;31m-[00m>rendered(opts);
objectList.cc:123:	    frames[01;31m-[00m>add(rend);
objectList.cc:132:    virtual bool operator() (RPObject x, RPObject y) {return x[01;31m-[00m>le(y);};
objectList.cc:139:    sort::quickSort(this[01;31m-[00m>_List.begin(),this[01;31m-[00m>_List.end(),oo,this[01;31m-[00m>lisp());
objectList.cc:148:    class_<O_ObjectList>(this[01;31m-[00m>lisp())
objectPair.cc:19:	class_<O_ObjectPair>(lisp[01;31m-[00m>lisp())
objectPair.cc:25:    this[01;31m-[00m>_First = this[01;31m-[00m>lisp()[01;31m-[00m>onil();
objectPair.cc:26:    this[01;31m-[00m>_Second = this[01;31m-[00m>lisp()[01;31m-[00m>onil();
objectPair.cc:33:    node[01;31m-[00m>archiveObject("first",this[01;31m-[00m>_First);
objectPair.cc:34:    node[01;31m-[00m>archiveObject("second",this[01;31m-[00m>_Second);
objectPair.cc:39:    if ( obj[01;31m-[00m>isAssignableTo<O_ObjectPair>() )
objectPair.cc:41:	RPObjectPair other = obj[01;31m-[00m>as<O_ObjectPair>();
objectPair.cc:42:	if ( !this[01;31m-[00m>_First[01;31m-[00m>equal(other[01;31m-[00m>first()) ) return false;
objectPair.cc:43:	if ( this[01;31m-[00m>_Second[01;31m-[00m>equal(other[01;31m-[00m>second() ) ) return true;
objectSet.cc:19:{_F(this[01;31m-[00m>lisp());
objectSet.cc:21:    for ( oi=other[01;31m-[00m>_Set.begin(); oi!=other[01;31m-[00m>_Set.end(); oi++ )
objectSet.cc:23:        this[01;31m-[00m>insert((*oi)[01;31m-[00m>sharedThis<O_Object>());
objectSet.cc:31:	RPCons res = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Cons>();
objectSet.cc:32:	for ( iterator it=this[01;31m-[00m>begin(); it!=this[01;31m-[00m>end(); it++ )
objectSet.cc:34:	    res = O_Cons::create(*it,res,this[01;31m-[00m>lisp());
objectSet.cc:42:	RPObjectSet os = O_ObjectSet::create(this[01;31m-[00m>lisp());
objectSet.cc:43:	os[01;31m-[00m>addObjects(this[01;31m-[00m>sharedThis<O_ObjectSet>());
objectSet.cc:44:	os[01;31m-[00m>addObjects(other);
objectSet.cc:50:{_F(this[01;31m-[00m>lisp());
objectSet.cc:53:    nset = O_ObjectSet::create(this[01;31m-[00m>lisp());
objectSet.cc:54:    for (si=this[01;31m-[00m>_Set.begin();si!=this[01;31m-[00m>_Set.end();si++)
objectSet.cc:56:	if ( b[01;31m-[00m>contains(*si) ) {
objectSet.cc:58:	    nset[01;31m-[00m>insert(*si);
objectSet.cc:71:    nset = O_ObjectSet::create(this[01;31m-[00m>lisp());
objectSet.cc:72:    for (si=this[01;31m-[00m>_Set.begin();si!=this[01;31m-[00m>_Set.end();si++)
objectSet.cc:74:	if ( !b[01;31m-[00m>contains(*si) ) 
objectSet.cc:76:	    nset[01;31m-[00m>insert(*si);
objectSet.cc:87:{_F(this[01;31m-[00m>lisp());
objectSet.cc:91:    nset = O_ObjectSet::create(this[01;31m-[00m>lisp());
objectSet.cc:92:    for (si=this[01;31m-[00m>_Set.begin();si!=this[01;31m-[00m>_Set.end();si++)
objectSet.cc:94:        for (bi=b[01;31m-[00m>_Set.begin();bi!=b[01;31m-[00m>_Set.end();bi++)
objectSet.cc:96:	    RPObjectPair op = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectPair>(*si,*bi);
objectSet.cc:97:	    nset[01;31m-[00m>insert(op);
objectSet.cc:107:    while ( c[01;31m-[00m>notNil() )
objectSet.cc:109:	this[01;31m-[00m>insert(c[01;31m-[00m>ocar());
objectSet.cc:110:	c = c[01;31m-[00m>cdr();
objectSet.cc:117:    if ( node[01;31m-[00m>saving() )
objectSet.cc:119:	if ( this[01;31m-[00m>_Set.size() != 0 )
objectSet.cc:125:	    for ( oi=this[01;31m-[00m>_Set.begin(); oi!=this[01;31m-[00m>_Set.end(); i++,oi++ )
objectSet.cc:130:		node[01;31m-[00m>archiveObject(suid.str(),obj);
objectSet.cc:137:	this[01;31m-[00m>_Set.clear();
objectSet.cc:138:	for ( ci=node[01;31m-[00m>begin_Children(); ci!=node[01;31m-[00m>end_Children(); ci++ )
objectSet.cc:140:	    object = node[01;31m-[00m>getArchive()[01;31m-[00m>loadObjectDirectly((*ci));
objectSet.cc:142:	    this[01;31m-[00m>_Set.insert(object);
objectSet.cc:153:    class_<O_ObjectSet>(this[01;31m-[00m>lisp())
oclass.cc:17:In Cando[01;31m-[00mScript class names like ``Hit'' or ``Real'' return objects that are of the class ``Class''.  These objects respond to the following methods.
oclass.cc:25:    oclass[01;31m-[00m>_Name = name;
oclass.cc:26:    oclass[01;31m-[00m>_InstanceClassId = instanceClassId;
oclass.cc:27:    oclass[01;31m-[00m>_InstanceBaseClass = O_MetaClass::nil(lisp);
oclass.cc:46:    this[01;31m-[00m>Base::initialize();
oclass.cc:47:    this[01;31m-[00m>_InitializationArguments = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_ArgumentHandler>();
oclass.cc:48://    LOG(BF("For class(%s)@%p handler@%p") % this[01;31m-[00m>static_className() % ((void*)(this)) % this[01;31m-[00m>_InitializationArguments.get() );
oclass.cc:53:{_F(this[01;31m-[00m>lisp());
oclass.cc:54:    ASSERT_NOT_NULL(this[01;31m-[00m>_InstanceNil);
oclass.cc:55:    this[01;31m-[00m>_InitializationArguments = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_ArgumentHandler>();
oclass.cc:56:    string args = this[01;31m-[00m>__getArgumentHandlerString();
oclass.cc:61:	RPArgumentHandler ah = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ArgumentHandler>(sargs.str());
oclass.cc:62:	this[01;31m-[00m>_InitializationArguments = ah;
oclass.cc:63:	LOG(BF("For class(%s)@%p setting up arguments(%s) handler@%p") % this[01;31m-[00m>className() % ((void*)(this))% args % ((void*)(ah.get())));
oclass.cc:72:    if ( this[01;31m-[00m>_InitializationArguments.use_count() == 0 ) return false;
oclass.cc:73:    if ( this[01;31m-[00m>_InitializationArguments[01;31m-[00m>isNil() ) return false;
oclass.cc:78:{_F(this[01;31m-[00m>lisp());
oclass.cc:79:    return this[01;31m-[00m>_InitializationArguments;
oclass.cc:85:{_F(this[01;31m-[00m>lisp());
oclass.cc:86:    RPMetaClass mc = lisp[01;31m-[00m>classFromClassId(this[01;31m-[00m>_InstanceClassId);
oclass.cc:87:    RPObject obj = mc[01;31m-[00m>allocateObject();
oclass.cc:88:    obj[01;31m-[00m>initialize();
oclass.cc:89:    LOG(BF( "Created a new instance of class(%s)")% mc[01;31m-[00m>className() );  
oclass.cc:90:    RPKeyedArguments emptyKeyed = O_KeyedArguments::nil(this[01;31m-[00m>lisp());
oclass.cc:91:    obj[01;31m-[00m>oldLispInitialize(emptyKeyed,lisp);
oclass.cc:100:{_F(this[01;31m-[00m>lisp());
oclass.cc:101:    printf("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m  Class name: %s    instanceClassId: %d\n", this[01;31m-[00m>_Name.c_str(), this[01;31m-[00m>_InstanceClassId );
oclass.cc:102:    if ( this[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>notNil() )
oclass.cc:104:        printf("Base class: %s\n", this[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>name().c_str());
oclass.cc:106:    printf("%s\n", this[01;31m-[00m>dumpInfo().c_str() );
oclass.cc:116:{_F(this[01;31m-[00m>lisp());
oclass.cc:118:    this[01;31m-[00m>_SlotNames.clear();
oclass.cc:120:    for ( ci=node[01;31m-[00m>begin_Children(); ci!=node[01;31m-[00m>end_Children(); ci++ )
oclass.cc:122:	RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern((*ci)[01;31m-[00m>getUniqueIdCharacters());
oclass.cc:123:	LOG(BF("Adding slot(%s)") % sym[01;31m-[00m>fullName() );
oclass.cc:124:	this[01;31m-[00m>_SlotNames.insert(sym);
oclass.cc:132:    this[01;31m-[00m>Base::initialize();
oclass.cc:133://    this[01;31m-[00m>_InstanceVariableNames = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Cons>();
oclass.cc:134:    this[01;31m-[00m>_SlotNames.clear();
oclass.cc:135:    this[01;31m-[00m>_CoreObjectClass = O_MetaClass::nil(this[01;31m-[00m>lisp());
oclass.cc:142:    oclass[01;31m-[00m>_Name = name[01;31m-[00m>currentName();
oclass.cc:143:    oclass[01;31m-[00m>setPackageName(name[01;31m-[00m>getPackage()[01;31m-[00m>getName());
oclass.cc:144:    oclass[01;31m-[00m>_InstanceClassId = instanceClassId;
oclass.cc:145:    oclass[01;31m-[00m>_InstanceBaseClass = e[01;31m-[00m>classObject<O_Object>();
oclass.cc:146://    oclass[01;31m-[00m>_InstanceVariableNames = O_Cons::nil(e);
oclass.cc:154:    for ( O_CandoClass::slotIterator si=this[01;31m-[00m>_SlotNames.begin(); si!=this[01;31m-[00m>_SlotNames.end(); si++ )
oclass.cc:156:	ss << (*si)[01;31m-[00m>fullName() << " ";
oclass.cc:165:{_F(this[01;31m-[00m>lisp());
oclass.cc:166:    return this[01;31m-[00m>_CoreObjectClass;
oclass.cc:170:{_F(this[01;31m-[00m>lisp());
oclass.cc:171:    this[01;31m-[00m>_CoreObjectClass = mc;
oclass.cc:175:{_F(this[01;31m-[00m>lisp());
oclass.cc:176:    _lisp[01;31m-[00m>print(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m  CandoClass name: %s    instanceClassId: %d") % this[01;31m-[00m>_Name.c_str()% this[01;31m-[00m>_InstanceClassId );
oclass.cc:177://    _lisp[01;31m-[00m>print(BF("Instance variables: %s") % this[01;31m-[00m>_InstanceVariableNames[01;31m-[00m>__repr__().c_str() );
oclass.cc:178:    if ( this[01;31m-[00m>supportsSlots() )
oclass.cc:180:	_lisp[01;31m-[00m>print(BF("Slot names: %s") % this[01;31m-[00m>slotNamesAsString());
oclass.cc:182:    _lisp[01;31m-[00m>print(BF("%s") % this[01;31m-[00m>dumpInfo() );
oclass.cc:183:    if ( this[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>notNil() )
oclass.cc:185:	this[01;31m-[00m>getInstanceBaseClass()[01;31m-[00m>describe();
oclass.cc:188:	_lisp[01;31m-[00m>print(BF("getInstanceBaseClass is nil"));
oclass.cc:193:{_F(this[01;31m-[00m>lisp());
oclass.cc:195:    ss << this[01;31m-[00m>Base::dumpInfo();
oclass.cc:196:    ss << "CoreObjectClass: " << this[01;31m-[00m>_CoreObjectClass[01;31m-[00m>getPackagedName() << endl;
oclass.cc:203:    return this[01;31m-[00m>_SlotNames.size();
oclass.cc:208:{_F(this[01;31m-[00m>lisp());
oclass.cc:210:    LOG(BF("Looking in CandoClass for slot for symbol: %s") % sym[01;31m-[00m>fullName() );
oclass.cc:211:    O_CandoClass::slotIterator fnd = this[01;31m-[00m>_SlotNames.find(sym);
oclass.cc:213:    if ( fnd==this[01;31m-[00m>_SlotNames.end() )
oclass.cc:222:    return this[01;31m-[00m>_SlotNames.find(sym);
oclass.cc:230:{_F(this[01;31m-[00m>lisp());
oclass.cc:232:    if ( args[01;31m-[00m>length()>1 )
oclass.cc:234:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Too many arguments, expecting only class" ));
oclass.cc:237:    RPObject obj = this[01;31m-[00m>_CoreObjectClass[01;31m-[00m>new_instance(e,args,environ,lisp);
oclass.cc:238:    RPCandoClass thisClass = this[01;31m-[00m>sharedThis<O_CandoClass>();
oclass.cc:239:    obj[01;31m-[00m>__setClass(thisClass);
oclass.cc:240:    if ( this[01;31m-[00m>supportsSlots() )
oclass.cc:242:	LOG(BF("This class supports slots [01;31m-[00m initializing them"));
oclass.cc:243:        obj[01;31m-[00m>initializeSlots(thisClass);
oclass.cc:246:	LOG(BF("This class does not support slots [01;31m-[00m not initializing anything"));
oclass.cc:249:    obj[01;31m-[00m>InvokeMethod("__init__",selfArgs);
oclass.cc:256:{_F(this[01;31m-[00m>lisp());
oclass.cc:257:    RPObject obj = this[01;31m-[00m>_CoreObjectClass[01;31m-[00m>new_instance(this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Executable>(), 
oclass.cc:258:    						this[01;31m-[00m>lisp()[01;31m-[00m>cnil(), this[01;31m-[00m>lisp()[01;31m-[00m>globalEnvironment(), this[01;31m-[00m>lisp() );
oclass.cc:259:    RPCandoClass thisClass = this[01;31m-[00m>sharedThis<O_CandoClass>();
oclass.cc:260:    obj[01;31m-[00m>__setClass(thisClass);
oclass.cc:268:{_F(this[01;31m-[00m>lisp());
oclass.cc:270:    for (RPCons ci = instanceVariableNames; ci[01;31m-[00m>notNil(); ci=ci[01;31m-[00m>cdr() )
oclass.cc:272:	RPSymbol sym = ci[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
oclass.cc:273:	if ( this[01;31m-[00m>_SlotNames.count(sym) )
oclass.cc:275:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("There is already a slot with name(%s)")%sym[01;31m-[00m>currentName()));
oclass.cc:277:	LOG(BF("Appending symbol(%s) as a slot")% sym[01;31m-[00m>currentName() );
oclass.cc:278:	this[01;31m-[00m>_SlotNames.insert(sym);
oclass.cc:283:{_F(this[01;31m-[00m>lisp());
oclass.cc:285:    for (si = cc[01;31m-[00m>begin(); si!=cc[01;31m-[00m>end(); si++ )
oclass.cc:287:	if ( this[01;31m-[00m>_SlotNames.count(*si)>0 )
oclass.cc:289:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("There is already a slot with name(%s)")%(*si)[01;31m-[00m>currentName()));
oclass.cc:291:	this[01;31m-[00m>_SlotNames.insert(*si);
oclass.cc:298:{_F(this[01;31m-[00m>lisp());
oclass.cc:299:    this[01;31m-[00m>_SlotNames.clear();
oclass.cc:305:{_F(this[01;31m-[00m>lisp());
oclass.cc:308:    this[01;31m-[00m>_InstanceVariableNames = slotNames;
oclass.cc:309:    while ( slotNames[01;31m-[00m>notNil() )
oclass.cc:311:	RPSymbol slotName = slotNames[01;31m-[00m>car<O_Symbol>();
oclass.cc:312:	string setterName = "set_"+slotName[01;31m-[00m>identifierName();
oclass.cc:313:	RPSymbol setterSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(setterName);
oclass.cc:314:	RPSlotSetter setterForm = O_SlotSetter::create(setterSymbol,this[01;31m-[00m>lisp());
oclass.cc:315:	this[01;31m-[00m>addMethod(setterSymbol,setterForm);
oclass.cc:316:	string getterName = "get_"+slotName[01;31m-[00m>identifierName();
oclass.cc:317:	RPSymbol getterSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(getterName);
oclass.cc:318:	RPSlotGetter getterForm = O_SlotGetter::create(getterSymbol,this[01;31m-[00m>lisp());
oclass.cc:319:	this[01;31m-[00m>addMethod(getterSymbol,getterForm);
oclass.cc:320:	slotNames = slotNames[01;31m-[00m>cdr();
oclass.cc:329:    class_<O_ObjectClass>(this[01;31m-[00m>lisp())
oclass.cc:342:    class_<O_CandoClass>(this[01;31m-[00m>lisp())
oligomer.cc:26: * 	[01;31m-[00m# Define the oligomer
oligomer.cc:27: * 		[01;31m-[00m Create the _Monomers, add them to the oligomer and couple them together.
oligomer.cc:28: * 	[01;31m-[00m# Construct the builders O_Oligomer::createBuilders (you may need to dismissBuilders first)
oligomer.cc:29: * 	[01;31m-[00m# Either accept the default build plan or construct one
oligomer.cc:30: *	 	[01;31m-[00m# For each monomer define the domainId using setDomainId
oligomer.cc:31: * 		[01;31m-[00m# (optional) Fix the coordinates of the fragmentBuilders that have defined coordinates
oligomer.cc:32: * 			[01;31m-[00m# Clear all Fixed builders using O_Oligomer::clearAllFragmentBuildersCoordinatesAreFixed
oligomer.cc:33: * 			[01;31m-[00m# Use setAllFragemntBuildersCoordinatesAreFixed(True)
oligomer.cc:34: * 			[01;31m-[00m# Define the coordinates for the residue of the monomer using applyCoordinatesFromResidue(res)
oligomer.cc:35: * 			[01;31m-[00m# Create a BuildPlan Dumb_BuildPlan::Dumb_BuildPlan(_oligomerBuilder_)
oligomer.cc:36: * 			[01;31m-[00m# Define a BuildPlan using Dumb_BuildPlan::recordPlan()
oligomer.cc:37: * 			[01;31m-[00m# Tell the OligomerBuilder that you want to use that plan using O_OligomerBuilder::applyBuildPlan
oligomer.cc:38: * 	[01;31m-[00m# Build the coordinates by calling:
oligomer.cc:39: * 		[01;31m-[00m O_OligomerBuilder::build
oligomer.cc:40: * 		[01;31m-[00m or O_OligomerBuilder::buildCore followed by O_OligomerBuilder::buildFinish
oligomer.cc:41: * 		[01;31m-[00m or O_Oligomer::buildCoordinates()
oligomer.cc:55:    this[01;31m-[00m>Base::initialize();
oligomer.cc:56:    this[01;31m-[00m>empty();
oligomer.cc:57:    this[01;31m-[00m>_Verbose = false;
oligomer.cc:58:    this[01;31m-[00m>_HasError = false;
oligomer.cc:59:    this[01;31m-[00m>_Name = "undefined";
oligomer.cc:64:{_F(this[01;31m-[00m>lisp());
oligomer.cc:65:    this[01;31m-[00m>signal(Oligomer_monomerContentsChanged);
oligomer.cc:70:{_F(this[01;31m-[00m>lisp());
oligomer.cc:71://    this[01;31m-[00m>signal(Oligomer_connectivityChanged);
oligomer.cc:75:{_F(this[01;31m-[00m>lisp());
oligomer.cc:77:    this[01;31m-[00m>O_Model::catchSignal(signal,source);
oligomer.cc:82:	    this[01;31m-[00m>checkForErrors();
oligomer.cc:83:	    this[01;31m-[00m>_WeakLastMultiMonomerChanged = monomer;
oligomer.cc:90:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakLastMultiMonomerChanged);
oligomer.cc:91:    return this[01;31m-[00m>_WeakLastMultiMonomerChanged.lock()[01;31m-[00m>notNil();
oligomer.cc:95:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakLastMultiMonomerChanged);
oligomer.cc:96:    return this[01;31m-[00m>_WeakLastMultiMonomerChanged.lock();
oligomer.cc:101:{_F(this[01;31m-[00m>lisp());
oligomer.cc:110:    this[01;31m-[00m>_Monomers.clear();
oligomer.cc:111:    this[01;31m-[00m>_Couplings.clear();
oligomer.cc:117:    this[01;31m-[00m>_WeakBuilderDatabase = bdb[01;31m-[00m>sharedThis<O_BuilderDatabase>();
oligomer.cc:122:{_F(this[01;31m-[00m>lisp());
oligomer.cc:123://    node[01;31m-[00m>archiveWeakPointer("builderDatabase",this[01;31m-[00m>_WeakBuilderDatabase);
oligomer.cc:124:    this[01;31m-[00m>Base::archiveBase(node);
oligomer.cc:125:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
oligomer.cc:126:    node[01;31m-[00m>archiveList("monomers",this[01;31m-[00m>_Monomers);
oligomer.cc:127:    node[01;31m-[00m>archiveList("couplings",this[01;31m-[00m>_Couplings);
oligomer.cc:128:    node[01;31m-[00m>attribute("hasError",this[01;31m-[00m>_HasError);
oligomer.cc:129:    node[01;31m-[00m>attribute("verbose",this[01;31m-[00m>_Verbose);
oligomer.cc:130:    node[01;31m-[00m>attribute("errorMessage",this[01;31m-[00m>_ErrorMessage);
oligomer.cc:135:{_F(this[01;31m-[00m>lisp());
oligomer.cc:136:    RPCons cons = O_Cons::nil(this[01;31m-[00m>lisp());
oligomer.cc:138:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:140:	cons = O_Cons::create(*mi,cons,this[01;31m-[00m>lisp());
oligomer.cc:146:{_F(this[01;31m-[00m>lisp());
oligomer.cc:156:	LOG(BF("    %s") % (*mi)[01;31m-[00m>description().c_str()  ); // vp0(("    %s",(*mi)[01;31m-[00m>description().c_str() ));
oligomer.cc:157:        for ( ci = (*mi)[01;31m-[00m>begin_value_WeakCouplings();
oligomer.cc:158:		ci != (*mi)[01;31m-[00m>end_value_WeakCouplings(); ci++ )
oligomer.cc:162:	    neighbor = coupling[01;31m-[00m>getOtherSideMonomer(*mi);
oligomer.cc:170:	LOG(BF("    %s") % (*si)[01;31m-[00m>description().c_str()  ); // vp0(("    %s",(*si)[01;31m-[00m>description().c_str() ));
oligomer.cc:178:{_F(this[01;31m-[00m>lisp());
oligomer.cc:183:    this[01;31m-[00m>expandMonomerListToNeighbors(expanded);
oligomer.cc:184:    this[01;31m-[00m>checkMonomersAndNotNeighborsForErrors(cdb,expanded);
oligomer.cc:189:{_F(this[01;31m-[00m>lisp());
oligomer.cc:194:        (*it)[01;31m-[00m>checkForErrorsAndUnknownContexts(cdb);
oligomer.cc:196:    this[01;31m-[00m>checkForErrors();
oligomer.cc:205:{_F(this[01;31m-[00m>lisp());
oligomer.cc:208:    monomer = s[01;31m-[00m>sharedThis<O_Monomer>();
oligomer.cc:210:    LOG(BF("Adding monomer@%X with name (%s)") % monomer.get() % s[01;31m-[00m>description().c_str() ); // vp0(("Adding monomer@%X with name (%s)",monomer.get(),s[01;31m-[00m>description().c_str()));
oligomer.cc:211:    idx = this[01;31m-[00m>_Monomers.size();
oligomer.cc:212:    monomer[01;31m-[00m>setSequenceNumber(idx);
oligomer.cc:213:    this[01;31m-[00m>_Monomers.push_back(monomer);
oligomer.cc:214:    if ( monomer[01;31m-[00m>getHasError() )
oligomer.cc:216:        this[01;31m-[00m>_HasError = true;
oligomer.cc:218://    monomer[01;31m-[00m>connectListener(this[01;31m-[00m>sharedThis<O_Oligomer>(),MultiMonomer_contentsChanged);
oligomer.cc:219:    monomer[01;31m-[00m>setOligomer(this[01;31m-[00m>sharedThis<O_Oligomer>());
oligomer.cc:224:{_F(this[01;31m-[00m>lisp());
oligomer.cc:226:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ ) 
oligomer.cc:228:	if ( (*mi)[01;31m-[00m>getId() == id ) return true;
oligomer.cc:235:{_F(this[01;31m-[00m>lisp());
oligomer.cc:237:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ ) 
oligomer.cc:239:	if ( (*mi)[01;31m-[00m>getId() == id ) return *mi;
oligomer.cc:241:    return O_Monomer::nil(this[01;31m-[00m>lisp());
oligomer.cc:250:{_F(this[01;31m-[00m>lisp());
oligomer.cc:252:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ ) 
oligomer.cc:256://	    (*mi)[01;31m-[00m>disconnectAll(this[01;31m-[00m>sharedThis<O_Oligomer>());
oligomer.cc:257:	    this[01;31m-[00m>_Monomers.erase(mi);
oligomer.cc:269:    for ( mi=this[01;31m-[00m>_Couplings.begin(); mi!=this[01;31m-[00m>_Couplings.end(); mi++ ) {
oligomer.cc:271://	    (*mi)[01;31m-[00m>disconnectAll(this[01;31m-[00m>sharedThis<O_Oligomer>());
oligomer.cc:272:	    this[01;31m-[00m>_Couplings.erase(mi);
oligomer.cc:281:{_F(this[01;31m-[00m>lisp());
oligomer.cc:284:    this[01;31m-[00m>_HasError = false;
oligomer.cc:285:    this[01;31m-[00m>_ErrorMessage.str("");
oligomer.cc:286:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi != this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:288:	if ( (*mi)[01;31m-[00m>getHasError() )
oligomer.cc:290:	    this[01;31m-[00m>addErrorMessage("Error in "+(*mi)[01;31m-[00m>description() );
oligomer.cc:293:    for ( ci=this[01;31m-[00m>_Couplings.begin();
oligomer.cc:294:		ci != this[01;31m-[00m>_Couplings.end(); ci++ )
oligomer.cc:296:	if ( (*ci)[01;31m-[00m>getHasError() )
oligomer.cc:298:	    this[01;31m-[00m>_HasError = true;
oligomer.cc:299:	    this[01;31m-[00m>addErrorMessage("Error in "+(*ci)[01;31m-[00m>description() );
oligomer.cc:302:    return this[01;31m-[00m>_HasError;
oligomer.cc:308:{_F(this[01;31m-[00m>lisp());
oligomer.cc:310:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:312:        (*mi)[01;31m-[00m>updateGroupName();
oligomer.cc:323:{_F(this[01;31m-[00m>lisp());
oligomer.cc:327:    coup = O_DirectionalCoupling::create(this[01;31m-[00m>lisp());
oligomer.cc:328:    coup[01;31m-[00m>setName(couplingName);
oligomer.cc:329:    monTo = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_MultiMonomer>();
oligomer.cc:330:    monTo[01;31m-[00m>setGroupName(monomerGroupName);
oligomer.cc:331:    monTo[01;31m-[00m>setPosition2D(pos);
oligomer.cc:332:    coup[01;31m-[00m>setOutMonomer(monTo);
oligomer.cc:333:    monTo[01;31m-[00m>setInCoupling(coup);
oligomer.cc:335:    monFrom[01;31m-[00m>addOutCoupling(coup);
oligomer.cc:336:    coup[01;31m-[00m>setInMonomer(monFrom);
oligomer.cc:337:    this[01;31m-[00m>addMonomer(monTo);
oligomer.cc:338:    this[01;31m-[00m>addCoupling(coup);
oligomer.cc:339:    monFrom[01;31m-[00m>throwIfBadConnections();
oligomer.cc:340:    monTo[01;31m-[00m>throwIfBadConnections();
oligomer.cc:341:    coup[01;31m-[00m>throwIfBadConnections();
oligomer.cc:350:{_F(this[01;31m-[00m>lisp());
oligomer.cc:355:    if ( !monomerToRemove[01;31m-[00m>hasInCoupling() )
oligomer.cc:357:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(BF("Trying to remove a leaf monomer that has no in coupling!") %monomerToRemove[01;31m-[00m>description()));
oligomer.cc:359:    couplings = monomerToRemove[01;31m-[00m>numberOfCouplings();
oligomer.cc:362:        TOSS(_lisp[01;31m-[00m>create<O_ContentException>(BF("Trying to remove a leaf monomer but it has out couplings!")%monomerToRemove[01;31m-[00m>description()));
oligomer.cc:364:    couplingToRemove = monomerToRemove[01;31m-[00m>getInCoupling()[01;31m-[00m>as<O_DirectionalCoupling>();
oligomer.cc:365:    monomerToRemain = couplingToRemove[01;31m-[00m>getMonomer1();
oligomer.cc:366:    monomerToRemain[01;31m-[00m>removeCoupling(couplingToRemove);
oligomer.cc:367:    this[01;31m-[00m>removeMonomer(monomerToRemove);
oligomer.cc:368:    this[01;31m-[00m>removeCoupling(couplingToRemove);
oligomer.cc:369:    monomerToRemain[01;31m-[00m>throwIfBadConnections();
oligomer.cc:378:{_F(this[01;31m-[00m>lisp());
oligomer.cc:379:    this[01;31m-[00m>_Couplings.push_back(c);
oligomer.cc:380://    c[01;31m-[00m>connectListener(this[01;31m-[00m>sharedThis<O_Oligomer>(),Coupling_nameChanged);
oligomer.cc:381:    c[01;31m-[00m>setOligomer(this[01;31m-[00m>sharedThis<O_Oligomer>());
oligomer.cc:389:{_F(this[01;31m-[00m>lisp());
oligomer.cc:393:    coupling = O_DirectionalCoupling::nil(this[01;31m-[00m>lisp());
oligomer.cc:394:    sub = this[01;31m-[00m>_Monomers[0];
oligomer.cc:396:        LOG(BF("Looking at monomer: %s") % sub[01;31m-[00m>description().c_str()  ); // vp0(("Looking at monomer: %s", sub[01;31m-[00m>description().c_str() ));
oligomer.cc:397:	if ( sub[01;31m-[00m>hasInCoupling() )
oligomer.cc:399:	    LOG(BF("    It has an in[01;31m-[00mcoupling") ); // vp0(("    It has an in[01;31m-[00mcoupling"));
oligomer.cc:400:	    coupling = sub[01;31m-[00m>getInCoupling();
oligomer.cc:401:	    if ( coupling[01;31m-[00m>isNil() ) 
oligomer.cc:406:	    sub = coupling[01;31m-[00m>getInMonomer();
oligomer.cc:409:	    coupling = O_DirectionalCoupling::nil(this[01;31m-[00m>lisp());
oligomer.cc:412:    } while ( coupling[01;31m-[00m>notNil() );
oligomer.cc:418:{_F(this[01;31m-[00m>lisp());
oligomer.cc:421:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi != this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:423:        (*mi)[01;31m-[00m>throwIfBadConnections();
oligomer.cc:425:    for ( ci=this[01;31m-[00m>_Couplings.begin();
oligomer.cc:426:		ci != this[01;31m-[00m>_Couplings.end(); ci++ )
oligomer.cc:428:        (*ci)[01;31m-[00m>throwIfBadConnections();
oligomer.cc:440:{_F(this[01;31m-[00m>lisp());
oligomer.cc:442:    this[01;31m-[00m>_Verbose = v;
oligomer.cc:444:    for ( mi = this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ ) {
oligomer.cc:447:        LOG(BF("Setting verbosity of monomer: %s") % (*mi)[01;31m-[00m>description().c_str() ); // vp0(("Setting verbosity of monomer: %s",(*mi)[01;31m-[00m>description().c_str()));
oligomer.cc:448:	(*mi)[01;31m-[00m>setVerbose(v);
oligomer.cc:463:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ ) 
oligomer.cc:473:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find first monomer in oligomer"));
oligomer.cc:476:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find second monomer in oligomer"));
oligomer.cc:479:    if ( outMon[01;31m-[00m>hasCouplingWithPlugName(outMonPlugName) ) {
oligomer.cc:480:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The second monomer already has an in coupling"));
oligomer.cc:483:    if ( inMon[01;31m-[00m>hasCouplingWithPlugName(inMonPlugName) ) {
oligomer.cc:484:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("The first monomer already has an out coupling with the name: %s") % name ));
oligomer.cc:486:    coupling = O_DirectionalCoupling::create(this[01;31m-[00m>lisp());
oligomer.cc:487:    coupling[01;31m-[00m>setName(name);
oligomer.cc:488:    coupling[01;31m-[00m>setInMonomer(inMon[01;31m-[00m>sharedThis<O_Monomer>());
oligomer.cc:489:    coupling[01;31m-[00m>setOutMonomer(outMon[01;31m-[00m>sharedThis<O_Monomer>());
oligomer.cc:490:    inMon[01;31m-[00m>addCoupling(inMonPlugName,coupling);
oligomer.cc:491:    outMon[01;31m-[00m>addCoupling(outMonPlugName,coupling);
oligomer.cc:492:    this[01;31m-[00m>addCoupling(coupling);
oligomer.cc:493:    LOG(BF("after coupling coupling: %s") % coupling[01;31m-[00m>description().c_str()  ); // vp0(( "after coupling coupling: %s", coupling[01;31m-[00m>description().c_str() ));
oligomer.cc:499:{_F(this[01;31m-[00m>lisp());
oligomer.cc:505:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ ) 
oligomer.cc:516:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find monomer1 in oligomer"));
oligomer.cc:520:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find monomer2 in oligomer"));
oligomer.cc:522:    RPRingClosingPlug rcPlug1 = mon1[01;31m-[00m>getMissingRingClosingPlug();
oligomer.cc:523:    if ( rcPlug1[01;31m-[00m>isNil() )
oligomer.cc:525:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The "+mon1[01;31m-[00m>description()+" can not make a ring closing coupling"));
oligomer.cc:527:    RPRingClosingPlug rcPlug2 = mon2[01;31m-[00m>getMissingRingClosingPlug();
oligomer.cc:528:    if ( rcPlug2[01;31m-[00m>isNil() )
oligomer.cc:530:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The "+mon2[01;31m-[00m>description()+" can not make a ring closing coupling"));
oligomer.cc:532:    string mon1PlugName = rcPlug1[01;31m-[00m>getName();
oligomer.cc:533:    string mon2PlugName = rcPlug2[01;31m-[00m>getName();
oligomer.cc:534:    coupling = O_RingCoupling::create(this[01;31m-[00m>lisp());
oligomer.cc:535:    coupling[01;31m-[00m>setMonomer1(mon1[01;31m-[00m>sharedThis<O_Monomer>());
oligomer.cc:536:    coupling[01;31m-[00m>setPlug1(mon1PlugName);
oligomer.cc:537:    coupling[01;31m-[00m>setMonomer2(mon2[01;31m-[00m>sharedThis<O_Monomer>());
oligomer.cc:538:    coupling[01;31m-[00m>setPlug2(mon2PlugName);
oligomer.cc:539:    mon1[01;31m-[00m>addCoupling(mon1PlugName,coupling);
oligomer.cc:540:    mon2[01;31m-[00m>addCoupling(mon2PlugName,coupling);
oligomer.cc:541:    this[01;31m-[00m>addCoupling(coupling);
oligomer.cc:549:{_F(this[01;31m-[00m>lisp());
oligomer.cc:552:    if ( this[01;31m-[00m>getHasError() ) {
oligomer.cc:553:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The molecule can not be returned, the Oligomer has an error"));
oligomer.cc:557:    mol = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Molecule>();
oligomer.cc:559:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ ) 
oligomer.cc:561:	ASSERT((*mi)[01;31m-[00m>notNil());
oligomer.cc:562:    	res = (*mi)[01;31m-[00m>createResidue();
oligomer.cc:563:	topology = (*mi)[01;31m-[00m>getTopology();
oligomer.cc:564:	residueNetCharge = topology[01;31m-[00m>getResidueNetCharge();
oligomer.cc:565:	res[01;31m-[00m>setNetCharge(residueNetCharge);
oligomer.cc:566:	(*mi)[01;31m-[00m>setTempResidue(res);
oligomer.cc:567:	mol[01;31m-[00m>addMatter(res);
oligomer.cc:572:    for ( ci=this[01;31m-[00m>_Couplings.begin(); ci!=this[01;31m-[00m>_Couplings.end(); ci++ ) 
oligomer.cc:574:	mon1 = (*ci)[01;31m-[00m>getMonomer1();
oligomer.cc:575:	ASSERT(mon1[01;31m-[00m>notNil());
oligomer.cc:576:	mon2 = (*ci)[01;31m-[00m>getMonomer2();
oligomer.cc:577:	ASSERT(mon2[01;31m-[00m>notNil());
oligomer.cc:578:	res1 = mon1[01;31m-[00m>getTemporaryResidue();
oligomer.cc:579:	res2 = mon2[01;31m-[00m>getTemporaryResidue();
oligomer.cc:580:    	(*ci)[01;31m-[00m>doCoupling(res1,res2);
oligomer.cc:587:{_F(this[01;31m-[00m>lisp());
oligomer.cc:592:    msg << this[01;31m-[00m>_ErrorMessage.str();
oligomer.cc:595:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ ) {
oligomer.cc:596:	if ( (*mi)[01;31m-[00m>getHasError() ) {
oligomer.cc:597:	    msg << (*mi)[01;31m-[00m>getStatusMessage() << endl;
oligomer.cc:601:    for ( ci=this[01;31m-[00m>_Couplings.begin(); ci!=this[01;31m-[00m>_Couplings.end(); ci++ ) {
oligomer.cc:602:	if ( (*ci)[01;31m-[00m>getHasError() ) {
oligomer.cc:603:	    msg << (*mi)[01;31m-[00m>getStatusMessage() << endl;
oligomer.cc:612:{_F(this[01;31m-[00m>lisp());
oligomer.cc:615:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:617:	if ( (*mi)[01;31m-[00m>numberOfPossibleMonomers()>1 )
oligomer.cc:635:{_F(this[01;31m-[00m>lisp());
oligomer.cc:638:    this[01;31m-[00m>_gatherMultiMonomers(multiMonomers);
oligomer.cc:646:    multiMonomers[iperturb][01;31m-[00m>randomizeMonomer();
oligomer.cc:652:{_F(this[01;31m-[00m>lisp());
oligomer.cc:656:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:658:        bases.push_back((*mi)[01;31m-[00m>numberOfPossibleMonomers());
oligomer.cc:661:    for ( mi=this[01;31m-[00m>_Monomers.begin(),di=digits.begin();
oligomer.cc:662:    		mi!=this[01;31m-[00m>_Monomers.end(); mi++,di++ )
oligomer.cc:664:        (*mi)[01;31m-[00m>setMonomerIndex(*di);
oligomer.cc:674:{_F(this[01;31m-[00m>lisp());
oligomer.cc:677:    this[01;31m-[00m>gotoSequence(0);
oligomer.cc:684:{_F(this[01;31m-[00m>lisp());
oligomer.cc:688:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:690:        bases.push_back((*mi)[01;31m-[00m>numberOfPossibleMonomers());
oligomer.cc:691:	digits.push_back((*mi)[01;31m-[00m>getMonomerIndex());
oligomer.cc:693:    index = mixedBaseDigitsToLongLongInt(bases,digits,this[01;31m-[00m>lisp());
oligomer.cc:700: * Return [01;31m-[00m1 if there are too many sequences.
oligomer.cc:703:{_F(this[01;31m-[00m>lisp());
oligomer.cc:707:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:709:        bases.push_back((*mi)[01;31m-[00m>numberOfPossibleMonomers());
oligomer.cc:720:{_F(this[01;31m-[00m>lisp());
oligomer.cc:724:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:726:        if ( (*mi)[01;31m-[00m>incrementMonomerIndex() ) return true;
oligomer.cc:727:        numSeq *= (*mi)[01;31m-[00m>numberOfPossibleMonomers();
oligomer.cc:738:    if ( this[01;31m-[00m>_Monomers.size() != 0 ) {
oligomer.cc:739:        return this[01;31m-[00m>_Monomers[0];
oligomer.cc:741:    return O_Monomer::nil(this[01;31m-[00m>lisp());
oligomer.cc:747:{_F(this[01;31m-[00m>lisp());
oligomer.cc:749:    seq << "monomer '" << mon[01;31m-[00m>getId() << " [GroupPart :group \"" << mon[01;31m-[00m>getGroupName() <<"\" :part \"" <<mon[01;31m-[00m>getName() << "\" ";
oligomer.cc:750:    RPStringSet aliases = mon[01;31m-[00m>getMonomerAliases();
oligomer.cc:751:    if ( aliases[01;31m-[00m>size() > 0 )
oligomer.cc:753:	seq << " :aliases '(" << aliases[01;31m-[00m>asString() << " ) ";
oligomer.cc:760:{_F(this[01;31m-[00m>lisp());
oligomer.cc:763:    outCouplings = rootMonomer[01;31m-[00m>getOutCouplings();
oligomer.cc:766:        RPMonomer mon1 = (*oci)[01;31m-[00m>getMonomer1();
oligomer.cc:767:        RPMonomer mon2 = (*oci)[01;31m-[00m>getMonomer2();
oligomer.cc:768:        seq << "[ link '"<<mon1[01;31m-[00m>getId();
oligomer.cc:769:	seq <<" '"<<(*oci)[01;31m-[00m>getName() << " ";
oligomer.cc:770:	this[01;31m-[00m>_fillMonomerAsString(mon2,seq);
oligomer.cc:775:	if ((*oci)[01;31m-[00m>isOfClass<O_RingCoupling>()) continue;
oligomer.cc:776:        RPMonomer mon2 = (*oci)[01;31m-[00m>getMonomer2();
oligomer.cc:777:        this[01;31m-[00m>_fillSequenceAsStringForChildren(mon2,seq);
oligomer.cc:782:{_F(this[01;31m-[00m>lisp());
oligomer.cc:784:    RPMonomer mon2 = this[01;31m-[00m>rootMonomer();
oligomer.cc:786:    this[01;31m-[00m>_fillMonomerAsString(mon2,seq);
oligomer.cc:788:    this[01;31m-[00m>_fillSequenceAsStringForChildren(mon2,seq);
oligomer.cc:789:    for (List<O_Coupling>::iterator ci=this[01;31m-[00m>_Couplings.begin(); ci!=this[01;31m-[00m>_Couplings.end(); ci++ )
oligomer.cc:791:	if ( (*ci)[01;31m-[00m>isOfClass<O_RingCoupling>() )
oligomer.cc:793:	    RPRingCoupling rc = (*ci)[01;31m-[00m>as<O_RingCoupling>();
oligomer.cc:794:	    RPMonomer mon1 = rc[01;31m-[00m>getMonomer1();
oligomer.cc:795:	    RPMonomer mon2 = rc[01;31m-[00m>getMonomer2();
oligomer.cc:797:	    seq << mon1[01;31m-[00m>getId();
oligomer.cc:798:	    seq <<" '"<<rc[01;31m-[00m>getPlug1() << " ";
oligomer.cc:799:	    seq << mon2[01;31m-[00m>getId();
oligomer.cc:800:	    seq <<" '"<<rc[01;31m-[00m>getPlug2() << " ";
oligomer.cc:810:{_F(this[01;31m-[00m>lisp());
oligomer.cc:813:    outCouplings = rootMonomer[01;31m-[00m>getOutCouplings();
oligomer.cc:816:        RPMonomer mon1 = (*oci)[01;31m-[00m>getMonomer1();
oligomer.cc:817:        RPMonomer mon2 = (*oci)[01;31m-[00m>getMonomer2();
oligomer.cc:818:	seq <<"[01;31m-[00m" << mon2[01;31m-[00m>getName();
oligomer.cc:822:	if ( (*oci)[01;31m-[00m>isOfClass<O_RingCoupling>() ) continue;
oligomer.cc:823:        RPMonomer mon2 = (*oci)[01;31m-[00m>getMonomer2();
oligomer.cc:824:        this[01;31m-[00m>_fillSequenceAsFileNameForChildren(mon2,seq);
oligomer.cc:830:{_F(this[01;31m-[00m>lisp());
oligomer.cc:831:    RPStringSet aliases = O_StringSet::create(this[01;31m-[00m>lisp());
oligomer.cc:833:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:835:	RPStringSet oneMonomerAliases = (*mi)[01;31m-[00m>getAllAliases();
oligomer.cc:836:	aliases[01;31m-[00m>insertStringSet(oneMonomerAliases);
oligomer.cc:842:{_F(this[01;31m-[00m>lisp());
oligomer.cc:843:    RPStringSet aliases = O_StringSet::create(this[01;31m-[00m>lisp());
oligomer.cc:845:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:847:	RPStringSet oneMonomerAliases = (*mi)[01;31m-[00m>getMonomerAliases();
oligomer.cc:848:	aliases[01;31m-[00m>insertStringSet(oneMonomerAliases);
oligomer.cc:854:{_F(this[01;31m-[00m>lisp());
oligomer.cc:856:    RPMonomer mon2 = this[01;31m-[00m>rootMonomer();
oligomer.cc:858:    seq << mon2[01;31m-[00m>getName();
oligomer.cc:859:    this[01;31m-[00m>_fillSequenceAsFileNameForChildren(mon2,seq);
oligomer.cc:860:    seq << "_" << this[01;31m-[00m>getName();
oligomer.cc:866:{_F(this[01;31m-[00m>lisp());
oligomer.cc:867:    RPSpecificContextSet allContexts = O_SpecificContextSet::create(this[01;31m-[00m>lisp());
oligomer.cc:869:    for ( mi=this[01;31m-[00m>_Monomers.begin(); mi!=this[01;31m-[00m>_Monomers.end(); mi++ )
oligomer.cc:871:	RPMonomerContext monomerContext = (*mi)[01;31m-[00m>getGeneralMonomerContext();
oligomer.cc:872:	RPSpecificContextSet oneSpecificSet = monomerContext[01;31m-[00m>getAllSpecificContexts();
oligomer.cc:873:	allContexts[01;31m-[00m>merge(oneSpecificSet);
oligomer.cc:882:    if ( args[01;31m-[00m>length()!=1 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide an oligomer"));
oligomer.cc:883:    RPOligomer olig = args[01;31m-[00m>listref<O_Oligomer>(0);
oligomer.cc:884:    string seq = olig[01;31m-[00m>sequenceAsString();
oligomer.cc:885:    return lisp[01;31m-[00m>create<O_String>(seq);
oligomer.cc:890:{_F(this[01;31m-[00m>lisp());
oligomer.cc:892:    for ( RPCons p=parts; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() )
oligomer.cc:894:	RPOligomerPart_Base oligPart = p[01;31m-[00m>car<O_OligomerPart_Base>();
oligomer.cc:895:	RPMultiMonomer mon = oligPart[01;31m-[00m>createMonomer(bdb);
oligomer.cc:896:	this[01;31m-[00m>addMonomer(mon);
oligomer.cc:897:	monomerMap.set(mon[01;31m-[00m>getId(), mon);
oligomer.cc:898:	if ( oligPart[01;31m-[00m>isOfClass<O_OligomerPart_Link>() )
oligomer.cc:901:	    string	mon1Id = link[01;31m-[00m>_Monomer1Id;
oligomer.cc:902:	    string	mon2Id = link[01;31m-[00m>_Monomer2[01;31m-[00m>_MonomerId;
oligomer.cc:903:	    if ( !monomerMap.contains(mon1Id) ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown monomer id: "+mon1Id));
oligomer.cc:904:	    if ( !monomerMap.contains(mon2Id) ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown monomer id: "+mon2Id));
oligomer.cc:907:	    this[01;31m-[00m>couple(mon1,link[01;31m-[00m>_Coupling,mon2);
oligomer.cc:914:{_F(this[01;31m-[00m>lisp());
oligomer.cc:915:    RPCons parts = kargs[01;31m-[00m>getAndRemoveOrDefault("parts",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
oligomer.cc:916:    if ( parts[01;31m-[00m>notNil() )
oligomer.cc:918:	RPBuilderDatabase bdb = env[01;31m-[00m>getBuilderDatabase();
oligomer.cc:919:	this[01;31m-[00m>_assembleFromParts(parts,bdb);
oligomer.cc:926:    if ( args[01;31m-[00m>length()!=2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide 2 args, a name and parts"));
oligomer.cc:927:    RPText oligomerName = args[01;31m-[00m>listref<O_Text>(0);
oligomer.cc:928:    RPCons parts = args[01;31m-[00m>listref<O_Cons>(1);
oligomer.cc:929:    RPOligomer olig = lisp[01;31m-[00m>create<O_Oligomer>();
oligomer.cc:930:    olig[01;31m-[00m>setName(oligomerName[01;31m-[00m>get());
oligomer.cc:931:    RPBuilderDatabase bdb = lisp[01;31m-[00m>getBuilderDatabase();
oligomer.cc:932:    olig[01;31m-[00m>_assembleFromParts(parts,bdb);
oligomer.cc:933:    RPSymbol sym = lisp[01;31m-[00m>intern(oligomerName[01;31m-[00m>get());
oligomer.cc:934:    lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(sym,olig);
oligomer.cc:944:    class_<O_Oligomer>(this[01;31m-[00m>lisp())
oligomer.cc:993:    defNoWrapPackage(MbbPackage,"setOligomer",&O_Oligomer::prim_setOligomer,this[01;31m-[00m>lisp());
oligomer.cc:994:    defNoWrapPackage(MbbPackage,"oligomerSequence",&O_Oligomer::prim_oligomerSequence,this[01;31m-[00m>lisp());
oligomerBuilder.cc:37:    RPBuilderDatabase bdb = e[01;31m-[00m>getBuilderDatabase();
oligomerBuilder.cc:38:    ob[01;31m-[00m>setupOligomer(bdb,olig);
oligomerBuilder.cc:48:    this[01;31m-[00m>Base::initialize();
oligomerBuilder.cc:49:    this[01;31m-[00m>_BuildSerialNumber = UndefinedUnsignedInt;
oligomerBuilder.cc:54:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:55:    this[01;31m-[00m>_BuildSerialNumber++;
oligomerBuilder.cc:56:    if ( this[01;31m-[00m>_BuildSerialNumber == UndefinedUnsignedInt )
oligomerBuilder.cc:58:	this[01;31m-[00m>_BuildSerialNumber = 1;
oligomerBuilder.cc:60:    LOG(BF("Preparing to build with _BuildSerialNumber=%d") % this[01;31m-[00m>_BuildSerialNumber  ); // vp0(("Preparing to build with _BuildSerialNumber=%d", this[01;31m-[00m>_BuildSerialNumber ));
oligomerBuilder.cc:61:    this[01;31m-[00m>_NumberOfFramesInitialized = 0;
oligomerBuilder.cc:62:    this[01;31m-[00m>_NumberOfFramesBuilt = 0;
oligomerBuilder.cc:67:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:68:    uint numFrameHolders = this[01;31m-[00m>_FrameHolders.size()[01;31m-[00m1; // First frame holder is always identity
oligomerBuilder.cc:70:    uint numTouched = this[01;31m-[00m>_NumberOfFramesInitialized + this[01;31m-[00m>_NumberOfFramesBuilt;
oligomerBuilder.cc:72:    if ( this[01;31m-[00m>_NumberOfFramesBuilt == numFrameHolders ) return;
oligomerBuilder.cc:73:    if ( this[01;31m-[00m>_NumberOfFramesBuilt > numFrameHolders )
oligomerBuilder.cc:75:	// Uh, we have a problem [01;31m-[00m apparently more frames were built than
oligomerBuilder.cc:79:	ss << " but " << this[01;31m-[00m>_NumberOfFramesBuilt << " were counted as built" << endl;
oligomerBuilder.cc:80:	ss << " and " << this[01;31m-[00m>_NumberOfFramesInitialized << " were counted as set to identity" << endl;
oligomerBuilder.cc:84:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
oligomerBuilder.cc:89:    ss << " and " << this[01;31m-[00m>_NumberOfFramesBuilt << " were counted as built" << endl;
oligomerBuilder.cc:90:    ss << " and " << this[01;31m-[00m>_NumberOfFramesInitialized << " were counted as set to identity" << endl;
oligomerBuilder.cc:96:    uint framesToBuild = numFrameHolders [01;31m-[00m this[01;31m-[00m>_NumberOfFramesBuilt;
oligomerBuilder.cc:98:    vector<FrameHolder>::iterator fhi = this[01;31m-[00m>_FrameHolders.begin();
oligomerBuilder.cc:102:    while ( fhi != this[01;31m-[00m>_FrameHolders.end() )
oligomerBuilder.cc:104:	if ( fhi[01;31m-[00m>_SaveBuildSerialNumber != this[01;31m-[00m>_BuildSerialNumber )
oligomerBuilder.cc:106:	    LOG(BF("FrameHolder(%d) has not been built") % (fhi[01;31m-[00mthis[01;31m-[00m>_FrameHolders.begin() ) ); // vp0(( "FrameHolder(%d) has not been built", fhi[01;31m-[00mthis[01;31m-[00m>_FrameHolders.begin() ));
oligomerBuilder.cc:107:	    fhi[01;31m-[00m>buildUsingAtoms(this[01;31m-[00m>sharedThis<O_OligomerBuilder>());
oligomerBuilder.cc:124:    oligomer = this[01;31m-[00m>getOligomer();
oligomerBuilder.cc:125:    for ( mi=oligomer[01;31m-[00m>begin_Monomers();
oligomerBuilder.cc:126:    		mi !=oligomer[01;31m-[00m>end_Monomers(); mi++ )
oligomerBuilder.cc:128:        context = (*mi)[01;31m-[00m>getMonomerContext();
oligomerBuilder.cc:139:    ASSERT_lessThan(i,this[01;31m-[00m>_Scaffolds.size());
oligomerBuilder.cc:140:    this[01;31m-[00m>_StartScaffoldHolderListIndex = i;
oligomerBuilder.cc:146:    i = this[01;31m-[00m>_StartScaffoldHolderListIndex;
oligomerBuilder.cc:147:    ASSERT_lessThan(i,this[01;31m-[00m>_Scaffolds.size());
oligomerBuilder.cc:154:    icur = this[01;31m-[00m>_Scaffolds[icur]._NextSpanIdx;
oligomerBuilder.cc:161:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:170:    cdb = this[01;31m-[00m>getBuilderDatabase();
oligomerBuilder.cc:171:    oligomer = this[01;31m-[00m>_Oligomer;
oligomerBuilder.cc:173:    this[01;31m-[00m>_Scaffolds.resize(oligomer[01;31m-[00m>numberOfMonomers(),ScaffoldHolder(_lisp));
oligomerBuilder.cc:174:    LOG(BF("There are %d ScaffoldHolders being allocated") % oligomer[01;31m-[00m>numberOfMonomers() ); // vp0(("There are %d ScaffoldHolders being allocated",oligomer[01;31m-[00m>numberOfMonomers()));
oligomerBuilder.cc:176:	for ( im=oligomer[01;31m-[00m>begin_Monomers();
oligomerBuilder.cc:177:		    im !=oligomer[01;31m-[00m>end_Monomers(); im++ )
oligomerBuilder.cc:178:	{_BLOCK_TRACEF(BF("Looking up context for %s") % (*im)[01;31m-[00m>description().c_str() );
oligomerBuilder.cc:179:    	    if ( !(*im)[01;31m-[00m>isMonomerContextValid() )
oligomerBuilder.cc:181:	        LOG(BF("Illegal context for monomer: %s") % (*im)[01;31m-[00m>description().c_str()  ); // vp0(("Illegal context for monomer: %s",(*im)[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:182:		(*im)[01;31m-[00m>addErrorMessage("Illegal context");
oligomerBuilder.cc:187:		context = (*im)[01;31m-[00m>getSpecificMonomerContext();
oligomerBuilder.cc:188:		LOG(BF("Context = %s") % context[01;31m-[00m>getKey().c_str() ); // vp0(("Context = %s",context[01;31m-[00m>getKey().c_str()));
oligomerBuilder.cc:189:		if ( !cdb[01;31m-[00m>recognizesContext(context) )
oligomerBuilder.cc:191:		    LOG(BF("Unrecognized context: %s") % context[01;31m-[00m>getKey().c_str() ); // vp0(("Unrecognized context: %s",context[01;31m-[00m>getKey().c_str()));
oligomerBuilder.cc:192:		    (*im)[01;31m-[00m>addErrorMessage("For "+(*im)[01;31m-[00m>description()+" unrecognized context:");
oligomerBuilder.cc:193:		    (*im)[01;31m-[00m>addErrorMessage("   "+context[01;31m-[00m>getKey());
oligomerBuilder.cc:194:		    this[01;31m-[00m>_ErrorStream << "OligomerBuilder[01;31m-[00m>Unrecognized context:" << context[01;31m-[00m>getKey() << endl;
oligomerBuilder.cc:198:		    seqNum = (*im)[01;31m-[00m>getSequenceNumber();
oligomerBuilder.cc:199:		    LOG(BF("Assigning monomer comment(%s) index: %d") % (*im)[01;31m-[00m>getComment().c_str() % seqNum  ); // vp0(("Assigning monomer comment(%s) index: %d",(*im)[01;31m-[00m>getComment().c_str(),seqNum ));
oligomerBuilder.cc:200:		    (*im)[01;31m-[00m>setTemporaryInt(index);
oligomerBuilder.cc:209:		    this[01;31m-[00m>_Scaffolds[seqNum].initializeFromMonomer(cdb,context,*im);
oligomerBuilder.cc:216:	    this[01;31m-[00m>_HasError = true;
oligomerBuilder.cc:224:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:232:	uint scaffoldsSize = this[01;31m-[00m>_Scaffolds.size();
oligomerBuilder.cc:237:	    ASSERT_NOT_NULL(this[01;31m-[00m>_Scaffolds[mbi]._MonomerCoordinates);
oligomerBuilder.cc:238:	    ASSERT_NOT_NULL(this[01;31m-[00m>_Scaffolds[mbi]._Monomer);
oligomerBuilder.cc:239:	    if ( this[01;31m-[00m>_Scaffolds[mbi].hasAnchorOrigin() )
oligomerBuilder.cc:241:		LOG(BF("Scaffold with AnchorOrigin has %s") % this[01;31m-[00m>_Scaffolds[mbi]._Monomer[01;31m-[00m>description().c_str()  ); // vp0(( "Scaffold with AnchorOrigin has %s", this[01;31m-[00m>_Scaffolds[mbi]._Monomer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:245:	    this[01;31m-[00m>_Scaffolds[mbi]._TouchedSpan = false;
oligomerBuilder.cc:246:	    this[01;31m-[00m>_Scaffolds[mbi]._NextSpanIdx = UndefinedUnsignedInt;
oligomerBuilder.cc:247:	    this[01;31m-[00m>_Scaffolds[mbi]._BackSpanIdx = UndefinedUnsignedInt;
oligomerBuilder.cc:251:	    TOSS(_lisp[01;31m-[00m>create<O_ContentException>("There is no AnchorOrigin scaffold",
oligomerBuilder.cc:252:	    	this[01;31m-[00m>sharedThis<O_OligomerBuilder>()[01;31m-[00m>description()));
oligomerBuilder.cc:256:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There can be only one scaffold anchored on the origin"));
oligomerBuilder.cc:259:    ASSERT_lessThan(iStartScaffoldHolder,this[01;31m-[00m>_Scaffolds.size());
oligomerBuilder.cc:260:    LOG(BF("Returning scaffold with AnchorOrigin has %s") % this[01;31m-[00m>_Scaffolds[iStartScaffoldHolder]._Monomer[01;31m-[00m>description().c_str()  ); // vp0(( "Returning scaffold with AnchorOrigin has %s", this[01;31m-[00m>_Scaffolds[iStartScaffoldHolder]._Monomer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:266:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:267:    RPStringSet monomerIds = O_StringSet::create(this[01;31m-[00m>lisp());
oligomerBuilder.cc:268:    uint scaffoldsSize = this[01;31m-[00m>_Scaffolds.size();
oligomerBuilder.cc:272:	ASSERT_NOT_NULL(this[01;31m-[00m>_Scaffolds[mbi]._Monomer);
oligomerBuilder.cc:273:	monomerIds[01;31m-[00m>insert(this[01;31m-[00m>_Scaffolds[mbi]._Monomer[01;31m-[00m>getId() );
oligomerBuilder.cc:281:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:282:    uint scaffoldsSize = this[01;31m-[00m>_Scaffolds.size();
oligomerBuilder.cc:286:	ASSERT_NOT_NULL(this[01;31m-[00m>_Scaffolds[mbi]._Monomer);
oligomerBuilder.cc:287:	if ( this[01;31m-[00m>_Scaffolds[mbi]._Monomer[01;31m-[00m>getId() == monomerId )
oligomerBuilder.cc:289:	    RPStringSet result = O_StringSet::create(this[01;31m-[00m>lisp());
oligomerBuilder.cc:290:	    for ( map<string,uint>::iterator it=this[01;31m-[00m>_Scaffolds[mbi]._TransformOrFrameNameToIndex.begin();
oligomerBuilder.cc:291:	    		it!=this[01;31m-[00m>_Scaffolds[mbi]._TransformOrFrameNameToIndex.end(); it++ )
oligomerBuilder.cc:293:		result[01;31m-[00m>insert(it[01;31m-[00m>first);
oligomerBuilder.cc:298:    return O_StringSet::nil(this[01;31m-[00m>lisp());
oligomerBuilder.cc:302:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:303:    uint scaffoldsSize = this[01;31m-[00m>_Scaffolds.size();
oligomerBuilder.cc:307:	ASSERT_NOT_NULL(this[01;31m-[00m>_Scaffolds[mbi]._Monomer);
oligomerBuilder.cc:308:	if ( this[01;31m-[00m>_Scaffolds[mbi]._Monomer[01;31m-[00m>getId() == monomerId )
oligomerBuilder.cc:310:	    if ( this[01;31m-[00m>_Scaffolds[mbi].recognizesTransformOrFrameName(frameName) )
oligomerBuilder.cc:312:		uint frameHolderIdx = this[01;31m-[00m>_Scaffolds[mbi].getIndexForTransformOrFrameName(frameName);
oligomerBuilder.cc:313:		RPCoordinateSystem coord = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
oligomerBuilder.cc:314:		coord[01;31m-[00m>defineCanonical();
oligomerBuilder.cc:315:		ASSERT_lt(frameHolderIdx,this[01;31m-[00m>_FrameHolders.size());
oligomerBuilder.cc:316:		coord[01;31m-[00m>transformWithMatrix(this[01;31m-[00m>_FrameHolders[frameHolderIdx].frameTransform());
oligomerBuilder.cc:321:    return O_CoordinateSystem::nil(this[01;31m-[00m>lisp());
oligomerBuilder.cc:326:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:327:    if ( this[01;31m-[00m>_Scaffolds[iNode]._TouchedSpan ) return;
oligomerBuilder.cc:328:    this[01;31m-[00m>_Scaffolds[iNode]._TouchedSpan = true;
oligomerBuilder.cc:329:    RPMonomer nodeMonomer = this[01;31m-[00m>_Scaffolds[iNode]._Monomer;
oligomerBuilder.cc:330:    LOG(BF("nodeMonomer %s") % nodeMonomer[01;31m-[00m>description().c_str()  ); // vp0(("nodeMonomer %s",nodeMonomer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:331:    RPMonomerCoordinates nodeMonomerCoordinates = this[01;31m-[00m>_Scaffolds[iNode]._MonomerCoordinates;
oligomerBuilder.cc:332:    RPScaffoldList nodeScaffoldList = nodeMonomerCoordinates[01;31m-[00m>getScaffoldList();
oligomerBuilder.cc:352:    LOG(BF("About to append children to build list,there are %d couplings") % nodeMonomer[01;31m-[00m>numberOfCouplings()  ); // vp0(("About to append children to build list,there are %d couplings",nodeMonomer[01;31m-[00m>numberOfCouplings() ));
oligomerBuilder.cc:355:    for ( wci = nodeMonomer[01;31m-[00m>begin_WeakCouplings();
oligomerBuilder.cc:356:	    wci != nodeMonomer[01;31m-[00m>end_WeakCouplings(); wci++ )
oligomerBuilder.cc:358:	WPCoupling weakCoupling = wci[01;31m-[00m>second;
oligomerBuilder.cc:362:	if ( O_DirectionalCoupling::isInPlugName(wci[01;31m-[00m>first,_lisp) ) continue;
oligomerBuilder.cc:363:	LOG(BF("Got weak coupling through plug: %s") % wci[01;31m-[00m>first.c_str() ); // vp0(("Got weak coupling through plug: %s",wci[01;31m-[00m>first.c_str()));
oligomerBuilder.cc:366:	if ( coupling[01;31m-[00m>isOfClass<O_DirectionalCoupling>() )
oligomerBuilder.cc:368:	    RPDirectionalCoupling dc = coupling[01;31m-[00m>as<O_DirectionalCoupling>();
oligomerBuilder.cc:369:	    LOG(BF("Got coupling: %s") % dc[01;31m-[00m>getName().c_str()  ); // vp0(("Got coupling: %s",dc[01;31m-[00m>getName().c_str() ));
oligomerBuilder.cc:373:	    if ( dc[01;31m-[00m>isRingClosing() ) continue;
oligomerBuilder.cc:375:	    RPMonomer childMonomer = dc[01;31m-[00m>getOtherSideMonomer(nodeMonomer);
oligomerBuilder.cc:376:	    uint iChild = childMonomer[01;31m-[00m>getTemporaryInt();	// index into this[01;31m-[00m>_Scaffolds
oligomerBuilder.cc:377:	    RPMonomerCoordinates childMonomerCoordinates = this[01;31m-[00m>_Scaffolds[iChild]._MonomerCoordinates;
oligomerBuilder.cc:378:	    RPScaffoldList childScaffoldList = childMonomerCoordinates[01;31m-[00m>getScaffoldList();
oligomerBuilder.cc:381:	    if ( childScaffoldList[01;31m-[00m>dependsOnIncompleteFrame(nodeScaffoldList,childMonomer) )
oligomerBuilder.cc:397:	    LOG(BF("%u  %s ") % ic % dit[01;31m-[00m>second[01;31m-[00m>getName().c_str()  ); // vp0(("%u  %s ", ic, dit[01;31m-[00m>second[01;31m-[00m>getName().c_str() ));
oligomerBuilder.cc:409:	this[01;31m-[00m>_visitNode(iNode,vit[01;31m-[00m>first,iList);
oligomerBuilder.cc:411:    this[01;31m-[00m>_Scaffolds[iNode]._NextSpanIdx = iList;
oligomerBuilder.cc:412:    this[01;31m-[00m>_Scaffolds[iNode]._BackSpanIdx = iParentNode;
oligomerBuilder.cc:417:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:419:    this[01;31m-[00m>_visitNode(UndefinedUnsignedInt,iStartScaffoldHolder,iList);
oligomerBuilder.cc:428:	    sll << " idx:" << zzi << "(back:"<<this[01;31m-[00m>_Scaffolds[zzi]._BackSpanIdx<<")";
oligomerBuilder.cc:429:	    sll << " " << this[01;31m-[00m>_Scaffolds[zzi]._Monomer[01;31m-[00m>description() << endl;
oligomerBuilder.cc:430:	    zzi = this[01;31m-[00m>_Scaffolds[zzi]._NextSpanIdx;
oligomerBuilder.cc:433:	{_BLOCK_TRACE("this[01;31m-[00m>_Scaffolds raw dump");
oligomerBuilder.cc:434:	    for ( zzi = 0; zzi < this[01;31m-[00m>_Scaffolds.size(); zzi++ )
oligomerBuilder.cc:436:		LOG(BF("Monomer@%d _NextSpanIdx(%d) _BackSpanIdx(%d) %s") % zzi % this[01;31m-[00m>_Scaffolds[zzi]._NextSpanIdx % this[01;31m-[00m>_Scaffolds[zzi]._BackSpanIdx % this[01;31m-[00m>_Scaffolds[zzi]._Monomer[01;31m-[00m>description().c_str()  ); // vp0(("Monomer@%d _NextSpanIdx(%d) _BackSpanIdx(%d) %s",zzi, this[01;31m-[00m>_Scaffolds[zzi]._NextSpanIdx, this[01;31m-[00m>_Scaffolds[zzi]._BackSpanIdx, this[01;31m-[00m>_Scaffolds[zzi]._Monomer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:450:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:472:    this[01;31m-[00m>_Scaffolds[iParent]._BackSpanIdx = UndefinedUnsignedInt;
oligomerBuilder.cc:473:    this[01;31m-[00m>_Scaffolds[iParent]._NextSpanIdx = UndefinedUnsignedInt;
oligomerBuilder.cc:478:        ASSERT_lessThan(iParent,this[01;31m-[00m>_Scaffolds.size());
oligomerBuilder.cc:479:        parentMonomer = this[01;31m-[00m>_Scaffolds[iParent]._Monomer;
oligomerBuilder.cc:480:    	LOG(BF("parentMonomer %s") % parentMonomer[01;31m-[00m>description().c_str()  ); // vp0(("parentMonomer %s",parentMonomer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:484:	parentMonomerCoordinates = this[01;31m-[00m>_Scaffolds[iParent]._MonomerCoordinates;
oligomerBuilder.cc:485:	parentScaffoldList = parentMonomerCoordinates[01;31m-[00m>getScaffoldList();
oligomerBuilder.cc:487:	LOG(BF("About to append children to build list,there are %d couplings") % parentMonomer[01;31m-[00m>numberOfCouplings()  ); // vp0(("About to append children to build list,there are %d couplings",parentMonomer[01;31m-[00m>numberOfCouplings() ));
oligomerBuilder.cc:488:	for ( wci = parentMonomer[01;31m-[00m>begin_WeakCouplings();
oligomerBuilder.cc:489:		wci != parentMonomer[01;31m-[00m>end_WeakCouplings(); wci++ )
oligomerBuilder.cc:491:	    weakCoupling = wci[01;31m-[00m>second;
oligomerBuilder.cc:492:	    LOG(BF("Got weak coupling through plug: %s") % wci[01;31m-[00m>first.c_str() ); // vp0(("Got weak coupling through plug: %s",wci[01;31m-[00m>first.c_str()));
oligomerBuilder.cc:495:	    LOG(BF("Got coupling: %s") % coupling[01;31m-[00m>getName().c_str()  ); // vp0(("Got coupling: %s",coupling[01;31m-[00m>getName().c_str() ));
oligomerBuilder.cc:496:	    if ( coupling[01;31m-[00m>isRingClosing() ) continue;
oligomerBuilder.cc:498:	    child = coupling[01;31m-[00m>getOtherSideMonomer(parentMonomer);
oligomerBuilder.cc:499:	    LOG(BF("Got child: %s") % child[01;31m-[00m>description().c_str()  ); // vp0(("Got child: %s",child[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:500:	    iChild = child[01;31m-[00m>getTemporaryInt();
oligomerBuilder.cc:505:	    if ( this[01;31m-[00m>_Scaffolds[iChild]._TouchedSpan ) continue;
oligomerBuilder.cc:513:	    this[01;31m-[00m>_Scaffolds[iChild]._BackSpanIdx = iParent;
oligomerBuilder.cc:514:	    this[01;31m-[00m>_Scaffolds[iChild]._TouchedSpan = true;
oligomerBuilder.cc:515:	    monomerCoordinates = this[01;31m-[00m>_Scaffolds[iChild]._MonomerCoordinates;
oligomerBuilder.cc:516:	    childScaffoldList = monomerCoordinates[01;31m-[00m>getScaffoldList();
oligomerBuilder.cc:517:	    if ( childScaffoldList[01;31m-[00m>dependsOnIncompleteFrame(parentScaffoldList,child) )
oligomerBuilder.cc:524:		this[01;31m-[00m>_Scaffolds[iChildListTail]._NextSpanIdx = iChild;
oligomerBuilder.cc:525:		this[01;31m-[00m>_Scaffolds[iChild]._NextSpanIdx = UndefinedUnsignedInt;
oligomerBuilder.cc:533:		this[01;31m-[00m>_Scaffolds[iChild]._NextSpanIdx =
oligomerBuilder.cc:534:			this[01;31m-[00m>_Scaffolds[iChildListHead]._NextSpanIdx;
oligomerBuilder.cc:535:		this[01;31m-[00m>_Scaffolds[iChildListHead]._NextSpanIdx = iChild;
oligomerBuilder.cc:547:	iParent = this[01;31m-[00m>_Scaffolds[iParent]._NextSpanIdx;
oligomerBuilder.cc:558:	    sll << " " << zzi << "("<<this[01;31m-[00m>_Scaffolds[zzi]._BackSpanIdx<<")";
oligomerBuilder.cc:563:	    zzi = this[01;31m-[00m>_Scaffolds[zzi]._NextSpanIdx;
oligomerBuilder.cc:566:	{_BLOCK_TRACE("this[01;31m-[00m>_Scaffolds dump");
oligomerBuilder.cc:567:	    for ( zzi = 0; zzi < this[01;31m-[00m>_Scaffolds.size(); zzi++ )
oligomerBuilder.cc:569:		LOG(BF("Monomer@%d _NextSpanIdx(%d) _BackSpanIdx(%d) %s") % zzi % this[01;31m-[00m>_Scaffolds[zzi]._NextSpanIdx % this[01;31m-[00m>_Scaffolds[zzi]._BackSpanIdx % this[01;31m-[00m>_Scaffolds[zzi]._Monomer[01;31m-[00m>description().c_str()  ); // vp0(("Monomer@%d _NextSpanIdx(%d) _BackSpanIdx(%d) %s",zzi, this[01;31m-[00m>_Scaffolds[zzi]._NextSpanIdx, this[01;31m-[00m>_Scaffolds[zzi]._BackSpanIdx, this[01;31m-[00m>_Scaffolds[zzi]._Monomer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:584:    ss << "INTERESTING_ATOM: " << comment << " [01;31m-[00m " << endl;
oligomerBuilder.cc:586:    ii = this[01;31m-[00m>_InterestingAtomHolderIndices.begin();
oligomerBuilder.cc:587:    this[01;31m-[00m>_AllAtomHolders[*ii].streamDump(ss);
oligomerBuilder.cc:595:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:596:    ss << format("BuildSerialNumber(%d) =========  InterestingAtomHolders\n") % this[01;31m-[00m>_BuildSerialNumber;
oligomerBuilder.cc:598:    for ( vector<uint>::iterator  ii= this[01;31m-[00m>_InterestingAtomHolderIndices.begin();
oligomerBuilder.cc:599:    		ii!=this[01;31m-[00m>_InterestingAtomHolderIndices.end(); ii++ )
oligomerBuilder.cc:602:	this[01;31m-[00m>_AllAtomHolders[*ii].streamDump(ss);
oligomerBuilder.cc:608:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:609:    ss << format("BuildSerialNumber(%d) =========  OligomerBuilder dump\n") % this[01;31m-[00m>_BuildSerialNumber;
oligomerBuilder.cc:610:    ss << format("_StartScaffoldHolderListIndex(%d)\n") % this[01;31m-[00m>_StartScaffoldHolderListIndex;
oligomerBuilder.cc:611:    this[01;31m-[00m>interestingAtomDump(ss);
oligomerBuilder.cc:612:    ss << format("========[01;31m-[00mthis[01;31m-[00m>_Scaffolds\n");
oligomerBuilder.cc:613:    for ( vector<ScaffoldHolder>::iterator shi = this[01;31m-[00m>_Scaffolds.begin();
oligomerBuilder.cc:614:    		shi!=this[01;31m-[00m>_Scaffolds.end(); shi++ )
oligomerBuilder.cc:616:        ss << format(":::entry(%d)\n") % (shi[01;31m-[00mthis[01;31m-[00m>_Scaffolds.begin());
oligomerBuilder.cc:619:    ss << format("=========this[01;31m-[00m>_FrameHolders\n");
oligomerBuilder.cc:620:    for ( vector<FrameHolder>::iterator fhi = this[01;31m-[00m>_FrameHolders.begin();
oligomerBuilder.cc:621:    		fhi!=this[01;31m-[00m>_FrameHolders.end(); fhi++ )
oligomerBuilder.cc:623:        ss << format(":::entry(%d)\n") % (fhi[01;31m-[00mthis[01;31m-[00m>_FrameHolders.begin());
oligomerBuilder.cc:626:    ss << format("=========this[01;31m-[00m>_InterestingFragmentHolderIndices\n");
oligomerBuilder.cc:627:    for ( vector<uint>::iterator iii = this[01;31m-[00m>_InterestingFragmentHolderIndices.begin();
oligomerBuilder.cc:628:    		iii!=this[01;31m-[00m>_InterestingFragmentHolderIndices.end(); iii++ )
oligomerBuilder.cc:630:        ss << format(":::entry(%d)=%d\n") % (iii[01;31m-[00mthis[01;31m-[00m>_InterestingFragmentHolderIndices.begin()) % *iii;
oligomerBuilder.cc:632:    ss << format("=========this[01;31m-[00m>_AllFragmentHolders\n");
oligomerBuilder.cc:633:    for ( vector<FragmentHolder>::iterator fghi = this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:634:    		fghi!=this[01;31m-[00m>_AllFragmentHolders.end(); fghi++ )
oligomerBuilder.cc:636:        ss << format(":::entry(%d)\n") % (fghi[01;31m-[00mthis[01;31m-[00m>_AllFragmentHolders.begin());
oligomerBuilder.cc:639:    ss << format("=========this[01;31m-[00m>_InterestingAtomHolderIndices\n");
oligomerBuilder.cc:640:    for ( vector<uint>::iterator aii = this[01;31m-[00m>_InterestingAtomHolderIndices.begin();
oligomerBuilder.cc:641:    		aii!=this[01;31m-[00m>_InterestingAtomHolderIndices.end(); aii++ )
oligomerBuilder.cc:643:        ss << format(":::entry(%d)=%d\n") % (aii[01;31m-[00mthis[01;31m-[00m>_InterestingAtomHolderIndices.begin()) % *aii;
oligomerBuilder.cc:645:    ss << format("=========this[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices\n");
oligomerBuilder.cc:646:    for ( vector<uint>::iterator aii = this[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices.begin();
oligomerBuilder.cc:647:    		aii!=this[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices.end(); aii++ )
oligomerBuilder.cc:649:        ss << format(":::entry(%d)=%d\n") % (aii[01;31m-[00mthis[01;31m-[00m>_FragmentBuildInterestingAtomHolderIndices.begin())%*aii;
oligomerBuilder.cc:651:    ss << format("=========this[01;31m-[00m>_AllAtomHolders\n");
oligomerBuilder.cc:652:    for ( vector<AtomHolder>::iterator aaii = this[01;31m-[00m>_AllAtomHolders.begin();
oligomerBuilder.cc:653:    		aaii!=this[01;31m-[00m>_AllAtomHolders.end(); aaii++ )
oligomerBuilder.cc:655:        ss << format("::::entry(%d)\n") % (aaii[01;31m-[00mthis[01;31m-[00m>_AllAtomHolders.begin());
oligomerBuilder.cc:664:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:668:    this[01;31m-[00m>_FrameHolders.clear();
oligomerBuilder.cc:669:    frameHolderOrigin.initializeRoot(this[01;31m-[00m>sharedThis<O_OligomerBuilder>());
oligomerBuilder.cc:674:    this[01;31m-[00m>_FrameHolders.push_back(frameHolderOrigin);
oligomerBuilder.cc:677:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:678:    LOG(BF("Number of scaffolds = %d") % this[01;31m-[00m>_Scaffolds.size()  ); // vp0(("Number of scaffolds = %d", this[01;31m-[00m>_Scaffolds.size() ));
oligomerBuilder.cc:681:    {_BLOCK_TRACEF(BF("Allocating scaffold %s icur(%d)") % this[01;31m-[00m>_Scaffolds[icur]._Monomer[01;31m-[00m>description() % icur );
oligomerBuilder.cc:682:        ScaffoldHolder& curScaffold = this[01;31m-[00m>_Scaffolds[icur];
oligomerBuilder.cc:692:	    ASSERT_lessThan(backSpanIdx, this[01;31m-[00m>_Scaffolds.size() );
oligomerBuilder.cc:693:	    LOG(BF("backSpan scaffold %s") % this[01;31m-[00m>_Scaffolds[backSpanIdx]._Monomer[01;31m-[00m>description().c_str()  ); // vp0(("backSpan scaffold %s", this[01;31m-[00m>_Scaffolds[backSpanIdx]._Monomer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:694:	    parentScaffoldHolder = &(this[01;31m-[00m>_Scaffolds[backSpanIdx] );
oligomerBuilder.cc:697:	curScaffold.allocateFrameHolders(this[01;31m-[00m>sharedThis<O_OligomerBuilder>(), this[01;31m-[00m>_FrameHolders, parentScaffoldHolder );
oligomerBuilder.cc:699:	icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:706:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:709:FragmentHolder		fragmentHolder(this[01;31m-[00m>lisp());
oligomerBuilder.cc:711:    this[01;31m-[00m>_AllFragmentHolders.clear();
oligomerBuilder.cc:712:    this[01;31m-[00m>_InterestingFragmentHolderIndices.clear();
oligomerBuilder.cc:713:    this[01;31m-[00m>_InterestingAtomHolderIndices.clear();
oligomerBuilder.cc:714:    this[01;31m-[00m>_AllAtomHolders.clear();
oligomerBuilder.cc:718:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:720:    {_BLOCK_TRACEF(BF("Initializing FragmentHolders for monomer: %s") %	this[01;31m-[00m>_Scaffolds[icur]._Monomer[01;31m-[00m>description() );
oligomerBuilder.cc:721:        ScaffoldHolder& scaffoldHolder = this[01;31m-[00m>_Scaffolds[icur];
oligomerBuilder.cc:722:	beginFragmentHolderIndex = this[01;31m-[00m>_AllFragmentHolders.size();
oligomerBuilder.cc:723:	monomerCoordinates = this[01;31m-[00m>_Scaffolds[icur]._MonomerCoordinates;
oligomerBuilder.cc:726:		this[01;31m-[00m>_InterestingAtomHolderIndices.size();
oligomerBuilder.cc:730:	RPMonomer monomer = this[01;31m-[00m>_Scaffolds[icur]._Monomer;
oligomerBuilder.cc:731:	RPAtomIndexer interestingAtomIndexer = monomer[01;31m-[00m>getInterestingAtomIndexer();
oligomerBuilder.cc:732:	LOG(BF("Got AtomIndexer: %s") % interestingAtomIndexer[01;31m-[00m>description().c_str()  ); // vp0(("Got AtomIndexer: %s",interestingAtomIndexer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:733:	LOG(BF("Current this[01;31m-[00m>_InterestingAtomHolderIndices.size() = %d") % this[01;31m-[00m>_InterestingAtomHolderIndices.size()  ); // vp0(( "Current this[01;31m-[00m>_InterestingAtomHolderIndices.size() = %d", this[01;31m-[00m>_InterestingAtomHolderIndices.size() ));
oligomerBuilder.cc:734:	LOG(BF("interestingAtomIndexer[01;31m-[00m>numberOfAtomNames() = %d") % interestingAtomIndexer[01;31m-[00m>numberOfAtomNames()  ); // vp0(( "interestingAtomIndexer[01;31m-[00m>numberOfAtomNames() = %d", interestingAtomIndexer[01;31m-[00m>numberOfAtomNames() ));
oligomerBuilder.cc:735:	this[01;31m-[00m>_InterestingAtomHolderIndices.resize(
oligomerBuilder.cc:736:	    this[01;31m-[00m>_InterestingAtomHolderIndices.size()+interestingAtomIndexer[01;31m-[00m>numberOfAtomNames());
oligomerBuilder.cc:737:	LOG(BF("Resized this[01;31m-[00m>_InterestingAtomHolderIndices.size() = %d") % this[01;31m-[00m>_InterestingAtomHolderIndices.size()  ); // vp0(( "Resized this[01;31m-[00m>_InterestingAtomHolderIndices.size() = %d", this[01;31m-[00m>_InterestingAtomHolderIndices.size() ));
oligomerBuilder.cc:738:        scaffoldHolder._InterestingAtomIndicesEndIndex = this[01;31m-[00m>_InterestingAtomHolderIndices.size();
oligomerBuilder.cc:739:	for ( fci=monomerCoordinates[01;31m-[00m>begin_FragmentCoordinates();
oligomerBuilder.cc:740:		fci!=monomerCoordinates[01;31m-[00m>end_FragmentCoordinates(); fci++ )
oligomerBuilder.cc:741:	{_BLOCK_TRACEF(BF("About to initialize FragmentCoordinates for fragment: %s") %	(*fci)[01;31m-[00m>getFragmentName() );
oligomerBuilder.cc:743:	    			(*fci), this[01;31m-[00m>_Scaffolds[icur],
oligomerBuilder.cc:744:				this[01;31m-[00m>sharedThis<O_OligomerBuilder>(),
oligomerBuilder.cc:745:				this[01;31m-[00m>_AllFragmentHolders.size(),
oligomerBuilder.cc:752:	        LOG(BF("  adding its index (%d) to " "_InterestingFragmentHolderIndices") % this[01;31m-[00m>_AllFragmentHolders.size() ); // vp0(("  adding its index (%d) to " "_InterestingFragmentHolderIndices",this[01;31m-[00m>_AllFragmentHolders.size()));
oligomerBuilder.cc:753:	        this[01;31m-[00m>_InterestingFragmentHolderIndices.push_back( this[01;31m-[00m>_AllFragmentHolders.size());
oligomerBuilder.cc:755:	    this[01;31m-[00m>_AllFragmentHolders.push_back(fragmentHolder);
oligomerBuilder.cc:757:	this[01;31m-[00m>_Scaffolds[icur]._EndInterestingAtomHolderIndex =
oligomerBuilder.cc:758:		this[01;31m-[00m>_InterestingAtomHolderIndices.size();
oligomerBuilder.cc:759:	endFragmentHolderIndex = this[01;31m-[00m>_AllFragmentHolders.size();
oligomerBuilder.cc:760:	this[01;31m-[00m>_Scaffolds[icur]._BeginFragmentHolderIndex =
oligomerBuilder.cc:762:	this[01;31m-[00m>_Scaffolds[icur]._EndFragmentHolderIndex = endFragmentHolderIndex;
oligomerBuilder.cc:764:	LOG(BF("  _BeginFragmentHolderIndex=%d") % this[01;31m-[00m>_Scaffolds[icur]._BeginFragmentHolderIndex ); // vp0(("  _BeginFragmentHolderIndex=%d",this[01;31m-[00m>_Scaffolds[icur]._BeginFragmentHolderIndex));
oligomerBuilder.cc:765:	LOG(BF("  _EndFragmentHolderIndex=%d") % this[01;31m-[00m>_Scaffolds[icur]._EndFragmentHolderIndex ); // vp0(("  _EndFragmentHolderIndex=%d",this[01;31m-[00m>_Scaffolds[icur]._EndFragmentHolderIndex));
oligomerBuilder.cc:767:	icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:777:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:780:    this[01;31m-[00m>_HasError = false;
oligomerBuilder.cc:781:    this[01;31m-[00m>_Oligomer = oligomer;
oligomerBuilder.cc:782://    this[01;31m-[00m>_BuilderDatabaseRef = O_BuilderDatabaseReference::create(this[01;31m-[00m>lisp(),cdb,"");
oligomerBuilder.cc:783:    this[01;31m-[00m>_Scaffolds.clear();
oligomerBuilder.cc:789:    this[01;31m-[00m>_Molecule = this[01;31m-[00m>_Oligomer[01;31m-[00m>getMolecule();
oligomerBuilder.cc:792:    this[01;31m-[00m>_allocateSpaceForAllScaffolds();
oligomerBuilder.cc:793:    if ( this[01;31m-[00m>_HasError )
oligomerBuilder.cc:798:    iStartScaffoldHolder = this[01;31m-[00m>_identifyStartingScaffold();
oligomerBuilder.cc:799:    this[01;31m-[00m>_setStartScaffoldHolderListIndex(iStartScaffoldHolder);
oligomerBuilder.cc:801:    LOG(BF("this[01;31m-[00m>_Scaffolds.size() = %u") % this[01;31m-[00m>_Scaffolds.size()  ); // vp0(("this[01;31m-[00m>_Scaffolds.size() = %u", this[01;31m-[00m>_Scaffolds.size() ));
oligomerBuilder.cc:802:    ASSERT_lessThan(iStartScaffoldHolder,this[01;31m-[00m>_Scaffolds.size());
oligomerBuilder.cc:803:    this[01;31m-[00m>_buildSpanningTree(iStartScaffoldHolder);
oligomerBuilder.cc:807:    this[01;31m-[00m>_allocateAllFrameHolders();
oligomerBuilder.cc:811:    this[01;31m-[00m>_allocateAllFragmentHolders();
oligomerBuilder.cc:812:    if ( this[01;31m-[00m>_HasError )
oligomerBuilder.cc:825:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:826:    return this[01;31m-[00m>_Molecule;
oligomerBuilder.cc:835:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:838:    this[01;31m-[00m>_BuiltInterestingAtomsOnly = true;
oligomerBuilder.cc:839:    this[01;31m-[00m>_prepareToBuild();
oligomerBuilder.cc:840:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:846:	icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:849:	    this[01;31m-[00m>_Scaffolds[icur].buildScaffold(this[01;31m-[00m>sharedThis<O_OligomerBuilder>(),this[01;31m-[00m>_FrameHolders);
oligomerBuilder.cc:850:	    icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:859:	for ( ifi=this[01;31m-[00m>_InterestingFragmentHolderIndices.begin();
oligomerBuilder.cc:860:		    ifi!=this[01;31m-[00m>_InterestingFragmentHolderIndices.end(); ifi++ )
oligomerBuilder.cc:862:	    this[01;31m-[00m>_AllFragmentHolders[*ifi].buildInterestingUntransformedAtomPositions(this[01;31m-[00m>sharedThis<O_OligomerBuilder>());
oligomerBuilder.cc:871:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:873:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:874:    this[01;31m-[00m>_BuiltInterestingAtomsOnly = false;
oligomerBuilder.cc:875:    this[01;31m-[00m>_prepareToBuild();
oligomerBuilder.cc:881:	icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:884:	    this[01;31m-[00m>_Scaffolds[icur].buildScaffold(this[01;31m-[00m>sharedThis<O_OligomerBuilder>(),this[01;31m-[00m>_FrameHolders);
oligomerBuilder.cc:885:	    icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:889:    LOG(BF("At this point _NumberOfFramesBuilt = %d") % this[01;31m-[00m>_NumberOfFramesBuilt  ); // vp0(( "At this point _NumberOfFramesBuilt = %d", this[01;31m-[00m>_NumberOfFramesBuilt ));
oligomerBuilder.cc:896:	for ( ifi=this[01;31m-[00m>_InterestingFragmentHolderIndices.begin();
oligomerBuilder.cc:897:		    ifi!=this[01;31m-[00m>_InterestingFragmentHolderIndices.end(); ifi++ )
oligomerBuilder.cc:899:	    this[01;31m-[00m>_AllFragmentHolders[*ifi].buildInterestingUntransformedAtomPositions(this[01;31m-[00m>sharedThis<O_OligomerBuilder>());
oligomerBuilder.cc:907:	for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:908:		    fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:910:	    bool builtOne = fi[01;31m-[00m>buildAllAtoms(this[01;31m-[00m>sharedThis<O_OligomerBuilder>());
oligomerBuilder.cc:923:    LOG(BF("At this point _NumberOfFramesBuilt = %d") % this[01;31m-[00m>_NumberOfFramesBuilt  ); // vp0(( "At this point _NumberOfFramesBuilt = %d", this[01;31m-[00m>_NumberOfFramesBuilt ));
oligomerBuilder.cc:932:        LOG(BF("At this point _NumberOfFramesBuilt = %d") % this[01;31m-[00m>_NumberOfFramesBuilt  ); // vp0(( "At this point _NumberOfFramesBuilt = %d", this[01;31m-[00m>_NumberOfFramesBuilt ));
oligomerBuilder.cc:933:        this[01;31m-[00m>_finishAllUnbuiltFrames();
oligomerBuilder.cc:934:        LOG(BF("At this point _NumberOfFramesBuilt = %d") % this[01;31m-[00m>_NumberOfFramesBuilt  ); // vp0(( "At this point _NumberOfFramesBuilt = %d", this[01;31m-[00m>_NumberOfFramesBuilt ));
oligomerBuilder.cc:940:	for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:941:		    fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:943:	    if ( !fi[01;31m-[00m>hasBeenBuilt(this[01;31m-[00m>sharedThis<O_OligomerBuilder>()) )
oligomerBuilder.cc:945:	        allFragmentsWereBuilt &= fi[01;31m-[00m>buildAllAtoms(this[01;31m-[00m>sharedThis<O_OligomerBuilder>());
oligomerBuilder.cc:952:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:953:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:954:    ASSERTP(!this[01;31m-[00m>_BuiltInterestingAtomsOnly,"You asked to write all coordinates to atoms but you only built the interesting ones [01;31m-[00m build them all first");
oligomerBuilder.cc:956:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:957:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:959:	fi[01;31m-[00m>writeScoreTransformedCoordinatesToAtoms(this[01;31m-[00m>sharedThis<O_OligomerBuilder>(),scorerState);
oligomerBuilder.cc:966:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:967:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:969:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:970:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:972:	fi[01;31m-[00m>extractCoordinatesFromAtoms(this[01;31m-[00m>sharedThis<O_OligomerBuilder>());
oligomerBuilder.cc:982:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:986:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:989:        ss << this[01;31m-[00m>_Scaffolds[icur]._Monomer[01;31m-[00m>getName() << " ";
oligomerBuilder.cc:990:	icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:1000:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1002:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:1003:    	 fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1005:        fi[01;31m-[00m>setMask(mask);
oligomerBuilder.cc:1015:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1017:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin(); fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1019:        if ( fi[01;31m-[00m>_ScaffoldHolderPtr[01;31m-[00m>_Monomer == mon )
oligomerBuilder.cc:1021:            fi[01;31m-[00m>setMask(mask);
oligomerBuilder.cc:1031:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1035:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin(); fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1037:        if ( fi[01;31m-[00m>_ManipulateMask == mask )
oligomerBuilder.cc:1049:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1050:    frag[01;31m-[00m>_ManipulateMask = mask;
oligomerBuilder.cc:1056:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1061:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1063:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1064:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:1069:	    scaffoldFragmentHolder = &(this[01;31m-[00m>_AllFragmentHolders[this[01;31m-[00m>_Scaffolds[icur]._FragmentHolderIndex]);
oligomerBuilder.cc:1070:	    part = scaffoldFragmentHolder[01;31m-[00m>numberOfFragmentConformations(0);
oligomerBuilder.cc:1071:	    LOG(BF("Number of scaffold %s conformations = %d") % this[01;31m-[00m>_Scaffolds[icur]._Monomer[01;31m-[00m>description().c_str() % part ); // vp0(("Number of scaffold %s conformations = %d",this[01;31m-[00m>_Scaffolds[icur]._Monomer[01;31m-[00m>description().c_str(),part));
oligomerBuilder.cc:1073:	    icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:1081:	for ( ifi=this[01;31m-[00m>_InterestingFragmentHolderIndices.begin();
oligomerBuilder.cc:1082:		    ifi!=this[01;31m-[00m>_InterestingFragmentHolderIndices.end(); ifi++ )
oligomerBuilder.cc:1087:	    if ( this[01;31m-[00m>_AllFragmentHolders[*ifi]._LockToScaffoldConformation ) continue;	// don't double count scaffold fragments
oligomerBuilder.cc:1088:	    part = this[01;31m-[00m>_AllFragmentHolders[*ifi].numberOfFragmentConformations(0);
oligomerBuilder.cc:1089:	    scaffoldHolderPtr = this[01;31m-[00m>_AllFragmentHolders[*ifi]._ScaffoldHolderPtr;
oligomerBuilder.cc:1091:	    LOG(BF("     %s") % scaffoldHolderPtr[01;31m-[00m>_Monomer[01;31m-[00m>description().c_str() ); // vp0(("     %s",scaffoldHolderPtr[01;31m-[00m>_Monomer[01;31m-[00m>description().c_str()));
oligomerBuilder.cc:1092:	    LOG(BF("     %s") % this[01;31m-[00m>_AllFragmentHolders[*ifi].description().c_str() ); // vp0(("     %s",this[01;31m-[00m>_AllFragmentHolders[*ifi].description().c_str()));
oligomerBuilder.cc:1104:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1106:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1107:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1108:    uint icur = randomNumber01(_lisp)*this[01;31m-[00m>_Scaffolds.size();
oligomerBuilder.cc:1109:    scaffoldFragmentHolder = &(this[01;31m-[00m>_AllFragmentHolders[this[01;31m-[00m>_Scaffolds[icur]._FragmentHolderIndex]);
oligomerBuilder.cc:1110:    scaffoldFragmentHolder[01;31m-[00m>randomizeFragmentConformation(0);
oligomerBuilder.cc:1113:    		randomNumber01(_lisp)*this[01;31m-[00m>_InterestingFragmentHolderIndices.size();
oligomerBuilder.cc:1114:    uint ifi = this[01;31m-[00m>_InterestingFragmentHolderIndices[interestingFragmentHolderIndexIndex];
oligomerBuilder.cc:1115:    if ( this[01;31m-[00m>_AllFragmentHolders[ifi]._LockToScaffoldConformation ) return;
oligomerBuilder.cc:1116:    this[01;31m-[00m>_AllFragmentHolders[ifi].randomizeFragmentConformation(0);
oligomerBuilder.cc:1121:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1123:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1124:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1125:    uint icur = randomNumber01(_lisp)*this[01;31m-[00m>_Scaffolds.size();
oligomerBuilder.cc:1126:    scaffoldFragmentHolder = &(this[01;31m-[00m>_AllFragmentHolders[this[01;31m-[00m>_Scaffolds[icur]._FragmentHolderIndex]);
oligomerBuilder.cc:1127:    scaffoldFragmentHolder[01;31m-[00m>randomizeFragmentConformation(0);
oligomerBuilder.cc:1129:    uint ifi = randomNumber01(_lisp)*this[01;31m-[00m>_AllFragmentHolders.size();
oligomerBuilder.cc:1130:    if ( this[01;31m-[00m>_AllFragmentHolders[ifi]._LockToScaffoldConformation ) return;
oligomerBuilder.cc:1131:    this[01;31m-[00m>_AllFragmentHolders[ifi].randomizeFragmentConformation(0);
oligomerBuilder.cc:1137:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1140:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1141:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1142:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:1151:	    scaffoldFragmentHolder = &(this[01;31m-[00m>_AllFragmentHolders[this[01;31m-[00m>_Scaffolds[icur]._FragmentHolderIndex]);
oligomerBuilder.cc:1152:	    scaffoldFragmentHolder[01;31m-[00m>randomizeFragmentConformation(0);
oligomerBuilder.cc:1153:	    icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:1159:	for ( ifi=this[01;31m-[00m>_InterestingFragmentHolderIndices.begin();
oligomerBuilder.cc:1160:		    ifi!=this[01;31m-[00m>_InterestingFragmentHolderIndices.end(); ifi++ )
oligomerBuilder.cc:1165:	    if ( this[01;31m-[00m>_AllFragmentHolders[*ifi]._LockToScaffoldConformation ) continue;
oligomerBuilder.cc:1166:	    this[01;31m-[00m>_AllFragmentHolders[*ifi].randomizeFragmentConformation(0);
oligomerBuilder.cc:1176:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1179:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1180:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1181:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:1190:	    scaffoldFragmentHolder = &(this[01;31m-[00m>_AllFragmentHolders[this[01;31m-[00m>_Scaffolds[icur]._FragmentHolderIndex]);
oligomerBuilder.cc:1191:	    if ( scaffoldFragmentHolder[01;31m-[00m>incrementFragmentConformation(0) ) return true;
oligomerBuilder.cc:1192:	    icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:1198:	for ( ifi=this[01;31m-[00m>_InterestingFragmentHolderIndices.begin();
oligomerBuilder.cc:1199:		    ifi!=this[01;31m-[00m>_InterestingFragmentHolderIndices.end(); ifi++ )
oligomerBuilder.cc:1204:	    if ( this[01;31m-[00m>_AllFragmentHolders[*ifi]._LockToScaffoldConformation ) continue;
oligomerBuilder.cc:1205:	    if ( this[01;31m-[00m>_AllFragmentHolders[*ifi].incrementFragmentConformation(0) ) return true;
oligomerBuilder.cc:1212:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1214:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1215:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1219:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:1220:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1222:	LOG(BF("Looking at fragment(%s) for %s") % fi[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>getFragmentName().c_str() % fi[01;31m-[00m>_ScaffoldHolderPtr[01;31m-[00m>_Monomer[01;31m-[00m>description().c_str()  ); // vp0(("Looking at fragment(%s) for %s", fi[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>getFragmentName().c_str(), fi[01;31m-[00m>_ScaffoldHolderPtr[01;31m-[00m>_Monomer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:1223:        num = fi[01;31m-[00m>numberOfFragmentConformations(mask);
oligomerBuilder.cc:1234:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1236:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1237:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1240:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:1244:        LOG(BF("Looking at [01;31m-[00m[01;31m-[00m[01;31m-[00mscaffold for monomer: %s") % this[01;31m-[00m>_Scaffolds[icur]._Monomer[01;31m-[00m>description().c_str()  ); // vp0(("Looking at [01;31m-[00m[01;31m-[00m[01;31m-[00mscaffold for monomer: %s",this[01;31m-[00m>_Scaffolds[icur]._Monomer[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:1245:	num = this[01;31m-[00m>_Scaffolds[icur].numberOfScaffolds();
oligomerBuilder.cc:1249:	icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:1254:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:1255:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1257:	LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m") ); // vp0(("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m"));
oligomerBuilder.cc:1258:        LOG(BF("Looking at fragment(%s) for %s") % fi[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>getFragmentName().c_str() % fi[01;31m-[00m>description().c_str()  ); // vp0(("Looking at fragment(%s) for %s",fi[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>getFragmentName().c_str(),fi[01;31m-[00m>description().c_str() ));
oligomerBuilder.cc:1259:	num = fi[01;31m-[00m>numberOfFragmentConformations(0);
oligomerBuilder.cc:1270:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1271:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1272:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1276:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:1277:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1279:	fi[01;31m-[00m>randomizeFragmentConformation(mask);
oligomerBuilder.cc:1286:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1287:    if ( this[01;31m-[00m>_HasError )
oligomerBuilder.cc:1291:	serr << this[01;31m-[00m>errorMessage();
oligomerBuilder.cc:1292:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>(serr.str()));
oligomerBuilder.cc:1294:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1295:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1299:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:1300:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1302:	fi[01;31m-[00m>gotoFirstFragmentConformation(mask);
oligomerBuilder.cc:1308:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1314:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1315:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:1316:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1318:        if ( fi[01;31m-[00m>matchesMask(mask) )
oligomerBuilder.cc:1320:	    num = fi[01;31m-[00m>_FragmentCoordinates[01;31m-[00m>numberOfCoordinateArrays();
oligomerBuilder.cc:1321:	    LOG(BF("For %s number of conformations(%d)") % fi[01;31m-[00m>description().c_str() % num  ); // vp0(("For %s number of conformations(%d)",fi[01;31m-[00m>description().c_str(),num ));
oligomerBuilder.cc:1328:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin(),di=digits.begin();
oligomerBuilder.cc:1329:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1331:        if ( fi[01;31m-[00m>matchesMask(mask) )
oligomerBuilder.cc:1333:	    LOG(BF("Setting %s to conformation(%d)") % fi[01;31m-[00m>description().c_str() % *di  ); // vp0(("Setting %s to conformation(%d)",fi[01;31m-[00m>description().c_str(),*di ));
oligomerBuilder.cc:1334:	    fi[01;31m-[00m>gotoFragmentConformation(mask,*di);
oligomerBuilder.cc:1342:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1343:    this[01;31m-[00m>gotoMaskConformation(0,index);
oligomerBuilder.cc:1348:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1349:    this[01;31m-[00m>gotoFirstMaskConformation(0);
oligomerBuilder.cc:1354:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1357:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1358:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1359:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:1368:	    scaffoldFragmentHolder = &(this[01;31m-[00m>_AllFragmentHolders[this[01;31m-[00m>_Scaffolds[icur]._FragmentHolderIndex]);
oligomerBuilder.cc:1369:	    if ( scaffoldFragmentHolder[01;31m-[00m>incrementFragmentConformation(mask) ) return true;
oligomerBuilder.cc:1370:	    icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:1376:	for ( ifi=this[01;31m-[00m>_InterestingFragmentHolderIndices.begin();
oligomerBuilder.cc:1377:		    ifi!=this[01;31m-[00m>_InterestingFragmentHolderIndices.end(); ifi++ )
oligomerBuilder.cc:1382:	    if ( this[01;31m-[00m>_AllFragmentHolders[*ifi]._LockToScaffoldConformation ) continue;
oligomerBuilder.cc:1383:	    if ( this[01;31m-[00m>_AllFragmentHolders[*ifi].incrementFragmentConformation(mask) ) return true;
oligomerBuilder.cc:1391:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1392:    return this[01;31m-[00m>incrementMaskConformations(0);
oligomerBuilder.cc:1396:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1397:    ASSERT(!this[01;31m-[00m>_HasError);
oligomerBuilder.cc:1398:    LOG(BF("There are %d scaffoldHolders") % this[01;31m-[00m>_Scaffolds.size() ); // vp0(("There are %d scaffoldHolders",this[01;31m-[00m>_Scaffolds.size()));
oligomerBuilder.cc:1402:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:1403:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++ )
oligomerBuilder.cc:1405:	fi[01;31m-[00m>randomizeFragmentConformation(0);
oligomerBuilder.cc:1412:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1416:    iScaffoldHolder = mon[01;31m-[00m>getTemporaryInt();
oligomerBuilder.cc:1417:    mc = this[01;31m-[00m>_Scaffolds[iScaffoldHolder]._MonomerCoordinates;
oligomerBuilder.cc:1418:    sl = mc[01;31m-[00m>getScaffoldList();
oligomerBuilder.cc:1419:    return sl[01;31m-[00m>numberOfScaffolds();
oligomerBuilder.cc:1424:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1428:    iScaffoldHolder = mon[01;31m-[00m>getTemporaryInt();
oligomerBuilder.cc:1429:    mc = this[01;31m-[00m>_Scaffolds[iScaffoldHolder]._MonomerCoordinates;
oligomerBuilder.cc:1430:    sl = mc[01;31m-[00m>getScaffoldList();
oligomerBuilder.cc:1431:    ASSERT_lessThan(i,sl[01;31m-[00m>numberOfScaffolds());
oligomerBuilder.cc:1432:    this[01;31m-[00m>_Scaffolds[iScaffoldHolder]._removeScaffoldListIndex = i;
oligomerBuilder.cc:1438:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1445:    scaffoldHolderPtr = &this[01;31m-[00m>_Scaffolds[iScaffoldHolder];
oligomerBuilder.cc:1446:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:1447:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++)
oligomerBuilder.cc:1449:	if (fi[01;31m-[00m>_ScaffoldHolderPtr == scaffoldHolderPtr )
oligomerBuilder.cc:1451:	    fc = fi[01;31m-[00m>_FragmentCoordinates;
oligomerBuilder.cc:1452:	    if ( fc[01;31m-[00m>getFragmentName() == fragmentName )
oligomerBuilder.cc:1454:		return fc[01;31m-[00m>numberOfCoordinateArrays();
oligomerBuilder.cc:1464:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1470:    scaffoldHolderPtr = &this[01;31m-[00m>_Scaffolds[iScaffoldHolder];
oligomerBuilder.cc:1471:    for ( fi=this[01;31m-[00m>_AllFragmentHolders.begin();
oligomerBuilder.cc:1472:    		fi!=this[01;31m-[00m>_AllFragmentHolders.end(); fi++)
oligomerBuilder.cc:1474:	if (fi[01;31m-[00m>_ScaffoldHolderPtr == scaffoldHolderPtr )
oligomerBuilder.cc:1476:	    fc = fi[01;31m-[00m>_FragmentCoordinates;
oligomerBuilder.cc:1477:	    if ( fc[01;31m-[00m>getFragmentName() == fragmentName )
oligomerBuilder.cc:1479:		if ( fi[01;31m-[00m>_LockToScaffoldConformation )
oligomerBuilder.cc:1484:		ASSERT_lessThan(iconf,fc[01;31m-[00m>numberOfCoordinateArrays());
oligomerBuilder.cc:1485:		fi[01;31m-[00m>_FragmentConformationIndex = iconf;
oligomerBuilder.cc:1493:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1501:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:1505:	fragmentHolderIndex = this[01;31m-[00m>_Scaffolds[icur]._FragmentHolderIndex;
oligomerBuilder.cc:1506:        iConf = this[01;31m-[00m>_AllFragmentHolders[fragmentHolderIndex]._localFragmentConformationIndex;
oligomerBuilder.cc:1507:	monomerComment = this[01;31m-[00m>_Scaffolds[icur]._Monomer[01;31m-[00m>getComment();
oligomerBuilder.cc:1508:	mc = this[01;31m-[00m>_Scaffolds[icur]._MonomerCoordinates;
oligomerBuilder.cc:1509:	sl = mc[01;31m-[00m>getScaffoldList();
oligomerBuilder.cc:1511:	ss << iConf << "/" << sl[01;31m-[00m>numberOfScaffolds() << ")"<<endl;
oligomerBuilder.cc:1512:	icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:1521:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1530:    RPRenderDisplayList dlAll = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1531:    icur = this[01;31m-[00m>_getStartScaffoldHolderListIndex();
oligomerBuilder.cc:1535:	RPRenderDisplayList dlMonomer = this[01;31m-[00m>_Scaffolds[icur].rendered(this[01;31m-[00m>sharedThis<O_OligomerBuilder>());
oligomerBuilder.cc:1536:	dlMonomer[01;31m-[00m>setName(this[01;31m-[00m>_Scaffolds[icur]._Monomer[01;31m-[00m>getId());
oligomerBuilder.cc:1537:	dlAll[01;31m-[00m>add(dlMonomer);
oligomerBuilder.cc:1538:	icur = this[01;31m-[00m>_advanceToNextScaffoldHolder(icur);
oligomerBuilder.cc:1545:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1548:    RPCoordinateArray array = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>(this[01;31m-[00m>_AllAtomHolders.size());
oligomerBuilder.cc:1551:    for ( ai=this[01;31m-[00m>_AllAtomHolders.begin(), ci= array[01;31m-[00m>begin(); ai!=this[01;31m-[00m>_AllAtomHolders.end(); ai++, ci++ )
oligomerBuilder.cc:1553:	(*ci) = scorerState[01;31m-[00m>scoreTransform()*(ai[01;31m-[00m>_Pos);
oligomerBuilder.cc:1562:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1563:    ASSERTP(array[01;31m-[00m>size() == this[01;31m-[00m>_AllAtomHolders.size(), "The CoordinateArray has to have the same number of entries as _AllAtomHolders");
oligomerBuilder.cc:1566:    for ( ai=this[01;31m-[00m>_AllAtomHolders.begin(), ci= array[01;31m-[00m>begin(); ai!=this[01;31m-[00m>_AllAtomHolders.end(); ai++, ci++ )
oligomerBuilder.cc:1568:	ai[01;31m-[00m>_Pos = (*ci);
oligomerBuilder.cc:1576:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1580:    num = this[01;31m-[00m>_Scaffolds[monomerSequenceNumber]._EndInterestingAtomHolderIndex
oligomerBuilder.cc:1581:	    	[01;31m-[00mthis[01;31m-[00m>_Scaffolds[monomerSequenceNumber]._BeginInterestingAtomHolderIndex;
oligomerBuilder.cc:1582:    ASSERT_lessThan(monomerSequenceNumber,this[01;31m-[00m>_Scaffolds.size());
oligomerBuilder.cc:1584:    idx = this[01;31m-[00m>_Scaffolds[monomerSequenceNumber]._BeginInterestingAtomHolderIndex+atomHandle;
oligomerBuilder.cc:1585:    atomHolderIndex = this[01;31m-[00m>_InterestingAtomHolderIndices[idx];
oligomerBuilder.cc:1586:    return this[01;31m-[00m>_AllAtomHolders[atomHolderIndex]._Atom;
oligomerBuilder.cc:1591:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1596:    num = this[01;31m-[00m>_Scaffolds[monomerSequenceNumber]._EndInterestingAtomHolderIndex
oligomerBuilder.cc:1597:    	[01;31m-[00mthis[01;31m-[00m>_Scaffolds[monomerSequenceNumber]._BeginInterestingAtomHolderIndex;
oligomerBuilder.cc:1598:    ASSERT_lessThan(monomerSequenceNumber,this[01;31m-[00m>_Scaffolds.size());
oligomerBuilder.cc:1600:    idx = this[01;31m-[00m>_Scaffolds[monomerSequenceNumber]._BeginInterestingAtomHolderIndex+atomHandle;
oligomerBuilder.cc:1601:    atomHolderIndex = this[01;31m-[00m>_InterestingAtomHolderIndices[idx];
oligomerBuilder.cc:1602:    LOG(BF("Got atom with name(%s)") % this[01;31m-[00m>_AllAtomHolders[atomHolderIndex]._Atom[01;31m-[00m>getName().c_str()  ); // vp0(("Got atom with name(%s)",this[01;31m-[00m>_AllAtomHolders[atomHolderIndex]._Atom[01;31m-[00m>getName().c_str() ));
oligomerBuilder.cc:1603:    return this[01;31m-[00m>_AllAtomHolders[atomHolderIndex]._Pos;
oligomerBuilder.cc:1613:	class_<O_OligomerBuilder>(this[01;31m-[00m>lisp())
oligomerBuilder.cc:1652:{_F(this[01;31m-[00m>lisp());
oligomerBuilder.cc:1656:    holders = this[01;31m-[00m>fragmentsWithMask(mask);
omatrix.cc:17:    node[01;31m-[00m>archivePlainObject<Matrix>( "matrix",
omatrix.cc:18:    				"Matrix", this[01;31m-[00m>_Value);
omatrix.cc:25:    ss << this[01;31m-[00m>_Value.asString();
omatrix.cc:30:    return this[01;31m-[00m>__repr__();
omatrix.cc:35:{_F(this[01;31m-[00m>lisp());
omatrix.cc:36:    this[01;31m-[00m>_Value.setFromString(s,_lisp);
omatrix.cc:40:{_F(this[01;31m-[00m>lisp());
omatrix.cc:41:    this[01;31m-[00m>_Value.setFromStringFast(s,this[01;31m-[00m>lisp());
omatrix.cc:46:{_F(this[01;31m-[00m>lisp());
omatrix.cc:47:    this[01;31m-[00m>_Value.setAll(m);
omatrix.cc:50:string O_OMatrix::asStringFast() { return this[01;31m-[00m>_Value.asStringFast(); }
omatrix.cc:51:string O_OMatrix::asString() { return this[01;31m-[00m>_Value.asString(); }
omatrix.cc:52:void O_OMatrix::identity() { this[01;31m-[00m>_Value.identity(); }
omatrix.cc:53:void O_OMatrix::translate(Vector3 pos) { this[01;31m-[00m>_Value.translate(&pos); }
omatrix.cc:54:void O_OMatrix::rotationX(double radians) { this[01;31m-[00m>_Value.rotationX(radians); }
omatrix.cc:55:void O_OMatrix::rotationY(double radians) { this[01;31m-[00m>_Value.rotationY(radians); }
omatrix.cc:56:void O_OMatrix::rotationZ(double radians) { this[01;31m-[00m>_Value.rotationZ(radians); }
omatrix.cc:63:        class_<O_OMatrix>(this[01;31m-[00m>lisp())
ovector3.cc:16:{_F(this[01;31m-[00m>lisp());
ovector3.cc:17:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_OVector3>(args,environment);
ovector3.cc:18:    double x = from_object<double>::convert(bargs[01;31m-[00m>lookup("x"));
ovector3.cc:19:    double y = from_object<double>::convert(bargs[01;31m-[00m>lookup("y"));
ovector3.cc:20:    double z = from_object<double>::convert(bargs[01;31m-[00m>lookup("z"));
ovector3.cc:22:    this[01;31m-[00m>_Value[0] = x;
ovector3.cc:23:    this[01;31m-[00m>_Value[1] = y;
ovector3.cc:24:    this[01;31m-[00m>_Value[2] = z;
ovector3.cc:25:    return lisp[01;31m-[00m>onil();
ovector3.cc:30:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "pos","Vector3", 
ovector3.cc:31:    					this[01;31m-[00m>_Value.isDefined(), this[01;31m-[00m>_Value);
ovector3.cc:38:    ss << this[01;31m-[00m>_Value.getX() << " ";
ovector3.cc:39:    ss << this[01;31m-[00m>_Value.getY() << " ";
ovector3.cc:40:    ss << this[01;31m-[00m>_Value.getZ();
ovector3.cc:45:    return this[01;31m-[00m>__repr__();
ovector3.cc:50:	Vector3 s = this[01;31m-[00m>_Value.sub(other);
ovector3.cc:56:	double l = this[01;31m-[00m>_Value.length();
ovector3.cc:62:	Vector3 s = this[01;31m-[00m>_Value.crossProduct(other);
ovector3.cc:68:	double d = this[01;31m-[00m>_Value.dotProduct(other);
ovector3.cc:76:	while ( args[01;31m-[00m>notNil() )
ovector3.cc:78:	    RPOVector3 one = args[01;31m-[00m>as<O_OVector3>();
ovector3.cc:79:	    sum = sum.add(one[01;31m-[00m>get());
ovector3.cc:81:	return O_OVector3::createFromVector3(args[01;31m-[00m>lisp(),sum);
ovector3.cc:88:	Vector3 result = Vector3(this[01;31m-[00m>getX(),this[01;31m-[00m>getY(),this[01;31m-[00m>getZ());
ovector3.cc:89:	args = args[01;31m-[00m>cdr();
ovector3.cc:91:	while ( args[01;31m-[00m>notNil() )
ovector3.cc:93:	    if ( args[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_Cons>() )
ovector3.cc:95:		RPCons cur = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
ovector3.cc:96:		while ( cur[01;31m-[00m>notNil() )
ovector3.cc:98:		    RPOVector3 o = cur[01;31m-[00m>car<O_OVector3>();
ovector3.cc:99:		    result = result.add(o[01;31m-[00m>get());
ovector3.cc:100:		    LOG(BF("Adding %s") % o[01;31m-[00m>__repr__() );
ovector3.cc:102:		    cur = cur[01;31m-[00m>cdr();
ovector3.cc:104:	    } else if ( args[01;31m-[00m>ocar()[01;31m-[00m>isAssignableTo<O_OVector3>() )
ovector3.cc:106:		RPOVector3 other = args[01;31m-[00m>car<O_OVector3>();
ovector3.cc:107:		result = result.add(other[01;31m-[00m>get());
ovector3.cc:110:		TOSS(lisp[01;31m-[00m>create<O_LispError>(BF("Illegal object class(%s) in OVector3 add") % args[01;31m-[00m>ocar()[01;31m-[00m>className() ) );
ovector3.cc:112:	    args = args[01;31m-[00m>cdr();
ovector3.cc:121:    Vector3 p = this[01;31m-[00m>_Value.multiplyByScalar(d);
ovector3.cc:128:	return this[01;31m-[00m>_Value.normalized(this[01;31m-[00m>lisp());
ovector3.cc:133:    return calculateDihedral(this[01;31m-[00m>_Value,vb,vc,vd,this[01;31m-[00m>lisp());
ovector3.cc:138:    return calculateAngle(this[01;31m-[00m>_Value,vb,vc,this[01;31m-[00m>lisp());
ovector3.cc:143:    return calculateDistance(this[01;31m-[00m>_Value,vb,this[01;31m-[00m>lisp());
ovector3.cc:151:        class_<O_OVector3>(this[01;31m-[00m>lisp())
package.cc:18:    class_<O_Package>(e[01;31m-[00m>lisp())
package.cc:39:    p[01;31m-[00m>setName(name);
package.cc:46:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
package.cc:52:    this[01;31m-[00m>Base::initialize();
package.cc:53:    this[01;31m-[00m>_KeywordPackage = false;
package.cc:54:    this[01;31m-[00m>_AmpPackage = false;
package.cc:60:    ss << "#<" << this[01;31m-[00m>_Name << ">";
package.cc:66:    this[01;31m-[00m>Base::archiveBase(node);
package.cc:67:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
package.cc:68:    node[01;31m-[00m>archiveMap("symbols",this[01;31m-[00m>_Symbols);
package.cc:69:    node[01;31m-[00m>archiveList("usingPackages",this[01;31m-[00m>_UsingPackages);
package.cc:70:    node[01;31m-[00m>archiveListIfDefined("exportedSymbols",this[01;31m-[00m>_ExportedSymbols);
package.cc:71:    node[01;31m-[00m>archiveMapIfDefined("shadowedSymbols",this[01;31m-[00m>_ShadowedSymbols);
package.cc:76:{_F(this[01;31m-[00m>lisp());
package.cc:78:    for ( Map<O_Symbol>::iterator mi=this[01;31m-[00m>_Symbols.begin(); mi!=this[01;31m-[00m>_Symbols.end(); mi++ )
package.cc:80:	ss << this[01;31m-[00m>getName() << " [01;31m-[00m[01;31m-[00m> " << mi[01;31m-[00m>second[01;31m-[00m>currentName() << endl;
package.cc:90:    ei = this[01;31m-[00m>_ShadowedSymbols.find(name);
package.cc:91:    if ( ei!=this[01;31m-[00m>_ShadowedSymbols.end() )
package.cc:93:	return ei[01;31m-[00m>second;
package.cc:96:    ei = this[01;31m-[00m>_Symbols.find(name);
package.cc:97:    if ( ei!=this[01;31m-[00m>_Symbols.end() )
package.cc:99:	return ei[01;31m-[00m>second;
package.cc:101:    return O_Symbol::nil(this[01;31m-[00m>lisp());
package.cc:107:    List<O_Symbol>& exportedSymbols = otherPackage[01;31m-[00m>_ExportedSymbols;
package.cc:110:	if ( this[01;31m-[00m>findSymbol((*si)[01;31m-[00m>identifierName())[01;31m-[00m>notNil() ) return true;
package.cc:118://    if ( this[01;31m-[00m>areThereNameCollisions(usePackage) ) return false;
package.cc:119:    List<O_Symbol>& exportedSymbols = usePackage[01;31m-[00m>_ExportedSymbols;
package.cc:122:	this[01;31m-[00m>import((*si)[01;31m-[00m>identifierName(),(*si));
package.cc:131:    this[01;31m-[00m>_ExportedSymbols.clear();
package.cc:132:    for (si=this[01;31m-[00m>_Symbols.begin(); si!=this[01;31m-[00m>_Symbols.end(); si++ )
package.cc:134:	this[01;31m-[00m>_ExportedSymbols.push_back(si[01;31m-[00m>second);
package.cc:141:    RPSymbol sym = this[01;31m-[00m>findSymbol(name);
package.cc:142:    if ( sym[01;31m-[00m>isNil() )
package.cc:144:	sym = O_Symbol::create(this[01;31m-[00m>lisp(),name);
package.cc:145:	sym[01;31m-[00m>setPackage(this[01;31m-[00m>sharedThis<O_Package>());
package.cc:146:	this[01;31m-[00m>_Symbols.set(name,sym);
package.cc:154:	if (this[01;31m-[00m>_ShadowedSymbols.count(symbolName)>0)
package.cc:156:	    TOSS(_lisp[01;31m-[00m>error(BF("Shadow symbol(%s) already exists in package(%s)") % symbolName % this[01;31m-[00m>_Name ));
package.cc:158:	if ( this[01;31m-[00m>_Symbols.contains(symbolName))
package.cc:160:	    LOG(BF("Importing shadow symbol name(%s) symbol(%s)") % symbolName % symbol[01;31m-[00m>__repr__() );
package.cc:161:	    this[01;31m-[00m>_ShadowedSymbols.set(symbolName,symbol);
package.cc:164:	    LOG(BF("Importing symbol name(%s) symbol(%s)") % symbolName % symbol[01;31m-[00m>__repr__() );
package.cc:165:	    this[01;31m-[00m>_Symbols.set(symbolName,symbol);
package.cc:171:    this[01;31m-[00m>_Symbols.set(symbolName,symbol);
pdb.cc:46:    virtual ~AtomPdbRec() {this[01;31m-[00m>_atom.reset();};
pdb.cc:87:    int	firstChar = firstChar1 [01;31m-[00m 1;
pdb.cc:88:    int lastChar = lastChar1 [01;31m-[00m 1;
pdb.cc:120:    this[01;31m-[00m>_atom = lisp[01;31m-[00m>nil<O_Atom>();
pdb.cc:126:    if ( this[01;31m-[00m>_name.size() > 3 )
pdb.cc:128:	name = this[01;31m-[00m>_name.substr(3,1)+this[01;31m-[00m>_name.substr(0,3);
pdb.cc:131:        name = " " + this[01;31m-[00m>_name;
pdb.cc:133:    fout << boost::format( "ATOM%7d %[01;31m-[00m4s %3s %1s%4d    %8.3f%8.3f%8.3f %5.2f %5.2f           %1s" ) % this[01;31m-[00m>_serial % name % this[01;31m-[00m>_resName % this[01;31m-[00m>_chainId % this[01;31m-[00m>_resSeq % this[01;31m-[00m>_x % this[01;31m-[00m>_y % this[01;31m-[00m>_z % this[01;31m-[00m>_occupancy % this[01;31m-[00m>_tempFactor % this[01;31m-[00m>_element;
pdb.cc:139:    this[01;31m-[00m>_atoms.push_back(atom);
pdb.cc:140:    this[01;31m-[00m>_atomRecIndexFromSerial[atom._serial] = this[01;31m-[00m>_atoms.size()[01;31m-[00m1;
pdb.cc:146:    this[01;31m-[00m>_connects.push_back(connect);
pdb.cc:155:    this[01;31m-[00m>_line = line;
pdb.cc:156:    this[01;31m-[00m>_recordName = pdb_substr(line,1,6);
pdb.cc:157:    this[01;31m-[00m>_serial = pdb_substr_int(line,7,11,[01;31m-[00m1);
pdb.cc:160:    this[01;31m-[00m>_name = name3+name1;
pdb.cc:161:    this[01;31m-[00m>_altLoc = pdb_substr(line,17,17);
pdb.cc:162:    this[01;31m-[00m>_resName = pdb_substr(line,18,20);
pdb.cc:163:    this[01;31m-[00m>_chainId = pdb_substr(line,22,22);
pdb.cc:164:    this[01;31m-[00m>_resSeq = pdb_substr_int(line,23,26,0);
pdb.cc:165:    this[01;31m-[00m>_iCode = pdb_substr(line,27,27);
pdb.cc:166:    this[01;31m-[00m>_x = pdb_substr_double(line,31,38,0.0);
pdb.cc:167:    this[01;31m-[00m>_y = pdb_substr_double(line,39,46,0.0);
pdb.cc:168:    this[01;31m-[00m>_z = pdb_substr_double(line,47,54,0.0);
pdb.cc:169:    this[01;31m-[00m>_occupancy = pdb_substr_double(line,55,60,0.0);
pdb.cc:170:    this[01;31m-[00m>_tempFactor = pdb_substr_double(line,61,66,0.0);
pdb.cc:171:    this[01;31m-[00m>_element = pdb_substr(line,77,78);
pdb.cc:172:    this[01;31m-[00m>_charge = pdb_substr(line,79,80);
pdb.cc:179:    atom[01;31m-[00m>setName(this[01;31m-[00m>_name);
pdb.cc:181:    pos.set(this[01;31m-[00m>_x,this[01;31m-[00m>_y,this[01;31m-[00m>_z);
pdb.cc:182:    atom[01;31m-[00m>setPosition(pos);
pdb.cc:183:    if ( this[01;31m-[00m>_element != "" )
pdb.cc:185:        atom[01;31m-[00m>setElementFromString(this[01;31m-[00m>_element);
pdb.cc:188:	atom[01;31m-[00m>setElement(elementFromNameCaseInsensitive(this[01;31m-[00m>_name,lisp));
pdb.cc:199:    this[01;31m-[00m>_atom1   = pdb_substr_int(line,  7, 11, [01;31m-[00m1 );
pdb.cc:200:    this[01;31m-[00m>_bonded[0] = pdb_substr_int(line, 12, 16, [01;31m-[00m1 );
pdb.cc:201:    this[01;31m-[00m>_bonded[1] = pdb_substr_int(line, 17, 21, [01;31m-[00m1 );
pdb.cc:202:    this[01;31m-[00m>_bonded[2] = pdb_substr_int(line, 22, 26, [01;31m-[00m1 );
pdb.cc:203:    this[01;31m-[00m>_bonded[3] = pdb_substr_int(line, 27, 31, [01;31m-[00m1 );
pdb.cc:211:    fout << this[01;31m-[00m>_atom1;
pdb.cc:214:	if ( this[01;31m-[00m>_bonded[i]>0 )
pdb.cc:216:	    fout << setw(5) << this[01;31m-[00m>_bonded[i];
pdb.cc:225:    RPAggregate agg = lisp[01;31m-[00m>create<O_Aggregate>();
pdb.cc:227:        int moleculeIdx = [01;31m-[00m1;
pdb.cc:228:	int residueSeq = [01;31m-[00m1;
pdb.cc:229:	int currentResidueIdx = [01;31m-[00m1;
pdb.cc:231:        for ( ai=this[01;31m-[00m>_atoms.begin();ai!=this[01;31m-[00m>_atoms.end(); ai++ )
pdb.cc:235:	    if ( moleculeIdx != ai[01;31m-[00m>_moleculeIdx )
pdb.cc:236:	    { _BLOCK_TRACEF(BF("Creating molecule with moleculeIdx: %d") % ai[01;31m-[00m>_moleculeIdx );
pdb.cc:237:		moleculeIdx = ai[01;31m-[00m>_moleculeIdx;
pdb.cc:238:		ASSERT((unsigned)(moleculeIdx)==this[01;31m-[00m>_molecules.size());
pdb.cc:239:		this[01;31m-[00m>_molecules.resize(moleculeIdx+1,lisp[01;31m-[00m>nil<O_Molecule>());
pdb.cc:240:		RPMolecule mol = lisp[01;31m-[00m>create<O_Molecule>();
pdb.cc:241:		mol[01;31m-[00m>setName(ai[01;31m-[00m>_chainId);
pdb.cc:242:		this[01;31m-[00m>_molecules[moleculeIdx] = mol;
pdb.cc:245:		residueSeq = [01;31m-[00m1;	
pdb.cc:246:		agg[01;31m-[00m>addMatter(mol);
pdb.cc:251:	    LOG(BF("residueSeq(%d)   ai[01;31m-[00m>_resSeq(%d)") % residueSeq % ai[01;31m-[00m>_resSeq  ); // vp0(("residueSeq(%d)   ai[01;31m-[00m>_resSeq(%d)", residueSeq, ai[01;31m-[00m>_resSeq ));
pdb.cc:252:	    if ( residueSeq != ai[01;31m-[00m>_resSeq)
pdb.cc:253:	    { _BLOCK_TRACEF(BF("Creating residue with sequence number: %d  resName: %s") % ai[01;31m-[00m>_resSeq % ai[01;31m-[00m>_resName    );
pdb.cc:254:		residueSeq = ai[01;31m-[00m>_resSeq;
pdb.cc:255:		RPResidue res = lisp[01;31m-[00m>create<O_Residue>();
pdb.cc:256:		res[01;31m-[00m>setName(ai[01;31m-[00m>_resName);
pdb.cc:257:		res[01;31m-[00m>setPdbName(ai[01;31m-[00m>_resName);
pdb.cc:258:		res[01;31m-[00m>setId(ai[01;31m-[00m>_resSeq);
pdb.cc:259:		res[01;31m-[00m>setFileSequenceNumber(ai[01;31m-[00m>_resSeq);
pdb.cc:260:		RPMolecule mol = this[01;31m-[00m>_molecules[ai[01;31m-[00m>_moleculeIdx];
pdb.cc:261:		mol[01;31m-[00m>addMatter(res);
pdb.cc:262:		ai[01;31m-[00m>_residueIdx = this[01;31m-[00m>_residues.size();
pdb.cc:263:		currentResidueIdx = ai[01;31m-[00m>_residueIdx;
pdb.cc:264:		this[01;31m-[00m>_residues.push_back(res);
pdb.cc:267:	    RPAtom atom = ai[01;31m-[00m>createAtom(lisp);
pdb.cc:268:    	    ai[01;31m-[00m>_atom = atom;
pdb.cc:270:	    ASSERTF(currentResidueIdx>=0,BF("residue index must be positive [01;31m-[00m line[01;31m-[00m[01;31m-[00m> %s")%ai[01;31m-[00m>_line );
pdb.cc:271:	    ASSERT_lessThan(currentResidueIdx,(int)(this[01;31m-[00m>_residues.size()));
pdb.cc:272:	    ai[01;31m-[00m>_residueIdx = currentResidueIdx;
pdb.cc:273:	    RPResidue res = this[01;31m-[00m>_residues[ai[01;31m-[00m>_residueIdx];
pdb.cc:274:	    res[01;31m-[00m>addMatter(atom);
pdb.cc:278:        LOG(BF("There are %d bonds") % this[01;31m-[00m>_connects.size()  ); // vp0(("There are %d bonds", this[01;31m-[00m>_connects.size() ));
pdb.cc:279:	for ( unsigned ci=0; ci<this[01;31m-[00m>_connects.size(); ci++ )
pdb.cc:281:	    LOG(BF("CONECT indices: %d %d %d %d %d") % this[01;31m-[00m>_connects[ci]._atom1 % this[01;31m-[00m>_connects[ci]._bonded[0] % this[01;31m-[00m>_connects[ci]._bonded[1] % this[01;31m-[00m>_connects[ci]._bonded[2] % this[01;31m-[00m>_connects[ci]._bonded[3]  ); // vp0(("CONECT indices: %d %d %d %d %d", this[01;31m-[00m>_connects[ci]._atom1, this[01;31m-[00m>_connects[ci]._bonded[0], this[01;31m-[00m>_connects[ci]._bonded[1], this[01;31m-[00m>_connects[ci]._bonded[2], this[01;31m-[00m>_connects[ci]._bonded[3] ));
pdb.cc:285:	    LOG(BF("Looking atom with index: %d") % this[01;31m-[00m>_connects[ci]._atom1  ); // vp0(("Looking atom with index: %d", this[01;31m-[00m>_connects[ci]._atom1 ));
pdb.cc:286:	    int atomRecIndex = this[01;31m-[00m>_atomRecIndexFromSerial[this[01;31m-[00m>_connects[ci]._atom1];
pdb.cc:287:	    atomPtr = &(this[01;31m-[00m>_atoms[atomRecIndex]);
pdb.cc:289:	    LOG(BF("Found atom entry with serial#%d") % atomPtr[01;31m-[00m>_serial  ); // vp0(("Found atom entry with serial#%d", atomPtr[01;31m-[00m>_serial ));
pdb.cc:290:	    LOG(BF("Atom.get = %X") % atomPtr[01;31m-[00m>_atom.get()  ); // vp0(("Atom.get = %X", atomPtr[01;31m-[00m>_atom.get() ));
pdb.cc:291:	    ANN(atomPtr[01;31m-[00m>_atom);
pdb.cc:292:	    ASSERTP(atomPtr[01;31m-[00m>_atom[01;31m-[00m>notNil(), "Atom is nil");
pdb.cc:293:	    bondedIdx = this[01;31m-[00m>_connects[ci]._bonded[0];
pdb.cc:296:		LOG(BF("Creating bond2 between atoms with indices %d[01;31m-[00m%d") % atomRecIndex % bondedIdx ); // vp0(("Creating bond2 between atoms with indices %d[01;31m-[00m%d", atomRecIndex, bondedIdx));
pdb.cc:297:		bondedAtomRecIdx = this[01;31m-[00m>_atomRecIndexFromSerial[bondedIdx];
pdb.cc:298:		bondedPtr = &(this[01;31m-[00m>_atoms[bondedAtomRecIdx]);
pdb.cc:299:		ANN(bondedPtr[01;31m-[00m>_atom);
pdb.cc:300:	        ASSERTP(bondedPtr[01;31m-[00m>_atom[01;31m-[00m>notNil(), "Atom is nil");
pdb.cc:301:		atomPtr[01;31m-[00m>_atom[01;31m-[00m>bondTo(bondedPtr[01;31m-[00m>_atom,singleBond);
pdb.cc:303:	    bondedIdx = this[01;31m-[00m>_connects[ci]._bonded[1];
pdb.cc:306:		LOG(BF("Creating bond3 between atoms with indices %d[01;31m-[00m%d") % atomRecIndex % bondedIdx ); // vp0(("Creating bond3 between atoms with indices %d[01;31m-[00m%d", atomRecIndex, bondedIdx));
pdb.cc:307:		bondedAtomRecIdx = this[01;31m-[00m>_atomRecIndexFromSerial[bondedIdx];
pdb.cc:308:		bondedPtr = &(this[01;31m-[00m>_atoms[bondedAtomRecIdx]);
pdb.cc:309:		ANN(bondedPtr[01;31m-[00m>_atom);
pdb.cc:310:	        ASSERTP(bondedPtr[01;31m-[00m>_atom[01;31m-[00m>notNil(), "Atom is nil");
pdb.cc:311:		atomPtr[01;31m-[00m>_atom[01;31m-[00m>bondTo(bondedPtr[01;31m-[00m>_atom,singleBond);
pdb.cc:313:	    bondedIdx = this[01;31m-[00m>_connects[ci]._bonded[2];
pdb.cc:316:		LOG(BF("Creating bond4 between atoms with indices %d[01;31m-[00m%d") % atomRecIndex % bondedIdx ); // vp0(("Creating bond4 between atoms with indices %d[01;31m-[00m%d", atomRecIndex, bondedIdx));
pdb.cc:317:		bondedAtomRecIdx = this[01;31m-[00m>_atomRecIndexFromSerial[bondedIdx];
pdb.cc:318:		bondedPtr = &(this[01;31m-[00m>_atoms[bondedAtomRecIdx]);
pdb.cc:319:		ANN(bondedPtr[01;31m-[00m>_atom);
pdb.cc:320:	        ASSERTP(bondedPtr[01;31m-[00m>_atom[01;31m-[00m>notNil(), "Atom is nil");
pdb.cc:321:		atomPtr[01;31m-[00m>_atom[01;31m-[00m>bondTo(bondedPtr[01;31m-[00m>_atom,singleBond);
pdb.cc:323:	    bondedIdx = this[01;31m-[00m>_connects[ci]._bonded[3];
pdb.cc:326:		LOG(BF("Creating bond5 between atoms with indices %d[01;31m-[00m%d") % atomRecIndex % bondedIdx ); // vp0(("Creating bond5 between atoms with indices %d[01;31m-[00m%d", atomRecIndex, bondedIdx));
pdb.cc:327:		bondedAtomRecIdx = this[01;31m-[00m>_atomRecIndexFromSerial[bondedIdx];
pdb.cc:328:		bondedPtr = &(this[01;31m-[00m>_atoms[bondedAtomRecIdx]);
pdb.cc:329:		ANN(bondedPtr[01;31m-[00m>_atom);
pdb.cc:330:	        ASSERTP(bondedPtr[01;31m-[00m>_atom[01;31m-[00m>notNil(), "Atom is nil");
pdb.cc:331:		atomPtr[01;31m-[00m>_atom[01;31m-[00m>bondTo(bondedPtr[01;31m-[00m>_atom,singleBond);
pdb.cc:342:    RPPdbReader pdb = lisp[01;31m-[00m>create<O_PdbReader>();
pdb.cc:343:    RPAggregate agg = pdb[01;31m-[00m>parse(fileName,lisp);
pdb.cc:349:    RPPdbReader pdb = lisp[01;31m-[00m>create<O_PdbReader>();
pdb.cc:350:    RPAggregate agg = pdb[01;31m-[00m>parse(fileName,lisp);
pdb.cc:358:    RPText fileName = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Text>();
pdb.cc:359:    RPAggregate agg = O_PdbReader::loadPdb(fileName[01;31m-[00m>get(),lisp);
pdb.cc:365:    this[01;31m-[00m>Base::initialize();
pdb.cc:376:{_F(this[01;31m-[00m>lisp());
pdb.cc:381:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("File not found: "+fileName));
pdb.cc:426:    this[01;31m-[00m>Base::initialize();
pdb.cc:454:	    atom._name = a[01;31m-[00m>getName();
pdb.cc:455:	    atom._element = a[01;31m-[00m>getElement();
pdb.cc:458:	    atom._resName = res[01;31m-[00m>getPdbName();
pdb.cc:459:	    atom._chainId = chainId+"A"[01;31m-[00m1;
pdb.cc:461:	    atom._x = a[01;31m-[00m>getPosition().getX();
pdb.cc:462:	    atom._y = a[01;31m-[00m>getPosition().getY();
pdb.cc:463:	    atom._z = a[01;31m-[00m>getPosition().getZ();
pdb.cc:466:	    a[01;31m-[00m>setTempInt(pdbAtoms.size());
pdb.cc:473:	vector<RPAtom>	bonded = ai[01;31m-[00m>_atom[01;31m-[00m>getBondedAtoms();
pdb.cc:477:	    if ( ai[01;31m-[00m>_atom[01;31m-[00m>getTempInt()<(*bi)[01;31m-[00m>getTempInt() )
pdb.cc:485:	    connect._atom1 = ai[01;31m-[00m>_atom[01;31m-[00m>getTempInt()+1;
pdb.cc:488:		connect._bonded[i] = uniqueBonded[i][01;31m-[00m>getTempInt()+1;
pdb.cc:505:	ai[01;31m-[00m>write(fout);
pdb.cc:510:	ci[01;31m-[00m>write(fout);
pdb.cc:517:{_F(this[01;31m-[00m>lisp());
pdb.cc:520:    if ( matter[01;31m-[00m>isOfClass<O_Aggregate>() )
pdb.cc:530:	    _setupAtomAndConnectRecordsForOneMolecule(mol,pdbAtoms,pdbConnects,chainId, this[01;31m-[00m>lisp());
pdb.cc:538:	_setupAtomAndConnectRecordsForOneMolecule(matter[01;31m-[00m>as<O_Molecule>(),pdbAtoms,pdbConnects,1, this[01;31m-[00m>lisp());
pdb.cc:548:    RPPdbWriter writer = matter[01;31m-[00m>lisp()[01;31m-[00m>create<O_PdbWriter>();
pdb.cc:549:    writer[01;31m-[00m>saveAs(matter,fileName);
pdb.cc:557:	class_<O_PdbReader>(this[01;31m-[00m>lisp())
pdb.cc:559:	defNoWrapPackage(MbbPackage,"loadPdb",&prim_loadPdb,this[01;31m-[00m>lisp());
pdb.cc:582:	class_<O_PdbWriter>(this[01;31m-[00m>lisp())
pdb.cc:584:	defInPackage(MbbPackage,"savePdb",&O_PdbWriter::savePdb,this[01;31m-[00m>lisp());
pdbMonomer.cc:56:	this[01;31m-[00m>_PdbCode = trimWhiteSpace(line.substr(10,3));
pdbMonomer.cc:57:	this[01;31m-[00m>_NumAtoms = atoi(trimWhiteSpace(line.substr(17,3)).c_str());
pdbMonomer.cc:73:	this[01;31m-[00m>_MainAtom = parts[1];
pdbMonomer.cc:74:	this[01;31m-[00m>_Bonded = O_StringSet::create(lisp);
pdbMonomer.cc:77:	    this[01;31m-[00m>_Bonded[01;31m-[00m>insert(parts[idx]);
pdbMonomer.cc:89:	this[01;31m-[00m>_PdbCode = trimWhiteSpace(line.substr(11,3));
pdbMonomer.cc:90:	this[01;31m-[00m>_LongName = trimWhiteSpace(line.substr(15,99999));
pdbMonomer.cc:104:	this[01;31m-[00m>_PdbCode = parts[1];
pdbMonomer.cc:108:	    this[01;31m-[00m>_FormulaTerm[eidx] = parts[idx];
pdbMonomer.cc:109:	    ASSERTF(eidx<MAX_FORMULA_TERMS,BF("Allocate more space for formula terms [01;31m-[00m need at least %d") % eidx );
pdbMonomer.cc:125:	RPPdbMonomerDatabase monomerDatabase = lisp[01;31m-[00m>create<O_PdbMonomerDatabase>();
pdbMonomer.cc:128:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Monomer connectivity database file not found: "+fileName));
pdbMonomer.cc:141:		    RPPdbMonomerConnectivity oneMonomer = lisp[01;31m-[00m>create<O_PdbMonomerConnectivity>();
pdbMonomer.cc:142:		    oneMonomer[01;31m-[00m>setPdbName(residue._PdbCode);
pdbMonomer.cc:143:		    monomerDatabase[01;31m-[00m>addMonomer(oneMonomer);
pdbMonomer.cc:157:			    oneMonomer[01;31m-[00m>addConnect(connect._MainAtom,connect._Bonded);
pdbMonomer.cc:160:			    TOSS(lisp[01;31m-[00m>create<O_LispError>(BF("Illegal record(%s) in monomer connection database") % recordName ) );
pdbMonomer.cc:167:		    RPPdbMonomerConnectivity oneMonomer = monomerDatabase[01;31m-[00m>findMonomer(hetName._PdbCode);
pdbMonomer.cc:168:		    oneMonomer[01;31m-[00m>addLongName(hetName._LongName);
pdbMonomer.cc:181:	class_<O_PdbMonomerConnectivity>(lisp[01;31m-[00m>lisp())
pdbMonomer.cc:188:	this[01;31m-[00m>_LongNames = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectList>();
pdbMonomer.cc:193:	node[01;31m-[00m>attribute("pdbName",this[01;31m-[00m>_PdbName);
pdbMonomer.cc:194:	node[01;31m-[00m>archiveObject("longNames",this[01;31m-[00m>_LongNames);
pdbMonomer.cc:195:	if ( node[01;31m-[00m>loading() )
pdbMonomer.cc:197:	    this[01;31m-[00m>_BondAtomPairs.clear();
pdbMonomer.cc:198:	    vector<string> data = node[01;31m-[00m>getDataAsVectorOfStrings();
pdbMonomer.cc:202:		this[01;31m-[00m>_BondAtomPairs.push_back(one);
pdbMonomer.cc:207:	    for ( vector<AtomPair>::iterator pi=this[01;31m-[00m>_BondAtomPairs.begin(); pi!=this[01;31m-[00m>_BondAtomPairs.end(); pi++ )
pdbMonomer.cc:209:		sout << pi[01;31m-[00m>first << " " << pi[01;31m-[00m>second << endl;
pdbMonomer.cc:211:	    node[01;31m-[00m>setCharacters(sout.str());
pdbMonomer.cc:220:    for ( vector<AtomPair>::iterator pi=this[01;31m-[00m>_BondAtomPairs.begin(); pi!=this[01;31m-[00m>_BondAtomPairs.end(); pi++ )
pdbMonomer.cc:221:    {_BLOCK_TRACEF(BF("Trying to connect %s [01;31m-[00m %s") % pi[01;31m-[00m>first % pi[01;31m-[00m>second );
pdbMonomer.cc:222:	string& s1 = pi[01;31m-[00m>first;
pdbMonomer.cc:223:	string& s2 = pi[01;31m-[00m>second;
pdbMonomer.cc:224:	RPAtom a1 = res[01;31m-[00m>contentWithNameOrNil(s1)[01;31m-[00m>as<O_Atom>();
pdbMonomer.cc:225:	RPAtom a2 = res[01;31m-[00m>contentWithNameOrNil(s2)[01;31m-[00m>as<O_Atom>();
pdbMonomer.cc:226:	if ( a1[01;31m-[00m>isNil() && a2[01;31m-[00m>notNil() )
pdbMonomer.cc:228:	    LOG(BF("Could not find atom(%s) [01;31m-[00m marking atom(%s) as unconnected") % pi[01;31m-[00m>first % pi[01;31m-[00m>second );
pdbMonomer.cc:233:	if ( a2[01;31m-[00m>isNil() && a1[01;31m-[00m>notNil() ) 
pdbMonomer.cc:235:	    LOG(BF("Could not find atom(%s) [01;31m-[00m marking atom(%s) as unconnected") % pi[01;31m-[00m>second % pi[01;31m-[00m>first );
pdbMonomer.cc:240:	if ( a1[01;31m-[00m>isNil() && a2[01;31m-[00m>isNil() )
pdbMonomer.cc:242:	    LOG(BF("Could not find either atom(%s) or atom(%s)") % pi[01;31m-[00m>first % pi[01;31m-[00m>second );
pdbMonomer.cc:245:	if ( a1[01;31m-[00m>notNil() && a2[01;31m-[00m>notNil() ) 
pdbMonomer.cc:247:	    LOG(BF("Connecting atoms %s [01;31m-[00m %s") % a1[01;31m-[00m>description() % a2[01;31m-[00m>description() )
pdbMonomer.cc:248:	    a1[01;31m-[00m>bondToSingle(a2);
pdbMonomer.cc:261:    this[01;31m-[00m>_PdbName = pdbName;
pdbMonomer.cc:267:	this[01;31m-[00m>_LongNames[01;31m-[00m>append(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(longName));
pdbMonomer.cc:272:    for ( O_StringSet::iterator si=bonded[01;31m-[00m>begin(); si!=bonded[01;31m-[00m>end(); si++ )
pdbMonomer.cc:274:	if ( !this[01;31m-[00m>hasConnection(mainAtom,*si) )
pdbMonomer.cc:277:	    this[01;31m-[00m>_BondAtomPairs.push_back(two);
pdbMonomer.cc:284:    for ( iterator it=this[01;31m-[00m>_BondAtomPairs.begin(); it!=this[01;31m-[00m>_BondAtomPairs.end(); it++ )
pdbMonomer.cc:286:	if ( (it[01;31m-[00m>first==a1 && it[01;31m-[00m>second==a2) || (it[01;31m-[00m>first==a2 && it[01;31m-[00m>second==a1) )
pdbMonomer.cc:302:	class_<O_PdbMonomerDatabase>(lisp[01;31m-[00m>lisp())
pdbMonomer.cc:308:	node[01;31m-[00m>archiveMap("db",this[01;31m-[00m>_Database);
pdbMonomer.cc:313:    this[01;31m-[00m>_Database.set(mon[01;31m-[00m>getPdbName(),mon);
pdbMonomer.cc:319:    if ( this[01;31m-[00m>_Database.contains(pdbName) )
pdbMonomer.cc:321:	return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_PdbMonomerConnectivity>();
pdbMonomer.cc:323:    return this[01;31m-[00m>_Database.get(pdbName);
pdbMonomer.cc:331:    for ( vector<RPAtom>::iterator i1 = atoms.begin(); i1!=atoms.end()[01;31m-[00m1; i1++ )
pdbMonomer.cc:333:	Vector3 v1 = (*i1)[01;31m-[00m>getPosition();
pdbMonomer.cc:334:	double rad1 = vdwRadiusForElement((*i1)[01;31m-[00m>getElement());
pdbMonomer.cc:337:	    Vector3 v2 = (*i2)[01;31m-[00m>getPosition();
pdbMonomer.cc:338:	    double rad2 = vdwRadiusForElement((*i2)[01;31m-[00m>getElement());
pdbMonomer.cc:341:	    double maxLen = maximumBondLengthBetweenElements((*i1)[01;31m-[00m>getElement(),(*i2)[01;31m-[00m>getElement());
pdbMonomer.cc:344:		if (!(*i1)[01;31m-[00m>isBondedTo(*i2))
pdbMonomer.cc:346:		    LOG(BF("Forming bond between atom(%s) and atom(%s) [01;31m-[00m they were %lf angstroms apart < max(%lf)") % (*i1)[01;31m-[00m>description() % (*i2)[01;31m-[00m>description() % len % maxLen );
pdbMonomer.cc:347:		    (*i1)[01;31m-[00m>bondToSingle(*i2);
pdbMonomer.cc:370:	{_BLOCK_TRACEF(BF("Looking at residue(%s)") % lResidues.getResidue()[01;31m-[00m>getPdbName() );
pdbMonomer.cc:372:	    if ( this[01;31m-[00m>_Database.contains(res[01;31m-[00m>getPdbName()) )
pdbMonomer.cc:374:		LOG(BF("Found residue(%s) in database connecting atoms") % res[01;31m-[00m>getPdbName()   );
pdbMonomer.cc:375:		RPPdbMonomerConnectivity connector = this[01;31m-[00m>_Database.get(res[01;31m-[00m>getPdbName());
pdbMonomer.cc:376:		numConnect += connector[01;31m-[00m>connectAtomsAndReturnUnconnected(res,unconnectedAtoms);
pdbMonomer.cc:379:		LOG(BF("Could not find residue(%s) pushing %d atoms into unconnectedAtoms") % res[01;31m-[00m>getPdbName() % res[01;31m-[00m>numberOfAtoms() );
pdbMonomer.cc:380:		for ( O_Matter::contentsIterator ci=res[01;31m-[00m>begin_contents(); 
pdbMonomer.cc:381:		      ci != res[01;31m-[00m>end_contents(); ci++ )
pdbMonomer.cc:383:		    unconnectedAtoms.push_back((*ci)[01;31m-[00m>as<O_Atom>());
pdbMonomer.cc:387:	uint numVdwConnected = this[01;31m-[00m>connectVdwOverlappingUnconnectedAtoms(unconnectedAtoms);
pdbMonomer.cc:390:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Number of unconnected atoms(%d)") % unconnectedAtoms.size() );
pdbMonomer.cc:391:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Number of atoms connected by monomer connectivity(%d)") % numConnect );
pdbMonomer.cc:392:	this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("Number of atoms connected by vdw overlap(%d)") % numVdwConnected);
plug.cc:21://    mate[01;31m-[00m>setBuilderDatabase(db);
plug.cc:28:{_F(this[01;31m-[00m>lisp());
plug.cc:29:    RPRingClosingMate cp = RP_Copy<O_RingClosingMate>(this[01;31m-[00m>sharedThis<O_RingClosingMate>());
plug.cc:57:{_F(this[01;31m-[00m>lisp());
plug.cc:58:    this[01;31m-[00m>Base::archiveBase(node);
plug.cc:78:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
plug.cc:88:    this[01;31m-[00m>_OverrideCapMateRequirement = false;
plug.cc:95:    mate[01;31m-[00m>setBuilderDatabase(db);
plug.cc:100:{_F(this[01;31m-[00m>lisp());
plug.cc:101:    RPMate cp = RP_Copy<O_Mate>(this[01;31m-[00m>sharedThis<O_Mate>());
plug.cc:116:    this[01;31m-[00m>_Cap = ss._Cap;
plug.cc:126:    ss << "( Cap "<< this[01;31m-[00m>_Cap<<") ";
plug.cc:131:{_F(this[01;31m-[00m>lisp());
plug.cc:132:    this[01;31m-[00m>Base::archiveBase(node);
plug.cc:133:    node[01;31m-[00m>attribute( "cap", this[01;31m-[00m>_Cap );
plug.cc:134:    node[01;31m-[00m>attributeIfNotDefault( "overrideCapMateRequirement", this[01;31m-[00m>_OverrideCapMateRequirement, false );
plug.cc:155:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
plug.cc:156:    this[01;31m-[00m>_Cap = dict[01;31m-[00m>getStringAndRemove("cap");
plug.cc:157:    this[01;31m-[00m>_OverrideCapMateRequirement = dict[01;31m-[00m>getBoolAndRemoveOrDefault("overrideCapMateRequirement",false);
plug.cc:168:    this[01;31m-[00m>Base::initialize();
plug.cc:169:    this[01;31m-[00m>_WeakConstitution = O_Constitution::nil(this[01;31m-[00m>lisp());
plug.cc:170:    this[01;31m-[00m>_Name = "Plug::initialize _Name undefined";
plug.cc:195:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
plug.cc:196:    this[01;31m-[00m>_Name = dict[01;31m-[00m>getStringAndRemove("name");
plug.cc:203:    this[01;31m-[00m>_WeakConstitution = p._WeakConstitution;
plug.cc:204:    this[01;31m-[00m>_Name = p._Name;
plug.cc:205:    LOG(BF("Copy constructed %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("Copy constructed %s",this[01;31m-[00m>description().c_str() ));
plug.cc:213:    ss << this[01;31m-[00m>Base::descriptionOfContents() << " ";
plug.cc:214:    ss << "( Name " << this[01;31m-[00m>_Name << " )";
plug.cc:215:    if ( this[01;31m-[00m>_WeakConstitution.use_count() != 0 )
plug.cc:217:	ss << this[01;31m-[00m>_WeakConstitution.lock()[01;31m-[00m>description();
plug.cc:227:    this[01;31m-[00m>_WeakConstitution = con[01;31m-[00m>sharedThis<O_Constitution>();
plug.cc:234:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakConstitution);
plug.cc:235:    if ( this[01;31m-[00m>_WeakConstitution.lock()[01;31m-[00m>isNil() )
plug.cc:238:	this[01;31m-[00m>_WeakConstitution = this[01;31m-[00m>ownerWithClass<O_Constitution>();
plug.cc:240:    return this[01;31m-[00m>_WeakConstitution.lock();
plug.cc:249:    return O_DirectionalCoupling::otherPlugName(this[01;31m-[00m>_Name,this[01;31m-[00m>lisp());
plug.cc:255:    this[01;31m-[00m>Base::archiveBase(node);
plug.cc:256:    if ( node[01;31m-[00m>saving() ) this[01;31m-[00m>getConstitution();
plug.cc:257:    node[01;31m-[00m>archiveWeakPointer("constitution",this[01;31m-[00m>_WeakConstitution);
plug.cc:259:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
plug.cc:261:    if ( node[01;31m-[00m>loading() )
plug.cc:263:	if ( node[01;31m-[00m>hasAttribute("name") )
plug.cc:265:	    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
plug.cc:268:	    node[01;31m-[00m>attribute("_key",this[01;31m-[00m>_Name);
plug.cc:272:	node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
plug.cc:322:    this[01;31m-[00m>Base::initialize();
plug.cc:327:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
plug.cc:328:    this[01;31m-[00m>_B0 = dict[01;31m-[00m>getStringAndRemove("bond0");
plug.cc:329:    this[01;31m-[00m>_B1 = dict[01;31m-[00m>getStringAndRemoveOrDefault("bond1","");
plug.cc:330:    RPCons mates = dict[01;31m-[00m>getAndRemove("mates")[01;31m-[00m>as<O_Cons>();
plug.cc:331:    this[01;31m-[00m>_Mates.fillFromCons(mates);
plug.cc:335:{_F(this[01;31m-[00m>lisp());
plug.cc:338:    this[01;31m-[00m>_B0 = p._B0;
plug.cc:339:    this[01;31m-[00m>_B1 = p._B1;
plug.cc:340:    this[01;31m-[00m>_Mates.clear();
plug.cc:346:	this[01;31m-[00m>_Mates.push_back(rn);
plug.cc:348:    LOG(BF("Copy constructed %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("Copy constructed %s",this[01;31m-[00m>description().c_str() ));
plug.cc:354:    ss << this[01;31m-[00m>Base::descriptionOfContents() << " ";
plug.cc:356:    ss << "#" << this[01;31m-[00m>_Mates.size() << " ";
plug.cc:358:    for ( vi=this[01;31m-[00m>_Mates.const_begin(); vi!=this[01;31m-[00m>_Mates.const_end(); vi++ ) {
plug.cc:359:    	ss << (*vi)[01;31m-[00m>description() << ", ";
plug.cc:367:    this[01;31m-[00m>Base::archiveBase(node);
plug.cc:368:    node[01;31m-[00m>attributeIfNotDefault<string>("b0",this[01;31m-[00m>_B0,"");
plug.cc:369:    node[01;31m-[00m>attributeIfNotDefault<string>("b1",this[01;31m-[00m>_B1,"");
plug.cc:370:    node[01;31m-[00m>archiveList("mates",this[01;31m-[00m>_Mates);
plug.cc:376:{_F(this[01;31m-[00m>lisp());
plug.cc:378:    for ( mi=this[01;31m-[00m>_Mates.begin(); mi!=this[01;31m-[00m>_Mates.end(); mi++ ) {
plug.cc:379:	if ( (*mi)[01;31m-[00m>recognizesNameOrPdb(name) ) return true;
plug.cc:386:    this[01;31m-[00m>Base::initialize();
plug.cc:387:    this[01;31m-[00m>_WeakExportFrame = O_Frame::nil(this[01;31m-[00m>lisp());
plug.cc:406:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
plug.cc:407:    this[01;31m-[00m>_WeakExportFrame = dict[01;31m-[00m>getAndRemoveOrDefault("exportFrame",O_Frame::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Frame>();
plug.cc:408:    RPCons completes = dict[01;31m-[00m>getAndRemove("needsFrameFinishers")[01;31m-[00m>as<O_Cons>();
plug.cc:409:    this[01;31m-[00m>_FrameFinishers.fillFromCons(completes);
plug.cc:415:{_F(this[01;31m-[00m>lisp());
plug.cc:418:    this[01;31m-[00m>_WeakExportFrame = p._WeakExportFrame;
plug.cc:420:    this[01;31m-[00m>_FrameFinishers = p._FrameFinishers;
plug.cc:421:    LOG(BF("Copy constructed %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("Copy constructed %s",this[01;31m-[00m>description().c_str() ));
plug.cc:426:{_F(this[01;31m-[00m>lisp());
plug.cc:427:    return this[01;31m-[00m>_FrameFinishers.asCons(this[01;31m-[00m>lisp());
plug.cc:434:    ss << this[01;31m-[00m>Base::descriptionOfContents() << " ";
plug.cc:435:    if ( this[01;31m-[00m>_WeakExportFrame.use_count() == 0 
plug.cc:436:	|| this[01;31m-[00m>_WeakExportFrame.lock()[01;31m-[00m>isNil() )
plug.cc:441:	ss << " ExportsFrame:" << this[01;31m-[00m>_WeakExportFrame.lock()[01;31m-[00m>getName();
plug.cc:448:{_F(this[01;31m-[00m>lisp());
plug.cc:449:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakExportFrame);
plug.cc:450:    return this[01;31m-[00m>_WeakExportFrame.lock();
plug.cc:456:    this[01;31m-[00m>Base::archiveBase(node);
plug.cc:457:    node[01;31m-[00m>archiveWeakPointer("exportFrame",this[01;31m-[00m>_WeakExportFrame);
plug.cc:464:    this[01;31m-[00m>Base::initialize();
plug.cc:480:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
plug.cc:494:    return this[01;31m-[00m>Base::descriptionOfContents();
plug.cc:502:    this[01;31m-[00m>Base::initialize();
plug.cc:503:    this[01;31m-[00m>_WeakOriginFrame = O_Frame::nil(this[01;31m-[00m>lisp());
plug.cc:516:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
plug.cc:517:    this[01;31m-[00m>_WeakOriginFrame = dict[01;31m-[00m>getAndRemove("originFrame")[01;31m-[00m>as<O_Frame>();
plug.cc:524:    this[01;31m-[00m>_WeakOriginFrame = p._WeakOriginFrame;
plug.cc:530:{_F(this[01;31m-[00m>lisp());
plug.cc:531:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakOriginFrame);
plug.cc:532:    return this[01;31m-[00m>_WeakOriginFrame.lock();
plug.cc:539:    ss << this[01;31m-[00m>Base::descriptionOfContents() << " ";
plug.cc:540:    if ( this[01;31m-[00m>_WeakOriginFrame.use_count() == 0 )
plug.cc:545:	ss << this[01;31m-[00m>_WeakOriginFrame.lock()[01;31m-[00m>description();
plug.cc:553:    this[01;31m-[00m>Base::archiveBase(node);
plug.cc:554:    node[01;31m-[00m>archiveWeakPointer("originFrame",this[01;31m-[00m>_WeakOriginFrame);
plug.cc:560:    this[01;31m-[00m>Base::initialize();
plug.cc:580:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
plug.cc:581:    RPCons mates = dict[01;31m-[00m>getAndRemove("ringClosingMates")[01;31m-[00m>as<O_Cons>();
plug.cc:582:    this[01;31m-[00m>_RingClosingMates.fillFromCons(mates);
plug.cc:595:	this[01;31m-[00m>_RingClosingMates.push_back(rn);
plug.cc:597:    LOG(BF("Copy constructed %s") % this[01;31m-[00m>description().c_str()  ); // vp0(("Copy constructed %s",this[01;31m-[00m>description().c_str() ));
plug.cc:605:    ss << this[01;31m-[00m>Base::descriptionOfContents() << " ";
plug.cc:607:    ss << "#" << this[01;31m-[00m>_RingClosingMates.size() << " ";
plug.cc:609:    for ( vi=this[01;31m-[00m>_RingClosingMates.const_begin(); vi!=this[01;31m-[00m>_RingClosingMates.const_end(); vi++ ) {
plug.cc:610:    	ss << (*vi)[01;31m-[00m>description() << ", ";
plug.cc:619:    this[01;31m-[00m>Base::archiveBase(node);
plug.cc:620:    node[01;31m-[00m>archiveList("ringCLosingMates",this[01;31m-[00m>_RingClosingMates);
plug.cc:634:    class_<O_RingClosingMate>(this[01;31m-[00m>lisp())
plug.cc:653:    class_<O_Mate>(this[01;31m-[00m>lisp())
plug.cc:675:    class_<O_Plug>(this[01;31m-[00m>lisp())
plug.cc:714:    class_<O_PlugWithMates>(this[01;31m-[00m>lisp())
plug.cc:745:    class_<O_OutPlug>(this[01;31m-[00m>lisp())
plug.cc:766:    class_<O_InPlug>(this[01;31m-[00m>lisp())
plug.cc:786:    class_<O_OriginPlug>(this[01;31m-[00m>lisp())
plug.cc:807:    class_<O_RingClosingPlug>(this[01;31m-[00m>lisp())
posixTime.cc:20:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
posixTime.cc:28:    now[01;31m-[00m>setToLocalTime();
posixTime.cc:36:    this[01;31m-[00m>Base::initialize();
posixTime.cc:41:    this[01;31m-[00m>Base::archiveBase(node);
posixTime.cc:42:    if ( node[01;31m-[00m>loading() )
posixTime.cc:45:	node[01;31m-[00m>attribute("iso",iso);
posixTime.cc:46:	this[01;31m-[00m>_Time = boost::posix_time::from_iso_string(iso);
posixTime.cc:50:	iso = boost::posix_time::to_iso_string(this[01;31m-[00m>_Time);
posixTime.cc:51:	node[01;31m-[00m>attribute("iso",iso);
posixTime.cc:57:{_F(this[01;31m-[00m>lisp());
posixTime.cc:58:    this[01;31m-[00m>_Time = boost::posix_time::second_clock::local_time();
posixTime.cc:59:    return this[01;31m-[00m>sharedThis<O_PosixTime>();
posixTime.cc:63:{_F(this[01;31m-[00m>lisp());
posixTime.cc:65:    ss << to_simple_string(this[01;31m-[00m>_Time);
posixTime.cc:72:{_F(this[01;31m-[00m>lisp());
posixTime.cc:73:    RPPosixTimeDuration result = O_PosixTimeDuration::create(this[01;31m-[00m>lisp());
posixTime.cc:74:    result[01;31m-[00m>_Duration = this[01;31m-[00m>_Time [01;31m-[00m t[01;31m-[00m>_Time;
posixTime.cc:86:    this[01;31m-[00m>Base::oldLispInitialize(kargs,lisp);
posixTime.cc:87:    LongLongInt hours = kargs[01;31m-[00m>getLlintAndRemoveOrDefault("hours",0L);
posixTime.cc:88:    LongLongInt minutes = kargs[01;31m-[00m>getLlintAndRemoveOrDefault("minutes",0L);
posixTime.cc:89:    LongLongInt seconds = kargs[01;31m-[00m>getLlintAndRemoveOrDefault("seconds",0L);
posixTime.cc:90:    LongLongInt milliseconds = kargs[01;31m-[00m>getLlintAndRemoveOrDefault("milliseconds",0L);
posixTime.cc:91:    this[01;31m-[00m>_Duration = boost::posix_time::hours(hours)
posixTime.cc:99:    RPPosixTime now = O_PosixTime::createNow(past[01;31m-[00m>lisp());
posixTime.cc:100:    RPPosixTimeDuration delta = now[01;31m-[00m>sub(past);
posixTime.cc:105:    this[01;31m-[00m>Base::initialize();
posixTime.cc:110:    this[01;31m-[00m>Base::archiveBase(node);
posixTime.cc:116:{_F(this[01;31m-[00m>lisp());
posixTime.cc:117:    RPPosixTimeDuration result = O_PosixTimeDuration::create(this[01;31m-[00m>lisp());
posixTime.cc:118:    result[01;31m-[00m>_Duration = this[01;31m-[00m>_Duration [01;31m-[00m t[01;31m-[00m>_Duration;
posixTime.cc:124:{_F(this[01;31m-[00m>lisp());
posixTime.cc:125:    return this[01;31m-[00m>_Duration.total_seconds();
posixTime.cc:129:{_F(this[01;31m-[00m>lisp());
posixTime.cc:130:    return this[01;31m-[00m>_Duration.total_milliseconds();
posixTime.cc:134:{_F(this[01;31m-[00m>lisp());
posixTime.cc:135:    return this[01;31m-[00m>_Duration.total_microseconds();
posixTime.cc:139:{_F(this[01;31m-[00m>lisp());
posixTime.cc:140:    return this[01;31m-[00m>_Duration.fractional_seconds();
posixTime.cc:144:{_F(this[01;31m-[00m>lisp());
posixTime.cc:145:    return this[01;31m-[00m>_Duration.seconds();
posixTime.cc:149:{_F(this[01;31m-[00m>lisp());
posixTime.cc:150:    return this[01;31m-[00m>_Duration.minutes();
posixTime.cc:154:{_F(this[01;31m-[00m>lisp());
posixTime.cc:155:    return this[01;31m-[00m>_Duration.hours();
posixTime.cc:159:{_F(this[01;31m-[00m>lisp());
posixTime.cc:160:    return boost::posix_time::to_simple_string(this[01;31m-[00m>_Duration);
posixTime.cc:164:{_F(this[01;31m-[00m>lisp());
posixTime.cc:165:    return boost::posix_time::to_iso_string(this[01;31m-[00m>_Duration);
posixTime.cc:175:	class_<O_PosixTime>(this[01;31m-[00m>lisp())
posixTime.cc:204:	class_<O_PosixTimeDuration>(this[01;31m-[00m>lisp())
preconditioner.cc:18:    if ( this[01;31m-[00m>isStretchEnergyEnabled() ) {
preconditioner.cc:19:	for ( vector<EnergyStretch>::iterator si=this[01;31m-[00m>_StretchTerms.begin();
preconditioner.cc:20:		    si!=this[01;31m-[00m>_StretchTerms.end(); si++ ) {
preconditioner.cc:24:    if ( this[01;31m-[00m>isAngleEnergyEnabled() ) {
preconditioner.cc:25:	for ( vector<EnergyAngle>::iterator ai=this[01;31m-[00m>_AngleTerms.begin();
preconditioner.cc:26:		    ai!=this[01;31m-[00m>_AngleTerms.end(); ai++ ) {
preconditioner.cc:30:    if ( this[01;31m-[00m>isDihedralEnergyEnabled() ) {
preconditioner.cc:31:	for ( vector<EnergyDihedral>::iterator di=this[01;31m-[00m>_DihedralTerms.begin();
preconditioner.cc:32:		    di!=this[01;31m-[00m>_DihedralTerms.end(); di++ ) {
preconditioner.cc:36:    if ( this[01;31m-[00m>isImproperRestraintEnergyEnabled() ) {
preconditioner.cc:37:	for ( vector<AmberImproperRestraint>::iterator iri=this[01;31m-[00m>_ImproperRestraintTerms.begin();
preconditioner.cc:38:		    iri!=this[01;31m-[00m>_ImproperRestraintTerms.end(); iri++ ) {
preconditioner.cc:42:    if ( this[01;31m-[00m>isChiralRestraintEnergyEnabled() ) {
preconditioner.cc:43:	for ( vector<AmberChiralRestraint>::iterator cri=this[01;31m-[00m>_ChiralRestraintTerms.begin();
preconditioner.cc:44:		    cri!=this[01;31m-[00m>_ChiralRestraintTerms.end(); cri++ ) {
profiler.cc:66:    _lisp[01;31m-[00m>profiler().disableMessages();
progress.cc:10:    this[01;31m-[00m>_On = true;
progress.cc:20:    this[01;31m-[00m>_MaxIndex = max;
progress.cc:21:    this[01;31m-[00m>_LastIndexDisplayed = 0;
progress.cc:22:    this[01;31m-[00m>_Index = 
pythonCallback.cc:18:    this[01;31m-[00m>callbackFn = callback;
pythonCallback.cc:30:    if ( this[01;31m-[00m>callbackFn != NULL ) {
pythonCallback.cc:34:				this[01;31m-[00m>doubleVal0, this[01;31m-[00m>doubleVal1,
pythonCallback.cc:35:				this[01;31m-[00m>longVal0, this[01;31m-[00m>longVal1 );
pythonCallback.cc:37:	result = PyEval_CallObject(this[01;31m-[00m>callbackFn, arglist);
pythonCallback.cc:41:	    this[01;31m-[00m>longReturn = 0;
pythonCallback.cc:47:	this[01;31m-[00m>longReturn = res;
pythonCallback.cc:50:    this[01;31m-[00m>longReturn = 0;
quickDom.cc:28:    // [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
quickDom.cc:30:    // [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
quickDom.cc:36:    // [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
quickDom.cc:38:    // [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
quickDom.cc:43:    O_QDomNode	*getTopNode() {return this[01;31m-[00m>topNode;}
quickDom.cc:54:    this[01;31m-[00m>topNode = n;
quickDom.cc:56:    this[01;31m-[00m>_currentNode=NULL;
quickDom.cc:66:    if ( this[01;31m-[00m>_currentNode == NULL ) 
quickDom.cc:68:	nd = this[01;31m-[00m>topNode;
quickDom.cc:75:        this[01;31m-[00m>_currentNode[01;31m-[00m>addChild(newNode);
quickDom.cc:78://    LOG(BF("Setting data for node: %lx  localName=%s") % (nd) % this[01;31m-[00m>getLocalName() );
quickDom.cc:79:    nd[01;31m-[00m>setLocalName(this[01;31m-[00m>getLocalName());
quickDom.cc:80:    nd[01;31m-[00m>setFileName(this[01;31m-[00m>topNode[01;31m-[00m>getFileName());
quickDom.cc:81:    nd[01;31m-[00m>setLineNumber(this[01;31m-[00m>getLineNumber());
quickDom.cc:82:    nd[01;31m-[00m>setCharacters("");
quickDom.cc:83:    nd[01;31m-[00m>setParent(this[01;31m-[00m>_currentNode);
quickDom.cc:85:    for ( i = 0; i<this[01;31m-[00m>getAttributeCount(); i++ ) 
quickDom.cc:87:	this[01;31m-[00m>getAttributeAtIndex( i, attrName, attrVal );
quickDom.cc:89:	nd[01;31m-[00m>addAttribute( attrName, attrVal );
quickDom.cc:92:    this[01;31m-[00m>_currentNode = nd;
quickDom.cc:98:    if ( this[01;31m-[00m>_currentNode != this[01;31m-[00m>topNode ) 
quickDom.cc:100:        this[01;31m-[00m>_currentNode = this[01;31m-[00m>_currentNode[01;31m-[00m>getParent();
quickDom.cc:101://	LOG(BF("Restored _currentNode to %X") % (void*)(this[01;31m-[00m>_currentNode));
quickDom.cc:109://    LOG(BF("About to appendCharacters(%s)") % this[01;31m-[00m>getData() );
quickDom.cc:110:    ASSERTP(this[01;31m-[00m>_currentNode!=NULL,"currentNode is NULL and you are trying to write characters to it");
quickDom.cc:111:    this[01;31m-[00m>_currentNode[01;31m-[00m>appendCharacters(this[01;31m-[00m>getData());
quickDom.cc:124:    node[01;31m-[00m>setLocalName(name);
quickDom.cc:135:    children = this[01;31m-[00m>getChildren();
quickDom.cc:140:        LOG(BF("Defining error for unknown xml command: %s") % (child[01;31m-[00m>getLocalName().c_str() ) );
quickDom.cc:141:        RPLispError err = _lisp[01;31m-[00m>create<O_LispError>(BF("There is an unknown command: %s in file(%s) line(%d)") % child[01;31m-[00m>getLocalName() % this[01;31m-[00m>getFileName() % this[01;31m-[00m>getLineNumber() );
quickDom.cc:142:	_lisp[01;31m-[00m>print(BF("%s") % err[01;31m-[00m>message().c_str() );
quickDom.cc:152:	RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_QDomNode>(args,environ);
quickDom.cc:153:        RPText fileName = from_object<RPText>::convert(bargs[01;31m-[00m>lookup("fromFile"));
quickDom.cc:154:	RPText xmlString = from_object<RPText>::convert(bargs[01;31m-[00m>lookup("fromString"));
quickDom.cc:155:	if ( fileName[01;31m-[00m>isNil() && xmlString[01;31m-[00m>isNil() )
quickDom.cc:157:	    return lisp[01;31m-[00m>onil();
quickDom.cc:159:	if ( fileName[01;31m-[00m>notNil() && xmlString[01;31m-[00m>notNil() )
quickDom.cc:161:	    TOSS(lisp[01;31m-[00m>create<O_LispError>("Only provide one argument (fromString) or (fromFile)"));
quickDom.cc:163:	if ( fileName[01;31m-[00m>notNil() )
quickDom.cc:165:	    string sin = fileName[01;31m-[00m>get();
quickDom.cc:170:		TOSS(lisp[01;31m-[00m>create<O_LispError>(BF("Could not open file %s") % sin ));
quickDom.cc:172:	    this[01;31m-[00m>parseFile( fIn, sin );
quickDom.cc:174:	    return lisp[01;31m-[00m>onil();
quickDom.cc:176:	string xml = xmlString[01;31m-[00m>get();
quickDom.cc:177:	this[01;31m-[00m>parseFromString(xml,lisp);
quickDom.cc:178:	return lisp[01;31m-[00m>onil();
quickDom.cc:187:    this[01;31m-[00m>Base::initialize();
quickDom.cc:201:    node[01;31m-[00m>parseFile( fIn, fileName );
quickDom.cc:213:    children = this[01;31m-[00m>getChildren();
quickDom.cc:217:	if ( child[01;31m-[00m>getLocalName() != nm ) {
quickDom.cc:218:            LOG(BF("Defining error for unknown xml command: %s") % (child[01;31m-[00m>getLocalName().c_str() ) ); // vp0(( "Defining error for unknown xml command: %s", child[01;31m-[00m>getLocalName().c_str() ));
quickDom.cc:219:	    RPLispError err = O_LispError::create(BF("There is an unknown command: %s in file(%s) line(%d)") % child[01;31m-[00m>getLocalName() % this[01;31m-[00m>getFileName() % this[01;31m-[00m>getLineNumber() ,_lisp);
quickDom.cc:220:	    _lisp[01;31m-[00m>print(BF("%s") % err[01;31m-[00m>message().c_str() );
quickDom.cc:238:    val = this[01;31m-[00m>characters.str();
quickDom.cc:257:    val = this[01;31m-[00m>characters.str();
quickDom.cc:268:	return this[01;31m-[00m>_children.size() == 0;
quickDom.cc:274:    first = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>();
quickDom.cc:276:    for ( O_QDomNode::iterator ci=this[01;31m-[00m>begin_Children(); ci!=this[01;31m-[00m>end_Children(); ci++ )
quickDom.cc:278:	RPCons one = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>(*ci);
quickDom.cc:279:	cur[01;31m-[00m>setCdr(one);
quickDom.cc:282:    return first[01;31m-[00m>cdr();
quickDom.cc:288:{_F(this[01;31m-[00m>lisp());
quickDom.cc:291:    this[01;31m-[00m>writeXml( "", out );
quickDom.cc:299:    this[01;31m-[00m>writeXml( "", out );
quickDom.cc:305:{_F(this[01;31m-[00m>lisp());
quickDom.cc:313:    out << prefix << "<" << this[01;31m-[00m>getLocalName();
quickDom.cc:315:    abegin = this[01;31m-[00m>attributes.begin();
quickDom.cc:316:    aend = this[01;31m-[00m>attributes.end();
quickDom.cc:323:    dataWhiteSpace = this[01;31m-[00m>dataIsAllWhiteSpace();
quickDom.cc:328:	dataNewLines = this[01;31m-[00m>dataCountNewLines();
quickDom.cc:330:    if ( this[01;31m-[00m>_children.begin() == this[01;31m-[00m>_children.end() && dataWhiteSpace ) {
quickDom.cc:343:	if ( this[01;31m-[00m>_children.begin() != this[01;31m-[00m>_children.end() ) {
quickDom.cc:349:	for ( it = this[01;31m-[00m>_children.begin(); it!=this[01;31m-[00m>_children.end(); it++ ) {
quickDom.cc:352:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("Bad child"));
quickDom.cc:354:	    (*it)[01;31m-[00m>writeXml(prefix+" ",out);
quickDom.cc:363:	    out << this[01;31m-[00m>getCharacters();
quickDom.cc:371:	out << "</" << this[01;31m-[00m>getLocalName() << ">\n";
quickDom.cc:387:    this[01;31m-[00m>localName = ln;
quickDom.cc:389:    this[01;31m-[00m>_FileName = "";
quickDom.cc:395:    this[01;31m-[00m>localName = ln;
quickDom.cc:396:    this[01;31m-[00m>characters.str(data);
quickDom.cc:398:    this[01;31m-[00m>_FileName = "";
quickDom.cc:408:    this[01;31m-[00m>writeXml(prefix,o);
quickDom.cc:417:    s = this[01;31m-[00m>getCharacters();
quickDom.cc:428:	stop = cur[01;31m-[00m1;
quickDom.cc:429:	vs.push_back(s.substr(start,stop[01;31m-[00mstart+1));
quickDom.cc:442:    ss = O_StringSet::create(this[01;31m-[00m>lisp());
quickDom.cc:443:    s = this[01;31m-[00m>getCharacters();
quickDom.cc:454:	stop = cur[01;31m-[00m1;
quickDom.cc:455:	str = s.substr(start,stop[01;31m-[00mstart+1);
quickDom.cc:457:	ss[01;31m-[00m>insert(str);
quickDom.cc:470:    s = this[01;31m-[00m>getCharacters();
quickDom.cc:481:	stop = cur[01;31m-[00m1;
quickDom.cc:482:	vs.push_back(atoi((s.substr(start,stop[01;31m-[00mstart+1)).c_str()));
quickDom.cc:494:    s = this[01;31m-[00m>getCharacters();
quickDom.cc:505:	stop = cur[01;31m-[00m1;
quickDom.cc:506:	LOG(BF("convertToVectorOfDoubles converting: |%s|") % (s.substr(start,stop[01;31m-[00mstart+1).c_str() ) );
quickDom.cc:507:	dVal = atof((s.substr(start,stop[01;31m-[00mstart+1)).c_str());
quickDom.cc:527:    this[01;31m-[00m>dumpChildToStream(o, "");
quickDom.cc:535:    this[01;31m-[00m>dumpChildToStream(cout, "");
quickDom.cc:548:        if ( newCur == this[01;31m-[00m>_children.end() ) goto FAILED;
quickDom.cc:549:	if ( (*newCur)[01;31m-[00m>getLocalName() == name ) {
quickDom.cc:564:    for ( it=this[01;31m-[00m>_children.begin(); it!=this[01;31m-[00m>_children.end(); it++ ) {
quickDom.cc:565:	if ( (*it)[01;31m-[00m>getLocalName() == name ) {
quickDom.cc:579:    for ( it=this[01;31m-[00m>_children.begin(); it!=this[01;31m-[00m>_children.end(); it++ ) {
quickDom.cc:580:	if ( (*it)[01;31m-[00m>getLocalName() == name ) {
quickDom.cc:587:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("There can only be one child with the name(%s) in XML file(%s) at line(%d)") % name % this[01;31m-[00m>getFileName() % this[01;31m-[00m>getLineNumber() ));
quickDom.cc:590:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("There must be one child with the name(%s) in XML file(%s) at line(%d)") % name % this[01;31m-[00m>getFileName() % this[01;31m-[00m>getLineNumber() ));
quickDom.cc:600:    if ( this[01;31m-[00m>_children.size() != 1 ) {
quickDom.cc:601:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("This node must have one and only one child file(%s) line(%d) ") % this[01;31m-[00m>getFileName() % this[01;31m-[00m>getLineNumber() ));
quickDom.cc:603:    child = *(this[01;31m-[00m>_children.begin());
quickDom.cc:614:    LOG(BF("Coming in there are %d children") % (this[01;31m-[00m>_children.size() ) ); // vp0(( "Coming in there are %d children", this[01;31m-[00m>_children.size() ));
quickDom.cc:615:    it = this[01;31m-[00m>_children.begin();
quickDom.cc:616:    while ( it != this[01;31m-[00m>_children.end() ) {
quickDom.cc:617:	if ( (*it)[01;31m-[00m>getLocalName() == name ) {
quickDom.cc:619:	    it = this[01;31m-[00m>_children.erase(it);
quickDom.cc:625:    LOG(BF("Going out there are %d children") % (this[01;31m-[00m>_children.size() ) ); // vp0(( "Going out there are %d children", this[01;31m-[00m>_children.size() ));
quickDom.cc:636:    return this[01;31m-[00m>countChildrenWithName(name) > 0;
quickDom.cc:646:    for ( it=this[01;31m-[00m>_children.begin(); it!=this[01;31m-[00m>_children.end(); it++ ) {
quickDom.cc:647:	if ( (*it)[01;31m-[00m>getLocalName() == name ) num++;
quickDom.cc:662:    childs = this[01;31m-[00m>gatherSubNodesWithName(nm);
quickDom.cc:675:    childs = this[01;31m-[00m>getChildrenWithName(nm);
quickDom.cc:687:    childs = this[01;31m-[00m>getChildrenWithName(nm);
quickDom.cc:699:    childs = this[01;31m-[00m>getChildren();
quickDom.cc:712:    this[01;31m-[00m>parent = NULL;
quickDom.cc:713:    this[01;31m-[00m>localName = "";
quickDom.cc:714:    this[01;31m-[00m>characters.str("");
quickDom.cc:715:    this[01;31m-[00m>attributes.erase(this[01;31m-[00m>attributes.begin(), this[01;31m-[00m>attributes.end());
quickDom.cc:716:    this[01;31m-[00m>_children.erase(this[01;31m-[00m>_children.begin(), this[01;31m-[00m>_children.end());
quickDom.cc:742:    this[01;31m-[00m>eraseAll();
quickDom.cc:745:    this[01;31m-[00m>_FileName = fileName;
quickDom.cc:752:	TOSS(_lisp[01;31m-[00m>create<O_FileNotFoundException>(fileName));
quickDom.cc:756:    ASSERT_NOT_NULL(this[01;31m-[00m>lisp());
quickDom.cc:757:    ASSERT(this[01;31m-[00m>lisp()[01;31m-[00m>notNil());
quickDom.cc:758:    MySaxParser parser(this[01;31m-[00m>lisp());
quickDom.cc:813:    this[01;31m-[00m>dumpToStream(ss);
quickDom.cc:821:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You tried to add an empty child"));
quickDom.cc:823:    this[01;31m-[00m>_children.push_back(child);
quickDom.cc:828:{//_F(this[01;31m-[00m>lisp());
quickDom.cc:831:    if ( me[01;31m-[00m>getLocalName() == name ) {
quickDom.cc:836:    children = this[01;31m-[00m>getChildren();
quickDom.cc:839:	child[01;31m-[00m>fillVectorQDomNodesIfNameIs(depth+1,child,vnodes,name);
quickDom.cc:845:{//_F(this[01;31m-[00m>lisp());
quickDom.cc:849:    children = this[01;31m-[00m>getChildren();
quickDom.cc:852:	child[01;31m-[00m>fillVectorQDomNodesIfNameIs(1,child,vnodes,name);
quickDom.cc:862:    class_<O_QDomNode>(this[01;31m-[00m>lisp())
randomGenerators.cc:46://    this[01;31m-[00m>_Generator = new boost::mt19937();
randomGenerators.cc:47:    this[01;31m-[00m>_Distribution = new boost::normal_distribution<> (mean,stdev);
randomGenerators.cc:48:    this[01;31m-[00m>_VariateGenerator = new boost::variate_generator<boost::mt19937&,
randomGenerators.cc:49:	boost::normal_distribution<> > (_OnlyGenerator,*(this[01;31m-[00m>_Distribution));
randomGenerators.cc:50://    this[01;31m-[00m>_VariateGenerator = new boost::variate_generator<boost::mt19937&,boost::normal_distribution<> > (*(this[01;31m-[00m>_Generator),*(this[01;31m-[00m>_Distribution));
randomGenerators.cc:59:    delete this[01;31m-[00m>_VariateGenerator;
randomGenerators.cc:60:    delete this[01;31m-[00m>_Distribution;
randomGenerators.cc:61://    delete this[01;31m-[00m>_Generator;
randomGenerators.cc:67:    return (*(this[01;31m-[00m>_VariateGenerator))();
range.cc:16:    if ( args[01;31m-[00m>numberOfPositionalArguments() < 2 || 
range.cc:17:		args[01;31m-[00m>numberOfPositionalArguments() > 3  )
range.cc:19:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must have arguments [begin,end,step]"));
range.cc:21:    this[01;31m-[00m>_Begin = args[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
range.cc:22:    this[01;31m-[00m>_End = args[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
range.cc:23:    this[01;31m-[00m>_Step = 1;
range.cc:24:    if ( args[01;31m-[00m>numberOfPositionalArguments() == 3 )
range.cc:26:	this[01;31m-[00m>_Step = args[01;31m-[00m>getPositionalArgument(2)[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
range.cc:35:    r[01;31m-[00m>_Begin = b;
range.cc:36:    r[01;31m-[00m>_End = e;
range.cc:37:    r[01;31m-[00m>_Step = 1;
range.cc:44:    r[01;31m-[00m>_Begin = b;
range.cc:45:    r[01;31m-[00m>_End = e;
range.cc:46:    r[01;31m-[00m>_Step = step;
range.cc:53:{_F(this[01;31m-[00m>lisp());
range.cc:54:    RPCons dummy = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
range.cc:56:    for (int i=this[01;31m-[00m>_Begin; i<this[01;31m-[00m>_End; i+=this[01;31m-[00m>_Step )
range.cc:58:	RPCons one = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Int>(i),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
range.cc:59:	cur[01;31m-[00m>setCdr(one);
range.cc:62:    return dummy[01;31m-[00m>cdr();
range.cc:71:    ss << this[01;31m-[00m>_Begin;
range.cc:73:    ss << this[01;31m-[00m>_End;
range.cc:75:    ss << this[01;31m-[00m>_Step;
range.cc:82:    this[01;31m-[00m>Base::initialize();
range.cc:95:	class_<O_Range>(this[01;31m-[00m>lisp())
range.cc:98://	def("oldRange",&O_Range::create,this[01;31m-[00m>lisp());
readAmberParameters.cc:21:    this[01;31m-[00m>Base::initialize();
readAmberParameters.cc:22:    this[01;31m-[00m>_Types = O_FFTypesDb::nil(this[01;31m-[00m>lisp());
readAmberParameters.cc:23:    this[01;31m-[00m>_ForceField = O_ForceField::nil(this[01;31m-[00m>lisp());
readAmberParameters.cc:32:{_F(this[01;31m-[00m>lisp());
readAmberParameters.cc:33:    this[01;31m-[00m>_Types = this[01;31m-[00m>parseTypeRules(fileName);
readAmberParameters.cc:39:    this[01;31m-[00m>_ForceField = this[01;31m-[00m>parseAmberFormattedForceField(fileName);
readAmberParameters.cc:45:{_F(this[01;31m-[00m>lisp());
readAmberParameters.cc:46:    if ( this[01;31m-[00m>_ForceField[01;31m-[00m>notNil() )
readAmberParameters.cc:48:	this[01;31m-[00m>_ForceField[01;31m-[00m>setFFTypeDb(this[01;31m-[00m>_Types);
readAmberParameters.cc:50:    if ( this[01;31m-[00m>_ForceField[01;31m-[00m>isNil() )
readAmberParameters.cc:52:	this[01;31m-[00m>_ForceField = RP_Create<O_ForceField>(this[01;31m-[00m>lisp());
readAmberParameters.cc:54:    this[01;31m-[00m>_ForceField[01;31m-[00m>setFFTypeDb(this[01;31m-[00m>_Types);
readAmberParameters.cc:55:    return this[01;31m-[00m>_ForceField;
readAmberParameters.cc:62:{_F(this[01;31m-[00m>lisp());
readAmberParameters.cc:63:    RPWildElementDict wildCardElementDictionary = RP_Create<O_WildElementDict>(this[01;31m-[00m>lisp());
readAmberParameters.cc:64:    RPFFTypesDb ffTypesDb = RP_Create<O_FFTypesDb>(this[01;31m-[00m>lisp());
readAmberParameters.cc:71:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not open file: "+fileName ));
readAmberParameters.cc:76:	fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:83:            wildCardElementDictionary[01;31m-[00m>addWildName(wildName);
readAmberParameters.cc:86:                wildCardElementDictionary[01;31m-[00m>addWildNameMap(wildName,*it);
readAmberParameters.cc:99:	RPChemInfo typeRule = O_ChemInfo::create(this[01;31m-[00m>lisp());
readAmberParameters.cc:100:	typeRule[01;31m-[00m>compileAntechamber(ei[01;31m-[00m>second,wildCardElementDictionary);
readAmberParameters.cc:101:        if ( typeRule[01;31m-[00m>compileSucceeded() )
readAmberParameters.cc:103:            ffTypesDb[01;31m-[00m>add(typeRule);
readAmberParameters.cc:106:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Antechamber compile failed on: "+ei[01;31m-[00m>second+"\n"+typeRule[01;31m-[00m>compilerMessage() ));
readAmberParameters.cc:117:{_F(this[01;31m-[00m>lisp());
readAmberParameters.cc:118:    RPFFNonbondDb ffNonbondDb = RP_Create<O_FFNonbondDb>(this[01;31m-[00m>lisp());
readAmberParameters.cc:123:	fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:134:            RPFFNonbond ffNonbond = RP_Create<O_FFNonbond>(this[01;31m-[00m>lisp());
readAmberParameters.cc:135:            ffNonbond[01;31m-[00m>_Type = typeName;
readAmberParameters.cc:136:            ffNonbond[01;31m-[00m>_Mass = mass;
readAmberParameters.cc:137:            ffNonbond[01;31m-[00m>_Polarizability = polarizability;
readAmberParameters.cc:138:            ffNonbondDb[01;31m-[00m>add(ffNonbond);
readAmberParameters.cc:141:    fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:146:{_F(this[01;31m-[00m>lisp());
readAmberParameters.cc:148:    RPFFStretchDb ffStretchDb = RP_Create<O_FFStretchDb>(this[01;31m-[00m>lisp());
readAmberParameters.cc:153:	fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:161:            vector<string>typeParts = split(types,"[01;31m-[00m");
readAmberParameters.cc:164:            RPFFStretch ffStretch = RP_Create<O_FFStretch>(this[01;31m-[00m>lisp());
readAmberParameters.cc:165:            ffStretch[01;31m-[00m>_Type1 = type1Name;
readAmberParameters.cc:166:            ffStretch[01;31m-[00m>_Type2 = type2Name;
readAmberParameters.cc:169:            ffStretch[01;31m-[00m>_kb = atof(parmsParts[0].c_str());
readAmberParameters.cc:170:            ffStretch[01;31m-[00m>_r0 = atof(parmsParts[1].c_str());
readAmberParameters.cc:171://            print "(%s)[01;31m-[00m(%s) k=%lf len=%lf"%(ffStretch._Type1,ffStretch._Type2,ffStretch._kb, ffStretch._r0)
readAmberParameters.cc:172:            ffStretchDb[01;31m-[00m>add(ffStretch);
readAmberParameters.cc:180:{_F(this[01;31m-[00m>lisp());
readAmberParameters.cc:184:    RPFFAngleDb ffAngleDb = RP_Create<O_FFAngleDb>(this[01;31m-[00m>lisp());
readAmberParameters.cc:189:	fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:198:            vector<string>typeParts = split(types,"[01;31m-[00m");
readAmberParameters.cc:202:            RPFFAngle ffAngle = RP_Create<O_FFAngle>(this[01;31m-[00m>lisp());
readAmberParameters.cc:203:            ffAngle[01;31m-[00m>_Type1 = t1;
readAmberParameters.cc:204:            ffAngle[01;31m-[00m>_Type2 = t2;
readAmberParameters.cc:205:            ffAngle[01;31m-[00m>_Type3 = t3;
readAmberParameters.cc:208:            ffAngle[01;31m-[00m>_K2 = atof(parmsParts[0].c_str());
readAmberParameters.cc:209:            ffAngle[01;31m-[00m>_AngRad = atof(parmsParts[1].c_str())*0.0174533;
readAmberParameters.cc:210://            print "(%s)[01;31m-[00m(%s)[01;31m-[00m(%s) k=%lf ang(deg)=%lf"%(ffAngle._Type1,ffAngle._Type2, ffAngle._Type3,ffAngle._K2, ffAngle._AngRad/0.0174533)
readAmberParameters.cc:211:            ffAngleDb[01;31m-[00m>add(ffAngle);
readAmberParameters.cc:220:{_F(this[01;31m-[00m>lisp());
readAmberParameters.cc:224:    RPFFPtorDb ffPtorDb = RP_Create<O_FFPtorDb>(this[01;31m-[00m>lisp());
readAmberParameters.cc:229:	fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:238:            vector<string>typeParts = split(types,"[01;31m-[00m");
readAmberParameters.cc:245:            RPFFPtor ffPtor = RP_Create<O_FFPtor>(this[01;31m-[00m>lisp());
readAmberParameters.cc:246:            ffPtor[01;31m-[00m>setTypes(t1,t2,t3,t4);
readAmberParameters.cc:253:            ffPtor[01;31m-[00m>setV(pn,pk/idivf);
readAmberParameters.cc:254:            ffPtor[01;31m-[00m>setPhaseRad(pn,phaseRad);
readAmberParameters.cc:255:            ffPtorDb[01;31m-[00m>add(ffPtor);
readAmberParameters.cc:266:{_F(this[01;31m-[00m>lisp());
readAmberParameters.cc:270:    RPFFItorDb ffItorDb = RP_Create<O_FFItorDb>(this[01;31m-[00m>lisp());
readAmberParameters.cc:275:	fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:284:            vector<string>typeParts = split(types,"[01;31m-[00m");
readAmberParameters.cc:292:            RPFFItor ffItor = RP_Create<O_FFItor>(this[01;31m-[00m>lisp());
readAmberParameters.cc:293:            ffItor[01;31m-[00m>setTypes(t1,t2,t3,t4);
readAmberParameters.cc:299:            ffItor[01;31m-[00m>setV(pn,pk);
readAmberParameters.cc:300:            ffItor[01;31m-[00m>setPhaseRad(pn,phaseRad);
readAmberParameters.cc:301:            ffItorDb[01;31m-[00m>add(ffItor);
readAmberParameters.cc:313:{_F(this[01;31m-[00m>lisp());
readAmberParameters.cc:316:    fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:323:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Nonbond parameters must be of kindnb=RE this file has kindnb="+kindnb));
readAmberParameters.cc:327:        fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:337:	    if ( ffNonbondDb[01;31m-[00m>hasType(type) )
readAmberParameters.cc:339:		ffNonbond = ffNonbondDb[01;31m-[00m>findType(type);
readAmberParameters.cc:342:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find type: "+type));
readAmberParameters.cc:350:            ffNonbond[01;31m-[00m>_Radius = radius;
readAmberParameters.cc:351:	    ffNonbond[01;31m-[00m>_Well = edep;
readAmberParameters.cc:369:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not open file: "+parametersFileName ));
readAmberParameters.cc:371:    fin.getline(buffer,sizeof(buffer)[01;31m-[00m1);
readAmberParameters.cc:373:    RPFFNonbondDb ffNonbondsDb = this[01;31m-[00m>parseFirstNonbondDb(fin);
readAmberParameters.cc:374:    RPFFStretchDb ffStretchesDb = this[01;31m-[00m>parseStretchDb(fin);
readAmberParameters.cc:375:    RPFFAngleDb ffAnglesDb = this[01;31m-[00m>parseAngleDb(fin);
readAmberParameters.cc:376:    RPFFPtorDb ffPtorsDb = this[01;31m-[00m>parsePtorDb(fin);
readAmberParameters.cc:377:    RPFFItorDb ffItorsDb = this[01;31m-[00m>parseItorDb(fin);
readAmberParameters.cc:378:    fin.getline(buffer,sizeof(buffer)[01;31m-[00m1); // skp 10[01;31m-[00m12 hbond
readAmberParameters.cc:379:    fin.getline(buffer,sizeof(buffer)[01;31m-[00m1); // blank
readAmberParameters.cc:380:    fin.getline(buffer,sizeof(buffer)[01;31m-[00m1); // skip equivalence
readAmberParameters.cc:381:    fin.getline(buffer,sizeof(buffer)[01;31m-[00m1); // blank
readAmberParameters.cc:382:    this[01;31m-[00m>parseNonbondDb(fin,ffNonbondsDb);
readAmberParameters.cc:384:    RPForceField ff = RP_Create<O_ForceField>(this[01;31m-[00m>lisp());
readAmberParameters.cc:385:    ff[01;31m-[00m>setTitle(title);
readAmberParameters.cc:386:    ff[01;31m-[00m>setFFStretchDb(ffStretchesDb);
readAmberParameters.cc:387:    ff[01;31m-[00m>setFFTypeDb(O_FFTypesDb::nil(this[01;31m-[00m>lisp()));
readAmberParameters.cc:388:    ff[01;31m-[00m>setFFAngleDb(ffAnglesDb);
readAmberParameters.cc:389:    ff[01;31m-[00m>setFFPtorDb(ffPtorsDb);
readAmberParameters.cc:390:    ff[01;31m-[00m>setFFItorDb(ffItorsDb);
readAmberParameters.cc:391:    ff[01;31m-[00m>setFFNonbondDb(ffNonbondsDb);
readAmberParameters.cc:395:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("H", 0.784);
readAmberParameters.cc:396:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("C", 1.183);
readAmberParameters.cc:397:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("N", 1.212);
readAmberParameters.cc:398:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("O", 1.219);
readAmberParameters.cc:399:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("F", 1.166);
readAmberParameters.cc:400:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("Cl", 1.272);
readAmberParameters.cc:401:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("Br", 1.378);
readAmberParameters.cc:402:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("I", 1.398);
readAmberParameters.cc:403:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("P", 1.620);
readAmberParameters.cc:404:    ff[01;31m-[00m>_Angles[01;31m-[00m>addZConstant("S", 1.280);
readAmberParameters.cc:405:    ff[01;31m-[00m>_Angles[01;31m-[00m>addCConstant("C", 1.339);
readAmberParameters.cc:406:    ff[01;31m-[00m>_Angles[01;31m-[00m>addCConstant("N", 1.300);
readAmberParameters.cc:407:    ff[01;31m-[00m>_Angles[01;31m-[00m>addCConstant("O", 1.249);
readAmberParameters.cc:408:    ff[01;31m-[00m>_Angles[01;31m-[00m>addCConstant("P", 0.906);
readAmberParameters.cc:409:    ff[01;31m-[00m>_Angles[01;31m-[00m>addCConstant("S", 1.448);
readAmberParameters.cc:414:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "H", 0.738, 4.661 );
readAmberParameters.cc:415:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "C", "C", 1.526, 7.643 );
readAmberParameters.cc:416:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "N", "N", 1.441, 7.634 );
readAmberParameters.cc:417:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "O", "O", 1.460, 7.561 );
readAmberParameters.cc:418:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "F", "F", 1.406, 7.358 );
readAmberParameters.cc:419:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "Cl", "Cl", 2.031, 8.648 );
readAmberParameters.cc:420:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "Br", "Br", 2.337, 9.012 );
readAmberParameters.cc:421:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "I", "I", 2.836, 9.511 );
readAmberParameters.cc:422:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "P", "P", 2.324, 8.805 );
readAmberParameters.cc:423:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "S", "S", 2.038, 8.316 );
readAmberParameters.cc:424:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "C", 1.090, 6.217 );
readAmberParameters.cc:425:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "N", 1.010, 6.057 );
readAmberParameters.cc:426:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "O", 0.960, 5.794 );
readAmberParameters.cc:427:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "F", 0.920, 5.600 );
readAmberParameters.cc:428:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "Cl", 1.280, 6.937 );
readAmberParameters.cc:429:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "Br", 1.410, 7.301 );
readAmberParameters.cc:430:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "I", 1.600, 7.802 );
readAmberParameters.cc:431:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "P", 1.410, 7.257 );
readAmberParameters.cc:432:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "H", "S", 1.340, 7.018 );
readAmberParameters.cc:433:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "C", "N", 1.470, 7.504 );
readAmberParameters.cc:434:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "C", "O", 1.440, 7.347 );
readAmberParameters.cc:435:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "C", "F", 1.370, 7.227 );
readAmberParameters.cc:436:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "C", "Cl", 1.800, 8.241 );
readAmberParameters.cc:437:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "C", "Br", 1.940, 8.478 );
readAmberParameters.cc:438:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "C", "I", 2.160, 8.859 );
readAmberParameters.cc:439:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "C", "P", 1.830, 8.237 );
readAmberParameters.cc:440:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "C", "S", 1.820, 8.117 );
readAmberParameters.cc:441:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "N", "O", 1.420, 7.526 );
readAmberParameters.cc:442:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "N", "F", 1.420, 7.475 );
readAmberParameters.cc:443:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "N", "Cl", 1.750, 8.266 );
readAmberParameters.cc:444:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "N", "Br", 1.930, 8.593 );
readAmberParameters.cc:445:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "N", "I", 2.120, 8.963 );
readAmberParameters.cc:446:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "N", "P", 1.720, 8.212 );
readAmberParameters.cc:447:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "N", "S", 1.690, 8.073 );
readAmberParameters.cc:448:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "O", "F", 1.410, 7.375 );
readAmberParameters.cc:449:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "O", "Cl", 1.700, 8.097 );
readAmberParameters.cc:450:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "O", "Br", 1.790, 8.276 );
readAmberParameters.cc:451:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "O", "I", 2.110, 8.854 );
readAmberParameters.cc:452:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "O", "P", 1.640, 7.957 );
readAmberParameters.cc:453:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "O", "S", 1.650, 7.922 );
readAmberParameters.cc:454:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "F", "Cl", 1.648, 7.947 );
readAmberParameters.cc:455:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "Cl", "I", 2.550, 9.309 );
readAmberParameters.cc:456:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "Br", "I", 2.671, 9.380 );
readAmberParameters.cc:457:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "F", "P", 1.500, 7.592 );
readAmberParameters.cc:458:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "F", "S", 1.580, 7.733 );
readAmberParameters.cc:459:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "Cl", "P", 2.040, 8.656 );
readAmberParameters.cc:460:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "Cl", "S", 2.030, 8.619 );
readAmberParameters.cc:461:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "Br", "P", 2.240, 8.729 );
readAmberParameters.cc:462:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "Br", "S", 2.210, 8.728 );
readAmberParameters.cc:463:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "I", "P", 2.490, 9.058 );
readAmberParameters.cc:464:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "I", "S", 2.560, 9.161 );
readAmberParameters.cc:465:    ff[01;31m-[00m>_Stretches[01;31m-[00m>addEstimateStretch( "P", "S", 2.120, 8.465 );
readAmberParameters.cc:475:	class_<O_ReadAmberParameters>(this[01;31m-[00m>lisp())
reader.cc:34:	    lisplex_init(&(this[01;31m-[00m>scanner));
reader.cc:35:	    lisp_LOG(this[01;31m-[00m>lisp(),BF("Flushing parser"));
reader.cc:36:	    lispset_extra(this,this[01;31m-[00m>scanner);
reader.cc:38:	this[01;31m-[00m>expression = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>();
reader.cc:39:	this[01;31m-[00m>bracketDepth = 0;
reader.cc:40:	this[01;31m-[00m>currentLineIndent = 0;
reader.cc:41:	this[01;31m-[00m>specialsDefined = false;
reader.cc:42:	this[01;31m-[00m>debugScannerLevel = 0;
reader.cc:43:	this[01;31m-[00m>_stringSaveStateDepth = 0;
reader.cc:44:	this[01;31m-[00m>switchToIndentStartCondition = true;
reader.cc:45:	this[01;31m-[00m>lispScannerQueue.reset(this[01;31m-[00m>lisp());
reader.cc:46:	this[01;31m-[00m>lispIndentStack.reset(this[01;31m-[00m>lisp());
reader.cc:47:	this[01;31m-[00m>lispIndentStack.push(0);
reader.cc:48:	this[01;31m-[00m>colnum = 1;
reader.cc:49:	this[01;31m-[00m>eofToEol=1;
reader.cc:55:	int ret = lisplex_destroy(this[01;31m-[00m>scanner);
reader.cc:56:	this[01;31m-[00m>scanner = NULL;
reader.cc:70:	class_<O_Reader>(lisp[01;31m-[00m>lisp())
reader.cc:77:	RPReader reader = lisp[01;31m-[00m>create<O_Reader>();
reader.cc:78:	reader[01;31m-[00m>openString(code);
reader.cc:84:	RPReader reader = lisp[01;31m-[00m>create<O_Reader>();
reader.cc:85:	reader[01;31m-[00m>openFile(fileName);
reader.cc:93:	this[01;31m-[00m>_ParserParam.scanner = NULL;
reader.cc:94:	this[01;31m-[00m>_ParserParam.lispStream = NULL;
reader.cc:96:	this[01;31m-[00m>_Input = NULL;
reader.cc:103:	this[01;31m-[00m>_ParserParam._lisp = this[01;31m-[00m>lisp();
reader.cc:105:	this[01;31m-[00m>_Column = 1;
reader.cc:106:	this[01;31m-[00m>_Input = NULL;
reader.cc:107:	this[01;31m-[00m>_LineNumber = 1;
reader.cc:109:	this[01;31m-[00m>_IsOpen = false;
reader.cc:114:	if ( this[01;31m-[00m>_IsOpen) this[01;31m-[00m>close();
reader.cc:119:	ASSERT(!this[01;31m-[00m>_IsOpen);
reader.cc:121:	this[01;31m-[00m>_ParserParam.startup();
reader.cc:123:	this[01;31m-[00m>_LineNumber = 1;
reader.cc:124:	this[01;31m-[00m>_Column = 1;
reader.cc:126:	this[01;31m-[00m>_IsOpen = true;
reader.cc:131:	ASSERT(!this[01;31m-[00m>_IsOpen);
reader.cc:135:	    pathName = this[01;31m-[00m>lisp()[01;31m-[00m>findFileInLispPath(fileName);
reader.cc:138:	    this[01;31m-[00m>lisp()[01;31m-[00m>print(BF("The script file: %s could not be found") % fileName.c_str() );
reader.cc:141:	this[01;31m-[00m>_FileReader = true;
reader.cc:143:	this[01;31m-[00m>_ParserParam.fileName = fileName;
reader.cc:144:	this[01;31m-[00m>_ParserParam.lispStream = new ifstream(pathName.c_str());
reader.cc:146:	this[01;31m-[00m>_FileName = fileName;
reader.cc:148:	this[01;31m-[00m>_Input = fin;
reader.cc:149:	if ( !fin[01;31m-[00m>is_open() )
reader.cc:151:	    TOSS(this[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Problem opening file(%s)") % pathName ) );
reader.cc:154:	this[01;31m-[00m>prepareToRead();
reader.cc:159:	ASSERT(!this[01;31m-[00m>_IsOpen);
reader.cc:161:	this[01;31m-[00m>_FileReader = false;
reader.cc:163:	this[01;31m-[00m>_ParserParam.fileName = "[01;31m-[00m[01;31m-[00minternalString[01;31m-[00m[01;31m-[00m";
reader.cc:164:	this[01;31m-[00m>_ParserParam.lispStream = new istringstream(code,istringstream::in);
reader.cc:166:	this[01;31m-[00m>_LineNumber = 1;
reader.cc:167:	this[01;31m-[00m>_Column = 1;
reader.cc:168:	this[01;31m-[00m>_Input = new istringstream(code,istringstream::in);
reader.cc:170:	this[01;31m-[00m>prepareToRead();
reader.cc:176:	ASSERT(this[01;31m-[00m>_IsOpen);
reader.cc:178:	if ( this[01;31m-[00m>_ParserParam.scanner != NULL )
reader.cc:180:	    this[01;31m-[00m>_ParserParam.shutdown();
reader.cc:182:	if ( this[01;31m-[00m>_ParserParam.lispStream != NULL )
reader.cc:184:	    delete this[01;31m-[00m>_ParserParam.lispStream;
reader.cc:185:	    this[01;31m-[00m>_ParserParam.lispStream = NULL;
reader.cc:188:	if ( this[01;31m-[00m>_Input != NULL )
reader.cc:190:	    delete this[01;31m-[00m>_Input;
reader.cc:191:	    this[01;31m-[00m>_Input = NULL;
reader.cc:198:	ASSERT(this[01;31m-[00m>_IsOpen);
reader.cc:199:	ASSERT(!this[01;31m-[00m>_FileReader);
reader.cc:200:	this[01;31m-[00m>close();
reader.cc:201:	this[01;31m-[00m>openString(code);
reader.cc:207:	RPSpecialForm special = this[01;31m-[00m>lisp()[01;31m-[00m>specialFormOrNil(chars);
reader.cc:208:	if ( special[01;31m-[00m>notNil() ) return special;
reader.cc:209:	RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(chars);
reader.cc:227:	    return this[01;31m-[00m>lisp()[01;31m-[00m>_true();
reader.cc:232:	    return this[01;31m-[00m>lisp()[01;31m-[00m>_false();
reader.cc:237:	    LOG(BF("saw escape [01;31m-[00m symbol"));
reader.cc:238:	    RPObject sym = this[01;31m-[00m>parseSymbolOrSpecial(chars);
reader.cc:244:	char lastChar = chars[chars.size()[01;31m-[00m1];
reader.cc:248:	if ( *beginChar == '+' || *beginChar == '[01;31m-[00m' )
reader.cc:273:		    RPReal od = O_Real::create(d,this[01;31m-[00m>lisp());
reader.cc:282:		if ( lastValid == endChar[01;31m-[00m1 )
reader.cc:285:		    RPLongLongInt oll = O_LongLongInt::create(lli,this[01;31m-[00m>lisp());
reader.cc:295:		RPInt oi = O_Int::create(li,this[01;31m-[00m>lisp());
reader.cc:302:	RPObject sym = this[01;31m-[00m>parseSymbolOrSpecial(chars);
reader.cc:308:	ASSERT(this[01;31m-[00m>_IsOpen);
reader.cc:311:	this[01;31m-[00m>skipWhiteSpace();
reader.cc:312:	if ( this[01;31m-[00m>eof() )
reader.cc:315:	    return this[01;31m-[00m>lisp()[01;31m-[00m>_eof();
reader.cc:317:	Token tok = this[01;31m-[00m>nextToken(chars,sawEscape);
reader.cc:322:	    RPParsingCons list = this[01;31m-[00m>readList();
reader.cc:327:	    RPObject quotedObject = this[01;31m-[00m>read();
reader.cc:328:	    RPParsingCons result = O_ParsingCons::createList(this[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_quote(),quotedObject,this[01;31m-[00m>lineNumber(),this[01;31m-[00m>column(),this[01;31m-[00m>fileName(),this[01;31m-[00m>lisp());
reader.cc:333:	    RPObject str = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(chars);
reader.cc:338:	    RPObject quotedObject = this[01;31m-[00m>read();
reader.cc:339:	    RPParsingCons result = O_ParsingCons::createList(this[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_sharpQuote(),
reader.cc:340:							     quotedObject,this[01;31m-[00m>lineNumber(),this[01;31m-[00m>column(),this[01;31m-[00m>fileName(),this[01;31m-[00m>lisp());
reader.cc:345:	    RPObject quotedObject = this[01;31m-[00m>read();
reader.cc:346:	    RPParsingCons result = O_ParsingCons::createList(this[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_backQuote(),quotedObject,this[01;31m-[00m>lineNumber(),this[01;31m-[00m>column(),this[01;31m-[00m>fileName(),this[01;31m-[00m>lisp());
reader.cc:351:	    RPObject quotedObject = this[01;31m-[00m>read();
reader.cc:352:	    RPParsingCons result = O_ParsingCons::createList(this[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_comma(),quotedObject,this[01;31m-[00m>lineNumber(),this[01;31m-[00m>column(),this[01;31m-[00m>fileName(),this[01;31m-[00m>lisp());
reader.cc:357:	    RPObject quotedObject = this[01;31m-[00m>read();
reader.cc:358:	    RPParsingCons result = O_ParsingCons::createList(this[01;31m-[00m>lisp()[01;31m-[00m>getSpecialForm_commaAt(),quotedObject,this[01;31m-[00m>lineNumber(),this[01;31m-[00m>column(),this[01;31m-[00m>fileName(),this[01;31m-[00m>lisp());
reader.cc:363:	    return this[01;31m-[00m>parseString(chars,sawEscape);
reader.cc:367:	    TOSS(this[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Hit unexpected close parenthesis %s") % this[01;31m-[00m>posAsString() ));
reader.cc:371:	    TOSS(this[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Hit unexpected token %s") % this[01;31m-[00m>posAsString() ));
reader.cc:374:	    return this[01;31m-[00m>lisp()[01;31m-[00m>onil();
reader.cc:382:	return this[01;31m-[00m>_Input[01;31m-[00m>peek();
reader.cc:387:	if ( this[01;31m-[00m>eof() ) return '\0';
reader.cc:389:	this[01;31m-[00m>_Input[01;31m-[00m>get(c);
reader.cc:390:	this[01;31m-[00m>_Column++;
reader.cc:393:	    this[01;31m-[00m>_Column = 1;
reader.cc:394:	    this[01;31m-[00m>_LineNumber++;
reader.cc:400:	    if ( this[01;31m-[00m>peekChar() == '\n') this[01;31m-[00m>_Input[01;31m-[00m>get(cc);
reader.cc:401:	    this[01;31m-[00m>_Column = 1;
reader.cc:402:	    this[01;31m-[00m>_LineNumber++;
reader.cc:411:	return this[01;31m-[00m>_Input[01;31m-[00m>eof();
reader.cc:417:	while (!this[01;31m-[00m>eof())
reader.cc:419:	    char c = this[01;31m-[00m>nextChar();
reader.cc:427:	while (!this[01;31m-[00m>eof())
reader.cc:429:	    char c = this[01;31m-[00m>_Input[01;31m-[00m>peek();
reader.cc:432:		this[01;31m-[00m>nextChar();
reader.cc:435:		this[01;31m-[00m>skipToEol();
reader.cc:452:	return this[01;31m-[00m>inSet(c," \t\n\r");
reader.cc:457:	return this[01;31m-[00m>inSet(c,"()\";,`'");
reader.cc:465:	while (!this[01;31m-[00m>eof())
reader.cc:467:	    char c = this[01;31m-[00m>_Input[01;31m-[00m>peek();
reader.cc:468:	    if ( this[01;31m-[00m>isWhiteSpace(c) || this[01;31m-[00m>isTerminal(c) ) break;
reader.cc:469:	    c = this[01;31m-[00m>nextChar();
reader.cc:480:	uint startLineNumber = this[01;31m-[00m>lineNumber();
reader.cc:483:	    char c = this[01;31m-[00m>peekChar();
reader.cc:486:		this[01;31m-[00m>nextChar();
reader.cc:489:	    c = this[01;31m-[00m>nextChar();
reader.cc:490:	    if ( this[01;31m-[00m>eof() )
reader.cc:492:		TOSS(this[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Unterminated string %s [01;31m-[00m it started on line %d") % this[01;31m-[00m>posAsString() % startLineNumber ));
reader.cc:503:	ss << this[01;31m-[00m>_LineNumber << ":" << this[01;31m-[00m>_Column << " " << this[01;31m-[00m>_FileName;
reader.cc:511:	this[01;31m-[00m>skipWhiteSpace();
reader.cc:512:	char c = this[01;31m-[00m>nextChar();
reader.cc:516:	    LOG(BF("Token[%c] [01;31m-[00m openParen") % c );
reader.cc:519:	    LOG(BF("Token[)] [01;31m-[00m closeParen") );
reader.cc:522:	    LOG(BF("Token['] [01;31m-[00m singleQuote"));
reader.cc:525:	    LOG(BF("Token[\"] [01;31m-[00m doubleQuote"));
reader.cc:526:	    chars = this[01;31m-[00m>readDoubleQuoteString();
reader.cc:530:	    LOG(BF("Token[#] [01;31m-[00m sharp"));
reader.cc:531:	    char p = this[01;31m-[00m>peekChar();
reader.cc:534:		LOG(BF("  completed [#'] [01;31m-[00m sharpQuote"));
reader.cc:535:		p = this[01;31m-[00m>nextChar();
reader.cc:538:	    TOSS(this[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Illegal sharp sequence (#%c)") % p ));
reader.cc:542:	    LOG(BF("Token[`] [01;31m-[00m backQuote"));
reader.cc:546:	    char cp = this[01;31m-[00m>peekChar();
reader.cc:549:		LOG(BF("Token[,@] [01;31m-[00m commaAt"));
reader.cc:550:		cp = this[01;31m-[00m>nextChar();
reader.cc:553:	    LOG(BF("Token[,] [01;31m-[00m comma"));
reader.cc:557:	chars = this[01;31m-[00m>readString(c);
reader.cc:564:	RPParsingCons first = O_ParsingCons::create(this[01;31m-[00m>lisp()[01;31m-[00m>onil(),this[01;31m-[00m>lisp()[01;31m-[00m>cnil(),0,0,"[01;31m-[00mnofile[01;31m-[00m",this[01;31m-[00m>lisp());
reader.cc:568:	    this[01;31m-[00m>skipWhiteSpace();
reader.cc:569:	    char c = this[01;31m-[00m>peekChar();
reader.cc:572:		this[01;31m-[00m>nextChar();
reader.cc:575:	    uint lineNumber = this[01;31m-[00m>_LineNumber;
reader.cc:576:	    uint column = this[01;31m-[00m>_Column;
reader.cc:577:	    RPObject element = this[01;31m-[00m>read();
reader.cc:578:	    if ( this[01;31m-[00m>eof() )
reader.cc:580:		TOSS(this[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Found unterminated list %s") % this[01;31m-[00m>posAsString() ));
reader.cc:582:	    RPParsingCons one = O_ParsingCons::create(element,this[01;31m-[00m>lisp()[01;31m-[00m>cnil(),lineNumber,column,this[01;31m-[00m>fileName(),this[01;31m-[00m>lisp());
reader.cc:583:	    cur[01;31m-[00m>setCdr(one);
reader.cc:586:	LOG(BF("readList: %s") % first[01;31m-[00m>cdr()[01;31m-[00m>__repr__() );
reader.cc:587:	return first[01;31m-[00m>cdr()[01;31m-[00m>as<O_ParsingCons>();
referencerConformation.cc:22:    class_<O_ReferencerConformation>(e[01;31m-[00m>lisp())
referencerConformation.cc:41:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
referencerConformation.cc:47:    this[01;31m-[00m>Base::initialize();
referencerConformation.cc:48:    this[01;31m-[00m>_Coordinates = O_CoordinateArray::nil(this[01;31m-[00m>lisp());
referencerConformation.cc:49:    this[01;31m-[00m>_Data = O_ObjectDictionary::create(this[01;31m-[00m>lisp());
referencerConformation.cc:57:    this[01;31m-[00m>Base::archiveBase(node);
referencerConformation.cc:58:    node[01;31m-[00m>attribute("oligomerChangeCounter",this[01;31m-[00m>_OligomerChangeCounter);
referencerConformation.cc:59:    node[01;31m-[00m>attribute("sequenceChangeCounter",this[01;31m-[00m>_SequenceChangeCounter);
referencerConformation.cc:60:    node[01;31m-[00m>archiveObject("coordinates",this[01;31m-[00m>_Coordinates);
referencerConformation.cc:61:    node[01;31m-[00m>archiveObject("data",this[01;31m-[00m>_Data);
referencerConformation.cc:68:    this[01;31m-[00m>_OligomerChangeCounter = olig;
referencerConformation.cc:69:    this[01;31m-[00m>_SequenceChangeCounter = seq;
referencerConformation.cc:75:    ASSERT_NOT_NULL(this[01;31m-[00m>_Coordinates);
referencerConformation.cc:76:    ASSERT(this[01;31m-[00m>_Coordinates[01;31m-[00m>notNil());
referencerConformation.cc:77:    return this[01;31m-[00m>_Coordinates;
referencerConformation.cc:83:    this[01;31m-[00m>_Coordinates = c;
referencerConformation.cc:89:{_F(this[01;31m-[00m>lisp());
referencerConformation.cc:90:    return this[01;31m-[00m>_Data[01;31m-[00m>rendered(kargs);
referencerConformation.cc:99:    this[01;31m-[00m>_OligomerChangeCounter = builder[01;31m-[00m>getOligomerChangeCounter();
referencerConformation.cc:100:    this[01;31m-[00m>_SequenceChangeCounter = builder[01;31m-[00m>getSequenceChangeCounter();
referencerConformation.cc:101:    this[01;31m-[00m>_Coordinates = builder[01;31m-[00m>getConformationAsCoordinateArray();
referencerConformation.cc:106:    ASSERTP( this[01;31m-[00m>_OligomerChangeCounter == builder[01;31m-[00m>getOligomerChangeCounter(),
referencerConformation.cc:108:    ASSERTP( this[01;31m-[00m>_SequenceChangeCounter == builder[01;31m-[00m>getSequenceChangeCounter(),
referencerConformation.cc:110:    builder[01;31m-[00m>applyCoordinateArrayAsConformation(this[01;31m-[00m>_Coordinates);
rejector.cc:47:    this[01;31m-[00m>Base::initialize();
rejector.cc:51:{_F(this[01;31m-[00m>lisp());
rejector.cc:52:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
rejector.cc:70:    class_<O_Rejector>(this[01;31m-[00m>lisp())
render.cc:34:{_F(dl[01;31m-[00m>lisp());
render.cc:40:    Vector3 toward1 = (pos1[01;31m-[00mcenter).normalizedOrZero();
render.cc:41:    Vector3 toward2 = (pos2[01;31m-[00mcenter).normalizedOrZero();
render.cc:48:	dl[01;31m-[00m>add(color);
render.cc:49:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(mid1,mid2));
render.cc:50:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("blue"));
render.cc:51:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(mid1,pos1));
render.cc:52:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(mid2,pos2));
render.cc:58:	dl[01;31m-[00m>add(color);
render.cc:59:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(pos1,pos2));
render.cc:60:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("red"));
render.cc:61:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(past1,pos1));
render.cc:62:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(past2,pos2));
render.cc:71:{_F(dl[01;31m-[00m>lisp());
render.cc:78:    Vector3 toward1 = (pos1[01;31m-[00mcenter).normalizedOrZero();
render.cc:79:    Vector3 toward2 = (pos2[01;31m-[00mcenter).normalizedOrZero();
render.cc:86:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("yellow"));
render.cc:87:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(mid1,mid2));
render.cc:88:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("blue"));
render.cc:89:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(mid1,pos1));
render.cc:90:	dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(mid2,pos2));
render.cc:105:{_F(dl[01;31m-[00m>lisp());
render.cc:112:    Vector3 toward1 = (pos1[01;31m-[00mcenter).normalizedOrZero();
render.cc:113:    Vector3 toward2 = (pos2[01;31m-[00mcenter).normalizedOrZero();
render.cc:120:	dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("yellow"));
render.cc:121:	dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(mid1,mid2));
render.cc:122:	dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("blue"));
render.cc:123:	dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(mid1,pos1));
render.cc:124:	dl[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(mid2,pos2));
render.cc:141:    dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("yellow"));
render.cc:142:    dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(pos1,pos2));
render.cc:143:    dl[01;31m-[00m>add(dl[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(pos3,pos4));
render.cc:151:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:167:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:174:    this[01;31m-[00m>Base::initialize();
render.cc:175:    this[01;31m-[00m>_Width = 1;
render.cc:180:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:181:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "v1","Vector3",
render.cc:182:    					this[01;31m-[00m>_V1.isDefined(), this[01;31m-[00m>_V1 );
render.cc:183:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "v2","Vector3",
render.cc:184:    					this[01;31m-[00m>_V2.isDefined(), this[01;31m-[00m>_V2 );
render.cc:185:    node[01;31m-[00m>attributeIfNotDefault("width",this[01;31m-[00m>_Width,(uint)(1));
render.cc:190:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrLine>(args,environ);
render.cc:191:    this[01;31m-[00m>_V1 = _ARG(Vector3,bargs,"v1");
render.cc:192://    this[01;31m-[00m>_V1 = from_object<Vector3>::convert(bargs[01;31m-[00m>lookup("v1"));
render.cc:193:    this[01;31m-[00m>_V2 = from_object<Vector3>::convert(bargs[01;31m-[00m>lookup("v2"));
render.cc:194:    this[01;31m-[00m>_Width = from_object<int>::convert(bargs[01;31m-[00m>lookup("width"));
render.cc:195:    return lisp[01;31m-[00m>onil();
render.cc:200:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrPoint>(args,environ);
render.cc:201:    this[01;31m-[00m>_Position = from_object<Vector3>::convert(bargs[01;31m-[00m>lookup("v"));
render.cc:202:    return lisp[01;31m-[00m>onil();
render.cc:208:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:209:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "v","Vector3",
render.cc:210:				this[01;31m-[00m>_Position.isDefined(), this[01;31m-[00m>_Position );
render.cc:216:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrSphere>(args,environ);
render.cc:217:    this[01;31m-[00m>_Center= from_object<Vector3>::convert(bargs[01;31m-[00m>lookup("center"));
render.cc:218:    this[01;31m-[00m>_Radius = from_object<double>::convert(bargs[01;31m-[00m>lookup("radius"));
render.cc:219:    return lisp[01;31m-[00m>onil();
render.cc:225:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:226:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "v","Vector3",
render.cc:227:				this[01;31m-[00m>_Center.isDefined(), this[01;31m-[00m>_Center );
render.cc:228:    node[01;31m-[00m>attribute("r",this[01;31m-[00m>_Radius );
render.cc:235:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrText>(args,environ);
render.cc:236:    this[01;31m-[00m>_Text = from_object<string>::convert(bargs[01;31m-[00m>lookup("text"));
render.cc:237:    this[01;31m-[00m>_Position = from_object<Vector3>::convert(bargs[01;31m-[00m>lookup("position"));
render.cc:238:    return lisp[01;31m-[00m>onil();
render.cc:246:    obj[01;31m-[00m>setText(text);
render.cc:247:    obj[01;31m-[00m>setPosition(v1);
render.cc:253:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:254:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "v","Vector3",
render.cc:255:    		this[01;31m-[00m>_Position.isDefined(), this[01;31m-[00m>_Position );
render.cc:256:    node[01;31m-[00m>attribute("t",this[01;31m-[00m>_Text);
render.cc:263:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrCylinder>(args,environ);
render.cc:264:    this[01;31m-[00m>_V1 = from_object<Vector3>::convert(bargs[01;31m-[00m>lookup("v1"));
render.cc:265:    this[01;31m-[00m>_V2 = from_object<Vector3>::convert(bargs[01;31m-[00m>lookup("v2"));
render.cc:266:    this[01;31m-[00m>_Radius = from_object<double>::convert(bargs[01;31m-[00m>lookup("radius"));
render.cc:267:    return lisp[01;31m-[00m>onil();
render.cc:273:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:274:    node[01;31m-[00m>attribute("radius",this[01;31m-[00m>_Radius);
render.cc:281:    i[01;31m-[00m>setInformation(info);
render.cc:288:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrInformation>(args,environ);
render.cc:289:    this[01;31m-[00m>_Information = from_object<string>::convert(bargs[01;31m-[00m>lookup("msg"));
render.cc:290:    return lisp[01;31m-[00m>onil();
render.cc:296:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:297:    node[01;31m-[00m>archiveString("info",this[01;31m-[00m>_Information);
render.cc:304:    RPSymbol elementColors = lisp[01;31m-[00m>symbol(_sym_MbbPackage_elementColors);
render.cc:305:    RPIntegerKeyObjectDictionary dict = lisp[01;31m-[00m>create<O_IntegerKeyObjectDictionary>();
render.cc:306:    lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>extend(elementColors,dict);
render.cc:307:    dict[01;31m-[00m>set(element_C,lisp[01;31m-[00m>create<O_GrColor>("cyan"));
render.cc:308:    dict[01;31m-[00m>set(element_H,lisp[01;31m-[00m>create<O_GrColor>("white"));
render.cc:309:    dict[01;31m-[00m>set(element_O,lisp[01;31m-[00m>create<O_GrColor>("red"));
render.cc:310:    dict[01;31m-[00m>set(element_N,lisp[01;31m-[00m>create<O_GrColor>("blue"));
render.cc:311:    dict[01;31m-[00m>set(element_S,lisp[01;31m-[00m>create<O_GrColor>("yellow"));
render.cc:312:    dict[01;31m-[00m>set(element_P,lisp[01;31m-[00m>create<O_GrColor>("yellow"));
render.cc:313:    dict[01;31m-[00m>set(element_Undefined,lisp[01;31m-[00m>create<O_GrColor>("magenta"));
render.cc:322:    this[01;31m-[00m>_ColorName = orig._ColorName;
render.cc:323:    this[01;31m-[00m>_Color = orig._Color;
render.cc:328:    this[01;31m-[00m>Base::initialize();
render.cc:329:    this[01;31m-[00m>setRGB(1.0,1.0,1.0);
render.cc:336:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrColor>(args,environ);
render.cc:337:    string name = from_object<string>::convert(bargs[01;31m-[00m>lookup("name"));
render.cc:338:    this[01;31m-[00m>setColorName(name);
render.cc:339:    return lisp[01;31m-[00m>onil();
render.cc:345:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:346:    node[01;31m-[00m>attributeIfNotDefault<string>("colorName",this[01;31m-[00m>_ColorName,"");
render.cc:347:    node[01;31m-[00m>attribute("color",this[01;31m-[00m>_Color);
render.cc:353:    values[0] = this[01;31m-[00m>getRed();
render.cc:354:    values[1] = this[01;31m-[00m>getGreen();
render.cc:355:    values[2] = this[01;31m-[00m>getBlue();
render.cc:361:    values[0] = this[01;31m-[00m>getRed();
render.cc:362:    values[1] = this[01;31m-[00m>getGreen();
render.cc:363:    values[2] = this[01;31m-[00m>getBlue();
render.cc:371:    ss << "\""<<this[01;31m-[00m>_ColorName <<"\",";
render.cc:372:    ss << this[01;31m-[00m>getRed() << ",";
render.cc:373:    ss << this[01;31m-[00m>getGreen() << ",";
render.cc:374:    ss << this[01;31m-[00m>getBlue();
render.cc:381:{_F(this[01;31m-[00m>lisp());
render.cc:385:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("RGB red value must be between 0.0 and 1.0" ));
render.cc:389:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("RGB green value must be between 0.0 and 1.0" ));
render.cc:393:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("RGB blue value must be between 0.0 and 1.0" ));
render.cc:399:    this[01;31m-[00m>_Color = (ir<<16)|(ig<<8)|ib;
render.cc:400:    this[01;31m-[00m>_ColorName = "";
render.cc:416:{_F(this[01;31m-[00m>lisp());
render.cc:418:    this[01;31m-[00m>_ColorName = name;
render.cc:419:    this[01;31m-[00m>_Color = O_GrColor::colorIdFromName(name);
render.cc:424:{_F(this[01;31m-[00m>lisp());
render.cc:428:    ic = ( this[01;31m-[00m>_Color >> 16 )&0xFF;
render.cc:434:{_F(this[01;31m-[00m>lisp());
render.cc:438:    ic = ( this[01;31m-[00m>_Color >> 8 )&0xFF;
render.cc:444:{_F(this[01;31m-[00m>lisp());
render.cc:448:    ic = ( this[01;31m-[00m>_Color  ) & 0xFF;
render.cc:456:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrPointList>(args,environ);
render.cc:457:    RPCons verticesAsCons = from_object<RPCons>::convert(bargs[01;31m-[00m>lookup("vertices"));
render.cc:458:    this[01;31m-[00m>_Vertices = O_CoordinateArray::create(verticesAsCons,lisp);
render.cc:459:    return lisp[01;31m-[00m>onil();
render.cc:466:    this[01;31m-[00m>_Vertices = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>();
render.cc:474:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:475:    node[01;31m-[00m>archiveObject("vertices",this[01;31m-[00m>_Vertices);
render.cc:481:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrLineStrip>(args,environ);
render.cc:482:    RPCons verticesAsCons = from_object<RPCons>::convert(bargs[01;31m-[00m>lookup("vertices"));
render.cc:483:    this[01;31m-[00m>_Vertices = O_CoordinateArray::create(verticesAsCons,lisp);
render.cc:484:    return lisp[01;31m-[00m>onil();
render.cc:490:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:496:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrPolygon>(args,environ);
render.cc:497:    RPCons verticesAsCons = from_object<RPCons>::convert(bargs[01;31m-[00m>lookup("vertices"));
render.cc:498:    this[01;31m-[00m>_Vertices = O_CoordinateArray::create(verticesAsCons,lisp);
render.cc:499:    this[01;31m-[00m>_SurfaceNormal = from_object<Vector3>::convert(bargs[01;31m-[00m>lookup("normal"));
render.cc:500:    return lisp[01;31m-[00m>onil();
render.cc:506:    this[01;31m-[00m>Base::initialize();
render.cc:507:    this[01;31m-[00m>_SurfaceNormal.set(0.0,0.0,0.0);
render.cc:512:    this[01;31m-[00m>_SurfaceNormal = v.normalizedOrZero();
render.cc:517:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:518:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "normal","Vector3",
render.cc:519:    					this[01;31m-[00m>_SurfaceNormal.isDefined(), this[01;31m-[00m>_SurfaceNormal );
render.cc:525:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_GrSphereList>(args,environ);
render.cc:526:    RPCons verticesAsCons = from_object<RPCons>::convert(bargs[01;31m-[00m>lookup("centers"));
render.cc:527:    this[01;31m-[00m>_Vertices = O_CoordinateArray::create(verticesAsCons,lisp);
render.cc:528:    this[01;31m-[00m>_Radius = from_object<double>::convert(bargs[01;31m-[00m>lookup("radius"));
render.cc:529:    return lisp[01;31m-[00m>onil();
render.cc:535:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:536:    node[01;31m-[00m>attribute("radius",this[01;31m-[00m>_Radius);
render.cc:545:    this[01;31m-[00m>initialize_setOwner(O_Object::nil(this[01;31m-[00m>lisp()));
render.cc:551:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:552:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
render.cc:553:    node[01;31m-[00m>needsFinalization();
render.cc:558:    this[01;31m-[00m>ownChildren();
render.cc:563:{_F(this[01;31m-[00m>lisp());
render.cc:571:    ASSERTP(this[01;31m-[00m>isNil(),"O_Render::beginRender should only be called for nil object");
render.cc:577:    ASSERTP(this[01;31m-[00m>isNil(),"O_Render::endRender should only be called for nil object");
render.cc:582:{_F(this[01;31m-[00m>lisp());
render.cc:584:    for ( it=this[01;31m-[00m>beginRender(controller); it!=this[01;31m-[00m>endRender(controller); it++ )
render.cc:586:	if ( (*it)[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:588:	    (*it)[01;31m-[00m>as<O_Render>()[01;31m-[00m>_walkAndDefineSliderRanges(controller);
render.cc:595:{_F(this[01;31m-[00m>lisp());
render.cc:596:    if ( this[01;31m-[00m>getName() != "" )
render.cc:598:	return controller[01;31m-[00m>isSwitchOn(this[01;31m-[00m>getFullSwitchName());
render.cc:606:    ss << "[ " << this[01;31m-[00m>Base::description();
render.cc:607:    ss << " name: " << this[01;31m-[00m>getName();
render.cc:608:    ss << " parent: " << this[01;31m-[00m>getParent()[01;31m-[00m>O_Object::description() << " ]";
render.cc:615:{_F(this[01;31m-[00m>lisp());
render.cc:617:    this[01;31m-[00m>_accumulateFullSwitchName(ss);
render.cc:618:    uint last = ss.str().size()[01;31m-[00m1;
render.cc:629:{_F(this[01;31m-[00m>lisp());
render.cc:631:    this[01;31m-[00m>_accumulateFullSliderName(ss);
render.cc:632:    uint last = ss.str().size()[01;31m-[00m1;
render.cc:644:{_F(this[01;31m-[00m>lisp());
render.cc:645:    this[01;31m-[00m>_walkAndDefineSliderRanges(controller);
render.cc:650:    if ( this[01;31m-[00m>owner()[01;31m-[00m>isNil() ) return O_Render::nil(this[01;31m-[00m>lisp());
render.cc:651:    return this[01;31m-[00m>owner();
render.cc:656:{_F(this[01;31m-[00m>lisp());
render.cc:657:    RPRenderController controller = O_RenderController::create(this[01;31m-[00m>lisp());
render.cc:658:    controller[01;31m-[00m>setRender(this[01;31m-[00m>sharedThis<O_Render>());
render.cc:659:    this[01;31m-[00m>_walkAndDefineController(controller);
render.cc:660:    this[01;31m-[00m>_walkAndDefineSliderRanges(controller);
render.cc:666:{_F(this[01;31m-[00m>lisp());
render.cc:667:    if ( this[01;31m-[00m>getParent()[01;31m-[00m>isNil() )
render.cc:669:	if (this[01;31m-[00m>_Name!="")
render.cc:671:	    ss << this[01;31m-[00m>_Name << renderSeparatorCharacter();
render.cc:676:    if ( this[01;31m-[00m>getParent()[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:678:	this[01;31m-[00m>getParent()[01;31m-[00m>as<O_Render>()[01;31m-[00m>_accumulateFullSwitchName(ss);
render.cc:680:    if (this[01;31m-[00m>_Name!="")
render.cc:682:	ss << this[01;31m-[00m>_Name << renderSeparatorCharacter();
render.cc:688:{_F(this[01;31m-[00m>lisp());
render.cc:689:    if ( this[01;31m-[00m>getParent()[01;31m-[00m>isNil() )
render.cc:694:    if ( this[01;31m-[00m>getParent()[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:696:	this[01;31m-[00m>getParent()[01;31m-[00m>as<O_Render>()[01;31m-[00m>_accumulateFullSliderName(ss);
render.cc:704:{_F(this[01;31m-[00m>lisp());
render.cc:706:    	this[01;31m-[00m>description().c_str()
render.cc:707:	% parent[01;31m-[00m>description().c_str() );
render.cc:708:    LOG(BF( "Before set (this[01;31m-[00m>_InitializationOwner.use_count() = %d")% this[01;31m-[00m>_InitializationOwner.use_count() );
render.cc:709:    if ( this[01;31m-[00m>_InitializationOwner.use_count() != 0 )
render.cc:711:	LOG(BF( "          (this[01;31m-[00m>_InitializationOwner.get() = %p")% 
render.cc:712:	    this[01;31m-[00m>_InitializationOwner.lock().get() );
render.cc:714:    this[01;31m-[00m>setOwner(parent);
render.cc:715:    LOG(BF( "After set (this[01;31m-[00m>_InitializationOwner.use_count() = %d")% 
render.cc:716:    	this[01;31m-[00m>_InitializationOwner.use_count() );
render.cc:717:    if ( this[01;31m-[00m>_InitializationOwner.use_count() != 0 )
render.cc:719:	LOG(BF( "          (this[01;31m-[00m>_InitializationOwner.get() = %p")% 
render.cc:720:	    this[01;31m-[00m>_InitializationOwner.lock().get() );
render.cc:725:{_F(this[01;31m-[00m>lisp());
render.cc:726:    if ( obj[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:728:	RPRender render = obj[01;31m-[00m>as<O_Render>();
render.cc:729:	render[01;31m-[00m>setParent(this[01;31m-[00m>sharedThis<O_Render>());
render.cc:731:    this[01;31m-[00m>_addObject(obj);
render.cc:739:    this[01;31m-[00m>Base::initialize();
render.cc:745:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_RenderDisplayList>(args,environ);
render.cc:746:    this[01;31m-[00m>_Name = from_object<string>::convert(bargs[01;31m-[00m>lookup("name"));
render.cc:747:    RPCons contents = from_object<RPCons>::convert(bargs[01;31m-[00m>lookup("contents"));
render.cc:748:    this[01;31m-[00m>appendAll(contents);
render.cc:749:    return lisp[01;31m-[00m>onil();
render.cc:755:{_F(this[01;31m-[00m>lisp());
render.cc:756:    for ( ; parts[01;31m-[00m>notNil(); parts = parts[01;31m-[00m>cdr() )
render.cc:758:	this[01;31m-[00m>add(parts[01;31m-[00m>car<O_Render>());
render.cc:765:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:766:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_Objects);
render.cc:771:{_F(this[01;31m-[00m>lisp());
render.cc:772:    this[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("red"));
render.cc:773:    this[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(Vector3(0,0,0),Vector3(1,0,0)));
render.cc:774:    this[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("green"));
render.cc:775:    this[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(Vector3(0,0,0),Vector3(0,1,0)));
render.cc:776:    this[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("blue"));
render.cc:777:    this[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(Vector3(0,0,0),Vector3(0,0,1)));
render.cc:783:{_F(this[01;31m-[00m>lisp());
render.cc:785:    if ( this[01;31m-[00m>notNil() )
render.cc:787:	if ( this[01;31m-[00m>getName() != "" )
render.cc:789:	    string fullName = this[01;31m-[00m>getFullSwitchName();
render.cc:790:	    controller[01;31m-[00m>createSwitch(fullName);
render.cc:792:	for ( it=this[01;31m-[00m>_Objects.begin(); it!=this[01;31m-[00m>_Objects.end(); it++ )
render.cc:794:	    if ( (*it)[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:796:		RPRender render = (*it)[01;31m-[00m>as<O_Render>();
render.cc:797:		render[01;31m-[00m>_walkAndDefineController(controller);
render.cc:804:{_F(this[01;31m-[00m>lisp());
render.cc:806:    if ( this[01;31m-[00m>notNil() )
render.cc:808:	for ( it=this[01;31m-[00m>_Objects.begin(); it!=this[01;31m-[00m>_Objects.end(); it++ )
render.cc:810:	    if ( (*it)[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:812:		LOG(BF( "%s is being set as parent of %s")% this[01;31m-[00m>description().c_str() % (*it)[01;31m-[00m>description().c_str());
render.cc:813:		(*it)[01;31m-[00m>as<O_Render>()[01;31m-[00m>setParent(this[01;31m-[00m>sharedThis<O_RenderDisplayList>());
render.cc:821:{_F(this[01;31m-[00m>lisp());
render.cc:823:    if ( this[01;31m-[00m>notNil() )
render.cc:825:	for ( it=this[01;31m-[00m>_Objects.begin(); it!=this[01;31m-[00m>_Objects.end(); it++ )
render.cc:827:	    if ( (*it)[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:829:		LOG(BF( "Child: %s")% (*it)[01;31m-[00m>description().c_str() );
render.cc:830:		LOG(BF( " (*it)[01;31m-[00m>_InitializationOwner.use_count() == %d")% 
render.cc:831:				(*it)[01;31m-[00m>_InitializationOwner.use_count() );
render.cc:832:		if ( (*it)[01;31m-[00m>_InitializationOwner.use_count() != 0 )
render.cc:834:		    LOG(BF( "   (*it)[01;31m-[00m>_InitializationOwner.lock().get() = %p")%
render.cc:835:		    		(*it)[01;31m-[00m>_InitializationOwner.lock().get() );
render.cc:837:		LOG(BF( "    (*it)[01;31m-[00m>getParent().get() = %p")% (*it)[01;31m-[00m>as<O_Render>()[01;31m-[00m>getParent().get() );
render.cc:838:		if ( (*it)[01;31m-[00m>as<O_Render>()[01;31m-[00m>getParent().get() != this )
render.cc:840:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("A child of "+this[01;31m-[00m>description()+" name: "+this[01;31m-[00m>getName()+" specifically: "+(*it)[01;31m-[00m>description()+" does not have it as a parent"));
render.cc:842:		(*it)[01;31m-[00m>as<O_Render>()[01;31m-[00m>check();
render.cc:851:    this[01;31m-[00m>_Objects.push_back(obj);
render.cc:858:{_F(this[01;31m-[00m>lisp());
render.cc:860:    xml = O_XmlSaveArchive::create(this[01;31m-[00m>lisp());
render.cc:861:    xml[01;31m-[00m>put("displayList",this[01;31m-[00m>sharedThis<O_RenderDisplayList>());
render.cc:862:    xml[01;31m-[00m>saveAs(fileName);
render.cc:871:{_F(this[01;31m-[00m>lisp());
render.cc:872:    this[01;31m-[00m>_Objects.append(obj);
render.cc:879:    string fullName = this[01;31m-[00m>getFullSwitchName();
render.cc:880:    if ( controller[01;31m-[00m>isSwitchOn(fullName) )
render.cc:882:	return this[01;31m-[00m>_Objects.begin();
render.cc:884:    return this[01;31m-[00m>_Objects.end();
render.cc:889:    return this[01;31m-[00m>_Objects.end();
render.cc:894:{_F(this[01;31m-[00m>lisp());
render.cc:896:    for ( it=list[01;31m-[00m>_Objects.begin(); it!=list[01;31m-[00m>_Objects.end(); it++ )
render.cc:898:        this[01;31m-[00m>add(*it);
render.cc:905:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_RenderFrameList>(args,environ);
render.cc:906:    this[01;31m-[00m>_Name = from_object<string>::convert(bargs[01;31m-[00m>lookup("name"));
render.cc:907:    this[01;31m-[00m>_SliderName = from_object<string>::convert(bargs[01;31m-[00m>lookup("sliderName"));
render.cc:908:    RPCons contents = from_object<RPCons>::convert(bargs[01;31m-[00m>lookup("frames"));
render.cc:909:    this[01;31m-[00m>appendFrames(contents);
render.cc:910:    return lisp[01;31m-[00m>onil();
render.cc:915:{_F(this[01;31m-[00m>lisp());
render.cc:916:    for ( ; parts[01;31m-[00m>notNil(); parts = parts[01;31m-[00m>cdr() )
render.cc:918:	this[01;31m-[00m>add(parts[01;31m-[00m>car<O_Render>());
render.cc:924:{_F(this[01;31m-[00m>lisp());
render.cc:926:    if ( this[01;31m-[00m>notNil() )
render.cc:928:	if ( this[01;31m-[00m>getName() != "" )
render.cc:930:	    string fullName = this[01;31m-[00m>getFullSwitchName();
render.cc:931:	    controller[01;31m-[00m>createSwitch(fullName);
render.cc:933:	if ( this[01;31m-[00m>getSliderName() != "" )
render.cc:935:	    string fullSliderPath = this[01;31m-[00m>getFullSliderName();
render.cc:936:	    controller[01;31m-[00m>createSlider(fullSliderPath);
render.cc:939:	for ( fit=this[01;31m-[00m>beginFrames(); fit!=this[01;31m-[00m>endFrames(); fit++ )
render.cc:941:	    (*fit)[01;31m-[00m>_walkAndDefineController(controller);
render.cc:947:{_F(this[01;31m-[00m>lisp());
render.cc:949:    string sliderName = this[01;31m-[00m>getFullSliderName();
render.cc:950:    uint upperLimit = this[01;31m-[00m>numberOfFrames()[01;31m-[00m1;
render.cc:951:    RPSliderController slider = controller[01;31m-[00m>getSlider(sliderName);
render.cc:953:    		this[01;31m-[00m>description().c_str() % 0 % upperLimit );
render.cc:954:    slider[01;31m-[00m>setSliderLimits(0,upperLimit);
render.cc:955:    uint frameIdx = controller[01;31m-[00m>getSliderValue(sliderName);
render.cc:956:    if ( this[01;31m-[00m>_Frames.size() > 0 )
render.cc:958:        ASSERT_lt(frameIdx,this[01;31m-[00m>_Frames.size());
render.cc:959:	this[01;31m-[00m>_Frames.get(frameIdx)[01;31m-[00m>_walkAndDefineSliderRanges(controller);
render.cc:965:    if ( obj[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:967:        this[01;31m-[00m>_Frames.push_back(obj[01;31m-[00m>as<O_Render>());
render.cc:970:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You can only add subclasses of Render to RenderFrameList"));
render.cc:979:    if ( this[01;31m-[00m>_Frames.size() == 0 )
render.cc:982:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There are no frames"));
render.cc:985:    fullName = this[01;31m-[00m>getFullSwitchName();
render.cc:986:    sliderName = this[01;31m-[00m>getFullSliderName();
render.cc:987:    uint frameIdx = controller[01;31m-[00m>getSliderValue(sliderName);
render.cc:988:    if ( controller[01;31m-[00m>isSwitchOn(fullName) )
render.cc:990:	ASSERT_lt(frameIdx,this[01;31m-[00m>_Frames.size());
render.cc:991:        return this[01;31m-[00m>_Frames.get(frameIdx)[01;31m-[00m>beginRender(controller);
render.cc:993:    ASSERT_lt(frameIdx,this[01;31m-[00m>_Frames.size());
render.cc:994:    return this[01;31m-[00m>_Frames.get(frameIdx)[01;31m-[00m>endRender(controller);
render.cc:999:    if ( this[01;31m-[00m>_Frames.size() == 0 )
render.cc:1002:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("There are no frames"));
render.cc:1004:    string fullName = this[01;31m-[00m>getFullSliderName();
render.cc:1005:    uint frameIdx = controller[01;31m-[00m>getSliderValue(fullName);
render.cc:1006:    ASSERT_lt(frameIdx,this[01;31m-[00m>_Frames.size());
render.cc:1007:    return this[01;31m-[00m>_Frames.get(frameIdx)[01;31m-[00m>endRender(controller);
render.cc:1013:    this[01;31m-[00m>Base::initialize();
render.cc:1014:    this[01;31m-[00m>_SliderName = "Frame";
render.cc:1019:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:1020:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_Frames);
render.cc:1021:    node[01;31m-[00m>attributeIfNotDefault<string>("sliderName",this[01;31m-[00m>_SliderName,"frame");
render.cc:1026:{_F(this[01;31m-[00m>lisp());
render.cc:1028:    if ( this[01;31m-[00m>notNil() )
render.cc:1031:	for ( fit=this[01;31m-[00m>beginFrames(); fit!=this[01;31m-[00m>endFrames(); fit++ )
render.cc:1033:	    if ( (*fit)[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:1035:		LOG(BF( "%s is being set as parent of %s")% this[01;31m-[00m>description().c_str() % (*fit)[01;31m-[00m>description().c_str());
render.cc:1036:	        (*fit)[01;31m-[00m>as<O_Render>()[01;31m-[00m>setParent(this[01;31m-[00m>sharedThis<O_RenderFrameList>());
render.cc:1044:{_F(this[01;31m-[00m>lisp());
render.cc:1045:    if ( this[01;31m-[00m>notNil() )
render.cc:1048:	for ( it=this[01;31m-[00m>beginFrames(); it!=this[01;31m-[00m>endFrames(); it++ )
render.cc:1050:	    if ( (*it)[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:1052:		LOG(BF( "Child: %s")% (*it)[01;31m-[00m>description().c_str() );
render.cc:1053:		LOG(BF( " (*it)[01;31m-[00m>_InitializationOwner.use_count() == %d")% 
render.cc:1054:				(*it)[01;31m-[00m>_InitializationOwner.use_count() );
render.cc:1055:		if ( (*it)[01;31m-[00m>_InitializationOwner.use_count() != 0 )
render.cc:1057:		    LOG(BF( "   (*it)[01;31m-[00m>_InitializationOwner.lock().get() = %p")%
render.cc:1058:		    		(*it)[01;31m-[00m>_InitializationOwner.lock().get() );
render.cc:1060:		LOG(BF( "    (*it)[01;31m-[00m>owner().get() = %p")% (*it)[01;31m-[00m>owner().get() );
render.cc:1061:		LOG(BF( "    (*it)[01;31m-[00m>owner()[01;31m-[00m>description() = %s")% (*it)[01;31m-[00m>owner()[01;31m-[00m>description().c_str() );
render.cc:1062:		LOG(BF( "    (*it)[01;31m-[00m>owner()[01;31m-[00m>isNil = %d")% (*it)[01;31m-[00m>owner()[01;31m-[00m>isNil() );
render.cc:1063:    		LOG(BF( "    (*it)[01;31m-[00m>ownerWithClass<O_Render>()[01;31m-[00m>description() = %s")% (*it)[01;31m-[00m>ownerWithClass<O_Render>()[01;31m-[00m>description().c_str() );
render.cc:1064:    		LOG(BF( "    (*it)[01;31m-[00m>ownerWithClass<O_Render>().get() = %p")% (*it)[01;31m-[00m>ownerWithClass<O_Render>().get() );
render.cc:1065:		LOG(BF( "    (*it)[01;31m-[00m>getParent().get() = %p")% (*it)[01;31m-[00m>as<O_Render>()[01;31m-[00m>getParent().get() );
render.cc:1066:		if ( (*it)[01;31m-[00m>getParent().get() != this )
render.cc:1068:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("A child of "+this[01;31m-[00m>description()+" name: "+this[01;31m-[00m>getName()+" specifically: "+(*it)[01;31m-[00m>description()+" does not have it as a parent"));
render.cc:1070:	        (*it)[01;31m-[00m>as<O_Render>()[01;31m-[00m>check();
render.cc:1077:{_F(this[01;31m-[00m>lisp());
render.cc:1078:    if ( this[01;31m-[00m>getParent()[01;31m-[00m>isNil() )
render.cc:1080:	if (this[01;31m-[00m>_SliderName!="")
render.cc:1082:	    ss << this[01;31m-[00m>_SliderName << renderSeparatorCharacter();
render.cc:1087:    if ( this[01;31m-[00m>getParent()[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:1089:	this[01;31m-[00m>getParent()[01;31m-[00m>as<O_Render>()[01;31m-[00m>_accumulateFullSliderName(ss);
render.cc:1091:    if (this[01;31m-[00m>_SliderName!="")
render.cc:1093:	ss << this[01;31m-[00m>_SliderName << renderSeparatorCharacter();
render.cc:1101:    RPIntegerKeyObjectDictionary elementColorMap = lisp[01;31m-[00m>globalEnvironment()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_elementColors))[01;31m-[00m>as<O_IntegerKeyObjectDictionary>();
render.cc:1102:    if ( elementColorMap[01;31m-[00m>contains(element) )
render.cc:1104:	return elementColorMap[01;31m-[00m>get(element)[01;31m-[00m>as<O_GrColor>();
render.cc:1106:    return elementColorMap[01;31m-[00m>get(element_Undefined)[01;31m-[00m>as<O_GrColor>();
render.cc:1112:    this[01;31m-[00m>_WeakLisp = lisp;
render.cc:1116:{_F(atom[01;31m-[00m>lisp());
render.cc:1117:    RPLisp lisp = atom[01;31m-[00m>lisp();
render.cc:1118:    this[01;31m-[00m>_Style = atom[01;31m-[00m>getPropertyOrDefault(lisp[01;31m-[00m>symbol(_sym_kw_renderStyle),lisp[01;31m-[00m>symbol(_sym_kw_ballAndStick))[01;31m-[00m>as<O_Symbol>();
render.cc:1119:    this[01;31m-[00m>_ShowLabel = atom[01;31m-[00m>getPropertyOrDefault(lisp[01;31m-[00m>symbol(_sym_kw_showLabel),lisp[01;31m-[00m>_boolean(false))[01;31m-[00m>isTrue();
render.cc:1120:    RPText label = atom[01;31m-[00m>getPropertyOrDefault(lisp[01;31m-[00m>symbol(_sym_kw_label),O_Text::nil(lisp))[01;31m-[00m>as<O_Text>();
render.cc:1121:    if ( label[01;31m-[00m>notNil() )
render.cc:1123:        this[01;31m-[00m>_Label = label[01;31m-[00m>get();
render.cc:1126:        this[01;31m-[00m>_Label = atom[01;31m-[00m>getName();
render.cc:1128:    this[01;31m-[00m>_Position = atom[01;31m-[00m>getPosition();
render.cc:1129:    this[01;31m-[00m>_NumberOfBonds = atom[01;31m-[00m>numberOfBonds();
render.cc:1130:    bool colorByElement = atom[01;31m-[00m>getPropertyOrDefault(lisp[01;31m-[00m>symbol(_sym_kw_colorByElement),lisp[01;31m-[00m>_boolean(true))[01;31m-[00m>isTrue();
render.cc:1133:	this[01;31m-[00m>_Color = (O_RenderMatter::elementToColor(atom[01;31m-[00m>getElement(),lisp));
render.cc:1136:	RPGrColor color = atom[01;31m-[00m>getPropertyOrDefault(lisp[01;31m-[00m>symbol(_sym_kw_color),O_GrColor::nil(lisp))[01;31m-[00m>as<O_GrColor>();
render.cc:1137:	if ( color[01;31m-[00m>isNil() )
render.cc:1139:	    this[01;31m-[00m>_Color = renderMatter[01;31m-[00m>defaultColor();
render.cc:1142:	    this[01;31m-[00m>_Color = color;
render.cc:1153:    node[01;31m-[00m>archivePlainObject<Vector3>("position","Vector3", this[01;31m-[00m>_Position );
render.cc:1154:    node[01;31m-[00m>attribute("nb",this[01;31m-[00m>_NumberOfBonds);
render.cc:1160:    node[01;31m-[00m>attribute("a1",this[01;31m-[00m>_Atom1);
render.cc:1161:    node[01;31m-[00m>attribute("a2",this[01;31m-[00m>_Atom2);
render.cc:1162:    node[01;31m-[00m>attributeEnum("order", this[01;31m-[00m>_Order, bondOrderKeys );
render.cc:1168:    this[01;31m-[00m>Base::initialize();
render.cc:1169:    this[01;31m-[00m>setName("_matter");
render.cc:1170:    this[01;31m-[00m>_DefaultColor = O_GrColor::create("white",this[01;31m-[00m>lisp());
render.cc:1176:    this[01;31m-[00m>Base::archiveBase(node);
render.cc:1177:    node[01;31m-[00m>archiveVectorPlainObjects<RenderMatterAtom>("atoms",this[01;31m-[00m>_Atoms);
render.cc:1178:    node[01;31m-[00m>archiveVectorPlainObjects<RenderMatterBond>("bonds",this[01;31m-[00m>_Bonds);
render.cc:1179:    node[01;31m-[00m>archiveObject("defColor",this[01;31m-[00m>_DefaultColor);
render.cc:1180:    node[01;31m-[00m>needsFinalization();
render.cc:1185:{_F(this[01;31m-[00m>lisp());
render.cc:1186:    return this[01;31m-[00m>_DefaultColor;
render.cc:1190:{_F(this[01;31m-[00m>lisp());
render.cc:1191:    this[01;31m-[00m>_DefaultColor = c;
render.cc:1198:    this[01;31m-[00m>Base::loadFinalize(node);
render.cc:1199:    this[01;31m-[00m>render();
render.cc:1204:{_F(this[01;31m-[00m>lisp());
render.cc:1206:    if ( this[01;31m-[00m>notNil() )
render.cc:1208:	for ( it=this[01;31m-[00m>_PartsDisplayList.begin(); it!=this[01;31m-[00m>_PartsDisplayList.end(); it++ )
render.cc:1210:	    if ( (*it)[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:1212:		RPRender render = (*it)[01;31m-[00m>as<O_Render>();
render.cc:1213:		LOG(BF( "%s is being set as parent of %s")% this[01;31m-[00m>description().c_str() % (*it)[01;31m-[00m>description().c_str());
render.cc:1214:		render[01;31m-[00m>setParent(this[01;31m-[00m>sharedThis<O_RenderMatter>());
render.cc:1221:{_F(this[01;31m-[00m>lisp());
render.cc:1223:    if ( this[01;31m-[00m>notNil() )
render.cc:1225:	for ( it=this[01;31m-[00m>_PartsDisplayList.begin(); it!=this[01;31m-[00m>_PartsDisplayList.end(); it++ )
render.cc:1227:	    if ( (*it)[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:1229:		LOG(BF( "Child: %s")% (*it)[01;31m-[00m>description().c_str() );
render.cc:1230:		LOG(BF( " (*it)[01;31m-[00m>_InitializationOwner.use_count() == %d")% 
render.cc:1231:				(*it)[01;31m-[00m>_InitializationOwner.use_count() );
render.cc:1232:		if ( (*it)[01;31m-[00m>_InitializationOwner.use_count() != 0 )
render.cc:1234:		    LOG(BF( "   (*it)[01;31m-[00m>_InitializationOwner.lock().get() = %p")%
render.cc:1235:		    		(*it)[01;31m-[00m>_InitializationOwner.lock().get() );
render.cc:1237:		RPRender render = (*it)[01;31m-[00m>as<O_Render>();
render.cc:1238:		LOG(BF( "    (*it)[01;31m-[00m>getParent().get() = %p")% (*it)[01;31m-[00m>as<O_Render>()[01;31m-[00m>getParent().get() );
render.cc:1239:		if ( render[01;31m-[00m>getParent().get() != this )
render.cc:1241:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("A child of "+this[01;31m-[00m>description()+" name: "+this[01;31m-[00m>getName()+" specifically: "+(*it)[01;31m-[00m>description()+" does not have it as a parent"));
render.cc:1243:	        (*it)[01;31m-[00m>as<O_Render>()[01;31m-[00m>check();
render.cc:1251:{_F(this[01;31m-[00m>lisp());
render.cc:1252:    this[01;31m-[00m>_PartsDisplayList.push_back(obj);
render.cc:1256:{_F(this[01;31m-[00m>lisp());
render.cc:1258:    if ( this[01;31m-[00m>notNil() )
render.cc:1260:	if ( this[01;31m-[00m>getName() != "" )
render.cc:1262:	    string fullPath = this[01;31m-[00m>getFullSwitchName();
render.cc:1263:	    controller[01;31m-[00m>createSwitch(fullPath);
render.cc:1265:	for ( it=this[01;31m-[00m>_PartsDisplayList.begin(); it!=this[01;31m-[00m>_PartsDisplayList.end(); it++ )
render.cc:1267:	    if ( (*it)[01;31m-[00m>isAssignableTo<O_Render>() )
render.cc:1269:		RPRender render = (*it)[01;31m-[00m>as<O_Render>();
render.cc:1270:		render[01;31m-[00m>_walkAndDefineController(controller);
render.cc:1279:    string fullName = this[01;31m-[00m>getFullSwitchName();
render.cc:1280:    if ( controller[01;31m-[00m>isSwitchOn(fullName) )
render.cc:1282:	return this[01;31m-[00m>_PartsDisplayList.begin();
render.cc:1284:    return this[01;31m-[00m>_PartsDisplayList.end();
render.cc:1289:    return this[01;31m-[00m>_PartsDisplayList.end();
render.cc:1296:{_F(this[01;31m-[00m>lisp());
render.cc:1300:    LOG(BF( "Rendering %d atoms")% this[01;31m-[00m>_Atoms.size() );
render.cc:1301:    for ( ai=this[01;31m-[00m>_Atoms.begin(); ai!=this[01;31m-[00m>_Atoms.end(); ai++ )
render.cc:1303:	sum = sum + ai[01;31m-[00m>_Position;
render.cc:1306:    if ( num == 0 ) return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_OVector3>();
render.cc:1308:    return O_OVector3::createFromVector3(this[01;31m-[00m>lisp(),sum);
render.cc:1314:{_F(this[01;31m-[00m>lisp());
render.cc:1322:    this[01;31m-[00m>_PartsDisplayList.clear();
render.cc:1323:    RPRenderDisplayList renderStructure = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
render.cc:1324:    renderStructure[01;31m-[00m>setName("structure");
render.cc:1325:    this[01;31m-[00m>add(renderStructure);
render.cc:1326:    RPRenderDisplayList renderLabels = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
render.cc:1327:    renderLabels[01;31m-[00m>setName("labels");
render.cc:1328:    this[01;31m-[00m>add(renderLabels);
render.cc:1330:    LOG(BF( "Rendering %d atoms")% this[01;31m-[00m>_Atoms.size() );
render.cc:1331:    for ( ai=this[01;31m-[00m>_Atoms.begin(); ai!=this[01;31m-[00m>_Atoms.end(); ai++ )
render.cc:1333:        LOG(BF( "Atom %s _NumberOfBonds = %d")% ai[01;31m-[00m>_Label % ai[01;31m-[00m>_NumberOfBonds );
render.cc:1334:	if ( ai[01;31m-[00m>_NumberOfBonds == 0 )
render.cc:1336:	    p1 = ai[01;31m-[00m>_Position;
render.cc:1337:	    grColor = ai[01;31m-[00m>_Color;
render.cc:1340:		dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
render.cc:1341:		dl[01;31m-[00m>add(grColor);
render.cc:1345:	    RPGrPoint grPoint = O_GrPoint::create(p1,this[01;31m-[00m>lisp());
render.cc:1346:	    dl[01;31m-[00m>add(grPoint);
render.cc:1350:    for ( bi=this[01;31m-[00m>_Bonds.begin(); bi!=this[01;31m-[00m>_Bonds.end(); bi++ )
render.cc:1352:	ai1 = bi[01;31m-[00m>_Atom1;
render.cc:1353:	ai2 = bi[01;31m-[00m>_Atom2;
render.cc:1354:	p1 = this[01;31m-[00m>_Atoms[ai1]._Position;
render.cc:1355:	p2 = this[01;31m-[00m>_Atoms[ai2]._Position;
render.cc:1356:	pMiddle = bi[01;31m-[00m>_Center;
render.cc:1357://	e1 = this[01;31m-[00m>_Atoms[ai1]._Element;
render.cc:1358://	e2 = this[01;31m-[00m>_Atoms[ai2]._Element;
render.cc:1359:	RPGrColor c1 = this[01;31m-[00m>_Atoms[ai1]._Color;
render.cc:1360:	RPGrColor c2 = this[01;31m-[00m>_Atoms[ai2]._Color;
render.cc:1366:		dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
render.cc:1367:		dl[01;31m-[00m>add(c1);
render.cc:1371:	    grLine = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(p1,p2);
render.cc:1372:	    dl[01;31m-[00m>add(grLine);
render.cc:1376:	    pMiddle = bi[01;31m-[00m>_Center;
render.cc:1380:		    dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
render.cc:1381:		    dl[01;31m-[00m>add(c1);
render.cc:1385:		grLine = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(p1,pMiddle);
render.cc:1386:		dl[01;31m-[00m>add(grLine);
render.cc:1391:		    dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
render.cc:1392:		    dl[01;31m-[00m>add(c2);
render.cc:1396:		grLine = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrLine>(p2,pMiddle);
render.cc:1397:		dl[01;31m-[00m>add(grLine);
render.cc:1404:	renderStructure[01;31m-[00m>add(it[01;31m-[00m>second);
render.cc:1406://    printf( "%s:%d Matter::render getShowLabels() = %d\n", __FILE__, __LINE__, this[01;31m-[00m>getShowLabels() );
render.cc:1408:	for ( ai=this[01;31m-[00m>_Atoms.begin(); ai!=this[01;31m-[00m>_Atoms.end(); ai++ )
render.cc:1410:	    p1 = ai[01;31m-[00m>_Position;
render.cc:1411:	    RPGrColor c = ai[01;31m-[00m>_Color;
render.cc:1412:	    renderLabels[01;31m-[00m>add(c);
render.cc:1413:	    RPGrText grText= O_GrText::create(ai[01;31m-[00m>_Label,ai[01;31m-[00m>_Position,this[01;31m-[00m>lisp());
render.cc:1414:	    renderLabels[01;31m-[00m>add(grText);
render.cc:1415:	    RPGrPoint grPoint = O_GrPoint::create(ai[01;31m-[00m>_Position,this[01;31m-[00m>lisp());
render.cc:1416:	    renderLabels[01;31m-[00m>add(grPoint);
render.cc:1423:{_F(this[01;31m-[00m>lisp());
render.cc:1432:	this[01;31m-[00m>_Atoms.clear();
render.cc:1437:	    grMatterAtom.defineForAtom(atom,this[01;31m-[00m>sharedThis<O_RenderMatter>());
render.cc:1438:	    grMatterAtom._Position = atom[01;31m-[00m>getPosition();
render.cc:1439:	    grMatterAtom._NumberOfBonds = atom[01;31m-[00m>numberOfBonds();
render.cc:1440:	    atomIndices[atom] = this[01;31m-[00m>_Atoms.size();
render.cc:1441:	    this[01;31m-[00m>_Atoms.push_back(grMatterAtom);
render.cc:1456:	    Vector3 v1 = a1[01;31m-[00m>getPosition();
render.cc:1457:	    Vector3 v2 = a2[01;31m-[00m>getPosition();
render.cc:1460:	    this[01;31m-[00m>_Bonds.push_back(grMatterBond);
render.cc:1463:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("A bond was found that contained an atom that hasn't been seen"));
render.cc:1466:    this[01;31m-[00m>render();
render.cc:1496:	class_<O_GraphicsObject>(this[01;31m-[00m>lisp())
render.cc:1522:	class_<O_GrPrimitive>(this[01;31m-[00m>lisp())
render.cc:1547:	class_<O_GrText>(this[01;31m-[00m>lisp())
render.cc:1579:	class_<O_GrPoint>(this[01;31m-[00m>lisp())
render.cc:1603:	class_<O_GrLine>(this[01;31m-[00m>lisp())
render.cc:1635:	class_<O_GrPointList>(this[01;31m-[00m>lisp())
render.cc:1665:	class_<O_GrLineStrip>(this[01;31m-[00m>lisp())
render.cc:1691:	class_<O_GrSphereList>(this[01;31m-[00m>lisp())
render.cc:1722:	class_<O_GrPolygon>(this[01;31m-[00m>lisp())
render.cc:1750:	class_<O_GrCylinder>(this[01;31m-[00m>lisp())
render.cc:1779:	class_<O_GrSphere>(this[01;31m-[00m>lisp())
render.cc:1810:	class_<O_GrColor>(this[01;31m-[00m>lisp())
render.cc:1813:        this[01;31m-[00m>lisp()[01;31m-[00m>installGlobalInitializationCallback(&initializeElementColors);
render.cc:1848:	class_<O_GrInformation>(this[01;31m-[00m>lisp())
render.cc:1883:	class_<O_Render>(this[01;31m-[00m>lisp())
render.cc:1921:	class_<O_RenderDisplayList>(this[01;31m-[00m>lisp())
render.cc:1959:	class_<O_RenderFrameList>(this[01;31m-[00m>lisp())
render.cc:2000:	class_<O_RenderMatter>(this[01;31m-[00m>lisp())
renderController.cc:20:    this[01;31m-[00m>Base::initialize();
renderController.cc:25:    this[01;31m-[00m>Base::initialize();
renderController.cc:26:    this[01;31m-[00m>_Value = true;
renderController.cc:31:    this[01;31m-[00m>Base::initialize();
renderController.cc:32:    this[01;31m-[00m>_Value = 0;
renderController.cc:33:    this[01;31m-[00m>_LowerLimit = 0;
renderController.cc:34:    this[01;31m-[00m>_UpperLimit = 0;
renderController.cc:39:{_F(this[01;31m-[00m>lisp());
renderController.cc:40:    if ( this[01;31m-[00m>_Value < this[01;31m-[00m>_LowerLimit ) this[01;31m-[00m>_Value = this[01;31m-[00m>_LowerLimit;
renderController.cc:41:    if ( this[01;31m-[00m>_Value > this[01;31m-[00m>_UpperLimit ) this[01;31m-[00m>_Value = this[01;31m-[00m>_UpperLimit;
renderController.cc:42:    return this[01;31m-[00m>_Value;
renderController.cc:48:    c[01;31m-[00m>setRender(render);
renderController.cc:59:	class_<O_RenderController>(env[01;31m-[00m>lisp())
renderController.cc:73:    RPEnvironment bargs = this[01;31m-[00m>parse__init__arguments<O_RenderController>(args,environ);
renderController.cc:74:    RPRender contents = from_object<RPRender>::convert(bargs[01;31m-[00m>lookup("contents"));
renderController.cc:75:    this[01;31m-[00m>setRender(contents);
renderController.cc:76:    return env[01;31m-[00m>onil();
renderController.cc:82:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
renderController.cc:92:    this[01;31m-[00m>Base::initialize();
renderController.cc:97:    this[01;31m-[00m>Base::archiveBase(node);
renderController.cc:98:    node[01;31m-[00m>archiveMap("switches",this[01;31m-[00m>_Switches);
renderController.cc:99:    node[01;31m-[00m>archiveMap("sliders",this[01;31m-[00m>_Sliders);
renderController.cc:104:{_F(this[01;31m-[00m>lisp());
renderController.cc:106:    cntrl = RP_Create<O_SwitchController>(this[01;31m-[00m>lisp());
renderController.cc:107:    cntrl[01;31m-[00m>setName(switchName);
renderController.cc:108:    this[01;31m-[00m>_Switches.set(switchName,cntrl);
renderController.cc:112:{_F(this[01;31m-[00m>lisp());
renderController.cc:113:    RPSliderController slider = RP_Create<O_SliderController>(this[01;31m-[00m>lisp());
renderController.cc:114:    slider[01;31m-[00m>setName(sliderName);
renderController.cc:115:    this[01;31m-[00m>_Sliders.set(sliderName,slider);
renderController.cc:120:{_F(this[01;31m-[00m>lisp());
renderController.cc:121:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
renderController.cc:123:    for ( Map<O_SwitchController>::iterator it=this[01;31m-[00m>_Switches.begin();
renderController.cc:124:    		it!=this[01;31m-[00m>_Switches.end(); it++ )
renderController.cc:126:	RPString s = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String,string>(it[01;31m-[00m>first);
renderController.cc:127:	RPCons one = O_Cons::create(s,this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Cons>(),this[01;31m-[00m>lisp());
renderController.cc:128:	cur[01;31m-[00m>setCdr(one);
renderController.cc:131:    return first[01;31m-[00m>cdr();
renderController.cc:135:{_F(this[01;31m-[00m>lisp());
renderController.cc:136:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
renderController.cc:138:    for ( Map<O_SliderController>::iterator it=this[01;31m-[00m>_Sliders.begin();
renderController.cc:139:    		it!=this[01;31m-[00m>_Sliders.end(); it++ )
renderController.cc:141:	RPCons one = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(it[01;31m-[00m>first),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
renderController.cc:142:	cur[01;31m-[00m>setCdr(one);
renderController.cc:145:    return first[01;31m-[00m>cdr();
renderController.cc:149:{_F(this[01;31m-[00m>lisp());
renderController.cc:151:    ASSERTP(this[01;31m-[00m>_Switches.count(name)>0,"Could not find switch name: "+name);
renderController.cc:152:    RPSwitchController control = this[01;31m-[00m>_Switches.get(name);
renderController.cc:153:    return control[01;31m-[00m>getSwitchValue();
renderController.cc:157:{_F(this[01;31m-[00m>lisp());
renderController.cc:158:    ASSERTP(this[01;31m-[00m>_Switches.count(name)>0,"Could not find switch name: "+name);
renderController.cc:159:    RPSwitchController control = this[01;31m-[00m>_Switches.get(name);
renderController.cc:163:{_F(this[01;31m-[00m>lisp());
renderController.cc:164:    ASSERTP(this[01;31m-[00m>_Sliders.count(name)>0,"Could not find slider name: "+name);
renderController.cc:165:    RPSliderController control = this[01;31m-[00m>_Sliders.get(name);
renderController.cc:172:    _lisp[01;31m-[00m>print(BF("RenderController description"));
renderController.cc:174:    for ( wi=this[01;31m-[00m>_Switches.begin(); wi!=this[01;31m-[00m>_Switches.end(); wi++ )
renderController.cc:176:	_lisp[01;31m-[00m>print(BF(" Switch %s value: %d") % wi[01;31m-[00m>first.c_str()% wi[01;31m-[00m>second[01;31m-[00m>getSwitchValue() );
renderController.cc:179:    for ( li=this[01;31m-[00m>_Sliders.begin(); li!=this[01;31m-[00m>_Sliders.end(); li++ )
renderController.cc:181:	_lisp[01;31m-[00m>print(BF(" Slider %s  value: %d  limits: [%d,%d]") 
renderController.cc:182:		     % li[01;31m-[00m>first
renderController.cc:183:		     % li[01;31m-[00m>second[01;31m-[00m>getSliderValue()
renderController.cc:184:		     % li[01;31m-[00m>second[01;31m-[00m>getLowerLimit()
renderController.cc:185:		     % li[01;31m-[00m>second[01;31m-[00m>getUpperLimit() );
renderController.cc:192:{_F(this[01;31m-[00m>lisp());
renderController.cc:193:    ASSERTP(this[01;31m-[00m>_Sliders.count(name)>0,"Could not find slider name: "+name);
renderController.cc:194:    RPSliderController control = this[01;31m-[00m>_Sliders.get(name);
renderController.cc:195:    return control[01;31m-[00m>getSliderValue();
renderController.cc:199:{_F(this[01;31m-[00m>lisp());
renderController.cc:200:    ASSERTP(this[01;31m-[00m>_Sliders.count(name)>0,"Could not find slider name: "+name);
renderController.cc:201:    RPSliderController control = this[01;31m-[00m>_Sliders.get(name);
renderController.cc:202:    control[01;31m-[00m>setSliderValue(v);
renderController.cc:210:	class_<O_Controller>(this[01;31m-[00m>lisp())
renderController.cc:234:	class_<O_SwitchController>(this[01;31m-[00m>lisp())
renderController.cc:258:	class_<O_SliderController>(this[01;31m-[00m>lisp())
residue.cc:38:    obonds = this[01;31m-[00m>getOutGoingBonds();
residue.cc:52:    this[01;31m-[00m>_Constitution = O_BuilderDatabaseReference::nil(this[01;31m-[00m>lisp());
residue.cc:58:    return this[01;31m-[00m>ownerWithClass<O_Constitution>()[01;31m-[00m>notNil();
residue.cc:62:{_F(this[01;31m-[00m>lisp());
residue.cc:66:   RPBuilderDatabase bdb = cc[01;31m-[00m>getBuilderDatabase();
residue.cc:67:   this[01;31m-[00m>_Constitution = O_BuilderDatabaseReference::create(this[01;31m-[00m>lisp(),bdb,"Constitution="+cc[01;31m-[00m>getName());
residue.cc:73:{_F(this[01;31m-[00m>lisp());
residue.cc:74:    if ( this[01;31m-[00m>eqV(obj) ) return true;
residue.cc:75:    if ( !obj[01;31m-[00m>isOfClass<O_Residue>() ) return false;
residue.cc:76:    RPResidue other = obj[01;31m-[00m>as<O_Residue>();
residue.cc:77:    if ( other[01;31m-[00m>getName() != this[01;31m-[00m>getName() ) return false;
residue.cc:78:    if ( other[01;31m-[00m>_contents.size() != this[01;31m-[00m>_contents.size() ) return false;
residue.cc:80:    for ( tit=this[01;31m-[00m>_contents.begin(), oit=other[01;31m-[00m>_contents.begin();
residue.cc:81:	    tit!=this[01;31m-[00m>_contents.end(); tit++, oit++ )
residue.cc:83:	if ( ! (*tit)[01;31m-[00m>equal(*oit) ) return false;
residue.cc:90:{_F(this[01;31m-[00m>lisp());
residue.cc:91:    if ( !obj[01;31m-[00m>isOfClass<O_Residue>() ) 
residue.cc:93:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You can only transfer coordinates to a Residue from another Residue"));
residue.cc:95:    RPResidue other = obj[01;31m-[00m>as<O_Residue>();
residue.cc:96:    if ( other[01;31m-[00m>_contents.size() != this[01;31m-[00m>_contents.size() )
residue.cc:98:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You can only transfer coordinates if the two residues have the same number of atoms"));
residue.cc:101:    for ( tit=this[01;31m-[00m>_contents.begin(), oit=other[01;31m-[00m>_contents.begin();
residue.cc:102:	    tit!=this[01;31m-[00m>_contents.end(); tit++, oit++ )
residue.cc:104:	(*tit)[01;31m-[00m>transferCoordinates(*oit);
residue.cc:111:{_F(this[01;31m-[00m>lisp());
residue.cc:112:    RPConstitution c = this[01;31m-[00m>ownerWithClass<O_Constitution>();
residue.cc:114:    if ( c[01;31m-[00m>isNil() ) 
residue.cc:127:    this[01;31m-[00m>addMatter(a);
residue.cc:128:    LOG(BF("Added %s to %s") % a[01;31m-[00m>description().c_str() % this[01;31m-[00m>description().c_str() ); // vp0(( "Added %s to %s", a[01;31m-[00m>description().c_str(), this[01;31m-[00m>description().c_str()));
residue.cc:133:{_F(this[01;31m-[00m>lisp());
residue.cc:134:    if ( this[01;31m-[00m>_MonomerAliases[01;31m-[00m>isNil() ) return false;
residue.cc:135:    return this[01;31m-[00m>_MonomerAliases[01;31m-[00m>contains(s);
residue.cc:139:{_F(this[01;31m-[00m>lisp());
residue.cc:140:    this[01;31m-[00m>_MonomerAliases = s;
residue.cc:144:{_F(this[01;31m-[00m>lisp());
residue.cc:145:    if (this[01;31m-[00m>_MonomerAliases[01;31m-[00m>isNil() )
residue.cc:147:	this[01;31m-[00m>_MonomerAliases = O_StringSet::create(this[01;31m-[00m>lisp());
residue.cc:149:    this[01;31m-[00m>_MonomerAliases[01;31m-[00m>insert(s);
residue.cc:155:{_F(this[01;31m-[00m>lisp());
residue.cc:156:    ASSERT_NOT_NULL(this[01;31m-[00m>_MonomerAliases);
residue.cc:157:    return this[01;31m-[00m>_MonomerAliases;
residue.cc:162:{_F(this[01;31m-[00m>lisp());
residue.cc:163:    LOG(BF("O_Residue::addVirtualAtom adding virtual atom with name(%s) in residue(%s)") % name.c_str() % this[01;31m-[00m>getName().c_str()  ); // vp0(("O_Residue::addVirtualAtom adding virtual atom with name(%s) in residue(%s)", name.c_str(), this[01;31m-[00m>getName().c_str() ));
residue.cc:164:    if ( this[01;31m-[00m>hasAtomWithName(name) )
residue.cc:167:	ss << "The " << this[01;31m-[00m>description() << " already has the virtual atom: " << name;
residue.cc:168:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
residue.cc:171:    va[01;31m-[00m>setElement(element_Dummy);
residue.cc:172:    this[01;31m-[00m>addMatter(va);
residue.cc:173:    va[01;31m-[00m>calculatePosition();
residue.cc:177:{ _F(this[01;31m-[00m>lisp());
residue.cc:179://    this[01;31m-[00m>getConstitution();
residue.cc:180:    this[01;31m-[00m>O_Matter::archiveBase(node);
residue.cc:181://    this[01;31m-[00m>getConstitution();
residue.cc:183:    node[01;31m-[00m>attribute("pdb",this[01;31m-[00m>pdbName);
residue.cc:184:    node[01;31m-[00m>attributeIfNotDefault<string>("uniqueLabel",this[01;31m-[00m>_UniqueLabel,"");
residue.cc:185:    node[01;31m-[00m>attributeIfNotDefault("NetCharge",this[01;31m-[00m>_NetCharge,0);
residue.cc:186:    node[01;31m-[00m>attributeIfNotDefault("fileSeqNum",this[01;31m-[00m>_FileSequenceNumber,UndefinedUnsignedInt);
residue.cc:187://    node[01;31m-[00m>archiveObjectIfDefined("constitution", this[01;31m-[00m>_Constitution );
residue.cc:188:    node[01;31m-[00m>archiveObjectIfDefined("monomerAliases",this[01;31m-[00m>_MonomerAliases);
residue.cc:190:    if ( node[01;31m-[00m>saving() ) {
residue.cc:192:        _BLOCK_TRACE("Xmling intra[01;31m-[00mresidue bonds");
residue.cc:195:	bondList = RP_Create<O_BondList>(this[01;31m-[00m>lisp());
residue.cc:198:	    for ( aPPCur=this[01;31m-[00m>getContents().begin();
residue.cc:199:			aPPCur != this[01;31m-[00m>getContents().end(); aPPCur++ ) {
residue.cc:202:		a[01;31m-[00m>addUniqueIntraResidueBondCopiesToBondList(bondList);
residue.cc:208:	node[01;31m-[00m>archiveObject<O_BondList>("bl",bondList);
residue.cc:215:	node[01;31m-[00m>archiveObject<O_BondList>("bl",bondList);
residue.cc:217:	bondList[01;31m-[00m>imposeYourself();
residue.cc:221:    node[01;31m-[00m>archiveContainerIfNotEmpty("Restraints",this[01;31m-[00m>_Restraints);
residue.cc:222:    LOG(BF("Done archive Restraints number of restraints = %d") % this[01;31m-[00m>_Restraints[01;31m-[00m>size()  ); // vp0(("Done archive Restraints number of restraints = %d", this[01;31m-[00m>_Restraints[01;31m-[00m>size() ));
residue.cc:236:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
residue.cc:242:    ss << this[01;31m-[00m>className();
residue.cc:248:    this[01;31m-[00m>Base::initialize();
residue.cc:249://    this[01;31m-[00m>_Constitution = O_BuilderDatabaseReference::nil(this[01;31m-[00m>lisp());
residue.cc:250:    this[01;31m-[00m>_FileSequenceNumber = [01;31m-[00m1;
residue.cc:251:    this[01;31m-[00m>_NetCharge = 0;
residue.cc:252:    this[01;31m-[00m>_Restraints = RP_Create<O_RestraintList>(this[01;31m-[00m>lisp());
residue.cc:253:    this[01;31m-[00m>_MonomerAliases = O_StringSet::nil(this[01;31m-[00m>lisp());
residue.cc:254:    this[01;31m-[00m>_UniqueLabel = "";
residue.cc:264:    this[01;31m-[00m>_Restraints = RP_Copy<O_RestraintList>(res._Restraints);
residue.cc:265:    this[01;31m-[00m>_Selected = res._Selected;
residue.cc:266:    this[01;31m-[00m>tempInt = res.tempInt;
residue.cc:267:    this[01;31m-[00m>pdbName = res.pdbName;
residue.cc:269://    this[01;31m-[00m>_Constitution = res._Constitution;
residue.cc:270:    this[01;31m-[00m>_FileSequenceNumber = res._FileSequenceNumber;
residue.cc:271:    this[01;31m-[00m>_MonomerAliases = res._MonomerAliases;
residue.cc:272:    this[01;31m-[00m>_UniqueLabel = res._UniqueLabel;
residue.cc:293:{_F(this[01;31m-[00m>lisp());
residue.cc:301://    rPNew[01;31m-[00m>duplicateFrom(this); //    *rPNew = *this;
residue.cc:302:    rPNew[01;31m-[00m>eraseContents();
residue.cc:303:    for ( a=this[01;31m-[00m>getContents().begin(); a!=this[01;31m-[00m>getContents().end(); a++ ) 
residue.cc:305:	aorig = (*a)[01;31m-[00m>as<O_Atom>();
residue.cc:306:	acopy = aorig[01;31m-[00m>copy()[01;31m-[00m>as<O_Atom>();
residue.cc:307:	LOG(BF("Copying atom(%s) with %d bonds") % aorig[01;31m-[00m>getName().c_str() % aorig[01;31m-[00m>numberOfBonds()  ); // vp0(( "Copying atom(%s) with %d bonds", aorig[01;31m-[00m>getName().c_str(),aorig[01;31m-[00m>numberOfBonds() ));
residue.cc:308:	rPNew[01;31m-[00m>addMatter((RPMatter)(acopy));
residue.cc:309:	acopy[01;31m-[00m>setId(aorig[01;31m-[00m>getId());
residue.cc:310:	LOG(BF("Completed copy for new %s") % acopy[01;31m-[00m>description().c_str()  ); // vp0(( "Completed copy for new %s",acopy[01;31m-[00m>description().c_str() ));
residue.cc:312:    rPNew[01;31m-[00m>_Restraints = this[01;31m-[00m>_Restraints[01;31m-[00m>copyDontRedirectAtoms();
residue.cc:313:    LOG(BF("Just created copy residue %s use_count=%d") % rPNew[01;31m-[00m>description().c_str() % rPNew.use_count()  ); // vp0(( "Just created copy residue %s use_count=%d", rPNew[01;31m-[00m>description().c_str(), rPNew.use_count() ));
residue.cc:319:{_F(this[01;31m-[00m>lisp());
residue.cc:322:    for ( a=this[01;31m-[00m>getContents().begin(); a!=this[01;31m-[00m>getContents().end(); a++ ) {
residue.cc:323:	at = (*a)[01;31m-[00m>as<O_Atom>();
residue.cc:324:	LOG(BF("Redirecting bonds for %s with %d bonds") % at[01;31m-[00m>description() % at[01;31m-[00m>numberOfBonds() );
residue.cc:325:	at[01;31m-[00m>redirectBonds();
residue.cc:327:    this[01;31m-[00m>_Restraints[01;31m-[00m>redirectAtoms();
residue.cc:333:{ _F(this[01;31m-[00m>lisp());
residue.cc:335:    rPNew = this[01;31m-[00m>copyDontRedirectBonds();
residue.cc:336:    LOG(BF("Just copied residue %s use_count=%d") % rPNew[01;31m-[00m>description() % rPNew.use_count()  );
residue.cc:337:    rPNew[01;31m-[00m>redirectBonds();
residue.cc:356:    rPNew[01;31m-[00m>eraseContents();
residue.cc:357:    for ( a=this[01;31m-[00m>getContents().begin(); a!=this[01;31m-[00m>getContents().end(); a++ ) {
residue.cc:359:	acopy = aorig[01;31m-[00m>copyDropExternalResidueBonds();
residue.cc:360:	rPNew[01;31m-[00m>addMatter((RPMatter)(acopy));
residue.cc:361:	acopy[01;31m-[00m>setId(aorig[01;31m-[00m>getId());
residue.cc:363:    rPNew[01;31m-[00m>redirectBonds();
residue.cc:370:{_F(this[01;31m-[00m>lisp());
residue.cc:371:    for ( ; c[01;31m-[00m>notNil(); c = c[01;31m-[00m>cdr() )
residue.cc:373:	string atomName = c[01;31m-[00m>car<O_Text>()[01;31m-[00m>get();
residue.cc:374:	RPAtom a = this[01;31m-[00m>atomWithName(atomName);
residue.cc:375:	this[01;31m-[00m>removeAtomDeleteBonds(a);
residue.cc:389:    for ( atom=this[01;31m-[00m>getContents().begin();
residue.cc:390:		atom != this[01;31m-[00m>getContents().end(); atom++ ) {
residue.cc:393:	    this[01;31m-[00m>eraseContent(atom);
residue.cc:394:	    aTemp[01;31m-[00m>removeAllBonds();
residue.cc:396:    	    aTemp[01;31m-[00m>setContainedByNothing();
residue.cc:401:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Residue does not contain atom for removal"));
residue.cc:407:{_F(this[01;31m-[00m>lisp());
residue.cc:408:    RPResidue res = a[01;31m-[00m>getResidueContainedBy();
residue.cc:425:    for ( atom=this[01;31m-[00m>getContents().begin();
residue.cc:426:		atom != this[01;31m-[00m>getContents().end(); atom++ ) {
residue.cc:428:	LOG(BF("Looking for atom name: %s in residue with name: %s") % a[01;31m-[00m>getName().c_str() % aTemp[01;31m-[00m>getName().c_str()  ); // vp0(( "Looking for atom name: %s in residue with name: %s", a[01;31m-[00m>getName().c_str(), aTemp[01;31m-[00m>getName().c_str() ));
residue.cc:431:	    this[01;31m-[00m>eraseContent(atom);
residue.cc:433:    	    aTemp[01;31m-[00m>setContainedByNothing();
residue.cc:438:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("You are asking to remove an atom from a residue that doesn't contain it"));
residue.cc:443:{_F(this[01;31m-[00m>lisp());
residue.cc:452:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) 
residue.cc:454:	atoms.push_back((*aCur)[01;31m-[00m>as<O_Atom>());
residue.cc:458:	(*it)[01;31m-[00m>fillInImplicitHydrogensOnCarbon();
residue.cc:464:{_F(this[01;31m-[00m>lisp());
residue.cc:468:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) 
residue.cc:470:	RPAtom atom = (*aCur)[01;31m-[00m>as<O_Atom>();
residue.cc:471:	if ( uniqueNames.count(atom[01;31m-[00m>getName()) == 0 )
residue.cc:473:	    uniqueNames.insert(atom[01;31m-[00m>getName());
residue.cc:476:	    problems[01;31m-[00m>writeln("Atom with name(" +atom[01;31m-[00m>getName() + ") is not unique");
residue.cc:487: * Make all the atom names unique by suffixing the non[01;31m-[00munique ones with
residue.cc:495:    for ( ai=this[01;31m-[00m>getContents().begin();
residue.cc:496:		ai != this[01;31m-[00m>getContents().end(); ai++ ) {
residue.cc:497:	RPAtom atom = (*ai)[01;31m-[00m>as<O_Atom>();
residue.cc:498:	LOG(BF("Looking at atom name(%s)") % atom[01;31m-[00m>getName().c_str()  ); // vp0(( "Looking at atom name(%s)", atom[01;31m-[00m>getName().c_str() ));
residue.cc:499:	allNames.insert(atom[01;31m-[00m>getName());
residue.cc:500:	allNamesAccumulate.insert(atom[01;31m-[00m>getName());
residue.cc:501:	atomsThatShareName.insert(pair<string,RPAtom>(atom[01;31m-[00m>getName(),atom));
residue.cc:515:		newName << mi[01;31m-[00m>second[01;31m-[00m>getName();
residue.cc:522:		    mi[01;31m-[00m>second[01;31m-[00m>setName(newName.str());
residue.cc:529:		    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There were more than 1000 fails trying to identify a unique atom name"));
residue.cc:538:{_F(this[01;31m-[00m>lisp());
residue.cc:539:    ASSERT_eq(aliasAtoms[01;31m-[00m>length(),atomAliases[01;31m-[00m>length());
residue.cc:540:    while ( aliasAtoms[01;31m-[00m>notNil() )
residue.cc:542:	RPText aliasAtom = aliasAtoms[01;31m-[00m>car<O_Text>();
residue.cc:543:	RPText atomAlias = atomAliases[01;31m-[00m>car<O_Text>();
residue.cc:544:	RPAtom a = this[01;31m-[00m>atomWithName(aliasAtom[01;31m-[00m>get());
residue.cc:545:	a[01;31m-[00m>setAlias(atomAlias[01;31m-[00m>get());
residue.cc:546:	aliasAtoms = aliasAtoms[01;31m-[00m>cdr();
residue.cc:547:	atomAliases = atomAliases[01;31m-[00m>cdr();
residue.cc:557:{_F(this[01;31m-[00m>lisp());
residue.cc:561:    unique = O_StringSet::create(this[01;31m-[00m>lisp());
residue.cc:562:    for ( atom=this[01;31m-[00m>getContents().begin();
residue.cc:563:		atom != this[01;31m-[00m>getContents().end(); atom++ ) {
residue.cc:565:	unique[01;31m-[00m>insert(aTemp[01;31m-[00m>getName());
residue.cc:580:    for ( atom=this[01;31m-[00m>getContents().begin();
residue.cc:581:		atom != this[01;31m-[00m>getContents().end(); atom++ ) {
residue.cc:583:	unique.insert(aTemp[01;31m-[00m>getName());
residue.cc:598:    for ( atom=this[01;31m-[00m>getContents().begin();
residue.cc:599:		atom != this[01;31m-[00m>getContents().end(); atom++ ) {
residue.cc:617:    for ( aPPCur=this[01;31m-[00m>getContents().begin();
residue.cc:618:		aPPCur != this[01;31m-[00m>getContents().end(); aPPCur++ ) {
residue.cc:620:	a[01;31m-[00m>addUniqueIntraResidueBondsToVectorRPBonds(bonds);
residue.cc:636:    for ( aPPCur=this[01;31m-[00m>getContents().begin();
residue.cc:637:		aPPCur != this[01;31m-[00m>getContents().end(); aPPCur++ ) {
residue.cc:639:	a[01;31m-[00m>addInterResidueBondsToVectorRPBonds(bonds);
residue.cc:646:{_F(this[01;31m-[00m>lisp());
residue.cc:648:    for ( aCur=this[01;31m-[00m>_contents.begin();aCur!=this[01;31m-[00m>_contents.end(); aCur++ ) {
residue.cc:649:	RPAtom a = (*aCur)[01;31m-[00m>as<O_Atom>();
residue.cc:650:	LOG(BF("Looking at(%s) for alias(%s)") % (*aCur)[01;31m-[00m>getName().c_str() % alias.c_str()  ); // vp0(( "Looking at(%s) for alias(%s)", (*aCur)[01;31m-[00m>getName().c_str(), alias.c_str() ));
residue.cc:651:        if ( a[01;31m-[00m>getAlias() == alias) {
residue.cc:655:    return O_Atom::nil(this[01;31m-[00m>lisp());
residue.cc:659:{_F(this[01;31m-[00m>lisp());
residue.cc:660:    RPAtom a = this[01;31m-[00m>atomWithAliasOrNil(alias);
residue.cc:661:    if ( a[01;31m-[00m>notNil() ) return a;
residue.cc:662:    LOG(BF("Matter(%s) with %d contents does not contain content with alias(%s)") % this[01;31m-[00m>name.c_str() % this[01;31m-[00m>_contents.size() % alias.c_str()  ); // vp0(( "Matter(%s) with %d contents does not contain content with alias(%s)", this[01;31m-[00m>name.c_str(), this[01;31m-[00m>_contents.size(), alias.c_str() ));
residue.cc:664:    ss << "residue (" << this[01;31m-[00m>name << ") does not contain atom with alias(" << alias << ")";
residue.cc:665:    TOSS(_lisp[01;31m-[00m>create<O_ContentException>(ss.str()));
residue.cc:673:    for ( aPPCur=this[01;31m-[00m>getContents().begin();
residue.cc:674:		aPPCur != this[01;31m-[00m>getContents().end(); aPPCur++ ) {
residue.cc:676:	if ( a[01;31m-[00m>invalid() ) return true;
residue.cc:682:{_F(this[01;31m-[00m>lisp());
residue.cc:683:    RPAtom a = this[01;31m-[00m>atomWithName(name);
residue.cc:684:    return a[01;31m-[00m>getPosition();
residue.cc:688:    if ( this[01;31m-[00m>invalid() ) {
residue.cc:689:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("INVALID %s")% this[01;31m-[00m>description()));
residue.cc:698:    for ( aPPCur=this[01;31m-[00m>getContents().begin();
residue.cc:699:		aPPCur != this[01;31m-[00m>getContents().end(); aPPCur++ ) {
residue.cc:701:	a[01;31m-[00m>setAnchorPos(a[01;31m-[00m>getPosition());
residue.cc:702:	a[01;31m-[00m>setAnchorRestraintOn();
residue.cc:707:{_F(this[01;31m-[00m>lisp());
residue.cc:708:    return this[01;31m-[00m>_contents.size();
residue.cc:718:    class_<O_Residue>(this[01;31m-[00m>lisp())
restraint.cc:56:    this[01;31m-[00m>archiveBase(node);
restraint.cc:65:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
restraint.cc:70:    this[01;31m-[00m>_A = old._A;
restraint.cc:71:    this[01;31m-[00m>_AnchorPos = old._AnchorPos;
restraint.cc:78:    rest[01;31m-[00m>_A = this[01;31m-[00m>getAtom();
restraint.cc:83:{_F(this[01;31m-[00m>lisp());
restraint.cc:84:    this[01;31m-[00m>_A = this[01;31m-[00m>getAtom()[01;31m-[00m>getCopyAtom();
restraint.cc:90:    node[01;31m-[00m>archiveWeakPointer("AtomA",this[01;31m-[00m>_A);
restraint.cc:91:    node[01;31m-[00m>archivePlainObject<Vector3>("AnchorPos","AnchorPos",this[01;31m-[00m>_AnchorPos);
restraint.cc:92:    node[01;31m-[00m>attribute("weight",this[01;31m-[00m>_Weight);
restraint.cc:98:{_F(this[01;31m-[00m>lisp());
restraint.cc:99:    this[01;31m-[00m>_AnchorPos.set(this[01;31m-[00m>_AnchorPos.getX(),this[01;31m-[00m>_AnchorPos.getY(),this[01;31m-[00m>_AnchorPos.getZ()*[01;31m-[00m1.0);
restraint.cc:108:    this[01;31m-[00m>_A = old._A;
restraint.cc:109:    this[01;31m-[00m>_Chirality = old._Chirality;
restraint.cc:116:    rest[01;31m-[00m>_A = this[01;31m-[00m>getAtomA();
restraint.cc:121:{_F(this[01;31m-[00m>lisp());
restraint.cc:122:    this[01;31m-[00m>_A = this[01;31m-[00m>getAtomA()[01;31m-[00m>getCopyAtom();
restraint.cc:128:    node[01;31m-[00m>archiveWeakPointer("AtomA",this[01;31m-[00m>_A);
restraint.cc:129:    node[01;31m-[00m>attribute("Chirality",this[01;31m-[00m>_Chirality);
restraint.cc:133:{_F(this[01;31m-[00m>lisp());
restraint.cc:134:    this[01;31m-[00m>_Chirality *= [01;31m-[00m1.0;
restraint.cc:148:    this[01;31m-[00m>_A = old._A;
restraint.cc:149:    this[01;31m-[00m>_B = old._B;
restraint.cc:150:    this[01;31m-[00m>_Min = old._Min;
restraint.cc:151:    this[01;31m-[00m>_Max = old._Max;
restraint.cc:152:    this[01;31m-[00m>_Weight = old._Weight;
restraint.cc:158:    rest[01;31m-[00m>_A = this[01;31m-[00m>getAtomA();
restraint.cc:159:    rest[01;31m-[00m>_B = this[01;31m-[00m>getAtomB();
restraint.cc:164:{_F(this[01;31m-[00m>lisp());
restraint.cc:165:    this[01;31m-[00m>_A = this[01;31m-[00m>getAtomA()[01;31m-[00m>getCopyAtom();
restraint.cc:166:    this[01;31m-[00m>_B = this[01;31m-[00m>getAtomB()[01;31m-[00m>getCopyAtom();
restraint.cc:173:    node[01;31m-[00m>archiveWeakPointer("AtomA",this[01;31m-[00m>_A);
restraint.cc:174:    node[01;31m-[00m>archiveWeakPointer("AtomB",this[01;31m-[00m>_B);
restraint.cc:175:    node[01;31m-[00m>attribute("Min",this[01;31m-[00m>_Min);
restraint.cc:176:    node[01;31m-[00m>attribute("Max",this[01;31m-[00m>_Max);
restraint.cc:177:    node[01;31m-[00m>attribute("Weight",this[01;31m-[00m>_Weight);
restraint.cc:182:    this[01;31m-[00m>_A = old._A;
restraint.cc:183:    this[01;31m-[00m>_B = old._B;
restraint.cc:184:    this[01;31m-[00m>_C = old._C;
restraint.cc:185:    this[01;31m-[00m>_MinRad = old._MinRad;
restraint.cc:186:    this[01;31m-[00m>_MaxRad = old._MaxRad;
restraint.cc:187:    this[01;31m-[00m>_Weight = old._Weight;
restraint.cc:193:    rest[01;31m-[00m>_A = this[01;31m-[00m>getAtomA()[01;31m-[00m>getCopyAtom();
restraint.cc:194:    rest[01;31m-[00m>_B = this[01;31m-[00m>getAtomB()[01;31m-[00m>getCopyAtom();
restraint.cc:195:    rest[01;31m-[00m>_C = this[01;31m-[00m>getAtomC()[01;31m-[00m>getCopyAtom();
restraint.cc:201:{_F(this[01;31m-[00m>lisp());
restraint.cc:202:    this[01;31m-[00m>_A = this[01;31m-[00m>getAtomA()[01;31m-[00m>getCopyAtom();
restraint.cc:203:    this[01;31m-[00m>_B = this[01;31m-[00m>getAtomB()[01;31m-[00m>getCopyAtom();
restraint.cc:204:    this[01;31m-[00m>_C = this[01;31m-[00m>getAtomC()[01;31m-[00m>getCopyAtom();
restraint.cc:209:    node[01;31m-[00m>archiveWeakPointer("AtomA",this[01;31m-[00m>_A);
restraint.cc:210:    node[01;31m-[00m>archiveWeakPointer("AtomB",this[01;31m-[00m>_B);
restraint.cc:211:    node[01;31m-[00m>archiveWeakPointer("AtomC",this[01;31m-[00m>_C);
restraint.cc:212:    node[01;31m-[00m>attribute("MinRad",this[01;31m-[00m>_MinRad);
restraint.cc:213:    node[01;31m-[00m>attribute("MaxRad",this[01;31m-[00m>_MaxRad);
restraint.cc:214:    node[01;31m-[00m>attribute("Weight",this[01;31m-[00m>_Weight);
restraint.cc:220:    this[01;31m-[00m>_A = old._A;
restraint.cc:221:    this[01;31m-[00m>_B = old._B;
restraint.cc:222:    this[01;31m-[00m>_C = old._C;
restraint.cc:223:    this[01;31m-[00m>_D = old._D;
restraint.cc:224:    this[01;31m-[00m>_MinDegrees = old._MinDegrees;
restraint.cc:225:    this[01;31m-[00m>_MaxDegrees = old._MaxDegrees;
restraint.cc:226:    this[01;31m-[00m>_Weight = old._Weight;
restraint.cc:232:    rest[01;31m-[00m>_A = this[01;31m-[00m>getAtomA()[01;31m-[00m>getCopyAtom();
restraint.cc:233:    rest[01;31m-[00m>_B = this[01;31m-[00m>getAtomB()[01;31m-[00m>getCopyAtom();
restraint.cc:234:    rest[01;31m-[00m>_C = this[01;31m-[00m>getAtomC()[01;31m-[00m>getCopyAtom();
restraint.cc:235:    rest[01;31m-[00m>_D = this[01;31m-[00m>getAtomD()[01;31m-[00m>getCopyAtom();
restraint.cc:240:{_F(this[01;31m-[00m>lisp());
restraint.cc:241:    this[01;31m-[00m>_A = this[01;31m-[00m>getAtomA()[01;31m-[00m>getCopyAtom();
restraint.cc:242:    this[01;31m-[00m>_B = this[01;31m-[00m>getAtomB()[01;31m-[00m>getCopyAtom();
restraint.cc:243:    this[01;31m-[00m>_C = this[01;31m-[00m>getAtomC()[01;31m-[00m>getCopyAtom();
restraint.cc:244:    this[01;31m-[00m>_D = this[01;31m-[00m>getAtomD()[01;31m-[00m>getCopyAtom();
restraint.cc:249:    node[01;31m-[00m>archiveWeakPointer("AtomA",this[01;31m-[00m>_A);
restraint.cc:250:    node[01;31m-[00m>archiveWeakPointer("AtomB",this[01;31m-[00m>_B);
restraint.cc:251:    node[01;31m-[00m>archiveWeakPointer("AtomC",this[01;31m-[00m>_C);
restraint.cc:252:    node[01;31m-[00m>archiveWeakPointer("AtomD",this[01;31m-[00m>_D);
restraint.cc:253:    node[01;31m-[00m>attribute("MinDegrees",this[01;31m-[00m>_MinDegrees);
restraint.cc:254:    node[01;31m-[00m>attribute("MaxDegrees",this[01;31m-[00m>_MaxDegrees);
restraint.cc:255:    node[01;31m-[00m>attribute("Weight",this[01;31m-[00m>_Weight);
restraint.cc:259:{_F(this[01;31m-[00m>lisp());
restraint.cc:260:    this[01;31m-[00m>_MinDegrees = 360.0 [01;31m-[00m this[01;31m-[00m>_MinDegrees;
restraint.cc:261:    this[01;31m-[00m>_MaxDegrees = 360.0 [01;31m-[00m this[01;31m-[00m>_MaxDegrees;
restraint.cc:270:    class_<O_RestraintFixedNonbond>(e[01;31m-[00m>lisp())
restraint.cc:284:    nb[01;31m-[00m>setMatter(matter);
restraint.cc:291:    this[01;31m-[00m>_Matter = O_Matter::nil(this[01;31m-[00m>lisp());
restraint.cc:296:    node[01;31m-[00m>archiveObject("matter",this[01;31m-[00m>_Matter);
restraint.cc:313:    node[01;31m-[00m>archiveList("Entries",this[01;31m-[00m>_Restraints);
restraint.cc:318:{_F(this[01;31m-[00m>lisp());
restraint.cc:319:    RPRestraintList newList = O_RestraintList::create(this[01;31m-[00m>lisp());
restraint.cc:321:    for ( it=this[01;31m-[00m>_Restraints.begin(); it!=this[01;31m-[00m>_Restraints.end(); it++ )
restraint.cc:323:	newList[01;31m-[00m>_Restraints.push_back((*it)[01;31m-[00m>copyDontRedirectAtoms());
restraint.cc:331:{_F(this[01;31m-[00m>lisp());
restraint.cc:333:    for ( it=this[01;31m-[00m>_Restraints.begin(); it!=this[01;31m-[00m>_Restraints.end(); it++ )
restraint.cc:335:	(*it)[01;31m-[00m>redirectAtoms();
restraint.cc:345:    for ( ri=rl[01;31m-[00m>_Restraints.begin(); ri!=rl[01;31m-[00m>_Restraints.end(); ri++ ) {
restraint.cc:347:	this[01;31m-[00m>addRestraint(rr);
restraint.cc:358:	class_<O_Restraint>(this[01;31m-[00m>lisp())
restraint.cc:381:	class_<O_RestraintDihedral>(this[01;31m-[00m>lisp())
restraint.cc:409:	class_<O_RestraintAnchor>(this[01;31m-[00m>lisp())
restraint.cc:433:	class_<O_RestraintList>(this[01;31m-[00m>lisp())
ringFinder.cc:34:    this[01;31m-[00m>Base::initialize();
ringFinder.cc:35:    this[01;31m-[00m>_beep = O_BitVector::nil(this[01;31m-[00m>lisp());
ringFinder.cc:36:    this[01;31m-[00m>_firstVertex= O_AGVertex::nil(this[01;31m-[00m>lisp());
ringFinder.cc:37:    this[01;31m-[00m>_lastVertex = O_AGVertex::nil(this[01;31m-[00m>lisp());
ringFinder.cc:38:    this[01;31m-[00m>_firstEdge = O_AGEdge::nil(this[01;31m-[00m>lisp());
ringFinder.cc:44:    this[01;31m-[00m>_graph = orig._graph;
ringFinder.cc:47:    LOG(BF(" beep[01;31m-[00m>isNil() = %d") % orig._beep[01;31m-[00m>isNil()  ); // vp0((" beep[01;31m-[00m>isNil() = %d", orig._beep[01;31m-[00m>isNil() ));
ringFinder.cc:48:    if ( orig._beep[01;31m-[00m>isNil() ) 
ringFinder.cc:50:	this[01;31m-[00m>_beep = O_BitVector::nil(this[01;31m-[00m>lisp());
ringFinder.cc:51:	LOG(BF("Setting this[01;31m-[00m>_beep to nil") ); // vp0(("Setting this[01;31m-[00m>_beep to nil"));
ringFinder.cc:54:	LOG(BF("Copying this[01;31m-[00m>_beep") ); // vp0(("Copying this[01;31m-[00m>_beep"));
ringFinder.cc:55:	this[01;31m-[00m>_beep = orig._beep[01;31m-[00m>copy();
ringFinder.cc:58:    this[01;31m-[00m>_firstVertex = orig._firstVertex;
ringFinder.cc:59:    this[01;31m-[00m>_firstEdge = orig._firstEdge;
ringFinder.cc:60:    this[01;31m-[00m>_lastVertex = orig._lastVertex;
ringFinder.cc:68:    pm[01;31m-[00m>_graph = graph;
ringFinder.cc:69:    pm[01;31m-[00m>_beep = O_BitVector::create(lisp);
ringFinder.cc:70:    pm[01;31m-[00m>_beep[01;31m-[00m>setLength(graph[01;31m-[00m>getNumberOfEdges());
ringFinder.cc:71:    pm[01;31m-[00m>_firstVertex = firstVertex;
ringFinder.cc:72:    pm[01;31m-[00m>_firstEdge = firstEdge;
ringFinder.cc:73:    pm[01;31m-[00m>_lastVertex = lastVertex;
ringFinder.cc:74:    pm[01;31m-[00m>_beep[01;31m-[00m>setBit(firstEdge[01;31m-[00m>getId(),1);
ringFinder.cc:80:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:89:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:90:    this[01;31m-[00m>_beep[01;31m-[00m>inPlaceOr(other[01;31m-[00m>_beep);
ringFinder.cc:94:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:95:    return this[01;31m-[00m>_firstVertex;
ringFinder.cc:99:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:100:    return this[01;31m-[00m>_firstEdge;
ringFinder.cc:105:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:106:    return this[01;31m-[00m>_lastVertex;
ringFinder.cc:110:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:111:    this[01;31m-[00m>_lastVertex = vert;
ringFinder.cc:115:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:116:    this[01;31m-[00m>_lastVertex = vertex;
ringFinder.cc:117:    uint ei = edge[01;31m-[00m>getId();
ringFinder.cc:118:    this[01;31m-[00m>_beep[01;31m-[00m>setBit(ei,1);
ringFinder.cc:123:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:124:    RPAtom a1 = this[01;31m-[00m>_firstVertex[01;31m-[00m>getAtom();
ringFinder.cc:125:    string firstName = a1[01;31m-[00m>getName();
ringFinder.cc:126:    uint firstResidue = a1[01;31m-[00m>getResidueContainedBy()[01;31m-[00m>getId();
ringFinder.cc:127:    RPAtom a2 = this[01;31m-[00m>_lastVertex[01;31m-[00m>getAtom();
ringFinder.cc:128:    string lastName = a2[01;31m-[00m>getName();
ringFinder.cc:129:    uint lastResidue = a2[01;31m-[00m>getResidueContainedBy()[01;31m-[00m>getId();
ringFinder.cc:130:    _lisp[01;31m-[00m>print(BF("Ring start: %d:%s end: %d:%s") % firstResidue %  firstName
ringFinder.cc:132:    RPObjectSet verts = O_ObjectSet::create(this[01;31m-[00m>lisp());
ringFinder.cc:133:    _lisp[01;31m-[00m>print(BF("Edges: "));
ringFinder.cc:135:    for ( ei=this[01;31m-[00m>_beep[01;31m-[00m>getOnIndices().begin();
ringFinder.cc:136:    		ei!=this[01;31m-[00m>_beep[01;31m-[00m>getOnIndices().end(); ei++ )
ringFinder.cc:138:	RPAGEdge edge = this[01;31m-[00m>getGraph()[01;31m-[00m>getEdge(*ei);
ringFinder.cc:139:	a1 = edge[01;31m-[00m>getVertex1()[01;31m-[00m>getAtom();
ringFinder.cc:140:	uint r1 = a1[01;31m-[00m>getResidueContainedBy()[01;31m-[00m>getId();
ringFinder.cc:141:	string s1 = a1[01;31m-[00m>getName();
ringFinder.cc:142:	a2 = edge[01;31m-[00m>getVertex2()[01;31m-[00m>getAtom();
ringFinder.cc:143:	uint r2 = a2[01;31m-[00m>getResidueContainedBy()[01;31m-[00m>getId();
ringFinder.cc:144:	string s2 = a2[01;31m-[00m>getName();
ringFinder.cc:145:	_lisp[01;31m-[00m>print(BF("    %d:%s [01;31m-[00m %d:%s") % r1% s1.c_str()% r2% s2.c_str() );
ringFinder.cc:151:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:152:    RPObjectSet verts = O_ObjectSet::create(this[01;31m-[00m>lisp());
ringFinder.cc:156:    edges = this[01;31m-[00m>_beep[01;31m-[00m>getOnIndices();
ringFinder.cc:160:	RPAGEdge edge = this[01;31m-[00m>getGraph()[01;31m-[00m>getEdge(*ei);
ringFinder.cc:161:	RPAtom a1 = edge[01;31m-[00m>getVertex1()[01;31m-[00m>getAtom();
ringFinder.cc:163:	RPAtom a2 = edge[01;31m-[00m>getVertex2()[01;31m-[00m>getAtom();
ringFinder.cc:167:    RPCons  list = O_Cons::nil(this[01;31m-[00m>lisp());
ringFinder.cc:170:	list = O_Cons::create(*si,list,this[01;31m-[00m>lisp());
ringFinder.cc:177:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:178:    return this[01;31m-[00m>_beep;
ringFinder.cc:183:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
ringFinder.cc:184:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
ringFinder.cc:185:// [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
ringFinder.cc:195:    v[01;31m-[00m>_graph = graph;
ringFinder.cc:196:    v[01;31m-[00m>_atom = atom;
ringFinder.cc:197:    v[01;31m-[00m>_edges.clear();
ringFinder.cc:198:    v[01;31m-[00m>_seenId = UndefinedUnsignedInt;
ringFinder.cc:199:    v[01;31m-[00m>emptySendBuffer();
ringFinder.cc:200:    v[01;31m-[00m>emptyReceiveBuffer();
ringFinder.cc:206:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:207:    return this[01;31m-[00m>_atom.get();
ringFinder.cc:211:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:212:RPCons	verts = O_Cons::nil(this[01;31m-[00m>lisp());
ringFinder.cc:213:    for ( vector<RPAGEdge>::iterator ei=this[01;31m-[00m>_edges.begin();
ringFinder.cc:214:    		ei!=this[01;31m-[00m>_edges.end(); ei++ )
ringFinder.cc:216:	verts = O_Cons::create(*ei,verts,this[01;31m-[00m>lisp());
ringFinder.cc:225:    ss << this[01;31m-[00m>className() << "{";
ringFinder.cc:226:    ss << this[01;31m-[00m>_atom[01;31m-[00m>description() << "}";
ringFinder.cc:231:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:232:    this[01;31m-[00m>_atom[01;31m-[00m>dump();
ringFinder.cc:234:    for ( cur=this[01;31m-[00m>getConnectedVertices(); cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
ringFinder.cc:236:	_lisp[01;31m-[00m>prin1(BF("%s ") % cur[01;31m-[00m>car<O_AGVertex>()[01;31m-[00m>getAtom()[01;31m-[00m>getName() );
ringFinder.cc:238:    _lisp[01;31m-[00m>print(BF(""));
ringFinder.cc:243:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:244:    return this[01;31m-[00m>_atom;
ringFinder.cc:249:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:250:    this[01;31m-[00m>_edges.push_back(edge);
ringFinder.cc:254:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:255:    this[01;31m-[00m>_sendBuffer = O_Cons::nil(this[01;31m-[00m>lisp());
ringFinder.cc:260:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:261:    this[01;31m-[00m>_receiveBuffer = O_Cons::nil(this[01;31m-[00m>lisp());
ringFinder.cc:266:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:267:    this[01;31m-[00m>emptySendBuffer();
ringFinder.cc:269:    for ( x=this[01;31m-[00m>_edges.begin(); x!=this[01;31m-[00m>_edges.end(); x++ )
ringFinder.cc:271:	RPAGVertex nVertex = (*x)[01;31m-[00m>otherVertex(this);
ringFinder.cc:272:	RPPathMessage mess = O_PathMessage::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>getGraph(),nVertex,*x,nVertex);
ringFinder.cc:273:	this[01;31m-[00m>_sendBuffer = O_Cons::create(mess,this[01;31m-[00m>_sendBuffer,this[01;31m-[00m>lisp());
ringFinder.cc:279:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:280:    if ( this[01;31m-[00m>_edges.size() == 0 ) return;
ringFinder.cc:282:    for ( edge=this[01;31m-[00m>_edges.begin(); edge!=this[01;31m-[00m>_edges.end(); edge++ )
ringFinder.cc:284:	RPAGVertex neighbor = (*edge)[01;31m-[00m>otherVertex(this);
ringFinder.cc:285:	_BLOCK_TRACEF(BF("sending messages to Vertex: %s") % neighbor[01;31m-[00m>description().c_str() );
ringFinder.cc:287:	for ( msgCur=this[01;31m-[00m>_sendBuffer; msgCur[01;31m-[00m>notNil(); msgCur=msgCur[01;31m-[00m>cdr())
ringFinder.cc:289:	    RPPathMessage msg = msgCur[01;31m-[00m>car<O_PathMessage>();
ringFinder.cc:290:	    LOG(BF("Sending message: %s") % msg[01;31m-[00m>beep()[01;31m-[00m>asString().c_str() ); // vp0(("Sending message: %s", msg[01;31m-[00m>beep()[01;31m-[00m>asString().c_str()));
ringFinder.cc:293:	    if ( msg[01;31m-[00m>getLastVertex() == neighbor ) continue;
ringFinder.cc:298:	    if ( msg[01;31m-[00m>getFirstVertex() == neighbor ) continue;
ringFinder.cc:299:	    RPPathMessage newMsg = msg[01;31m-[00m>copy();
ringFinder.cc:300:	    newMsg[01;31m-[00m>update(*edge,this[01;31m-[00m>sharedThis<O_AGVertex>());
ringFinder.cc:301:	    neighbor[01;31m-[00m>acceptMessage(newMsg);
ringFinder.cc:304:    this[01;31m-[00m>emptySendBuffer();
ringFinder.cc:308:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:309:    this[01;31m-[00m>_receiveBuffer = O_Cons::create(msg,this[01;31m-[00m>_receiveBuffer,this[01;31m-[00m>lisp());
ringFinder.cc:316:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:317:    if ( this[01;31m-[00m>_edges.size() == 0 ) return;
ringFinder.cc:322:    RPRingFinder		graph = this[01;31m-[00m>getGraph();
ringFinder.cc:323:    edgeArray0.resize(graph[01;31m-[00m>getNumberOfEdges(),O_PathMessage::nil(this[01;31m-[00m>lisp()));
ringFinder.cc:324:    edgeArray1.resize(graph[01;31m-[00m>getNumberOfEdges(),O_PathMessage::nil(this[01;31m-[00m>lisp()));
ringFinder.cc:326:    LOG(BF("Stage(%d) Vertex(%s) distributing receiveBuffer, there are %d messages") % stage % this[01;31m-[00m>_atom[01;31m-[00m>description().c_str() % this[01;31m-[00m>_receiveBuffer[01;31m-[00m>length() ); // vp0(("Stage(%d) Vertex(%s) distributing receiveBuffer, there are %d messages", stage, this[01;31m-[00m>_atom[01;31m-[00m>description().c_str(), this[01;31m-[00m>_receiveBuffer[01;31m-[00m>length()));
ringFinder.cc:329:    ASSERTP(this[01;31m-[00m>_receiveBuffer[01;31m-[00m>notNil(),"The receive buffer is empty for atom("+this[01;31m-[00m>_atom[01;31m-[00m>description()+")!");
ringFinder.cc:330:    for ( msgCur = this[01;31m-[00m>_receiveBuffer; msgCur[01;31m-[00m>notNil(); msgCur=msgCur[01;31m-[00m>cdr())
ringFinder.cc:332:	RPPathMessage msg = msgCur[01;31m-[00m>car<O_PathMessage>();
ringFinder.cc:333:	_BLOCK_TRACEF(BF("Stage(%d) Vertex(%s) received bitVector: %s") % stage % this[01;31m-[00m>_atom[01;31m-[00m>getName() % msg[01;31m-[00m>beep()[01;31m-[00m>asString() );
ringFinder.cc:334:	RPAGEdge edge = msg[01;31m-[00m>getFirstEdge();
ringFinder.cc:335:	RPAGVertex vert = msg[01;31m-[00m>getFirstVertex();
ringFinder.cc:336:	uint side = edge[01;31m-[00m>getSide(vert);
ringFinder.cc:337:	uint edgeId = edge[01;31m-[00m>getId();
ringFinder.cc:339:	    if ( edgeArray0[edgeId][01;31m-[00m>isNil() )
ringFinder.cc:346:	    if ( edgeArray1[edgeId][01;31m-[00m>isNil() )
ringFinder.cc:359:	    // They represent odd[01;31m-[00mmembered rings
ringFinder.cc:361:    { _BLOCK_TRACEF(BF("Detecting odd[01;31m-[00mmembered rings numberOfEdges=%d") % graph[01;31m-[00m>getNumberOfEdges() );
ringFinder.cc:362:	numEdges = graph[01;31m-[00m>getNumberOfEdges();
ringFinder.cc:365:	    LOG(BF("Detecting odd[01;31m-[00mmembered rings i = %d") % i ); // vp0(("Detecting odd[01;31m-[00mmembered rings i = %d", i));
ringFinder.cc:366:		    // detect odd[01;31m-[00mmembered rings
ringFinder.cc:367:	    if ( edgeArray0[i][01;31m-[00m>notNil() && edgeArray1[i][01;31m-[00m>notNil() )
ringFinder.cc:369:		RPPathMessage ring = edgeArray0[i][01;31m-[00m>copy();
ringFinder.cc:370:		ring[01;31m-[00m>join(edgeArray1[i]);
ringFinder.cc:371:		edgeArray0[i] = O_PathMessage::nil(this[01;31m-[00m>lisp());
ringFinder.cc:372:		edgeArray1[i] = O_PathMessage::nil(this[01;31m-[00m>lisp());
ringFinder.cc:373:		ring[01;31m-[00m>updateLastVertex(this[01;31m-[00m>sharedThis<O_AGVertex>());
ringFinder.cc:374:		graph[01;31m-[00m>addRing(ring,stage);
ringFinder.cc:385:    {_BLOCK_TRACE("Detecting even[01;31m-[00mmembered rings");
ringFinder.cc:389:	    LOG(BF("Detecting even[01;31m-[00mmembered rings: i = %d") % i ); // vp0(("Detecting even[01;31m-[00mmembered rings: i = %d", i));
ringFinder.cc:390:	    if ( edgeArray0[i][01;31m-[00m>notNil() )
ringFinder.cc:393:		void* nodeId = msg[01;31m-[00m>getFirstVertex()[01;31m-[00m>getId();
ringFinder.cc:396:		    vertexDict[nodeId] = O_Cons::create(msg,vertexDict[nodeId],this[01;31m-[00m>lisp());
ringFinder.cc:399:		    vertexDict[nodeId]=O_Cons::create(msg,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
ringFinder.cc:402:	    if ( edgeArray1[i][01;31m-[00m>notNil() )
ringFinder.cc:405:		void* nodeId = msg[01;31m-[00m>getFirstVertex()[01;31m-[00m>getId();
ringFinder.cc:408:		    vertexDict[nodeId] = O_Cons::create(msg,vertexDict[nodeId],this[01;31m-[00m>lisp());
ringFinder.cc:411:		    vertexDict[nodeId]=O_Cons::create(msg,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
ringFinder.cc:422:    {_BLOCK_TRACEF(BF("Detecting even[01;31m-[00mmembered rings"));
ringFinder.cc:428:		    // a node[01;31m-[00mcollision, combine the messages and
ringFinder.cc:431:	    if ( it[01;31m-[00m>second[01;31m-[00m>cdr()[01;31m-[00m>notNil() )
ringFinder.cc:434:		for ( first=it[01;31m-[00m>second; first[01;31m-[00m>notNil(); first = first[01;31m-[00m>cdr() )
ringFinder.cc:437:		    for ( second=first[01;31m-[00m>cdr();second[01;31m-[00m>notNil();second=second[01;31m-[00m>cdr())
ringFinder.cc:439:			RPPathMessage ring = first[01;31m-[00m>car<O_PathMessage>()[01;31m-[00m>copy();
ringFinder.cc:440:			ring[01;31m-[00m>join(second[01;31m-[00m>car<O_PathMessage>());
ringFinder.cc:441:			ring[01;31m-[00m>updateLastVertex(this[01;31m-[00m>sharedThis<O_AGVertex>());
ringFinder.cc:442:			graph[01;31m-[00m>addRing(ring,stage);
ringFinder.cc:447:		this[01;31m-[00m>_sendBuffer = O_Cons::create(it[01;31m-[00m>second[01;31m-[00m>car<O_PathMessage>(),
ringFinder.cc:448:						    this[01;31m-[00m>_sendBuffer,this[01;31m-[00m>lisp());
ringFinder.cc:452:    this[01;31m-[00m>emptyReceiveBuffer();
ringFinder.cc:463:    edge[01;31m-[00m>_graph = graph;
ringFinder.cc:464:    edge[01;31m-[00m>_id = graph[01;31m-[00m>getNextEdgeId();
ringFinder.cc:465:    if ( atom1[01;31m-[00m>atLowerAddressThan(atom2) )
ringFinder.cc:467:	edge[01;31m-[00m>_vertex1 = graph[01;31m-[00m>vertexForAtom(atom1);
ringFinder.cc:468:	edge[01;31m-[00m>_vertex2 = graph[01;31m-[00m>vertexForAtom(atom2);
ringFinder.cc:471:	edge[01;31m-[00m>_vertex2 = graph[01;31m-[00m>vertexForAtom(atom1);
ringFinder.cc:472:	edge[01;31m-[00m>_vertex1 = graph[01;31m-[00m>vertexForAtom(atom2);
ringFinder.cc:474:    edge[01;31m-[00m>_vertex1[01;31m-[00m>addEdge(edge);
ringFinder.cc:475:    edge[01;31m-[00m>_vertex2[01;31m-[00m>addEdge(edge);
ringFinder.cc:481:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:482:    return this[01;31m-[00m>_vertex1;
ringFinder.cc:486:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:487:    return this[01;31m-[00m>_vertex2;
ringFinder.cc:491:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:492:    return this[01;31m-[00m>_id;
ringFinder.cc:499:    if ( firstVertex == this[01;31m-[00m>_vertex1.get() )
ringFinder.cc:501:	return this[01;31m-[00m>_vertex2;
ringFinder.cc:503:    return this[01;31m-[00m>_vertex1;
ringFinder.cc:508:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:509:    if ( vert == this[01;31m-[00m>_vertex1 )
ringFinder.cc:519:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
ringFinder.cc:520:    RPMolecule mol = kargs[01;31m-[00m>getAndRemove("molecule")[01;31m-[00m>as<O_Molecule>();
ringFinder.cc:521:    this[01;31m-[00m>defineForMolecule(mol);
ringFinder.cc:527:    graph[01;31m-[00m>defineForMolecule(mol);
ringFinder.cc:533:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:537:    this[01;31m-[00m>_vertices.clear();
ringFinder.cc:541:	if ( at[01;31m-[00m>isOfClass<O_VirtualAtom>() ) continue;
ringFinder.cc:542:	LOG(BF("### Adding atom: %s id:%p to graph") % at[01;31m-[00m>description().c_str() % at.get()  ); // vp0(( "### Adding atom: %s id:%p to graph", at[01;31m-[00m>description().c_str(), at.get() ));
ringFinder.cc:543:	if ( this[01;31m-[00m>_vertices.count(at.get() ) != 0 )
ringFinder.cc:545:	    TOSS(_lisp[01;31m-[00m>create<O_ContentException>("Non unique atom id"));
ringFinder.cc:547:	RPAGVertex vert = O_AGVertex::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>sharedThis<O_RingFinder>(),at);
ringFinder.cc:548:	this[01;31m-[00m>_vertices[at.get()] = vert;
ringFinder.cc:551:    this[01;31m-[00m>_edges.clear();
ringFinder.cc:556:	RPAGEdge edge = O_AGEdge::create(this[01;31m-[00m>lisp(),this[01;31m-[00m>sharedThis<O_RingFinder>(),a1,a2);
ringFinder.cc:557:	this[01;31m-[00m>_edges.push_back(edge);
ringFinder.cc:562:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:563:    return this[01;31m-[00m>_edges.size();
ringFinder.cc:568:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:570:    it = this[01;31m-[00m>_vertices.begin();
ringFinder.cc:571:    return it[01;31m-[00m>second[01;31m-[00m>getAtom();
ringFinder.cc:576:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:577:    return this[01;31m-[00m>_vertices[anAtom.get()];
ringFinder.cc:583:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:586:    for ( it=this[01;31m-[00m>_vertices.begin(); it!=this[01;31m-[00m>_vertices.end(); it++ )
ringFinder.cc:588:	it[01;31m-[00m>second[01;31m-[00m>dump();
ringFinder.cc:591:    _lisp[01;31m-[00m>print(BF("There are %d atoms") % cnt );
ringFinder.cc:596:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:597:    return this[01;31m-[00m>_vertices;
ringFinder.cc:601:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:602:    return this[01;31m-[00m>_edges;
ringFinder.cc:606:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:607:    return this[01;31m-[00m>_edges.size();
ringFinder.cc:611:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:612:    LOG(BF("this[01;31m-[00m>_edges.size() = %d") % this[01;31m-[00m>_edges.size()  ); // vp0(("this[01;31m-[00m>_edges.size() = %d", this[01;31m-[00m>_edges.size() ));
ringFinder.cc:613:    LOG(BF("this[01;31m-[00m>_vertices.size() = %d") % this[01;31m-[00m>_vertices.size()  ); // vp0(("this[01;31m-[00m>_vertices.size() = %d", this[01;31m-[00m>_vertices.size() ));
ringFinder.cc:614:    int num = this[01;31m-[00m>_edges.size()[01;31m-[00mthis[01;31m-[00m>_vertices.size()+1;
ringFinder.cc:623:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:624:    this[01;31m-[00m>_rings.clear();
ringFinder.cc:625:    this[01;31m-[00m>_finalRings.clear();
ringFinder.cc:626://    this[01;31m-[00m>_numberRings = 0;
ringFinder.cc:628:    for ( x=this[01;31m-[00m>_vertices.begin(); x!=this[01;31m-[00m>_vertices.end(); x++ )
ringFinder.cc:630:	(x[01;31m-[00m>second)[01;31m-[00m>initializeRingSearch();
ringFinder.cc:632:    this[01;31m-[00m>_gaussian.clear();
ringFinder.cc:637:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:640:	for ( vi=this[01;31m-[00m>_vertices.begin(); vi!=this[01;31m-[00m>_vertices.end(); vi++ )
ringFinder.cc:642:	    vi[01;31m-[00m>second[01;31m-[00m>send();
ringFinder.cc:646:	for ( vi=this[01;31m-[00m>_vertices.begin(); vi!=this[01;31m-[00m>_vertices.end(); vi++ )
ringFinder.cc:648:	    vi[01;31m-[00m>second[01;31m-[00m>receive(stage);
ringFinder.cc:656:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:657:    this[01;31m-[00m>initializeRingSearch();
ringFinder.cc:658:    unsigned numberOfRingsExpected = this[01;31m-[00m>getNumberOfRingsExpected();
ringFinder.cc:661:    while ( this[01;31m-[00m>_finalRings.size() < numberOfRingsExpected )
ringFinder.cc:664:        this[01;31m-[00m>advanceRingSearch(stage);
ringFinder.cc:665:	LOG(BF("After ring search, number of final rings= %d") % this[01;31m-[00m>_finalRings.size()  ); // vp0(("After ring search, number of final rings= %d", this[01;31m-[00m>_finalRings.size() ));
ringFinder.cc:672:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:673:    RPBitVector beep = ring[01;31m-[00m>beep();
ringFinder.cc:674:    LOG(BF("Adding ring with beep=%s") % beep[01;31m-[00m>asString().c_str()  ); // vp0(("Adding ring with beep=%s", beep[01;31m-[00m>asString().c_str() ));
ringFinder.cc:675:    uint hash = beep[01;31m-[00m>hash();
ringFinder.cc:676:    RPCons ringList = O_Cons::nil(this[01;31m-[00m>lisp());
ringFinder.cc:677:    if ( this[01;31m-[00m>_rings.count(hash) != 0 )
ringFinder.cc:679:	ringList = this[01;31m-[00m>_rings[hash];
ringFinder.cc:682:	this[01;31m-[00m>_rings[hash] = O_Cons::nil(this[01;31m-[00m>lisp());
ringFinder.cc:686:    for ( ; ringList[01;31m-[00m>notNil(); ringList = ringList[01;31m-[00m>cdr() )
ringFinder.cc:688:	if ( ringList[01;31m-[00m>car<O_PathMessage>()[01;31m-[00m>beep()[01;31m-[00m>equal(beep) ) return;
ringFinder.cc:692:    this[01;31m-[00m>_rings[hash] = O_Cons::create(ring,this[01;31m-[00m>_rings[hash],this[01;31m-[00m>lisp());
ringFinder.cc:693:    if ( this[01;31m-[00m>linearlyIndependentRing(ring) )
ringFinder.cc:695:	this[01;31m-[00m>_finalRings.push_back(ring);
ringFinder.cc:701:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:702:    RPBitVector beep = ring[01;31m-[00m>beep()[01;31m-[00m>copy();
ringFinder.cc:706:    uint glast = this[01;31m-[00m>_gaussian.size();
ringFinder.cc:707:    this[01;31m-[00m>_gaussian.push_back(beep);
ringFinder.cc:711:    if ( this[01;31m-[00m>_gaussian.size() == 1 ) return true;
ringFinder.cc:716:    uint left = this[01;31m-[00m>_gaussian[glast][01;31m-[00m>lowestIndex();
ringFinder.cc:719:	uint gleft = this[01;31m-[00m>_gaussian[z][01;31m-[00m>lowestIndex();
ringFinder.cc:724:	    RPBitVector temp = this[01;31m-[00m>_gaussian[z];
ringFinder.cc:725:	    this[01;31m-[00m>_gaussian[z] = this[01;31m-[00m>_gaussian[glast];
ringFinder.cc:726:	    this[01;31m-[00m>_gaussian[glast] = temp;
ringFinder.cc:730:	    this[01;31m-[00m>_gaussian[glast][01;31m-[00m>inPlaceXor(this[01;31m-[00m>_gaussian[z]);
ringFinder.cc:731:	    left = this[01;31m-[00m>_gaussian[glast][01;31m-[00m>lowestIndex();
ringFinder.cc:736:    if ( this[01;31m-[00m>_gaussian[glast][01;31m-[00m>isZero() )
ringFinder.cc:738:	this[01;31m-[00m>_gaussian.pop_back();
ringFinder.cc:748:{_F(this[01;31m-[00m>lisp());
ringFinder.cc:749:    RPCons lists = O_Cons::nil(this[01;31m-[00m>lisp());
ringFinder.cc:752:    for ( it=this[01;31m-[00m>_finalRings.begin(); it!=this[01;31m-[00m>_finalRings.end(); it++ )
ringFinder.cc:754:	RPCons oneRing = (*it)[01;31m-[00m>getAtoms();
ringFinder.cc:755:	lists = O_Cons::create(oneRing,lists,this[01;31m-[00m>lisp());
ringFinder.cc:756:	LOG(BF("Ring #%d = size(%d) %s") % ridx % oneRing[01;31m-[00m>length() % oneRing[01;31m-[00m>__repr__().c_str()  ); // vp0(("Ring #%d = size(%d) %s", ridx, oneRing[01;31m-[00m>length(), oneRing[01;31m-[00m>__repr__().c_str() ));
ringFinder.cc:774:	if ( atom[01;31m-[00m>totalBondOrder() > atom[01;31m-[00m>maxTotalBondOrder() )
ringFinder.cc:777:	    ss << "There is a problem with atom " << atom[01;31m-[00m>description() << " the sum of bond orders is: " << atom[01;31m-[00m>totalBondOrder() << " and it should never be more than " << atom[01;31m-[00m>maxTotalBondOrder();
ringFinder.cc:778:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str() ));
ringFinder.cc:780:	atom[01;31m-[00m>clearAllRingMembershipFlags();
ringFinder.cc:781:	atom[01;31m-[00m>setRingMembershipCount(0);
ringFinder.cc:783:    RPRingFinder atomGraph = O_RingFinder::create(molecule[01;31m-[00m>lisp(),molecule);
ringFinder.cc:784:    atomGraph[01;31m-[00m>findRings();
ringFinder.cc:785:    RPCons rings = atomGraph[01;31m-[00m>getAllRingsAsListsOfAtoms();
ringFinder.cc:786:    for ( RPCons curRing=rings; curRing[01;31m-[00m>notNil(); curRing = curRing[01;31m-[00m>cdr() )
ringFinder.cc:788:        RPCons atoms = curRing[01;31m-[00m>car<O_Cons>();
ringFinder.cc:789:        uint ringSize = atoms[01;31m-[00m>length();
ringFinder.cc:790:	for ( RPCons atomCons = atoms; atomCons[01;31m-[00m>notNil(); atomCons = atomCons[01;31m-[00m>cdr() )
ringFinder.cc:792:	    RPAtom atom = atomCons[01;31m-[00m>car<O_Atom>();
ringFinder.cc:793:	    atom[01;31m-[00m>setInRingOfSize(ringSize);
ringFinder.cc:794:	    atom[01;31m-[00m>incrementRingMembershipCount();
ringFinder.cc:814:    if ( matter[01;31m-[00m>isOfClass<O_Molecule>() )
ringFinder.cc:820:    if ( matter[01;31m-[00m>isOfClass<O_Aggregate>() )
ringFinder.cc:831:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("You can only find rings in aggregates or molecules"));
ringFinder.cc:844:    class_<O_PathMessage>(this[01;31m-[00m>lisp())
ringFinder.cc:858:    class_<O_AGVertex>(this[01;31m-[00m>lisp())
ringFinder.cc:872:    class_<O_AGEdge>(this[01;31m-[00m>lisp())
ringFinder.cc:887:    class_<O_RingFinder>(this[01;31m-[00m>lisp())
ringFinder.cc:891:    defInPackage(MbbPackage,"identifyRings",&O_RingFinder::identifyRings,this[01;31m-[00m>lisp());
scaffold.cc:34:{_F(this[01;31m-[00m>lisp());
scaffold.cc:35:    node[01;31m-[00m>archiveWeakPointer("sl",this[01;31m-[00m>_WeakEncompasingScaffoldList);
scaffold.cc:36:    node[01;31m-[00m>archivePlainObject("external","Transforms",this[01;31m-[00m>_ExternalTransforms);
scaffold.cc:37:    node[01;31m-[00m>archivePlainObject("internal","Transforms",this[01;31m-[00m>_InternalTransforms);
scaffold.cc:39:    if ( !node[01;31m-[00m>loading() )
scaffold.cc:42:	s = this[01;31m-[00m>_DebugMessages.str();
scaffold.cc:43:	node[01;31m-[00m>archiveString("DebugMessage",s);
scaffold.cc:47:	node[01;31m-[00m>archiveString("DebugMessage",s);
scaffold.cc:48:	this[01;31m-[00m>_DebugMessages.str(s);
scaffold.cc:56:{_F(this[01;31m-[00m>lisp());
scaffold.cc:57:    return this[01;31m-[00m>_IncompleteFrameTransforms.contains(name);
scaffold.cc:62:{_F(this[01;31m-[00m>lisp());
scaffold.cc:63:    Matrix &res = this[01;31m-[00m>_ExternalTransforms.get(offset);
scaffold.cc:68:{_F(this[01;31m-[00m>lisp());
scaffold.cc:69:    Matrix &res = this[01;31m-[00m>_InternalTransforms.get(offset);
scaffold.cc:74:{_F(this[01;31m-[00m>lisp());
scaffold.cc:75:    Matrix res = this[01;31m-[00m>_ExternalTransforms.get(offset);
scaffold.cc:80:{_F(this[01;31m-[00m>lisp());
scaffold.cc:81:    Matrix res = this[01;31m-[00m>_InternalTransforms.get(offset);
scaffold.cc:91:{_F(this[01;31m-[00m>lisp());
scaffold.cc:101:    this[01;31m-[00m>_DebugMessages.str("");
scaffold.cc:102:    this[01;31m-[00m>_DebugMessages << "O_Scaffold::defineFromExtractScaffoldAndStructure for index: "<<scaffoldIndex<<endl;
scaffold.cc:104:    scaffoldList = this[01;31m-[00m>getEncompasingScaffoldList();
scaffold.cc:105:    anchor = extractScaffold[01;31m-[00m>getAnchor();
scaffold.cc:108:	anchorCoordSys = anchor[01;31m-[00m>getCoordinateSystem(focusMonomer);
scaffold.cc:111:	if ( !exep.conditionObject()[01;31m-[00m>isAssignableTo<O_MathException>() )
scaffold.cc:119:	anchorCoordSys = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
scaffold.cc:122:    this[01;31m-[00m>_DebugMessages << "Anchor coordinate system:"<<endl;
scaffold.cc:123:    this[01;31m-[00m>_DebugMessages << anchorCoordSys[01;31m-[00m>asString() << endl;
scaffold.cc:124:    this[01;31m-[00m>_DebugMessages << "Anchor was calculated from: "<<endl;
scaffold.cc:125:    this[01;31m-[00m>_DebugMessages << anchor[01;31m-[00m>debugAsString(focusMonomer) << endl;
scaffold.cc:127:    LOG(BF("Extracting scaffold with respect to CoordinateSystem: %s") % (anchorCoordSys[01;31m-[00m>asString().c_str() ) ); // vp0(("Extracting scaffold with respect to CoordinateSystem: %s",anchorCoordSys[01;31m-[00m>asString().c_str() ));
scaffold.cc:129:        ASSERT(extractScaffold[01;31m-[00m>numberOfExtractFrameFinishers()
scaffold.cc:130:			==scaffoldList[01;31m-[00m>numberOfFinishFrameTransforms());
scaffold.cc:131:	LOG(BF("Allocating %d ExternalTransforms") % scaffoldList[01;31m-[00m>numberOfFinishFrameTransforms()  ); // vp0(("Allocating %d ExternalTransforms",scaffoldList[01;31m-[00m>numberOfFinishFrameTransforms() ));
scaffold.cc:132:        this[01;31m-[00m>_ExternalTransforms.setSize(scaffoldList[01;31m-[00m>numberOfFinishFrameTransforms());
scaffold.cc:134:	for ( effi = extractScaffold[01;31m-[00m>begin_ExtractFrameFinishers();
scaffold.cc:135:		    effi != extractScaffold[01;31m-[00m>end_ExtractFrameFinishers(); effi++ )
scaffold.cc:136:	{_BLOCK_TRACEF(BF("Extracting frame with name(%s)") % (*effi)[01;31m-[00m>getAlias().c_str() );
scaffold.cc:137:	    finishFrameTransform  = scaffoldList[01;31m-[00m>getFinishFrameWithName((*effi)[01;31m-[00m>getAlias());
scaffold.cc:138:	    index = finishFrameTransform[01;31m-[00m>getOffsetOfTransform();
scaffold.cc:141:	        transform = finishFrameTransform[01;31m-[00m>calculateTransformFromExtractFrame(
scaffold.cc:145:		if ( !err.conditionObject()[01;31m-[00m>isAssignableTo<O_MathException>() )
scaffold.cc:156:	    this[01;31m-[00m>_ExternalTransforms.set(index,transform);
scaffold.cc:160:	ASSERT(extractScaffold[01;31m-[00m>numberOfExtractCompleteFrames()==scaffoldList[01;31m-[00m>numberOfCompleteFrameTransforms());
scaffold.cc:161:	LOG(BF("Allocating %d InternalTransforms") % scaffoldList[01;31m-[00m>numberOfCompleteFrameTransforms()  ); // vp0(("Allocating %d InternalTransforms",scaffoldList[01;31m-[00m>numberOfCompleteFrameTransforms() ));
scaffold.cc:162:	this[01;31m-[00m>_InternalTransforms.setSize(scaffoldList[01;31m-[00m>numberOfCompleteFrameTransforms());
scaffold.cc:164:	for ( eci = extractScaffold[01;31m-[00m>begin_ExtractCompleteFrames();
scaffold.cc:165:		    eci != extractScaffold[01;31m-[00m>end_ExtractCompleteFrames(); eci++ )
scaffold.cc:166:	{_BLOCK_TRACEF(BF("Extracting frame with name(%s)") % (*eci)[01;31m-[00m>getAlias().c_str() );
scaffold.cc:167:	    completeFrameTransform = scaffoldList[01;31m-[00m>getCompleteFrameWithName((*eci)[01;31m-[00m>getAlias());
scaffold.cc:169:	    index = completeFrameTransform[01;31m-[00m>getOffsetOfTransform();
scaffold.cc:173:	        transform = completeFrameTransform[01;31m-[00m>calculateTransformFromExtractFrame(
scaffold.cc:177:		if ( !err.conditionObject()[01;31m-[00m>isAssignableTo<O_MathException>() )
scaffold.cc:188:	    this[01;31m-[00m>_InternalTransforms.set(index,transform);
scaffold.cc:196:{_F(this[01;31m-[00m>lisp());
scaffold.cc:197:    if ( !node[01;31m-[00m>loading() )
scaffold.cc:199:        ASSERT_NOT_NULL(this[01;31m-[00m>_Anchor);
scaffold.cc:201:    node[01;31m-[00m>archiveObject("anchor",this[01;31m-[00m>_Anchor);
scaffold.cc:202:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_Scaffolds);
scaffold.cc:203:    node[01;31m-[00m>archiveMapOfObjectsSubClassOf(this[01;31m-[00m>_FinishFrameTransforms);
scaffold.cc:204:    node[01;31m-[00m>archiveMapOfObjectsSubClassOf(this[01;31m-[00m>_CompleteFrameTransforms);
scaffold.cc:205:    node[01;31m-[00m>archiveMapOfObjectsSubClassOf(this[01;31m-[00m>_IncompleteFrameTransforms);
scaffold.cc:217:{_F(this[01;31m-[00m>lisp());
scaffold.cc:226:    anchor = extractScaffold[01;31m-[00m>getAnchor();
scaffold.cc:227:    this[01;31m-[00m>setAnchor(anchor);
scaffold.cc:228:    agg = downcast<O_Aggregate>(structureList[01;31m-[00m>getMatter());
scaffold.cc:235:	for ( effi = extractScaffold[01;31m-[00m>begin_ExtractFrameFinishers(), i=0;
scaffold.cc:236:		    effi != extractScaffold[01;31m-[00m>end_ExtractFrameFinishers(); effi++, i++ )
scaffold.cc:238:	    finishFrameTransform = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_FinishFrameOnOtherSideOfPlugTransform>();
scaffold.cc:239:	    finishFrameTransform[01;31m-[00m>setOffsetOfTransform(i);
scaffold.cc:240:	    finishFrameTransform[01;31m-[00m>defineFromExtractFrameFinisher(
scaffold.cc:242:	    LOG(BF("Set FinishFrameTransform(%s) index to %d") % (*effi)[01;31m-[00m>getAlias().c_str() % i ); // vp0(("Set FinishFrameTransform(%s) index to %d",(*effi)[01;31m-[00m>getAlias().c_str(),i));
scaffold.cc:243:	    this[01;31m-[00m>_FinishFrameTransforms.set((*effi)[01;31m-[00m>getAlias(),
scaffold.cc:249:	for ( eci = extractScaffold[01;31m-[00m>begin_ExtractCompleteFrames(),i=0;
scaffold.cc:250:	    eci != extractScaffold[01;31m-[00m>end_ExtractCompleteFrames(); eci++, i++ )
scaffold.cc:252:	    completeFrameTransform = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CompleteFrameTransform>();
scaffold.cc:253:	    completeFrameTransform[01;31m-[00m>setOffsetOfTransform(i);
scaffold.cc:254:	    completeFrameTransform[01;31m-[00m>defineFromExtractCompleteFrame(
scaffold.cc:256:	    LOG(BF("Set CompleteFrameTransform(%s) index to %d") % (*eci)[01;31m-[00m>getAlias().c_str() % i ); // vp0(("Set CompleteFrameTransform(%s) index to %d",(*eci)[01;31m-[00m>getAlias().c_str(),i));
scaffold.cc:257:	    this[01;31m-[00m>_CompleteFrameTransforms.set((*eci)[01;31m-[00m>getAlias(),
scaffold.cc:263:	for ( eii = extractScaffold[01;31m-[00m>begin_ExtractIncompleteFrames(), i=0;
scaffold.cc:264:	    eii != extractScaffold[01;31m-[00m>end_ExtractIncompleteFrames(); eii++, i++ )
scaffold.cc:266:	    incompleteFrameTransform = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_IncompleteFrameTransform>();
scaffold.cc:267:	    incompleteFrameTransform[01;31m-[00m>setOffsetOfTransform(i);
scaffold.cc:268:	    incompleteFrameTransform[01;31m-[00m>defineFromExtractIncompleteFrame(
scaffold.cc:270:	    LOG(BF("Set IncompleteFrameTransform(%s) index to %d") % (*eii)[01;31m-[00m>getAlias().c_str() % i ); // vp0(("Set IncompleteFrameTransform(%s) index to %d",(*eii)[01;31m-[00m>getAlias().c_str(),i));
scaffold.cc:271:	    this[01;31m-[00m>_IncompleteFrameTransforms.set((*eii)[01;31m-[00m>getAlias(),
scaffold.cc:279:	for ( sli=structureList[01;31m-[00m>begin_Entries();
scaffold.cc:280:		    sli!=structureList[01;31m-[00m>end_Entries(); sli++ )
scaffold.cc:282:	    (*sli)[01;31m-[00m>writeCoordinatesToMatter(agg);
scaffold.cc:283:	    scaffold = O_Scaffold::create(this[01;31m-[00m>sharedThis<O_ScaffoldList>(),this[01;31m-[00m>lisp());
scaffold.cc:284:	    scaffold[01;31m-[00m>defineFromExtractScaffoldAndStructure(
scaffold.cc:285:	    			    this[01;31m-[00m>_Scaffolds.size(),
scaffold.cc:287:	    this[01;31m-[00m>_Scaffolds.push_back(scaffold);
scaffold.cc:288:	    maximumNumberOfConformations[01;31m-[00m[01;31m-[00m;
scaffold.cc:296:{_F(this[01;31m-[00m>lisp());
scaffold.cc:297:    return this[01;31m-[00m>_Anchor;
scaffold.cc:301:{_F(this[01;31m-[00m>lisp());
scaffold.cc:302:    return this[01;31m-[00m>_Anchor[01;31m-[00m>isOfClass<O_AnchorOrigin>();
scaffold.cc:306:{_F(this[01;31m-[00m>lisp());
scaffold.cc:307:    ASSERT_NOT_NULL(this[01;31m-[00m>_Anchor);
scaffold.cc:308:    return this[01;31m-[00m>_Anchor[01;31m-[00m>dependsOnIncompleteFrame(neighborScaffold,myMonomer);
scaffold.cc:319:	class_<O_Scaffold>(this[01;31m-[00m>lisp())
scaffold.cc:342:	class_<O_ScaffoldList>(this[01;31m-[00m>lisp())
scaffoldHolder.cc:23:    this[01;31m-[00m>_WeakLisp = lisp;
scaffoldHolder.cc:24:    this[01;31m-[00m>_FrameHolderIndex = UndefinedUnsignedInt;
scaffoldHolder.cc:25:    this[01;31m-[00m>_SaveBuildSerialNumber = UndefinedUnsignedInt;
scaffoldHolder.cc:26:    this[01;31m-[00m>_OffsetOfTransformInScaffold = UndefinedUnsignedInt;
scaffoldHolder.cc:27:    this[01;31m-[00m>_Recognizer.reset();
scaffoldHolder.cc:28:    this[01;31m-[00m>_RecognizerOriginAtom.reset();
scaffoldHolder.cc:35:    this[01;31m-[00m>_WeakLisp = f._WeakLisp;
scaffoldHolder.cc:36:    LOG(BF("Copy[01;31m-[00mctor into new FrameHolder@%p [01;31m-[00m copied from FrameHolder@%p#%d ") % (void*)(this) % (void*)(&f) % f._FrameHolderIndex );
scaffoldHolder.cc:37:    this[01;31m-[00m>_FrameHolderIndex = f._FrameHolderIndex;
scaffoldHolder.cc:38:    this[01;31m-[00m>_SaveBuildSerialNumber = f._SaveBuildSerialNumber;
scaffoldHolder.cc:39:    this[01;31m-[00m>_OffsetOfTransformInScaffold = f._OffsetOfTransformInScaffold;
scaffoldHolder.cc:40:    this[01;31m-[00m>_UpdatedId = f._UpdatedId;
scaffoldHolder.cc:41:    this[01;31m-[00m>_MatrixForFrameTransform = f._MatrixForFrameTransform;
scaffoldHolder.cc:42:    this[01;31m-[00m>_Incomplete = f._Incomplete;
scaffoldHolder.cc:43:    this[01;31m-[00m>_Recognizer = f._Recognizer;
scaffoldHolder.cc:44:    this[01;31m-[00m>_RecognizerOriginAtom = f._RecognizerOriginAtom;
scaffoldHolder.cc:45:    this[01;31m-[00m>_CanBuildFrameFromAtomIndices = f._CanBuildFrameFromAtomIndices;
scaffoldHolder.cc:46:    this[01;31m-[00m>_AtomO = f._AtomO;
scaffoldHolder.cc:47:    this[01;31m-[00m>_AtomP = f._AtomP;
scaffoldHolder.cc:48:    this[01;31m-[00m>_AtomQ = f._AtomQ;
scaffoldHolder.cc:49:    LOG(BF("atomO(%s) atomP(%s) atomQ(%s)") % this[01;31m-[00m>_AtomO.lock()[01;31m-[00m>__repr__() % this[01;31m-[00m>_AtomP.lock()[01;31m-[00m>__repr__() % this[01;31m-[00m>_AtomQ.lock()[01;31m-[00m>__repr__() );
scaffoldHolder.cc:54:    ss << boost::format("_OffsetOfTransformInScaffold = %d") % this[01;31m-[00m>_OffsetOfTransformInScaffold << endl ;
scaffoldHolder.cc:55:    ss << boost::format("_Transfor = \n%s") % this[01;31m-[00m>frameTransform().asString() << endl;
scaffoldHolder.cc:62:    this[01;31m-[00m>_SaveBuildSerialNumber = ob[01;31m-[00m>_BuildSerialNumber;
scaffoldHolder.cc:63:    ob[01;31m-[00m>_NumberOfFramesBuilt++;
scaffoldHolder.cc:64:    this[01;31m-[00m>_MatrixForFrameTransform = m;
scaffoldHolder.cc:70:    this[01;31m-[00m>_SaveBuildSerialNumber = UndefinedUnsignedInt;
scaffoldHolder.cc:71:    this[01;31m-[00m>_MatrixForFrameTransform.identity();
scaffoldHolder.cc:72:    this[01;31m-[00m>_Incomplete = false;
scaffoldHolder.cc:73:    this[01;31m-[00m>_AtomO = O_Atom::nil(ob[01;31m-[00m>lisp());
scaffoldHolder.cc:74:    this[01;31m-[00m>_AtomP = O_Atom::nil(ob[01;31m-[00m>lisp());
scaffoldHolder.cc:75:    this[01;31m-[00m>_AtomQ = O_Atom::nil(ob[01;31m-[00m>lisp());
scaffoldHolder.cc:80:    this[01;31m-[00m>setFrameHolderIndex(frameHolderIndex);
scaffoldHolder.cc:82:    this[01;31m-[00m>_SaveBuildSerialNumber = UndefinedUnsignedInt;
scaffoldHolder.cc:83:    this[01;31m-[00m>_MatrixForFrameTransform.identity();
scaffoldHolder.cc:84:    this[01;31m-[00m>_Incomplete = false;
scaffoldHolder.cc:85:    this[01;31m-[00m>_AtomO = O_Atom::nil(ob[01;31m-[00m>lisp());
scaffoldHolder.cc:86:    this[01;31m-[00m>_AtomP = O_Atom::nil(ob[01;31m-[00m>lisp());
scaffoldHolder.cc:87:    this[01;31m-[00m>_AtomQ = O_Atom::nil(ob[01;31m-[00m>lisp());
scaffoldHolder.cc:92:    this[01;31m-[00m>setFrameHolderIndex(frameHolderIndex);
scaffoldHolder.cc:94:    LOG(BF("FrameHolder::initializeIncompleteFrame for FrameHolder@%p#%d")%(void*)(this)%this[01;31m-[00m>getFrameHolderIndex());
scaffoldHolder.cc:95:    this[01;31m-[00m>_SaveBuildSerialNumber = UndefinedUnsignedInt;
scaffoldHolder.cc:96:    this[01;31m-[00m>_MatrixForFrameTransform.identity();
scaffoldHolder.cc:97:    this[01;31m-[00m>_Incomplete = true;
scaffoldHolder.cc:98:    RPConstitution con = monomer[01;31m-[00m>getConstitution();
scaffoldHolder.cc:99:    if ( !con[01;31m-[00m>hasFrameWithName(frameName) )
scaffoldHolder.cc:102:	ss << "Huh? The constitution(" << con[01;31m-[00m>getName() << ") is supposed to have the frame named("<<frameName<<")";
scaffoldHolder.cc:104:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
scaffoldHolder.cc:106:    RPFrame frame = con[01;31m-[00m>getFrameWithName(frameName);
scaffoldHolder.cc:107:    if ( !frame[01;31m-[00m>isAssignableTo<O_RecognizedFrame>() )
scaffoldHolder.cc:112:	ss << " but its not, it has the class: " << frame[01;31m-[00m>className();
scaffoldHolder.cc:113:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
scaffoldHolder.cc:115:    RPRecognizedFrame recFrame = frame[01;31m-[00m>as<O_RecognizedFrame>();
scaffoldHolder.cc:116:    string originName = recFrame[01;31m-[00m>getOriginAtomName();
scaffoldHolder.cc:117:    RPFrameRecognizer recognizer = recFrame[01;31m-[00m>getFrameRecognizer();
scaffoldHolder.cc:118:    RPResidue res = monomer[01;31m-[00m>getTemporaryResidue();
scaffoldHolder.cc:119:    RPAtom atom = res[01;31m-[00m>atomWithName(originName);
scaffoldHolder.cc:120:    this[01;31m-[00m>_CanBuildFrameFromAtomIndices = false;
scaffoldHolder.cc:123:    this[01;31m-[00m>_Recognizer = recognizer;
scaffoldHolder.cc:124:    this[01;31m-[00m>_RecognizerOriginAtom = atom;
scaffoldHolder.cc:125:    if ( !recognizer[01;31m-[00m>recognizes(atom) )
scaffoldHolder.cc:127:	LOG(BF("WHOAH!!!! FrameRecognizer(%s)/Smarts(%s) did not recognize atom context: %s") % recognizer[01;31m-[00m>__repr__() % recognizer[01;31m-[00m>getSmarts() % atom[01;31m-[00m>localSpanningTree(recognizer[01;31m-[00m>depth())[01;31m-[00m>__repr__() );
scaffoldHolder.cc:130:    this[01;31m-[00m>_CanBuildFrameFromAtomIndices = true;
scaffoldHolder.cc:131:    RPChemInfoMatch match = recognizer[01;31m-[00m>getMatch();
scaffoldHolder.cc:132:    RPAtom atomO = match[01;31m-[00m>tag("1");
scaffoldHolder.cc:133:    RPAtom atomP = match[01;31m-[00m>tag("2");
scaffoldHolder.cc:134:    RPAtom atomQ = match[01;31m-[00m>tag("3");
scaffoldHolder.cc:135:    if ( atomO[01;31m-[00m>isNil() || atomP[01;31m-[00m>isNil() || atomQ[01;31m-[00m>isNil() )
scaffoldHolder.cc:137:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("One of the FrameHolder O,P,Q atoms is nil.  Verify that the FrameRecognizer describes the three atom tags '1,2,3'"));
scaffoldHolder.cc:141:    this[01;31m-[00m>_AtomO = atomO;
scaffoldHolder.cc:142:    this[01;31m-[00m>_AtomP = atomP;
scaffoldHolder.cc:143:    this[01;31m-[00m>_AtomQ = atomQ;
scaffoldHolder.cc:145:    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mincomplete frame atoms") ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mincomplete frame atoms" ));
scaffoldHolder.cc:146:    LOG(BF("atomO = %s") % (atomO[01;31m-[00m>description().c_str() ) ); // vp0(( "atomO = %s", atomO[01;31m-[00m>description().c_str() ));
scaffoldHolder.cc:147:    LOG(BF("atomP = %s") % (atomP[01;31m-[00m>description().c_str() ) ); // vp0(( "atomP = %s", atomP[01;31m-[00m>description().c_str() ));
scaffoldHolder.cc:148:    LOG(BF("atomQ = %s") % (atomQ[01;31m-[00m>description().c_str() ) ); // vp0(( "atomQ = %s", atomQ[01;31m-[00m>description().c_str() ));
scaffoldHolder.cc:155:    this[01;31m-[00m>_SaveBuildSerialNumber = ob[01;31m-[00m>_BuildSerialNumber;
scaffoldHolder.cc:156:    ob[01;31m-[00m>_NumberOfFramesInitialized++;
scaffoldHolder.cc:157:    this[01;31m-[00m>_MatrixForFrameTransform.identity();
scaffoldHolder.cc:163:    if ( !this[01;31m-[00m>_CanBuildFrameFromAtomIndices )
scaffoldHolder.cc:165:	LOG(BF("There is a problem [01;31m-[00m you are trying to build an incomplete Frame that "));
scaffoldHolder.cc:179:	ASSERT_NOT_NULL(this[01;31m-[00m>_RecognizerOriginAtom);
scaffoldHolder.cc:180:	ASSERTP(this[01;31m-[00m>_RecognizerOriginAtom[01;31m-[00m>notNil(), "The _RecognizerOriginAtom is nil and it shouldn't be");
scaffoldHolder.cc:181:	uint idxO = this[01;31m-[00m>_RecognizerOriginAtom[01;31m-[00m>getAtomHolderIndex(); 
scaffoldHolder.cc:182:	vO = ob[01;31m-[00m>_AllAtomHolders[idxO]._Pos;
scaffoldHolder.cc:187:	RPAtom atomO = this[01;31m-[00m>_AtomO.lock();
scaffoldHolder.cc:188:	RPAtom atomP = this[01;31m-[00m>_AtomP.lock();
scaffoldHolder.cc:189:	RPAtom atomQ = this[01;31m-[00m>_AtomQ.lock();
scaffoldHolder.cc:191:	if ( atomO[01;31m-[00m>isNil() || atomP[01;31m-[00m>isNil() || atomQ[01;31m-[00m>isNil() )
scaffoldHolder.cc:193:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("When FrameHolder[01;31m-[00m>_CanBuildFrameFromAtomIndices was true [01;31m-[00m one or more of the atoms for FrameHolder@%p#%d is nil atomO=%s atomP=%s atomQ=%s") 
scaffoldHolder.cc:195:		% this[01;31m-[00m>getFrameHolderIndex() 
scaffoldHolder.cc:196:		% atomO[01;31m-[00m>__repr__() 
scaffoldHolder.cc:197:		% atomP[01;31m-[00m>__repr__() 
scaffoldHolder.cc:198:		% atomQ[01;31m-[00m>__repr__() ) );
scaffoldHolder.cc:201:	ASSERT(atomO[01;31m-[00m>notNil());
scaffoldHolder.cc:202:	ASSERT(atomP[01;31m-[00m>notNil());
scaffoldHolder.cc:203:	ASSERT(atomQ[01;31m-[00m>notNil());
scaffoldHolder.cc:204:	LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mincomplete frame atoms") ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mincomplete frame atoms" ));
scaffoldHolder.cc:205:	LOG(BF("atomO = %s") % (atomO[01;31m-[00m>description().c_str() ) ); // vp0(( "atomO = %s", atomO[01;31m-[00m>description().c_str() ));
scaffoldHolder.cc:206:	LOG(BF("atomP = %s") % (atomP[01;31m-[00m>description().c_str() ) ); // vp0(( "atomP = %s", atomP[01;31m-[00m>description().c_str() ));
scaffoldHolder.cc:207:	LOG(BF("atomQ = %s") % (atomQ[01;31m-[00m>description().c_str() ) ); // vp0(( "atomQ = %s", atomQ[01;31m-[00m>description().c_str() ));
scaffoldHolder.cc:208:	ASSERT(atomO[01;31m-[00m>getWeakOligomerBuilder().use_count()>0);
scaffoldHolder.cc:209:	ASSERT(atomP[01;31m-[00m>getWeakOligomerBuilder().use_count()>0);
scaffoldHolder.cc:210:	ASSERT(atomQ[01;31m-[00m>getWeakOligomerBuilder().use_count()>0);
scaffoldHolder.cc:212:	if ( atomO[01;31m-[00m>getWeakOligomerBuilder().lock() != ob )
scaffoldHolder.cc:214:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("There is a problem with atomO(%s) [01;31m-[00m the OligomerBuilder(%s) referenced by it is not the same as the OligomerBuilder(%s) passed to FrameHolder::buildUsingAtoms") % atomO[01;31m-[00m>__repr__() % atomO[01;31m-[00m>getWeakOligomerBuilder().lock()[01;31m-[00m>__repr__() % ob[01;31m-[00m>__repr__() ));
scaffoldHolder.cc:216:	if ( atomP[01;31m-[00m>getWeakOligomerBuilder().lock() != ob )
scaffoldHolder.cc:218:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("There is a problem with atomP(%s) [01;31m-[00m the OligomerBuilder(%s) referenced by it is not the same as the OligomerBuilder(%s) passed to FrameHolder::buildUsingAtoms") % atomP[01;31m-[00m>__repr__() % atomP[01;31m-[00m>getWeakOligomerBuilder().lock()[01;31m-[00m>__repr__() % ob[01;31m-[00m>__repr__() ));
scaffoldHolder.cc:220:	if ( atomQ[01;31m-[00m>getWeakOligomerBuilder().lock() != ob )
scaffoldHolder.cc:222:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("There is a problem with atomQ(%s) [01;31m-[00m the OligomerBuilder(%s) referenced by it is not the same as the OligomerBuilder(%s) passed to FrameHolder::buildUsingAtoms") % atomQ[01;31m-[00m>__repr__() % atomQ[01;31m-[00m>getWeakOligomerBuilder().lock()[01;31m-[00m>__repr__() % ob[01;31m-[00m>__repr__() ));
scaffoldHolder.cc:225:	ASSERT_eq(atomO[01;31m-[00m>getWeakOligomerBuilder().lock(),ob); 
scaffoldHolder.cc:226:	ASSERT_eq(atomP[01;31m-[00m>getWeakOligomerBuilder().lock(),ob); 
scaffoldHolder.cc:227:	ASSERT_eq(atomQ[01;31m-[00m>getWeakOligomerBuilder().lock(),ob); 
scaffoldHolder.cc:228:	uint idxO = atomO[01;31m-[00m>getAtomHolderIndex(); 
scaffoldHolder.cc:229:	uint idxP = atomP[01;31m-[00m>getAtomHolderIndex(); 
scaffoldHolder.cc:230:	uint idxQ = atomQ[01;31m-[00m>getAtomHolderIndex(); 
scaffoldHolder.cc:231:	ASSERT_lt(idxO,ob[01;31m-[00m>_AllAtomHolders.size());
scaffoldHolder.cc:232:	ASSERT_lt(idxP,ob[01;31m-[00m>_AllAtomHolders.size());
scaffoldHolder.cc:233:	ASSERT_lt(idxQ,ob[01;31m-[00m>_AllAtomHolders.size());
scaffoldHolder.cc:234:	vO = ob[01;31m-[00m>_AllAtomHolders[idxO]._Pos;
scaffoldHolder.cc:235:	vP = ob[01;31m-[00m>_AllAtomHolders[idxP]._Pos;
scaffoldHolder.cc:236:	vQ = ob[01;31m-[00m>_AllAtomHolders[idxQ]._Pos;
scaffoldHolder.cc:242:	    // becuase the P[01;31m-[00mO, Q[01;31m-[00mO bonds may be nearly parallel
scaffoldHolder.cc:245:    RPCoordinateSystem cs = O_CoordinateSystem::create(ob[01;31m-[00m>lisp());
scaffoldHolder.cc:246:    cs[01;31m-[00m>defineForAtomVectors( vO, vP, vQ );
scaffoldHolder.cc:247:    this[01;31m-[00m>_MatrixForFrameTransform = cs[01;31m-[00m>matrixFromCanonical();
scaffoldHolder.cc:248:    this[01;31m-[00m>_SaveBuildSerialNumber = ob[01;31m-[00m>_BuildSerialNumber;
scaffoldHolder.cc:254:    return this[01;31m-[00m>_SaveBuildSerialNumber == ob[01;31m-[00m>_BuildSerialNumber;
scaffoldHolder.cc:260:    return this[01;31m-[00m>_MatrixForFrameTransform;
scaffoldHolder.cc:271:    this[01;31m-[00m>_WeakLisp = lisp;
scaffoldHolder.cc:272:    this[01;31m-[00m>_FragmentHolderIndex = UndefinedUnsignedInt;
scaffoldHolder.cc:273:    this[01;31m-[00m>_InterestingAtomIndicesBeginIndex = UndefinedUnsignedInt;
scaffoldHolder.cc:274:    this[01;31m-[00m>_InterestingAtomIndicesEndIndex = UndefinedUnsignedInt;
scaffoldHolder.cc:289:    mc = this[01;31m-[00m>_MonomerCoordinates;
scaffoldHolder.cc:290:    sl = mc[01;31m-[00m>getScaffoldList();
scaffoldHolder.cc:291:    return sl[01;31m-[00m>hasAnchorOrigin();
scaffoldHolder.cc:300:    this[01;31m-[00m>_Monomer = monomer;
scaffoldHolder.cc:301:    ASSERT_NOT_NULL(this[01;31m-[00m>_Monomer);
scaffoldHolder.cc:302:    this[01;31m-[00m>_MonomerCoordinates = cdb[01;31m-[00m>get(context);
scaffoldHolder.cc:303:    ASSERT_NOT_NULL(this[01;31m-[00m>_MonomerCoordinates);
scaffoldHolder.cc:304:    this[01;31m-[00m>_TouchedSpan = false;
scaffoldHolder.cc:305:    this[01;31m-[00m>_NextSpanIdx = UndefinedUnsignedInt;
scaffoldHolder.cc:306:    this[01;31m-[00m>_BackSpanIdx = UndefinedUnsignedInt;
scaffoldHolder.cc:307:    this[01;31m-[00m>clearTransformOrFrameNameMap();
scaffoldHolder.cc:308://    this[01;31m-[00m>_removeScaffoldListIndex = 0;
scaffoldHolder.cc:309:    this[01;31m-[00m>_FragmentHolderIndex = UndefinedUnsignedInt;	// This will be initialized by FragmentHolder
scaffoldHolder.cc:310:    this[01;31m-[00m>_NumberOfExternalFrameHolders = 0;
scaffoldHolder.cc:312:	 this[01;31m-[00m>_IndicesOfExternalFrameHolders[i] = UndefinedUnsignedInt;
scaffoldHolder.cc:313:    this[01;31m-[00m>_NumberOfInternalFrameHolders = 0;
scaffoldHolder.cc:315:	 this[01;31m-[00m>_IndicesOfInternalFrameHolders[i] = UndefinedUnsignedInt;
scaffoldHolder.cc:321:    RPRenderDisplayList dlScaffold = O_RenderDisplayList::create(ob[01;31m-[00m>lisp());
scaffoldHolder.cc:322:    RPRenderDisplayList dlCore = FragmentHolder::render(ob,this[01;31m-[00m>_FragmentHolderIndex);
scaffoldHolder.cc:323:    dlCore[01;31m-[00m>setName(ob[01;31m-[00m>_AllFragmentHolders[this[01;31m-[00m>_FragmentHolderIndex]._FragmentCoordinates[01;31m-[00m>getFragmentName());
scaffoldHolder.cc:324:    dlScaffold[01;31m-[00m>add(dlCore);
scaffoldHolder.cc:325:    for (uint i=this[01;31m-[00m>_BeginFragmentHolderIndex; i<this[01;31m-[00m>_EndFragmentHolderIndex; i++ )
scaffoldHolder.cc:328:        dlOther[01;31m-[00m>setName(ob[01;31m-[00m>_AllFragmentHolders[i]._FragmentCoordinates[01;31m-[00m>getFragmentName());
scaffoldHolder.cc:329:	dlScaffold[01;31m-[00m>add(dlOther);
scaffoldHolder.cc:338:    ss << format("this[01;31m-[00m>_Monomer(%s)\n") % this[01;31m-[00m>_Monomer[01;31m-[00m>description().c_str();
scaffoldHolder.cc:339:#define VAR(name) #name << "(" << this[01;31m-[00m>name << ")" << endl;
scaffoldHolder.cc:343:    ss << "this[01;31m-[00m>_FrameNameToIndex = ";
scaffoldHolder.cc:345:    for (it=this[01;31m-[00m>_TransformOrFrameNameToIndex.begin(); 
scaffoldHolder.cc:346:    		it!=this[01;31m-[00m>_TransformOrFrameNameToIndex.end(); it++ )
scaffoldHolder.cc:348:        ss << format("  [%s]=%d") % it[01;31m-[00m>first.c_str() % it[01;31m-[00m>second;
scaffoldHolder.cc:355:    ss << "this[01;31m-[00m>_IndicesOfExternalFrameHolders: ";
scaffoldHolder.cc:356:    for ( uint i=0; i<this[01;31m-[00m>_NumberOfExternalFrameHolders; i++ )
scaffoldHolder.cc:358:        ss << format(" [%d]=%d") % i % this[01;31m-[00m>_IndicesOfExternalFrameHolders[i];
scaffoldHolder.cc:362:    ss << "this[01;31m-[00m>_IndicesOfInternalFrameHolders: ";
scaffoldHolder.cc:363:    for (uint i=0; i<this[01;31m-[00m>_NumberOfInternalFrameHolders; i++ )
scaffoldHolder.cc:365:        ss << format(" [%d]=%d") % i % this[01;31m-[00m>_IndicesOfInternalFrameHolders[i];
scaffoldHolder.cc:376:    if ( this[01;31m-[00m>recognizesTransformOrFrameName(name) == 0 )
scaffoldHolder.cc:379:	err << "In Scaffold for Monomer(" << this[01;31m-[00m>_Monomer[01;31m-[00m>description() << ")"<<endl;
scaffoldHolder.cc:382:	for ( map<string,uint>::iterator fi=this[01;31m-[00m>_TransformOrFrameNameToIndex.begin(); 
scaffoldHolder.cc:383:	      fi!=this[01;31m-[00m>_TransformOrFrameNameToIndex.end(); fi++ )
scaffoldHolder.cc:385:	    err << fi[01;31m-[00m>first << " ";
scaffoldHolder.cc:388:        TOSS(_lisp[01;31m-[00m>create<O_LispError>(err.str()));
scaffoldHolder.cc:390:    return this[01;31m-[00m>getIndexForTransformOrFrameName(name);
scaffoldHolder.cc:396:    this[01;31m-[00m>_TransformOrFrameNameToIndex[tn] = i;
scaffoldHolder.cc:401:    this[01;31m-[00m>_TransformOrFrameNameToIndex.clear();
scaffoldHolder.cc:406:    return this[01;31m-[00m>_TransformOrFrameNameToIndex[tn];
scaffoldHolder.cc:411:    return this[01;31m-[00m>_TransformOrFrameNameToIndex.count(tn)>0;
scaffoldHolder.cc:433:    LOG(BF("Allocate frame holders for monomer comment(%s)") % this[01;31m-[00m>_Monomer[01;31m-[00m>getComment() );
scaffoldHolder.cc:434:    mc = this[01;31m-[00m>_MonomerCoordinates;
scaffoldHolder.cc:437:    sl = mc[01;31m-[00m>getScaffoldList();
scaffoldHolder.cc:442:        ASSERT(sl[01;31m-[00m>hasAnchorOrigin());
scaffoldHolder.cc:448:	ASSERT(sl[01;31m-[00m>getAnchor()[01;31m-[00m>isOfClass<O_AnchorOnOtherSideOfPlug>());
scaffoldHolder.cc:449:        anchor = sl[01;31m-[00m>getAnchor()[01;31m-[00m>as<O_AnchorOnOtherSideOfPlug>();
scaffoldHolder.cc:450:	myMonomer = this[01;31m-[00m>_Monomer;
scaffoldHolder.cc:452:	string othersExportedFrameName = anchor[01;31m-[00m>getOthersExportedFrameName(myMonomer);
scaffoldHolder.cc:453:        iFrameHolderIndex = preceedingScaffold[01;31m-[00m>getFrameHolderIndex(othersExportedFrameName);
scaffoldHolder.cc:456:    this[01;31m-[00m>_AnchorFrameHolderIndex = iFrameHolderIndex;
scaffoldHolder.cc:460:    this[01;31m-[00m>_NumberOfExternalFrameHolders = 0;
scaffoldHolder.cc:462:	for ( fti=sl[01;31m-[00m>begin_FinishFrameTransforms(), fhi=0;
scaffoldHolder.cc:463:		    fti!=sl[01;31m-[00m>end_FinishFrameTransforms(); fti++, fhi++ )
scaffoldHolder.cc:467:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("The preceedingScaffold is NULL"));
scaffoldHolder.cc:469:	    iFrameHolderIndex = preceedingScaffold[01;31m-[00m>getFrameHolderIndex((*fti)[01;31m-[00m>getTransformName());
scaffoldHolder.cc:471:	    this[01;31m-[00m>setIndexForTransformOrFrameName((*fti)[01;31m-[00m>getTransformName(),iFrameHolderIndex);
scaffoldHolder.cc:472:    //	this[01;31m-[00m>setIndexForTransformOrFrameName((*fti)[01;31m-[00m>getInternalFrameName(),iFrameHolderIndex);
scaffoldHolder.cc:473:	    this[01;31m-[00m>_IndicesOfExternalFrameHolders[fhi] = iFrameHolderIndex;
scaffoldHolder.cc:474:	    this[01;31m-[00m>_NumberOfExternalFrameHolders++;
scaffoldHolder.cc:477:		    (*fti)[01;31m-[00m>getOffsetOfTransform();
scaffoldHolder.cc:485:	for ( cti=sl[01;31m-[00m>begin_CompleteFrameTransforms(), fhi=0;
scaffoldHolder.cc:486:		    cti!=sl[01;31m-[00m>end_CompleteFrameTransforms(); cti++, fhi++ )
scaffoldHolder.cc:489:	    this[01;31m-[00m>setIndexForTransformOrFrameName((*cti)[01;31m-[00m>getTransformName(),iFrameHolderIndex);
scaffoldHolder.cc:490:	    this[01;31m-[00m>setIndexForTransformOrFrameName((*cti)[01;31m-[00m>getInternalFrameName(),iFrameHolderIndex);
scaffoldHolder.cc:491:	    this[01;31m-[00m>_IndicesOfInternalFrameHolders[fhi] = iFrameHolderIndex;
scaffoldHolder.cc:492:	    this[01;31m-[00m>_NumberOfInternalFrameHolders++;
scaffoldHolder.cc:494:	    frameHolder._OffsetOfTransformInScaffold = (*cti)[01;31m-[00m>getOffsetOfTransform();
scaffoldHolder.cc:495:	    LOG(BF("Setting up complete frame transform %s @%d") % (*cti)[01;31m-[00m>getTransformName().c_str() % iFrameHolderIndex  ); // vp0(("Setting up complete frame transform %s @%d",(*cti)[01;31m-[00m>getTransformName().c_str(),iFrameHolderIndex ));
scaffoldHolder.cc:501:	for ( iti=sl[01;31m-[00m>begin_IncompleteFrameTransforms();
scaffoldHolder.cc:502:		    iti!=sl[01;31m-[00m>end_IncompleteFrameTransforms(); iti++ )
scaffoldHolder.cc:505:	    this[01;31m-[00m>setIndexForTransformOrFrameName((*iti)[01;31m-[00m>getTransformName(),iFrameHolderIndex);
scaffoldHolder.cc:506:	    this[01;31m-[00m>setIndexForTransformOrFrameName((*iti)[01;31m-[00m>getInternalFrameName(),iFrameHolderIndex);
scaffoldHolder.cc:507:	    LOG(BF("Setting up incomplete frame transform(%s)/aka(%s) @%d") % (*iti)[01;31m-[00m>getTransformName().c_str() % (*iti)[01;31m-[00m>getInternalFrameName().c_str() % iFrameHolderIndex  ); // vp0(("Setting up incomplete frame transform(%s)/aka(%s) @%d", (*iti)[01;31m-[00m>getTransformName().c_str(), (*iti)[01;31m-[00m>getInternalFrameName().c_str(), iFrameHolderIndex ));
scaffoldHolder.cc:515:		frameHolder.initializeIncompleteFrame(ob, this[01;31m-[00m>_Monomer, (*iti)[01;31m-[00m>getInternalFrameName(),iFrameHolderIndex );
scaffoldHolder.cc:547:    LOG(BF("Building ScaffoldHolder with monomer sequence number: %d") % this[01;31m-[00m>_Monomer[01;31m-[00m>getSequenceNumber()  ); // vp0(("Building ScaffoldHolder with monomer sequence number: %d",this[01;31m-[00m>_Monomer[01;31m-[00m>getSequenceNumber() ));
scaffoldHolder.cc:554:    sl = this[01;31m-[00m>_MonomerCoordinates[01;31m-[00m>getScaffoldList();
scaffoldHolder.cc:555:    ASSERT_lessThan(this[01;31m-[00m>_FragmentHolderIndex,oligomerBuilder[01;31m-[00m>_AllFragmentHolders.size());
scaffoldHolder.cc:556:    fragmentHolderPtr = &(oligomerBuilder[01;31m-[00m>_AllFragmentHolders[this[01;31m-[00m>_FragmentHolderIndex]);
scaffoldHolder.cc:557://    scaffold = sl[01;31m-[00m>getScaffold(this[01;31m-[00m>_removeScaffoldListIndex);
scaffoldHolder.cc:558:    LOG(BF("FragmentHolder %s") % fragmentHolderPtr[01;31m-[00m>description().c_str()  ); // vp0(("FragmentHolder %s",fragmentHolderPtr[01;31m-[00m>description().c_str() ));
scaffoldHolder.cc:559:    scaffold = sl[01;31m-[00m>getScaffold(fragmentHolderPtr[01;31m-[00m>_localFragmentConformationIndex);
scaffoldHolder.cc:560:    ASSERT_lessThan(this[01;31m-[00m>_AnchorFrameHolderIndex,frameHolders.size());
scaffoldHolder.cc:561:    anchorFrameHolderPtr = &frameHolders[this[01;31m-[00m>_AnchorFrameHolderIndex];
scaffoldHolder.cc:565:    for (uint ffti=0; ffti<this[01;31m-[00m>_NumberOfExternalFrameHolders; ffti++ )
scaffoldHolder.cc:567:        iFrameHolder = this[01;31m-[00m>_IndicesOfExternalFrameHolders[ffti];
scaffoldHolder.cc:570:	transformOffset = targetFrameHolderPtr[01;31m-[00m>_OffsetOfTransformInScaffold;
scaffoldHolder.cc:571:	ASSERT(transformOffset<sl[01;31m-[00m>numberOfFinishFrameTransforms());
scaffoldHolder.cc:572:	localTransform = scaffold[01;31m-[00m>getExternalTransform(transformOffset);
scaffoldHolder.cc:573:	targetFrameHolderPtr[01;31m-[00m>setFrameTransform( anchorFrameHolderPtr[01;31m-[00m>frameTransform()*localTransform,oligomerBuilder );
scaffoldHolder.cc:574://	targetFrameHolderPtr[01;31m-[00m>_Transform = anchorFrameHolderPtr[01;31m-[00m>_Transform*localTransform;
scaffoldHolder.cc:579:    for ( uint ffti=0; ffti<this[01;31m-[00m>_NumberOfInternalFrameHolders; ffti++ )
scaffoldHolder.cc:581:        iFrameHolder = this[01;31m-[00m>_IndicesOfInternalFrameHolders[ffti];
scaffoldHolder.cc:584:	transformOffset = targetFrameHolderPtr[01;31m-[00m>_OffsetOfTransformInScaffold;
scaffoldHolder.cc:585:	ASSERT_lessThan(transformOffset,sl[01;31m-[00m>numberOfCompleteFrameTransforms());
scaffoldHolder.cc:586:	localTransform = scaffold[01;31m-[00m>getInternalTransform(transformOffset);
scaffoldHolder.cc:587://	targetFrameHolderPtr[01;31m-[00m>_Transform = anchorFrameHolderPtr[01;31m-[00m>_Transform*localTransform;
scaffoldHolder.cc:588:	targetFrameHolderPtr[01;31m-[00m>setFrameTransform(anchorFrameHolderPtr[01;31m-[00m>frameTransform()*localTransform,oligomerBuilder);
scaffoldHolder.cc:595:    ASSERT_NOT_NULL(this[01;31m-[00m>_MonomerCoordinates);
scaffoldHolder.cc:597:    sl = this[01;31m-[00m>_MonomerCoordinates[01;31m-[00m>getScaffoldList();
scaffoldHolder.cc:599:    return sl[01;31m-[00m>numberOfScaffolds();
scaffoldHolder.cc:606:TOSS(_lisp[01;31m-[00m>create<O_LispError>("Depreciated function"));
scaffoldHolder.cc:607:    ASSERT_NOT_NULL(this[01;31m-[00m>_MonomerCoordinates);
scaffoldHolder.cc:609:    sl = this[01;31m-[00m>_MonomerCoordinates[01;31m-[00m>getScaffoldList();
scaffoldHolder.cc:613:    if ( sl[01;31m-[00m>numberOfScaffolds() == 0 ) return;
scaffoldHolder.cc:616://    this[01;31m-[00m>_removeScaffoldListIndex = randomNumber01(_lisp)*sl[01;31m-[00m>numberOfScaffolds();
scaffoldHolder.cc:618://    LOG(BF("New conformation(%d/ max %d)") % this[01;31m-[00m>_ScaffoldListIndex % sl[01;31m-[00m>numberOfScaffolds()  ); // vp0(("New conformation(%d/ max %d)",this[01;31m-[00m>_ScaffoldListIndex,sl[01;31m-[00m>numberOfScaffolds() ));
scoreOperations.cc:23:    this[01;31m-[00m>_Scale = 1.0;
scoreOperations.cc:28:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:29:    node[01;31m-[00m>attributeIfNotDefault("overallScale",this[01;31m-[00m>_Scale,1.0);
scoreOperations.cc:36:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
scoreOperations.cc:37:    this[01;31m-[00m>_Scale = kargs[01;31m-[00m>getDoubleAndRemoveOrDefault("scale",1.0);
scoreOperations.cc:43:    this[01;31m-[00m>Base::oldLispInitialize(arg,env);
scoreOperations.cc:44:    for ( uint i = 0; i<arg[01;31m-[00m>numberOfPositionalArguments(); i++ )
scoreOperations.cc:46:	RPScoreOperation s = arg[01;31m-[00m>getPositionalArgument(i)[01;31m-[00m>as<O_ScoreOperation>();
scoreOperations.cc:47:	this[01;31m-[00m>addOperation(s);
scoreOperations.cc:54:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:55:    node[01;31m-[00m>archiveList("operations",this[01;31m-[00m>_Operations);
scoreOperations.cc:62:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:63:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:65:    for ( it=this[01;31m-[00m>_Operations.begin(); it!=this[01;31m-[00m>_Operations.end(); it++ )
scoreOperations.cc:67:	(*it)[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:72:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:73:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:75:    for ( it=this[01;31m-[00m>_Operations.begin(); it!=this[01;31m-[00m>_Operations.end(); it++ )
scoreOperations.cc:77:	(*it)[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:84:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:87:    for ( it=this[01;31m-[00m>_Operations.begin(); it!=this[01;31m-[00m>_Operations.end(); it++ )
scoreOperations.cc:89:	req |= (*it)[01;31m-[00m>needsAllAtomsBuilt();
scoreOperations.cc:99:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:100:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:102:    for ( it=this[01;31m-[00m>_Operations.begin(); it!=this[01;31m-[00m>_Operations.end(); it++ )
scoreOperations.cc:104:	(*it)[01;31m-[00m>renderIntoDisplayList(dl,scorerState,scorer,builder);
scoreOperations.cc:110:    ASSERT(b[01;31m-[00m>notNil());
scoreOperations.cc:111:    this[01;31m-[00m>_Operations.push_back(b);
scoreOperations.cc:117:    this[01;31m-[00m>Base::oldLispInitialize(arg,env);
scoreOperations.cc:122:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:127:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:131:    ASSERT(scorer[01;31m-[00m>notNil());
scoreOperations.cc:132:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:136:    for ( it=this[01;31m-[00m>_Operations.begin(); it!=this[01;31m-[00m>_Operations.end(); it++ )
scoreOperations.cc:138:	double oneSum = (*it)[01;31m-[00m>evaluate(scorerState,scorer,builder);
scoreOperations.cc:142:    double result = sum*this[01;31m-[00m>getScale();
scoreOperations.cc:151:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:153:    for ( it=this[01;31m-[00m>_Operations.begin(); it!=this[01;31m-[00m>_Operations.end(); it++ )
scoreOperations.cc:155:        (*it)[01;31m-[00m>insertRestraints(builder,scorer,restraints);
scoreOperations.cc:163:    this[01;31m-[00m>Base::oldLispInitialize(arg,env);
scoreOperations.cc:170:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:175:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:179:    ASSERT(scorer[01;31m-[00m>notNil());
scoreOperations.cc:180:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:184:    for ( it=this[01;31m-[00m>_Operations.begin(); it!=this[01;31m-[00m>_Operations.end(); it++ )
scoreOperations.cc:186:	double val = (*it)[01;31m-[00m>evaluate(scorerState,scorer,builder);
scoreOperations.cc:196:    return min*this[01;31m-[00m>getScale();
scoreOperations.cc:201:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:204:    RPScorerState scorerState = O_ScorerState::create(this[01;31m-[00m>lisp());
scoreOperations.cc:205:    minIt = this[01;31m-[00m>_Operations.end();
scoreOperations.cc:206:    for ( it=this[01;31m-[00m>_Operations.begin(); it!=this[01;31m-[00m>_Operations.end(); it++ )
scoreOperations.cc:208:	double score = this[01;31m-[00m>evaluate(scorerState, scorer, builder);
scoreOperations.cc:214:        (*it)[01;31m-[00m>insertRestraints(builder,scorer,restraints);
scoreOperations.cc:216:    if ( minIt != this[01;31m-[00m>_Operations.end() )
scoreOperations.cc:218:	(*minIt)[01;31m-[00m>insertRestraints(builder,scorer,restraints);
scoreOperations.cc:227:    this[01;31m-[00m>Base::initialize();
scoreOperations.cc:228:    this[01;31m-[00m>_AnchorWeight = 1.0;
scoreOperations.cc:234:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:235:    node[01;31m-[00m>attributeIfNotDefault("anchorWeight",this[01;31m-[00m>_AnchorWeight,1.0);
scoreOperations.cc:241:    this[01;31m-[00m>Base::oldLispInitialize(arg,env);
scoreOperations.cc:242:    this[01;31m-[00m>_AnchorWeight = arg[01;31m-[00m>getDoubleAndRemoveOrDefault("anchorWeight",1.0);
scoreOperations.cc:249:    if ( !scorer[01;31m-[00m>hasSuperposer() )
scoreOperations.cc:251:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You are asking to score the superposition but you haven't defined a superposer"));
scoreOperations.cc:253:    double result = scorer[01;31m-[00m>calculateSuperposerSumOfSquaresOfDifferences(scorerState)*this[01;31m-[00m>getScale();
scoreOperations.cc:254:    LOG_SCORE(scorerState,BF("O_ScoreSuperposition score after applying scale(%lf) = %lf")% this[01;31m-[00m>getScale() % result);
scoreOperations.cc:261:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:262:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:267:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:268:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:276:    RPRender deviations = scorer[01;31m-[00m>renderSuperposeDeviations(builder,scorerState);
scoreOperations.cc:277:    dl[01;31m-[00m>add(deviations);
scoreOperations.cc:281:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:282:    RPScorer scorer = scorerBase[01;31m-[00m>as<O_Scorer>();
scoreOperations.cc:283:    scorer[01;31m-[00m>insertSuperpositionsIntoRestraintList(this[01;31m-[00m>_AnchorWeight,builder,restraints);
scoreOperations.cc:296:    ASSERT_eq(args[01;31m-[00m>numberOfPositionalArguments(),2);
scoreOperations.cc:297:    this[01;31m-[00m>_Alias1 = args[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:298:    this[01;31m-[00m>_Alias2 = args[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:299:    this[01;31m-[00m>_Distance = args[01;31m-[00m>getDoubleAndRemove("distance");
scoreOperations.cc:300:    this[01;31m-[00m>_Force = args[01;31m-[00m>getDoubleAndRemoveOrDefault("force",1.0);
scoreOperations.cc:306:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:307:    node[01;31m-[00m>archiveObject("alias1",this[01;31m-[00m>_Alias1);
scoreOperations.cc:308:    node[01;31m-[00m>archiveObject("alias2",this[01;31m-[00m>_Alias2);
scoreOperations.cc:309:    node[01;31m-[00m>attribute("distance",this[01;31m-[00m>_Distance);
scoreOperations.cc:310:    node[01;31m-[00m>attribute("force",this[01;31m-[00m>_Force);
scoreOperations.cc:311:    node[01;31m-[00m>attribute("comment",this[01;31m-[00m>_Comment);
scoreOperations.cc:316:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:317:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:318:    this[01;31m-[00m>_Alias1[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:319:    this[01;31m-[00m>_Alias2[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:323:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:324:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:325:    this[01;31m-[00m>_Alias1[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:326:    this[01;31m-[00m>_Alias2[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:331:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:332:    ASSERT(scorer[01;31m-[00m>notNil());
scoreOperations.cc:333:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:335:    Vector3 pos1 = this[01;31m-[00m>_Alias1[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:336:    Vector3 pos2 = this[01;31m-[00m>_Alias2[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:337:    LOG_SCORE(scorerState,BF("ScoreDistance %s pos1 = %s")% this[01;31m-[00m>_Alias1[01;31m-[00m>description()% pos1.asString() );
scoreOperations.cc:338:    LOG_SCORE(scorerState,BF("ScoreDistance %s pos2 = %s")% this[01;31m-[00m>_Alias2[01;31m-[00m>description()% pos2.asString() );
scoreOperations.cc:342:    double d = dist[01;31m-[00mthis[01;31m-[00m>getDistance();
scoreOperations.cc:343:    double res = d*d*this[01;31m-[00m>getForce();
scoreOperations.cc:345:    double retres = res*this[01;31m-[00m>getScale();
scoreOperations.cc:352:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:353:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:354:    Vector3 pos1 = this[01;31m-[00m>_Alias1[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:355:    Vector3 pos2 = this[01;31m-[00m>_Alias2[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:359:    renderDistanceDeviation(dl,pos1,pos2,this[01;31m-[00m>getDistance(),this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>(RGB_yellow));
scoreOperations.cc:378:    ASSERT_eq(args[01;31m-[00m>numberOfPositionalArguments(),3);
scoreOperations.cc:379:    this[01;31m-[00m>_Alias1 = args[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:380:    this[01;31m-[00m>_Alias2 = args[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:381:    this[01;31m-[00m>_Alias3 = args[01;31m-[00m>getPositionalArgument(2)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:382:    this[01;31m-[00m>_Radians = args[01;31m-[00m>getDoubleAndRemove("degrees")*0.0174533;
scoreOperations.cc:383:    this[01;31m-[00m>_Force = args[01;31m-[00m>getDoubleAndRemoveOrDefault("force",0.1);
scoreOperations.cc:389:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:390:    node[01;31m-[00m>archiveObject("alias1",this[01;31m-[00m>_Alias1);
scoreOperations.cc:391:    node[01;31m-[00m>archiveObject("alias2",this[01;31m-[00m>_Alias2);
scoreOperations.cc:392:    node[01;31m-[00m>archiveObject("alias3",this[01;31m-[00m>_Alias3);
scoreOperations.cc:393:    node[01;31m-[00m>attribute("radians",this[01;31m-[00m>_Radians);
scoreOperations.cc:394:    node[01;31m-[00m>attribute("force",this[01;31m-[00m>_Force);
scoreOperations.cc:395:    node[01;31m-[00m>attribute("comment",this[01;31m-[00m>_Comment);
scoreOperations.cc:400:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:401:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:402:    this[01;31m-[00m>_Alias1[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:403:    this[01;31m-[00m>_Alias2[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:404:    this[01;31m-[00m>_Alias3[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:408:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:409:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:410:    this[01;31m-[00m>_Alias1[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:411:    this[01;31m-[00m>_Alias2[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:412:    this[01;31m-[00m>_Alias3[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:417:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:418:    ASSERT(scorer[01;31m-[00m>notNil());
scoreOperations.cc:419:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:420:    Vector3 pos1 = this[01;31m-[00m>_Alias1[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:421:    Vector3 pos2 = this[01;31m-[00m>_Alias2[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:422:    Vector3 pos3 = this[01;31m-[00m>_Alias3[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:428:    double d = angle[01;31m-[00mthis[01;31m-[00m>getRadians();
scoreOperations.cc:429:    double res = d*d*this[01;31m-[00m>getForce();
scoreOperations.cc:431:    return res*this[01;31m-[00m>getScale();
scoreOperations.cc:435:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:436:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:437://    LOG(BF("scorerState[01;31m-[00m>scoreTransform() = %s") % scorerState[01;31m-[00m>scoreTransform().asString().c_str()  ); // vp0(( "scorerState[01;31m-[00m>scoreTransform() = %s", scorerState[01;31m-[00m>scoreTransform().asString().c_str() ));
scoreOperations.cc:438:    Vector3 pos1 = this[01;31m-[00m>_Alias1[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:439:    Vector3 pos2 = this[01;31m-[00m>_Alias2[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:440:    Vector3 pos3 = this[01;31m-[00m>_Alias3[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:444:    renderAngleDeviation(dl,pos1,pos2,pos3,this[01;31m-[00m>getRadians());
scoreOperations.cc:466:    ASSERT_eq(args[01;31m-[00m>numberOfPositionalArguments(),4);
scoreOperations.cc:467:    this[01;31m-[00m>_Alias1 = args[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:468:    this[01;31m-[00m>_Alias2 = args[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:469:    this[01;31m-[00m>_Alias3 = args[01;31m-[00m>getPositionalArgument(2)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:470:    this[01;31m-[00m>_Alias4 = args[01;31m-[00m>getPositionalArgument(3)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:471:    this[01;31m-[00m>_Radians = args[01;31m-[00m>getDoubleAndRemove("degrees")*0.0174533;
scoreOperations.cc:472:    this[01;31m-[00m>_Force = args[01;31m-[00m>getDoubleAndRemoveOrDefault("force",0.1);
scoreOperations.cc:478:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:479:    node[01;31m-[00m>archiveObject("alias1",this[01;31m-[00m>_Alias1);
scoreOperations.cc:480:    node[01;31m-[00m>archiveObject("alias2",this[01;31m-[00m>_Alias2);
scoreOperations.cc:481:    node[01;31m-[00m>archiveObject("alias3",this[01;31m-[00m>_Alias3);
scoreOperations.cc:482:    node[01;31m-[00m>archiveObject("alias4",this[01;31m-[00m>_Alias4);
scoreOperations.cc:483:    node[01;31m-[00m>attribute("radians",this[01;31m-[00m>_Radians);
scoreOperations.cc:484:    node[01;31m-[00m>attribute("force",this[01;31m-[00m>_Force);
scoreOperations.cc:485:    node[01;31m-[00m>attribute("comment",this[01;31m-[00m>_Comment);
scoreOperations.cc:490:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:491:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:492:    this[01;31m-[00m>_Alias1[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:493:    this[01;31m-[00m>_Alias2[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:494:    this[01;31m-[00m>_Alias3[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:495:    this[01;31m-[00m>_Alias4[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:499:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:500:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:501:    this[01;31m-[00m>_Alias1[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:502:    this[01;31m-[00m>_Alias2[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:503:    this[01;31m-[00m>_Alias3[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:504:    this[01;31m-[00m>_Alias4[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:509:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:510:    ASSERT(scorer[01;31m-[00m>notNil());
scoreOperations.cc:511:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:512:    Vector3 pos1 = this[01;31m-[00m>_Alias1[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:513:    Vector3 pos2 = this[01;31m-[00m>_Alias2[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:514:    Vector3 pos3 = this[01;31m-[00m>_Alias3[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:515:    Vector3 pos4 = this[01;31m-[00m>_Alias4[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:522:    double d = angle[01;31m-[00mthis[01;31m-[00m>getRadians();
scoreOperations.cc:523:    double res = d*d*this[01;31m-[00m>getForce();
scoreOperations.cc:525:    return res*this[01;31m-[00m>getScale();
scoreOperations.cc:529:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:530:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:531://    LOG(BF("scorerState[01;31m-[00m>scoreTransform() = %s") % scorerState[01;31m-[00m>scoreTransform().asString().c_str()  ); // vp0(( "scorerState[01;31m-[00m>scoreTransform() = %s", scorerState[01;31m-[00m>scoreTransform().asString().c_str() ));
scoreOperations.cc:532:    Vector3 pos1 = this[01;31m-[00m>_Alias1[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:533:    Vector3 pos2 = this[01;31m-[00m>_Alias2[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:534:    Vector3 pos3 = this[01;31m-[00m>_Alias3[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:535:    Vector3 pos4 = this[01;31m-[00m>_Alias4[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:541:    renderDihedralDeviation(dl,pos1,pos2,pos3,pos4,this[01;31m-[00m>getRadians());
scoreOperations.cc:558:    ASSERT_eq(args[01;31m-[00m>numberOfPositionalArguments(),4);
scoreOperations.cc:559:    this[01;31m-[00m>_Alias1 = args[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:560:    this[01;31m-[00m>_Alias2 = args[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:561:    this[01;31m-[00m>_Alias3 = args[01;31m-[00m>getPositionalArgument(2)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:562:    this[01;31m-[00m>_Alias4 = args[01;31m-[00m>getPositionalArgument(3)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:563:    this[01;31m-[00m>_NormalizedDotProduct = args[01;31m-[00m>getDoubleAndRemove("dotProduct");
scoreOperations.cc:564:    this[01;31m-[00m>_Force = args[01;31m-[00m>getDoubleAndRemoveOrDefault("force",0.1);
scoreOperations.cc:570:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:571:    node[01;31m-[00m>archiveObject("alias1",this[01;31m-[00m>_Alias1);
scoreOperations.cc:572:    node[01;31m-[00m>archiveObject("alias2",this[01;31m-[00m>_Alias2);
scoreOperations.cc:573:    node[01;31m-[00m>archiveObject("alias3",this[01;31m-[00m>_Alias3);
scoreOperations.cc:574:    node[01;31m-[00m>archiveObject("alias4",this[01;31m-[00m>_Alias4);
scoreOperations.cc:575:    node[01;31m-[00m>attribute("dotProduct",this[01;31m-[00m>_NormalizedDotProduct);
scoreOperations.cc:576:    node[01;31m-[00m>attribute("force",this[01;31m-[00m>_Force);
scoreOperations.cc:577:    node[01;31m-[00m>attribute("comment",this[01;31m-[00m>_Comment);
scoreOperations.cc:582:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:583:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:584:    this[01;31m-[00m>_Alias1[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:585:    this[01;31m-[00m>_Alias2[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:586:    this[01;31m-[00m>_Alias3[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:587:    this[01;31m-[00m>_Alias4[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:591:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:592:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:593:    this[01;31m-[00m>_Alias1[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:594:    this[01;31m-[00m>_Alias2[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:595:    this[01;31m-[00m>_Alias3[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:596:    this[01;31m-[00m>_Alias4[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:601:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:602:    ASSERT(scorer[01;31m-[00m>notNil());
scoreOperations.cc:603:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:604:    Vector3 pos1 = this[01;31m-[00m>_Alias1[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:605:    Vector3 pos2 = this[01;31m-[00m>_Alias2[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:606:    Vector3 pos3 = this[01;31m-[00m>_Alias3[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:607:    Vector3 pos4 = this[01;31m-[00m>_Alias4[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:612:    Vector3 diff1 = (pos1.sub(pos2)).normalized(this[01;31m-[00m>lisp());
scoreOperations.cc:613:    Vector3 diff2 = (pos3.sub(pos4)).normalized(this[01;31m-[00m>lisp());
scoreOperations.cc:615:    double d = dot[01;31m-[00mthis[01;31m-[00m>getNormalizedDotProduct();
scoreOperations.cc:616:    double res = d*d*this[01;31m-[00m>getForce();
scoreOperations.cc:618:    return res*this[01;31m-[00m>getScale();
scoreOperations.cc:623:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:624://    LOG(BF("scorerState[01;31m-[00m>scoreTransform() = %s") % scorerState[01;31m-[00m>scoreTransform().asString().c_str()  ); // vp0(( "scorerState[01;31m-[00m>scoreTransform() = %s", scorerState[01;31m-[00m>scoreTransform().asString().c_str() ));
scoreOperations.cc:625:    Vector3 pos1 = this[01;31m-[00m>_Alias1[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:626:    Vector3 pos2 = this[01;31m-[00m>_Alias2[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:627:    Vector3 pos3 = this[01;31m-[00m>_Alias3[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:628:    Vector3 pos4 = this[01;31m-[00m>_Alias4[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:634:    renderNormalizedDotProductDeviation(dl,pos1,pos2,pos3,pos4,this[01;31m-[00m>getNormalizedDotProduct());
scoreOperations.cc:661:    ASSERT_eq(args[01;31m-[00m>numberOfPositionalArguments(),2);
scoreOperations.cc:662:    this[01;31m-[00m>_Alias = args[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:663:    this[01;31m-[00m>_Point = args[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_OVector3>()[01;31m-[00m>get();
scoreOperations.cc:664:    this[01;31m-[00m>_Distance = args[01;31m-[00m>getDoubleAndRemoveOrDefault("distance",0.0);
scoreOperations.cc:665:    this[01;31m-[00m>_Force = args[01;31m-[00m>getDoubleAndRemoveOrDefault("force",1.0);
scoreOperations.cc:671:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:672:    node[01;31m-[00m>archiveObject("alias",this[01;31m-[00m>_Alias);
scoreOperations.cc:673:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "pos","Vector3",
scoreOperations.cc:674:    					this[01;31m-[00m>_Point.isDefined(), this[01;31m-[00m>_Point);
scoreOperations.cc:675:    node[01;31m-[00m>attribute("distance",this[01;31m-[00m>_Distance);
scoreOperations.cc:676:    node[01;31m-[00m>attribute("force",this[01;31m-[00m>_Force);
scoreOperations.cc:677:    node[01;31m-[00m>attribute("comment",this[01;31m-[00m>_Comment);
scoreOperations.cc:682:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:683:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:684:    this[01;31m-[00m>_Alias[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:688:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:689:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:690:    this[01;31m-[00m>_Alias[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:695:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:696:    ASSERT(scorer[01;31m-[00m>notNil());
scoreOperations.cc:697:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:698:    Vector3 pos = this[01;31m-[00m>_Alias[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:700:    Vector3 diff = pos.sub(this[01;31m-[00m>getPoint());
scoreOperations.cc:703:    double d = dist[01;31m-[00mthis[01;31m-[00m>getDistance();
scoreOperations.cc:704:    double res = d*d*this[01;31m-[00m>getForce();
scoreOperations.cc:706:    return res*this[01;31m-[00m>getScale();
scoreOperations.cc:712:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:713:    Vector3 pos = this[01;31m-[00m>_Alias[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:715:    renderDistanceDeviation(dl,pos,this[01;31m-[00m>getPoint(),this[01;31m-[00m>getDistance(),this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>(RGB_yellow));
scoreOperations.cc:735:    RPCons targets = args[01;31m-[00m>getAndRemove("targetAtomAliases")[01;31m-[00m>as<O_Cons>();
scoreOperations.cc:736:    this[01;31m-[00m>_TargetAtomAliases.clear();
scoreOperations.cc:737:    this[01;31m-[00m>_TargetAtomAliases.fillFromCons(targets);
scoreOperations.cc:738:    this[01;31m-[00m>_Distance = args[01;31m-[00m>getDoubleAndRemove("distance");
scoreOperations.cc:739:    this[01;31m-[00m>_DistanceAlias = args[01;31m-[00m>getAndRemove("distanceAlias")[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:740:    this[01;31m-[00m>_AngleRadians = args[01;31m-[00m>getDoubleAndRemoveOrDefault("angleDegrees",0.0)*0.0174533;
scoreOperations.cc:741:    this[01;31m-[00m>_AngleAlias = args[01;31m-[00m>getAndRemoveOrNil("angleAlias")[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:742:    this[01;31m-[00m>_DihedralRadians = args[01;31m-[00m>getDoubleAndRemoveOrDefault("dihedralDegrees",0.0)*0.0174533;
scoreOperations.cc:743:    this[01;31m-[00m>_DihedralAlias = args[01;31m-[00m>getAndRemoveOrNil("dihedralAlias")[01;31m-[00m>as<O_Alias>();
scoreOperations.cc:744:    this[01;31m-[00m>_DistanceScale = args[01;31m-[00m>getDoubleAndRemoveOrDefault("distanceScale",1.0)*0.0174533;
scoreOperations.cc:745:    this[01;31m-[00m>_AngleScale = args[01;31m-[00m>getDoubleAndRemoveOrDefault("angleScale",1.0)*0.0174533;
scoreOperations.cc:746:    this[01;31m-[00m>_DihedralScale = args[01;31m-[00m>getDoubleAndRemoveOrDefault("dihedralScale",1.0)*0.0174533;
scoreOperations.cc:747:    this[01;31m-[00m>_Comment = args[01;31m-[00m>getStringAndRemoveOrDefault("comment","");
scoreOperations.cc:752:    this[01;31m-[00m>Base::initialize();
scoreOperations.cc:753:    this[01;31m-[00m>_Distance = 0.0;
scoreOperations.cc:754:    this[01;31m-[00m>_AngleRadians = 0.0;
scoreOperations.cc:755:    this[01;31m-[00m>_DihedralRadians= 0.0;
scoreOperations.cc:756:    this[01;31m-[00m>_DistanceScale = 1.0;
scoreOperations.cc:757:    this[01;31m-[00m>_AngleScale = 1.0;
scoreOperations.cc:758:    this[01;31m-[00m>_DihedralScale = 1.0;
scoreOperations.cc:763:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:764:    node[01;31m-[00m>archiveList("targets",this[01;31m-[00m>_TargetAtomAliases);
scoreOperations.cc:765:    node[01;31m-[00m>archiveObject("DistanceAlias",this[01;31m-[00m>_DistanceAlias);
scoreOperations.cc:766:    node[01;31m-[00m>attribute("Distance",this[01;31m-[00m>_Distance);
scoreOperations.cc:767:    node[01;31m-[00m>archiveObject("AngleAlias",this[01;31m-[00m>_AngleAlias);
scoreOperations.cc:768:    node[01;31m-[00m>attributeIfNotDefault("Angle",this[01;31m-[00m>_AngleRadians,0.0);
scoreOperations.cc:769:    node[01;31m-[00m>archiveObject("DihedralAlias",this[01;31m-[00m>_DihedralAlias);
scoreOperations.cc:770:    node[01;31m-[00m>attributeIfNotDefault("Dihedral",this[01;31m-[00m>_DihedralRadians,0.0);
scoreOperations.cc:771:    node[01;31m-[00m>attributeIfNotDefault("DistanceScale",this[01;31m-[00m>_DistanceScale,1.0);
scoreOperations.cc:772:    node[01;31m-[00m>attributeIfNotDefault("AngleScale",this[01;31m-[00m>_AngleScale,1.0);
scoreOperations.cc:773:    node[01;31m-[00m>attributeIfNotDefault("DihedralScale",this[01;31m-[00m>_DihedralScale,1.0);
scoreOperations.cc:774:    node[01;31m-[00m>attributeIfNotDefault<string>("Comment",this[01;31m-[00m>_Comment,"");
scoreOperations.cc:779:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:780:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:782:    for ( it=this[01;31m-[00m>_TargetAtomAliases.begin(); it!=this[01;31m-[00m>_TargetAtomAliases.end(); it++ )
scoreOperations.cc:784:	(*it)[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:786:    ASSERT(this[01;31m-[00m>_DistanceAlias[01;31m-[00m>notNil());
scoreOperations.cc:787:    this[01;31m-[00m>_DistanceAlias[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:788:    if ( this[01;31m-[00m>_AngleAlias[01;31m-[00m>notNil() ) this[01;31m-[00m>_AngleAlias[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:789:    if ( this[01;31m-[00m>_DihedralAlias[01;31m-[00m>notNil() ) this[01;31m-[00m>_DihedralAlias[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:793:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:794:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:796:    for ( it=this[01;31m-[00m>_TargetAtomAliases.begin(); it!=this[01;31m-[00m>_TargetAtomAliases.end(); it++ )
scoreOperations.cc:798:	(*it)[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:800:    ASSERT(this[01;31m-[00m>_DistanceAlias[01;31m-[00m>notNil());
scoreOperations.cc:801:    this[01;31m-[00m>_DistanceAlias[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:802:    if ( this[01;31m-[00m>_AngleAlias[01;31m-[00m>notNil() ) this[01;31m-[00m>_AngleAlias[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:803:    if ( this[01;31m-[00m>_DihedralAlias[01;31m-[00m>notNil() ) this[01;31m-[00m>_DihedralAlias[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:812:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:813:    ASSERT(scorer[01;31m-[00m>notNil());
scoreOperations.cc:814:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:817:    ASSERT(this[01;31m-[00m>_DistanceAlias[01;31m-[00m>notNil());
scoreOperations.cc:818:    Vector3 posDistance = this[01;31m-[00m>_DistanceAlias[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:821:    if ( this[01;31m-[00m>_AngleAlias[01;31m-[00m>notNil() )
scoreOperations.cc:824:	posAngle = this[01;31m-[00m>_AngleAlias[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:826:	if ( this[01;31m-[00m>_DihedralAlias[01;31m-[00m>notNil() )
scoreOperations.cc:829:	    posDihedral = this[01;31m-[00m>_DihedralAlias[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:837:    for ( it=this[01;31m-[00m>_TargetAtomAliases.begin();
scoreOperations.cc:838:    		 it!=this[01;31m-[00m>_TargetAtomAliases.end(); it++ )
scoreOperations.cc:841:	Vector3 targetPos = alias[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:846:	    if ( alias[01;31m-[00m>equal(this[01;31m-[00m>_DistanceAlias) )
scoreOperations.cc:848:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("The target alias("+alias[01;31m-[00m>__repr__()+") is the same as Distance alias("+this[01;31m-[00m>_DistanceAlias[01;31m-[00m>__repr__()+")"));
scoreOperations.cc:850:	    if ( alias[01;31m-[00m>equal(this[01;31m-[00m>_AngleAlias) )
scoreOperations.cc:852:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("The target alias("+alias[01;31m-[00m>__repr__()+") is the same as Angle alias("+this[01;31m-[00m>_AngleAlias[01;31m-[00m>__repr__()+")"));
scoreOperations.cc:854:	    if ( alias[01;31m-[00m>equal(this[01;31m-[00m>_DihedralAlias) )
scoreOperations.cc:856:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("The target alias("+alias[01;31m-[00m>__repr__()+") is the same as Dihedral alias("+this[01;31m-[00m>_DihedralAlias[01;31m-[00m>__repr__()+")"));
scoreOperations.cc:858:	    double deltaDist = calculateDistance(targetPos,posDistance,_lisp) [01;31m-[00m this[01;31m-[00m>_Distance;
scoreOperations.cc:860:	    double deltaAngle = calculateAngle(targetPos,posDistance,posAngle,_lisp) [01;31m-[00m this[01;31m-[00m>_AngleRadians;
scoreOperations.cc:862:	    double deltaDihedral = calculateDihedral(targetPos,posDistance,posAngle,posDihedral,_lisp) [01;31m-[00m this[01;31m-[00m>_DihedralRadians;
scoreOperations.cc:864:	    score = deltaDist*deltaDist*this[01;31m-[00m>_DistanceScale
scoreOperations.cc:865:	    		+deltaAngle*deltaAngle*this[01;31m-[00m>_AngleScale
scoreOperations.cc:866:			+deltaDihedral*deltaDihedral*this[01;31m-[00m>_DihedralScale;
scoreOperations.cc:870:	    if ( alias[01;31m-[00m>equal(this[01;31m-[00m>_DistanceAlias) )
scoreOperations.cc:872:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("The target alias("+alias[01;31m-[00m>__repr__()+") is the same as Distance alias("+this[01;31m-[00m>_DistanceAlias[01;31m-[00m>__repr__()+")"));
scoreOperations.cc:874:	    if ( alias[01;31m-[00m>equal(this[01;31m-[00m>_AngleAlias) )
scoreOperations.cc:876:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("The target alias("+alias[01;31m-[00m>__repr__()+") is the same as Angle alias("+this[01;31m-[00m>_AngleAlias[01;31m-[00m>__repr__()+")"));
scoreOperations.cc:878:	    double deltaDist = calculateDistance(targetPos,posDistance,_lisp) [01;31m-[00m this[01;31m-[00m>_Distance;
scoreOperations.cc:880:	    double deltaAngle = calculateAngle(targetPos,posDistance,posAngle,_lisp) [01;31m-[00m this[01;31m-[00m>_AngleRadians;
scoreOperations.cc:882:	    score = deltaDist*deltaDist*this[01;31m-[00m>_DistanceScale
scoreOperations.cc:883:	    		+deltaAngle*deltaAngle*this[01;31m-[00m>_AngleScale;
scoreOperations.cc:887:	    if ( alias[01;31m-[00m>equal(this[01;31m-[00m>_DistanceAlias) )
scoreOperations.cc:889:		TOSS(_lisp[01;31m-[00m>create<O_LispError>("The target alias("+alias[01;31m-[00m>__repr__()+") is the same as Distance alias("+this[01;31m-[00m>_DistanceAlias[01;31m-[00m>__repr__()+")"));
scoreOperations.cc:891:	    double deltaDist = calculateDistance(targetPos,posDistance,_lisp) [01;31m-[00m this[01;31m-[00m>_Distance;
scoreOperations.cc:893:	    score = deltaDist*deltaDist*this[01;31m-[00m>_DistanceScale;
scoreOperations.cc:910:    this[01;31m-[00m>findBest(scorerState,scorer,builder,bestScore,bestAlias);
scoreOperations.cc:911:    double score = bestScore*this[01;31m-[00m>getScale();
scoreOperations.cc:919:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:922:    this[01;31m-[00m>findBest(scorerState,scorer,builder,bestScore,bestAlias);
scoreOperations.cc:923:    Vector3 bestPos = bestAlias[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:924:    Vector3 distancePos = this[01;31m-[00m>_DistanceAlias[01;31m-[00m>getScoreTransformedAtomPosition(builder,scorerState);
scoreOperations.cc:927:    renderDistanceDeviation(dl,distancePos,bestPos,this[01;31m-[00m>_Distance,this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>(RGB_yellow));
scoreOperations.cc:946:    this[01;31m-[00m>_Rejector = args[01;31m-[00m>getAndRemove("rejector")[01;31m-[00m>as<O_Rejector>();
scoreOperations.cc:947:    ASSERT(this[01;31m-[00m>_Rejector[01;31m-[00m>notNil());
scoreOperations.cc:948:    this[01;31m-[00m>_Scale = args[01;31m-[00m>getDoubleAndRemoveOrDefault("scale",1.0);
scoreOperations.cc:954:    this[01;31m-[00m>Base::initialize();
scoreOperations.cc:955:    this[01;31m-[00m>_Rejector = O_Rejector::nil(this[01;31m-[00m>lisp());
scoreOperations.cc:956:    this[01;31m-[00m>_Scale = 1.0;
scoreOperations.cc:961:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:962:    node[01;31m-[00m>archiveObject("rejector",this[01;31m-[00m>_Rejector);
scoreOperations.cc:963:    node[01;31m-[00m>attribute("Scale",this[01;31m-[00m>_Scale);
scoreOperations.cc:968:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:969:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:970:    if ( this[01;31m-[00m>_Rejector[01;31m-[00m>notNil() )
scoreOperations.cc:972:	this[01;31m-[00m>_Rejector[01;31m-[00m>oligomerChanged(builder);
scoreOperations.cc:977:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:978:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:979:    if ( this[01;31m-[00m>_Rejector[01;31m-[00m>notNil() )
scoreOperations.cc:981:	this[01;31m-[00m>_Rejector[01;31m-[00m>sequenceChanged(builder);
scoreOperations.cc:987:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:988:    this[01;31m-[00m>_Rejector = rejector;
scoreOperations.cc:992:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:993:    this[01;31m-[00m>_Scale = scale;
scoreOperations.cc:999:    ASSERT(this[01;31m-[00m>_Rejector[01;31m-[00m>notNil());
scoreOperations.cc:1001:    double score = this[01;31m-[00m>_Rejector[01;31m-[00m>countRejects(scorerState,scorer,builder);
scoreOperations.cc:1002:    double scaledScore = score*this[01;31m-[00m>_Scale;
scoreOperations.cc:1011:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:1012:    RPRenderDisplayList mine = this[01;31m-[00m>_Rejector[01;31m-[00m>getRenderForScore(builder,scorerState);
scoreOperations.cc:1013:    dl[01;31m-[00m>add(mine);
scoreOperations.cc:1018:    return this[01;31m-[00m>_Rejector[01;31m-[00m>needsAllAtomsBuilt();
scoreOperations.cc:1028:    class_<O_ScoreIntraMolecularVdwCollisions>(e[01;31m-[00m>lisp())
scoreOperations.cc:1046:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
scoreOperations.cc:1052:    this[01;31m-[00m>Base::initialize();
scoreOperations.cc:1057:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:1062:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1063:    this[01;31m-[00m>Base::oligomerChanged(builder);
scoreOperations.cc:1067:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1068:    this[01;31m-[00m>Base::sequenceChanged(builder);
scoreOperations.cc:1073:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1074:    ASSERT(this[01;31m-[00m>_Rejector[01;31m-[00m>notNil());
scoreOperations.cc:1076:    RPVdwCollisionRejector vdwRejector = this[01;31m-[00m>_Rejector[01;31m-[00m>as<O_VdwCollisionRejector>();
scoreOperations.cc:1077:    double score = vdwRejector[01;31m-[00m>countIntraMolecularVdwCollisions(builder[01;31m-[00m>as<O_Builder>(),scorerState);
scoreOperations.cc:1078:    double scaledScore = score*this[01;31m-[00m>_Scale;
scoreOperations.cc:1086:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1087:    ASSERT(this[01;31m-[00m>_Rejector[01;31m-[00m>notNil());
scoreOperations.cc:1088:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:1089:    RPVdwCollisionRejector vdwRejector = this[01;31m-[00m>_Rejector[01;31m-[00m>as<O_VdwCollisionRejector>();
scoreOperations.cc:1090:    RPRenderDisplayList mine = vdwRejector[01;31m-[00m>getRenderForIntraMolecularVdwCollisions(builder[01;31m-[00m>as<O_Builder>(),scorerState);
scoreOperations.cc:1091:    dl[01;31m-[00m>add(mine);
scoreOperations.cc:1095:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1096:	// Do nothing, the normal non[01;31m-[00mbond interactions will handle IntraMolecular Nonbond terms
scoreOperations.cc:1104:    class_<O_ScoreInterMolecularVdwCollisions>(e[01;31m-[00m>lisp())
scoreOperations.cc:1121:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
scoreOperations.cc:1127:    this[01;31m-[00m>Base::initialize();
scoreOperations.cc:1132:    this[01;31m-[00m>Base::archiveBase(node);
scoreOperations.cc:1137:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1138:    this[01;31m-[00m>Base::oligomerChanged(builder);
scoreOperations.cc:1142:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1143:    this[01;31m-[00m>Base::sequenceChanged(builder);
scoreOperations.cc:1148:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1149:    ASSERT(this[01;31m-[00m>_Rejector[01;31m-[00m>notNil());
scoreOperations.cc:1151:    RPVdwCollisionRejector vdwRejector = this[01;31m-[00m>_Rejector[01;31m-[00m>as<O_VdwCollisionRejector>();
scoreOperations.cc:1152:    double score = vdwRejector[01;31m-[00m>countInterMolecularVdwCollisions(builder[01;31m-[00m>as<O_Builder>(),scorerState);
scoreOperations.cc:1153:    double scaledScore = score*this[01;31m-[00m>_Scale;
scoreOperations.cc:1161:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1162:    ASSERT(builder[01;31m-[00m>notNil());
scoreOperations.cc:1163:    ASSERT(this[01;31m-[00m>_Rejector[01;31m-[00m>notNil());
scoreOperations.cc:1164:    RPVdwCollisionRejector vdwRejector = this[01;31m-[00m>_Rejector[01;31m-[00m>as<O_VdwCollisionRejector>();
scoreOperations.cc:1165:    RPRenderDisplayList mine = vdwRejector[01;31m-[00m>getRenderForInterMolecularVdwCollisions(builder,scorerState);
scoreOperations.cc:1166:    dl[01;31m-[00m>add(mine);
scoreOperations.cc:1171:{_F(this[01;31m-[00m>lisp());
scoreOperations.cc:1172:    RPVdwCollisionRejector vdwRejector = this[01;31m-[00m>_Rejector[01;31m-[00m>as<O_VdwCollisionRejector>();
scoreOperations.cc:1173:    RPMatter fixedMatter = vdwRejector[01;31m-[00m>getFixedMatter();
scoreOperations.cc:1174:    RPRestraintFixedNonbond restraint = O_RestraintFixedNonbond::create(this[01;31m-[00m>lisp(),fixedMatter);
scoreOperations.cc:1178:    restraints = O_Cons::create(restraint,restraints,this[01;31m-[00m>lisp());
scoreOperations.cc:1199:	class_<O_ScoreOperation>(this[01;31m-[00m>lisp())
scoreOperations.cc:1221:	class_<O_ScoreSuperposition>(this[01;31m-[00m>lisp())
scoreOperations.cc:1243:    class_<O_ScoreList>(this[01;31m-[00m>lisp())
scoreOperations.cc:1265:    class_<O_ScoreMin>(this[01;31m-[00m>lisp())
scoreOperations.cc:1285:    class_<O_ScoreSum>(this[01;31m-[00m>lisp())
scoreOperations.cc:1306:    class_<O_ScoreDistance>(this[01;31m-[00m>lisp())
scoreOperations.cc:1343:    class_<O_ScoreAngle>(this[01;31m-[00m>lisp())
scoreOperations.cc:1383:    class_<O_ScoreDihedral>(this[01;31m-[00m>lisp())
scoreOperations.cc:1431:    class_<O_ScoreNormalizedDotProduct>(this[01;31m-[00m>lisp())
scoreOperations.cc:1480:    class_<O_ScoreDistanceToPoint>(this[01;31m-[00m>lisp())
scoreOperations.cc:1516:    class_<O_ScoreBestGeometry>(this[01;31m-[00m>lisp())
scoreOperations.cc:1537:    class_<O_ScoreRejects>(this[01;31m-[00m>lisp())
scorer.cc:32:{_F(this[01;31m-[00m>lisp());
scorer.cc:33:    LOG(BF("Arguments before Base::oldLispInitialize =%s") % args[01;31m-[00m>__repr__() );
scorer.cc:34:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
scorer.cc:35:    LOG(BF("Arguments after Base::oldLispInitialize =%s") % args[01;31m-[00m>__repr__() );
scorer.cc:36:    if ( args[01;31m-[00m>numberOfPositionalArguments()<2 ) 
scorer.cc:37:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide 2 args: monomerAtomAlias position"));
scorer.cc:38:    this[01;31m-[00m>_Alias = args[01;31m-[00m>getPositionalArgument(0)[01;31m-[00m>as<O_Alias>();
scorer.cc:39:    this[01;31m-[00m>_FixedPosition = args[01;31m-[00m>getPositionalArgument(1)[01;31m-[00m>as<O_OVector3>()[01;31m-[00m>get();
scorer.cc:51:    this[01;31m-[00m>Base::initialize();
scorer.cc:52:    this[01;31m-[00m>_Alias = O_Alias::nil(this[01;31m-[00m>lisp());
scorer.cc:53:    this[01;31m-[00m>_MonomerId = [01;31m-[00m1;
scorer.cc:54:    this[01;31m-[00m>_AtomId = [01;31m-[00m1;
scorer.cc:67:    this[01;31m-[00m>Base::archiveBase(node);
scorer.cc:68:    node[01;31m-[00m>archiveObject("alias",this[01;31m-[00m>_Alias);
scorer.cc:69:    node[01;31m-[00m>archivePlainObjectIfDefined<Vector3>( "pos","Vector3",
scorer.cc:70:    					this[01;31m-[00m>_FixedPosition.isDefined(),
scorer.cc:71:					this[01;31m-[00m>_FixedPosition );
scorer.cc:77:{_F(this[01;31m-[00m>lisp());
scorer.cc:78:    this[01;31m-[00m>setAlias(alias);
scorer.cc:79:    this[01;31m-[00m>setPosition(pos);
scorer.cc:96:{_F(this[01;31m-[00m>lisp());
scorer.cc:97:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
scorer.cc:98:    RPCons items = args[01;31m-[00m>getAndRemoveOrDefault("superposeAtoms",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
scorer.cc:99:    this[01;31m-[00m>_ScoreCalculator = args[01;31m-[00m>getAndRemove("calculator")[01;31m-[00m>as<O_ScoreSum>();
scorer.cc:100:    for ( RPCons p=items; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr() )
scorer.cc:102:	RPSuperposeAlias item = p[01;31m-[00m>car<O_SuperposeAlias>();
scorer.cc:103:	this[01;31m-[00m>_Superposes.push_back(item);
scorer.cc:113:{_F(this[01;31m-[00m>lisp());
scorer.cc:115:    this[01;31m-[00m>Base::initialize();
scorer.cc:116:    this[01;31m-[00m>_SuperposeEngine = O_SuperposeEngine::nil(this[01;31m-[00m>lisp());
scorer.cc:117:    this[01;31m-[00m>_ScoreCalculator = O_ScoreSum::create(this[01;31m-[00m>lisp());
scorer.cc:118:    this[01;31m-[00m>_ScorerIdentifier = UndefinedUnsignedInt;
scorer.cc:126:{_F(this[01;31m-[00m>lisp());
scorer.cc:127:    this[01;31m-[00m>Base::archiveBase(node);
scorer.cc:128:    node[01;31m-[00m>archiveListOfObjectsSubClassOf(this[01;31m-[00m>_Superposes);
scorer.cc:129:    node[01;31m-[00m>archiveObject("calculator",this[01;31m-[00m>_ScoreCalculator);
scorer.cc:130:    node[01;31m-[00m>attribute("identifier",this[01;31m-[00m>_ScorerIdentifier);
scorer.cc:135:{_F(this[01;31m-[00m>lisp());
scorer.cc:139:    this[01;31m-[00m>Base::oligomerChanged(builder);
scorer.cc:140:    for ( it=this[01;31m-[00m>_Superposes.begin(); it!=this[01;31m-[00m>_Superposes.end(); it++ )
scorer.cc:142:	alias = (*it)[01;31m-[00m>getAlias();
scorer.cc:143:	monomerId = builder[01;31m-[00m>getMonomerIdForUniqueAlias(alias);
scorer.cc:144:	(*it)[01;31m-[00m>setMonomerId(monomerId);
scorer.cc:146:    if ( this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>notNil() )
scorer.cc:148:	if ( builder[01;31m-[00m>notNil() )
scorer.cc:150:            this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>oligomerChanged(builder);
scorer.cc:156:{_F(this[01;31m-[00m>lisp());
scorer.cc:159:    this[01;31m-[00m>Base::sequenceChanged(builder);
scorer.cc:160:    for ( it=this[01;31m-[00m>_Superposes.begin(); it!=this[01;31m-[00m>_Superposes.end(); it++ )
scorer.cc:162:        LOG(BF("MonomerId = %d") % (*it)[01;31m-[00m>getMonomerId()  ); // vp0(("MonomerId = %d",(*it)[01;31m-[00m>getMonomerId() ));
scorer.cc:163:	atomId = builder[01;31m-[00m>indexOfInterestingAtomWithAlias((*it)[01;31m-[00m>getMonomerId(),(*it)[01;31m-[00m>getAlias());
scorer.cc:165:	(*it)[01;31m-[00m>setAtomId(atomId);
scorer.cc:167:    if ( this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>notNil() )
scorer.cc:169:	if ( builder[01;31m-[00m>notNil() )
scorer.cc:171:            this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>sequenceChanged(builder);
scorer.cc:180:{_F(this[01;31m-[00m>lisp());
scorer.cc:181:    bool needsAll = this[01;31m-[00m>Base::needsAllAtomsBuilt();
scorer.cc:183:    return this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>needsAllAtomsBuilt();
scorer.cc:191:{_F(this[01;31m-[00m>lisp());
scorer.cc:194:    this[01;31m-[00m>_SuperposeEngine = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SuperposeEngine>();
scorer.cc:195:    fixed = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>();
scorer.cc:196:    moveable = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>();
scorer.cc:197:    for ( it=this[01;31m-[00m>_Superposes.begin(); it!=this[01;31m-[00m>_Superposes.end(); it++ )
scorer.cc:199:        fixed[01;31m-[00m>appendElement((*it)[01;31m-[00m>getPosition());
scorer.cc:203:        moveable[01;31m-[00m>appendElement((*it)[01;31m-[00m>getPosition());
scorer.cc:205:    this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>setFixedAllPoints(fixed);
scorer.cc:206:    this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>setMoveableAllPoints(moveable);
scorer.cc:212:{_F(this[01;31m-[00m>lisp());
scorer.cc:217:    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeEngine);
scorer.cc:218:    if ( this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>isNil() )
scorer.cc:220:        this[01;31m-[00m>_initializeSuperposeEngine();
scorer.cc:222:    moveable = this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>getMoveableCoordinates();
scorer.cc:223:    ASSERT(moveable[01;31m-[00m>size()==this[01;31m-[00m>_Superposes.size());
scorer.cc:229:	for ( sit=this[01;31m-[00m>_Superposes.begin(), cit=moveable[01;31m-[00m>begin();
scorer.cc:230:		    sit!=this[01;31m-[00m>_Superposes.end(); sit++, cit++ )
scorer.cc:232:	    pos = builder[01;31m-[00m>getUntransformedAtomPosition((*sit)[01;31m-[00m>getAtomId());
scorer.cc:233:	    LOG(BF("Position for atomId(%d) = %s") % (*sit)[01;31m-[00m>getAtomId() % pos.asString().c_str()  ); // vp0(("Position for atomId(%d) = %s",(*sit)[01;31m-[00m>getAtomId(),pos.asString().c_str() ));
scorer.cc:237:    transformToFixed = this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>superpose();
scorer.cc:243:    return this[01;31m-[00m>_Superposes.size()!=0;
scorer.cc:249:    ASSERTP(this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>notNil(),"You asked for the sum of squares of differences but you have no superpose engine");
scorer.cc:250:    double score = this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>sumOfSquaresOfDifferences(scorerState);
scorer.cc:255:{_F(this[01;31m-[00m>lisp());
scorer.cc:258:    this[01;31m-[00m>throwIfBuilderOutOfSync(builder);
scorer.cc:259:    LOG(BF("Setting scorerState ScorerIdentifier to %d")% this[01;31m-[00m>getScorerIdentifier() );
scorer.cc:260:    scorerState[01;31m-[00m>clear();
scorer.cc:262:    scorerState[01;31m-[00m>setScorerIdentifier(this[01;31m-[00m>getScorerIdentifier());
scorer.cc:264:    ASSERT(builder[01;31m-[00m>notNil());
scorer.cc:266:    if ( this[01;31m-[00m>_Superposes.size() > 0 )
scorer.cc:273:		this[01;31m-[00m>_doSuperpose(builder,transform);
scorer.cc:276:	    scorerState[01;31m-[00m>scoreLog() << "I don't log the superpose operation but here is a summary of the superposition and results" << endl;
scorer.cc:277:	    this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>sumOfSquaresOfDifferences(scorerState );
scorer.cc:279:	    LOG_SCORE( scorerState,BF( "Did superpose for %s got transform: \n%s")% builder[01;31m-[00m>stateIdentifier() % transform.asString() );
scorer.cc:280://	    LOG_SCORE(BF( scorerState, "Superposition report:\n%s")% this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>report() );
scorer.cc:281://	    scorerState[01;31m-[00m>setScoreTransform(transform);
scorer.cc:282:    LOG_SCORE(scorerState,BF("Builder state after superposition:{\n%s\n}")% builder[01;31m-[00m>stateAsString() );
scorer.cc:284:	if ( this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>isNil() )
scorer.cc:286:	    LOG_SCORE(scorerState,BF("There is no ScoreCalculator [01;31m-[00m calculating score from superposeEngine"));
scorer.cc:288:	    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeEngine);
scorer.cc:289:	    ASSERT(this[01;31m-[00m>_SuperposeEngine[01;31m-[00m>notNil());
scorer.cc:290:	    score = this[01;31m-[00m>calculateSuperposerSumOfSquaresOfDifferences(scorerState);
scorer.cc:291:	    scorerState[01;31m-[00m>setScore(score);
scorer.cc:294:	    score = this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>evaluate(scorerState, this[01;31m-[00m>sharedThis<O_Scorer>(),builder);
scorer.cc:296:	    scorerState[01;31m-[00m>setScore(score);
scorer.cc:300:	if ( this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>isNil() )
scorer.cc:302:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("There must be either a Superposer or a score calculator"));
scorer.cc:304:	score = this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>evaluate(scorerState, this[01;31m-[00m>sharedThis<O_Scorer>(),builder);
scorer.cc:306:	scorerState[01;31m-[00m>setScore(score);
scorer.cc:315:    this[01;31m-[00m>_evaluate(builder,scorerState,true);
scorer.cc:320:    this[01;31m-[00m>_evaluate(builder,scorerState,false);
scorer.cc:323:{_F(this[01;31m-[00m>lisp());
scorer.cc:324:    this[01;31m-[00m>_ScorerIdentifier = id;
scorer.cc:328:{_F(this[01;31m-[00m>lisp());
scorer.cc:329:    return this[01;31m-[00m>_ScorerIdentifier;
scorer.cc:334:{_F(this[01;31m-[00m>lisp());
scorer.cc:335:    this[01;31m-[00m>throwIfBuilderOutOfSync(builder);
scorer.cc:336:    RPRenderDisplayList dlAll = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
scorer.cc:337:    dlAll[01;31m-[00m>setName("Scorer");
scorer.cc:339:    if ( this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>notNil() )
scorer.cc:341:        dlOps = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
scorer.cc:342:	this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>renderIntoDisplayList(dlOps,scorerState,
scorer.cc:343:					this[01;31m-[00m>sharedThis<O_Scorer>(),builder);
scorer.cc:346:	dlOps = this[01;31m-[00m>renderSuperposeDeviations(builder,scorerState );
scorer.cc:348:    dlAll[01;31m-[00m>add(dlOps);
scorer.cc:349:    dlAll[01;31m-[00m>add(this[01;31m-[00m>Base::getRenderForScore(builder,scorerState));
scorer.cc:350:    if ( this[01;31m-[00m>getBackgroundRender()[01;31m-[00m>notNil() )
scorer.cc:352:	dlAll[01;31m-[00m>add(this[01;31m-[00m>getBackgroundRender());
scorer.cc:358:{_F(this[01;31m-[00m>lisp());
scorer.cc:362:    this[01;31m-[00m>throwIfBuilderOutOfSync(builder);
scorer.cc:363:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
scorer.cc:365:    dl[01;31m-[00m>setName("superposeDeviations");
scorer.cc:366:    if ( this[01;31m-[00m>_Superposes.size() != 0 )
scorer.cc:368://	this[01;31m-[00m>_doSuperpose(this[01;31m-[00m>_LatestTransform);
scorer.cc:369:	RPGrColor color = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("yellow");
scorer.cc:370:	dl[01;31m-[00m>add(color);
scorer.cc:372:	for ( sit=this[01;31m-[00m>_Superposes.begin();
scorer.cc:373:		    sit!=this[01;31m-[00m>_Superposes.end(); sit++ )
scorer.cc:375:	    Vector3 moveablePos = builder[01;31m-[00m>getScoreTransformedAtomPosition((*sit)[01;31m-[00m>getAtomId(),scorerState);
scorer.cc:376:	    LOG(BF("Position for atomId(%d) = %s") % (*sit)[01;31m-[00m>getAtomId() % moveablePos.asString().c_str()  ); // vp0(("Position for atomId(%d) = %s",(*sit)[01;31m-[00m>getAtomId(),moveablePos.asString().c_str() ));
scorer.cc:377:	    LOG(BF("Line from moveablePos(%s) to (*sit)[01;31m-[00m>getPosition(%s)") % moveablePos.asString().c_str() % (*sit)[01;31m-[00m>getPosition().asString().c_str()  ); // vp0(("Line from moveablePos(%s) to (*sit)[01;31m-[00m>getPosition(%s)", moveablePos.asString().c_str(), (*sit)[01;31m-[00m>getPosition().asString().c_str() ));
scorer.cc:378:	    RPGrLine line = O_GrLine::create(moveablePos,(*sit)[01;31m-[00m>getPosition(),this[01;31m-[00m>lisp());
scorer.cc:379:	    dl[01;31m-[00m>add(line);
scorer.cc:382:	    sdebug << "moveablePos atom(" << (*sit)[01;31m-[00m>getAtomId() << ") = " << moveablePos.asString() << endl;
scorer.cc:384:	    RPGrSphere sphere = O_GrSphere::create(moveablePos,0.1,this[01;31m-[00m>lisp());
scorer.cc:385:	    dl[01;31m-[00m>add(sphere);
scorer.cc:389:    RPGrInformation info = O_GrInformation::create(sdebug.str(),this[01;31m-[00m>lisp());
scorer.cc:390:    dl[01;31m-[00m>add(info);
scorer.cc:397:{_F(this[01;31m-[00m>lisp());
scorer.cc:398:    ASSERT_NOT_NULL(this[01;31m-[00m>_ScoreCalculator);
scorer.cc:399:    ASSERT(this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>notNil());
scorer.cc:400:    this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>addOperation(op);
scorer.cc:413:{_F(this[01;31m-[00m>lisp());
scorer.cc:415:    if ( this[01;31m-[00m>_Superposes.size()==0 )
scorer.cc:417:	this[01;31m-[00m>_LatestTransform.identity();
scorer.cc:420://        this[01;31m-[00m>_doSuperpose(this);
scorer.cc:423:    return this[01;31m-[00m>_LatestTransform;
scorer.cc:427:{_F(this[01;31m-[00m>lisp());
scorer.cc:428:    return this[01;31m-[00m>_LatestTransform;
scorer.cc:436:{_F(this[01;31m-[00m>lisp());
scorer.cc:437:    this[01;31m-[00m>throwIfBuilderOutOfSync(builder);
scorer.cc:439:    for ( it=this[01;31m-[00m>_Superposes.begin();
scorer.cc:440:    		 it!=this[01;31m-[00m>_Superposes.end(); it++ )
scorer.cc:442:	RPRestraintAnchor anchor = O_RestraintAnchor::create(this[01;31m-[00m>lisp());
scorer.cc:443:	RPAtom atom = builder[01;31m-[00m>getInterestingAtom((*it)[01;31m-[00m>getAtomId());
scorer.cc:444:	anchor[01;31m-[00m>setAtom(atom);
scorer.cc:445:	anchor[01;31m-[00m>setAnchorPos((*it)[01;31m-[00m>getPosition());
scorer.cc:446:	anchor[01;31m-[00m>setWeight(anchorWeight);
scorer.cc:447:	restraints = O_Cons::create(anchor,restraints,this[01;31m-[00m>lisp());
scorer.cc:453:{_F(this[01;31m-[00m>lisp());
scorer.cc:454:    ASSERT_NOT_NULL(this[01;31m-[00m>_ScoreCalculator);
scorer.cc:455:    this[01;31m-[00m>_ScoreCalculator[01;31m-[00m>insertRestraints(builder,this[01;31m-[00m>sharedThis<O_Scorer>(),restraints);
scorer.cc:460:{_F(this[01;31m-[00m>lisp());
scorer.cc:461:    RPCons restraints = O_Cons::nil(this[01;31m-[00m>lisp());
scorer.cc:462:    this[01;31m-[00m>insertScoreOperationsIntoRestraintList(builder,restraints);
scorer.cc:472:	class_<O_Scorer>(this[01;31m-[00m>lisp())
scorer.cc:499:	class_<O_SuperposeAlias>(this[01;31m-[00m>lisp())
scorerBase.cc:26:    {_F(this[01;31m-[00m>lisp());
scorerBase.cc:27:	this[01;31m-[00m>Base::oldLispInitialize(args,env);
scorerBase.cc:28:	this[01;31m-[00m>_ScorerName = args[01;31m-[00m>getStringAndRemove("name");
scorerBase.cc:29:	this[01;31m-[00m>_BackgroundRender = args[01;31m-[00m>getAndRemoveOrDefault("render",O_Render::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Render>();
scorerBase.cc:40:	this[01;31m-[00m>Base::initialize();
scorerBase.cc:41:	this[01;31m-[00m>_BackgroundRender = O_Render::nil(this[01;31m-[00m>lisp());
scorerBase.cc:42:	this[01;31m-[00m>_Data = O_ObjectDictionary::create(this[01;31m-[00m>lisp());
scorerBase.cc:48:	ASSERT_NOT_NULL(this[01;31m-[00m>_Data);
scorerBase.cc:49:	ASSERT(this[01;31m-[00m>_Data[01;31m-[00m>notNil());
scorerBase.cc:50:	return this[01;31m-[00m>_Data;
scorerBase.cc:59:	node[01;31m-[00m>attributeIfNotDefault<string>("scorerName",this[01;31m-[00m>_ScorerName,"undefScorer");
scorerBase.cc:60:	node[01;31m-[00m>archiveObject("BackgroundRender",this[01;31m-[00m>_BackgroundRender);
scorerBase.cc:61:	node[01;31m-[00m>archiveObjectIfDefined("data",this[01;31m-[00m>_Data);
scorerBase.cc:69:    {_F(this[01;31m-[00m>lisp());
scorerBase.cc:71:	LOG(BF("Does the scorer need all atoms built? [01;31m-[00m> %d") % needs  ); // vp0(("Does the scorer need all atoms built? [01;31m-[00m> %d", needs ));
scorerBase.cc:78:	this[01;31m-[00m>storeOligomerChangeCounter(builder);
scorerBase.cc:84:    {_F(this[01;31m-[00m>lisp());
scorerBase.cc:85:	this[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(builder);
scorerBase.cc:86:	this[01;31m-[00m>storeSequenceChangeCounter(builder);
scorerBase.cc:91:	this[01;31m-[00m>oligomerChanged(builder);
scorerBase.cc:92:	this[01;31m-[00m>sequenceChanged(builder);
scorerBase.cc:98:	RPRenderDisplayList	render = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
scorerBase.cc:99:	render[01;31m-[00m>setName("Background");
scorerBase.cc:100:	render[01;31m-[00m>add(this[01;31m-[00m>_BackgroundRender);
scorerBase.cc:106:    {_F(this[01;31m-[00m>lisp());
scorerBase.cc:107:	this[01;31m-[00m>_OligomerChangeCounter = builder[01;31m-[00m>getOligomerChangeCounter();
scorerBase.cc:112:    {_F(this[01;31m-[00m>lisp());
scorerBase.cc:113:	this[01;31m-[00m>_SequenceChangeCounter = builder[01;31m-[00m>getSequenceChangeCounter();
scorerBase.cc:120:	this[01;31m-[00m>throwIfOligomerChangeCounterOutOfSync(builder);
scorerBase.cc:121:	this[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(builder);
scorerBase.cc:125:    {_F(this[01;31m-[00m>lisp());
scorerBase.cc:126:	if ( builder[01;31m-[00m>getOligomerChangeCounter() != this[01;31m-[00m>_OligomerChangeCounter )
scorerBase.cc:130:	    ss << builder[01;31m-[00m>getOligomerChangeCounter();
scorerBase.cc:132:	    ss << this[01;31m-[00m>_OligomerChangeCounter << ")";
scorerBase.cc:133:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
scorerBase.cc:138:	if ( builder[01;31m-[00m>getSequenceChangeCounter() != this[01;31m-[00m>_SequenceChangeCounter )
scorerBase.cc:142:	    ss << builder[01;31m-[00m>getSequenceChangeCounter();
scorerBase.cc:144:	    ss << this[01;31m-[00m>_SequenceChangeCounter << ")";
scorerBase.cc:145:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
scorerBase.cc:154:    {_F(this[01;31m-[00m>lisp());
scorerBase.cc:156:	this[01;31m-[00m>throwIfBuilderOutOfSync(builder);
scorerBase.cc:157:	rend = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
scorerBase.cc:158:	rend[01;31m-[00m>setName("ScorerBase");
scorerBase.cc:159:	string sequence = builder[01;31m-[00m>getCurrentSequence();
scorerBase.cc:161:	ss << "Score: " << scorerState[01;31m-[00m>getScore() << endl;
scorerBase.cc:165:	RPGrInformation info = O_GrInformation::create(ss.str(),this[01;31m-[00m>lisp());
scorerBase.cc:166:	rend[01;31m-[00m>add(info);
scorerBase.cc:174:	return O_ScorerState::create(this[01;31m-[00m>lisp());
scorerBase.cc:178:    {_F(this[01;31m-[00m>lisp());
scorerBase.cc:194:    {_F(this[01;31m-[00m>lisp());
scorerBase.cc:195:	this[01;31m-[00m>Base::oldLispInitialize(args,env);
scorerBase.cc:206:	this[01;31m-[00m>Base::initialize();
scorerBase.cc:217:	state[01;31m-[00m>setScore(0.0);
scorerBase.cc:218:	state[01;31m-[00m>setReject(false);
scorerBase.cc:230:	    class_<O_ScorerBase>(this[01;31m-[00m>lisp())
scorerBase.cc:266:	    class_<O_BuildAllSelectAll>(this[01;31m-[00m>lisp())
scorerStage.cc:20:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
scorerStage.cc:22:    this[01;31m-[00m>_Name = kargs[01;31m-[00m>getStringAndRemoveOrDefault("name","[01;31m-[00mnoStageName[01;31m-[00m");
scorerStage.cc:23:    this[01;31m-[00m>_Comment = kargs[01;31m-[00m>getStringAndRemoveOrDefault("comment","[01;31m-[00mnoStageComment[01;31m-[00m");
scorerStage.cc:28:    this[01;31m-[00m>Base::initialize();
scorerStage.cc:29:    this[01;31m-[00m>_Scorer = O_ScorerBase::nil(this[01;31m-[00m>lisp());
scorerStage.cc:30:    this[01;31m-[00m>_HitList = O_HitList::nil(this[01;31m-[00m>lisp());
scorerStage.cc:31:    this[01;31m-[00m>_Score = 1234.56789;
scorerStage.cc:36:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
scorerStage.cc:37:    node[01;31m-[00m>attribute("comment",this[01;31m-[00m>_Comment);
scorerStage.cc:38:    node[01;31m-[00m>archiveObject("hitList",this[01;31m-[00m>_HitList);
scorerStage.cc:39:    node[01;31m-[00m>archiveObject("scorer",this[01;31m-[00m>_Scorer);
scorerStage.cc:40:    node[01;31m-[00m>attribute("score",this[01;31m-[00m>_Score);
scorerStage.cc:45:{_F(this[01;31m-[00m>lisp());
scorerStage.cc:46:    this[01;31m-[00m>_Scorer = sc;
scorerStage.cc:51:{_F(this[01;31m-[00m>lisp());
scorerStage.cc:52:    return this[01;31m-[00m>_Scorer;
scorerStage.cc:57:{_F(this[01;31m-[00m>lisp());
scorerStage.cc:58:    this[01;31m-[00m>_HitList = sc;
scorerStage.cc:63:{_F(this[01;31m-[00m>lisp());
scorerStage.cc:64:    return this[01;31m-[00m>_HitList;
scorerStage.cc:73:	class_<O_ScorerStage>(this[01;31m-[00m>lisp())
scorerStageList.cc:18:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
scorerStageList.cc:25:    this[01;31m-[00m>Base::initialize();
scorerStageList.cc:30:    node[01;31m-[00m>archiveList("stages",this[01;31m-[00m>_Stages);
scorerStageList.cc:36:{_F(this[01;31m-[00m>lisp());
scorerStageList.cc:37:    this[01;31m-[00m>_Stages.push_back(stage);
scorerStageList.cc:41:{_F(this[01;31m-[00m>lisp());
scorerStageList.cc:43:    for ( it=this[01;31m-[00m>_Stages.end()[01;31m-[00m1; it>=this[01;31m-[00m>_Stages.begin(); it[01;31m-[00m[01;31m-[00m )
scorerStageList.cc:45:	if ( (*it)[01;31m-[00m>getName() == name ) return *it;
scorerStageList.cc:47:    return O_ScorerStage::nil(this[01;31m-[00m>lisp());
scorerStageList.cc:51:{_F(this[01;31m-[00m>lisp());
scorerStageList.cc:53:    RPCons entries = O_Cons::nil(this[01;31m-[00m>lisp());
scorerStageList.cc:54:    for ( it=this[01;31m-[00m>_Stages.end()[01;31m-[00m1; it>=this[01;31m-[00m>_Stages.begin(); it[01;31m-[00m[01;31m-[00m )
scorerStageList.cc:57:	entries = O_Cons::create(stage,entries,this[01;31m-[00m>lisp());
scorerStageList.cc:66:	class_<O_ScorerStageList>(this[01;31m-[00m>lisp())
scorerState.cc:26:    {_F(this[01;31m-[00m>lisp());
scorerState.cc:28:	return this[01;31m-[00m>_ScoreLog.str();
scorerState.cc:30:	return "Score evaluation logging is off [01;31m-[00m turn on DEBUG_SCORE_EVALUATION in foundation.h";
scorerState.cc:35:    {_F(this[01;31m-[00m>lisp());
scorerState.cc:44:	ss << " _Score: " << this[01;31m-[00m>_Score;
scorerState.cc:74:	this[01;31m-[00m>_ScoreSet = false;
scorerState.cc:75:	this[01;31m-[00m>_NumberOfTransforms = 0;
scorerState.cc:85:	this[01;31m-[00m>Base::initialize();
scorerState.cc:86:	this[01;31m-[00m>clear();
scorerState.cc:94:	node[01;31m-[00m>attribute("score",this[01;31m-[00m>_Score);
scorerState.cc:96:	node[01;31m-[00m>archiveStringStreamIfDefined("scoreLog",this[01;31m-[00m>_ScoreLog);
scorerState.cc:104:    {_F(this[01;31m-[00m>lisp());
scorerState.cc:105:	this[01;31m-[00m>_Score = r;
scorerState.cc:110:    {_F(this[01;31m-[00m>lisp());
scorerState.cc:111:	return this[01;31m-[00m>_Score;
scorerState.cc:117:	class_<O_ScorerState>(lisp[01;31m-[00m>lisp())
scorerStatistics.cc:19:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
scorerStatistics.cc:25:    this[01;31m-[00m>Base::initialize();
scorerStatistics.cc:26:    this[01;31m-[00m>reset();
scorerStatistics.cc:37:    this[01;31m-[00m>_NumberOfBuilds = 0;
scorerStatistics.cc:38:    this[01;31m-[00m>_NumberOfRejects = 0;
scorerStatistics.cc:39:    this[01;31m-[00m>_NumberOfHits = 0;
scorerStatistics.cc:40:    this[01;31m-[00m>_BuildsToLatestHit = 0;
scorerStatistics.cc:44:{_F(this[01;31m-[00m>lisp());
scorerStatistics.cc:45:    this[01;31m-[00m>_NumberOfBuilds++;
scorerStatistics.cc:49:{_F(this[01;31m-[00m>lisp());
scorerStatistics.cc:50:    this[01;31m-[00m>_NumberOfHits++;
scorerStatistics.cc:51:    this[01;31m-[00m>_BuildsToLatestHit = this[01;31m-[00m>_NumberOfBuilds;
scorerStatistics.cc:56:{_F(this[01;31m-[00m>lisp());
scorerStatistics.cc:58:    ss << "Builds(" << this[01;31m-[00m>_NumberOfBuilds << ")";
scorerStatistics.cc:59:    ss << " Rejects(" << this[01;31m-[00m>_NumberOfRejects << ")";
scorerStatistics.cc:60:    ss << " Hits(" << this[01;31m-[00m>_NumberOfHits << ")";
scorerStatistics.cc:61:    ss << " BuildsToLastHit("<<this[01;31m-[00m>_BuildsToLatestHit<<")";
scorerStatistics.cc:72:	class_<O_ScorerStatistics>(this[01;31m-[00m>lisp())
scorerVirtualMachine.cc:48:	this[01;31m-[00m>_HasTransform = true;
scorerVirtualMachine.cc:49:	this[01;31m-[00m>_TransformUpdateCounter++;
scorerVirtualMachine.cc:50:	this[01;31m-[00m>_Transform = m;
scorerVirtualMachine.cc:55:	this[01;31m-[00m>_SuperposeRms = val;
scorerVirtualMachine.cc:61:	SVM_ASSERT(index<this[01;31m-[00m>_Vectors.size());
scorerVirtualMachine.cc:62:	VectorReference& ref = this[01;31m-[00m>_Vectors[index];
scorerVirtualMachine.cc:64:	if ( !this[01;31m-[00m>_HasTransform )
scorerVirtualMachine.cc:70:	if ( this[01;31m-[00m>_TransformUpdateCounter != ref._TransformUpdateTest )
scorerVirtualMachine.cc:72:	    ref._TransformedVector = this[01;31m-[00m>_Transform.multiplyByVector3(ref._UntransformedVector);
scorerVirtualMachine.cc:73:	    ref._TransformUpdateTest = this[01;31m-[00m>_TransformUpdateCounter;
scorerVirtualMachine.cc:81:	lisp_TOSS(machine[01;31m-[00m>lisp(),machine[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Hit a missing O_ScorerVirtualMachine operation(%s)") %  scoreCommandAsString(cmd,machine[01;31m-[00m>lisp())));
scorerVirtualMachine.cc:86:	SReal val = machine[01;31m-[00m>topReal();
scorerVirtualMachine.cc:87:	machine[01;31m-[00m>pushReal(val);
scorerVirtualMachine.cc:92:	machine[01;31m-[00m>pushReal(0.0);
scorerVirtualMachine.cc:96:	machine[01;31m-[00m>pushReal(1.0);
scorerVirtualMachine.cc:100:	machine[01;31m-[00m>pushReal(2.0);
scorerVirtualMachine.cc:104:	SReal value = machine[01;31m-[00m>lookupRealConstant(cmd._Index);
scorerVirtualMachine.cc:105:	machine[01;31m-[00m>pushReal(value);
scorerVirtualMachine.cc:109:	SReal y = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:110:	machine[01;31m-[00m>replaceTopReal(machine[01;31m-[00m>topReal()+y);
scorerVirtualMachine.cc:114:	SReal y = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:115:	machine[01;31m-[00m>replaceTopReal(machine[01;31m-[00m>topReal()[01;31m-[00my);
scorerVirtualMachine.cc:119:	SReal y = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:120:	machine[01;31m-[00m>replaceTopReal(machine[01;31m-[00m>topReal()*y);
scorerVirtualMachine.cc:124:	SReal y = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:125:	machine[01;31m-[00m>replaceTopReal(machine[01;31m-[00m>topReal()/y);
scorerVirtualMachine.cc:134:	machine[01;31m-[00m>selectSuperposeEngine(cmd._ArrayId);
scorerVirtualMachine.cc:141:	machine[01;31m-[00m>selectedSuperposeEngine()[01;31m-[00m>eraseMoveablePoints();
scorerVirtualMachine.cc:148:	machine[01;31m-[00m>selectedSuperposeEngine()[01;31m-[00m>eraseFixedPoints();
scorerVirtualMachine.cc:167:	machine[01;31m-[00m>setRunFlag(false);
scorerVirtualMachine.cc:184:	RPSuperposeEngine superposer = machine[01;31m-[00m>selectedSuperposeEngine();
scorerVirtualMachine.cc:185:	Vector3& vec = machine[01;31m-[00m>resolveVector(cmd);
scorerVirtualMachine.cc:186:	superposer[01;31m-[00m>appendMoveablePoint(vec);
scorerVirtualMachine.cc:194:	RPSuperposeEngine superposer = machine[01;31m-[00m>selectedSuperposeEngine();
scorerVirtualMachine.cc:195:	Vector3& vec = machine[01;31m-[00m>resolveVector(cmd);
scorerVirtualMachine.cc:196:	superposer[01;31m-[00m>appendFixedPoint(vec);
scorerVirtualMachine.cc:205:	RPSuperposeEngine superposer = machine[01;31m-[00m>selectedSuperposeEngine();
scorerVirtualMachine.cc:206:	Matrix transform = superposer[01;31m-[00m>superpose();
scorerVirtualMachine.cc:207:	AliasReferencerHolder& target = machine[01;31m-[00m>aliasReferencers(cmd._ArrayId);
scorerVirtualMachine.cc:209:	target.setSuperposeRms(superposer[01;31m-[00m>rootMeanSquareDifference());
scorerVirtualMachine.cc:215:	SReal value = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:216:	RPScorerState scorerState = machine[01;31m-[00m>getScorerState();
scorerVirtualMachine.cc:217:	if (!machine[01;31m-[00m>getScorerState()[01;31m-[00m>isScoreSet() || (value<scorerState[01;31m-[00m>getScore()))
scorerVirtualMachine.cc:219:	    machine[01;31m-[00m>writeMachineStateToScorerState();
scorerVirtualMachine.cc:226:	machine[01;31m-[00m>pushAlias(cmd);
scorerVirtualMachine.cc:231:      Real[[01;31m-[00m1] force
scorerVirtualMachine.cc:233:      Alias[[01;31m-[00m1] VectorB
scorerVirtualMachine.cc:234:      [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m>  Real[0] (|VecA[01;31m-[00mVecB|[01;31m-[00mOptimal)^2*force
scorerVirtualMachine.cc:238:	ScoreCommand refB = machine[01;31m-[00m>popAlias();
scorerVirtualMachine.cc:239:	ScoreCommand refA = machine[01;31m-[00m>popAlias();
scorerVirtualMachine.cc:240:	SReal optimal = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:241:	SReal force = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:242:	Vector3& vecA = machine[01;31m-[00m>resolveVector(refA);
scorerVirtualMachine.cc:243:	Vector3& vecB = machine[01;31m-[00m>resolveVector(refB);
scorerVirtualMachine.cc:244:	Vector3 vdiff = vecA[01;31m-[00mvecB;
scorerVirtualMachine.cc:246:	double diff = dist[01;31m-[00moptimal;
scorerVirtualMachine.cc:248:	machine[01;31m-[00m>pushReal(res);
scorerVirtualMachine.cc:255:      Real[[01;31m-[00m1] force
scorerVirtualMachine.cc:257:      Alias[[01;31m-[00m1] VectorB
scorerVirtualMachine.cc:258:      Alias[[01;31m-[00m2] VectorC
scorerVirtualMachine.cc:260:      Real[0] (angle(VecA,VecB,VecC)[01;31m-[00moptimalAngle)^2*force
scorerVirtualMachine.cc:264:	ScoreCommand refC = machine[01;31m-[00m>popAlias();
scorerVirtualMachine.cc:265:	ScoreCommand refB = machine[01;31m-[00m>popAlias();
scorerVirtualMachine.cc:266:	ScoreCommand refA = machine[01;31m-[00m>popAlias();
scorerVirtualMachine.cc:267:	SReal optimal = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:268:	SReal force = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:269:	Vector3& vecA = machine[01;31m-[00m>resolveVector(refA);
scorerVirtualMachine.cc:270:	Vector3& vecB = machine[01;31m-[00m>resolveVector(refB);
scorerVirtualMachine.cc:271:	Vector3& vecC = machine[01;31m-[00m>resolveVector(refC);
scorerVirtualMachine.cc:272:	double angle = calculateAngle(vecA,vecB,vecC,machine[01;31m-[00m>lisp());
scorerVirtualMachine.cc:273:	double diff = angle[01;31m-[00moptimal;
scorerVirtualMachine.cc:275:	machine[01;31m-[00m>pushReal(res);
scorerVirtualMachine.cc:281:      Real[[01;31m-[00m1] force
scorerVirtualMachine.cc:283:      Alias[[01;31m-[00m1] VectorB
scorerVirtualMachine.cc:284:      Alias[[01;31m-[00m2] VectorC
scorerVirtualMachine.cc:285:      Alias[[01;31m-[00m3] VectorD
scorerVirtualMachine.cc:287:      Real[0] (dihedral(VecA,VecB,VecC,VecD)[01;31m-[00moptimal)^2*force
scorerVirtualMachine.cc:291:	ScoreCommand refD = machine[01;31m-[00m>popAlias();
scorerVirtualMachine.cc:292:	ScoreCommand refC = machine[01;31m-[00m>popAlias();
scorerVirtualMachine.cc:293:	ScoreCommand refB = machine[01;31m-[00m>popAlias();
scorerVirtualMachine.cc:294:	ScoreCommand refA = machine[01;31m-[00m>popAlias();
scorerVirtualMachine.cc:295:	SReal optimal = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:296:	SReal force = machine[01;31m-[00m>popReal();
scorerVirtualMachine.cc:297:	Vector3& vecA = machine[01;31m-[00m>resolveVector(refA);
scorerVirtualMachine.cc:298:	Vector3& vecB = machine[01;31m-[00m>resolveVector(refB);
scorerVirtualMachine.cc:299:	Vector3& vecC = machine[01;31m-[00m>resolveVector(refC);
scorerVirtualMachine.cc:300:	Vector3& vecD = machine[01;31m-[00m>resolveVector(refD);
scorerVirtualMachine.cc:301:	double angle = calculateDihedral(vecA,vecB,vecC,vecD,machine[01;31m-[00m>lisp());
scorerVirtualMachine.cc:302:	double diff = angle[01;31m-[00moptimal;
scorerVirtualMachine.cc:304:	machine[01;31m-[00m>pushReal(res);
scorerVirtualMachine.cc:310:      Real[[01;31m-[00m1] force
scorerVirtualMachine.cc:311:      Real[[01;31m-[00m2] phase
scorerVirtualMachine.cc:313:      Alias[[01;31m-[00m1] VectorB
scorerVirtualMachine.cc:314:      Alias[[01;31m-[00m2] VectorC
scorerVirtualMachine.cc:315:      Alias[[01;31m-[00m3] VectorD
scorerVirtualMachine.cc:331:	RPSymbolToEnumConverter opConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_scorerOperationsToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
scorerVirtualMachine.cc:332:	return opConverter[01;31m-[00m>enumForSymbol<ScoreOperationEnum>(sym);
scorerVirtualMachine.cc:337: 	RPSymbolToEnumConverter opConverter = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_scorerOperationsToSymbolConverter))[01;31m-[00m>as<O_SymbolToEnumConverter>();
scorerVirtualMachine.cc:338:	return opConverter[01;31m-[00m>symbolForEnumIndex(sop);
scorerVirtualMachine.cc:348:	this[01;31m-[00m>_Referencer = lisp[01;31m-[00m>nil<O_AliasReferencer>();
scorerVirtualMachine.cc:349:	this[01;31m-[00m>_Vectors.clear();
scorerVirtualMachine.cc:356:	RPBinder opArgs = lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>lookup(lisp[01;31m-[00m>symbol(_sym_MbbPackage_scorerOperationsUseArgs))[01;31m-[00m>as<O_Binder>();
scorerVirtualMachine.cc:358:	RPObjectPair useArgs = opArgs[01;31m-[00m>lookup(opSymbol)[01;31m-[00m>as<O_ObjectPair>();
scorerVirtualMachine.cc:359:	bool useArg1 = useArgs[01;31m-[00m>first()[01;31m-[00m>as<O_Bool>()[01;31m-[00m>get();
scorerVirtualMachine.cc:360:	bool useArg2 = useArgs[01;31m-[00m>second()[01;31m-[00m>as<O_Bool>()[01;31m-[00m>get();
scorerVirtualMachine.cc:361:        string cmdString = (BF("%[01;31m-[00m20s") % opSymbol[01;31m-[00m>name() ).str();
scorerVirtualMachine.cc:384:	class_<O_ScorerVirtualMachine>(lisp[01;31m-[00m>lisp())
scorerVirtualMachine.cc:399:        lisp[01;31m-[00m>installGlobalInitializationCallback(&O_ScorerVirtualMachine::initializeGlobals);
scorerVirtualMachine.cc:405:	RPBinder useArgs = lisp[01;31m-[00m>create<O_Binder>();
scorerVirtualMachine.cc:406:	lisp[01;31m-[00m>hiddenBinder()[01;31m-[00m>extend(lisp[01;31m-[00m>symbol(_sym_MbbPackage_scorerOperationsUseArgs),useArgs);
scorerVirtualMachine.cc:411:	    RPSymbol sym = converter.symbolFromEnum(sop_addReal)[01;31m-[00m>as<O_Symbol>(); \
scorerVirtualMachine.cc:412:	    RPObjectPair objPair = lisp[01;31m-[00m>create<O_ObjectPair>(lisp[01;31m-[00m>create<O_Bool>(useArg1),lisp[01;31m-[00m>create<O_Bool>(useArg2)); \
scorerVirtualMachine.cc:413:	    useArgs[01;31m-[00m>extend(sym,objPair);				\
scorerVirtualMachine.cc:444:	    TOSS(lisp[01;31m-[00m>error(BF("Not all of the ScorerVirtualMachine operations were accounted for [01;31m-[00m there are %d operations in the enum and only %d were defined") % ((int)sop_end+1) % numberOfOperations  ));
scorerVirtualMachine.cc:450:	this[01;31m-[00m>Base::initialize();
scorerVirtualMachine.cc:451:	this[01;31m-[00m>_ScorerProgramCounterStart = 0;
scorerVirtualMachine.cc:452:	this[01;31m-[00m>_AppendingSetupCommands = true;
scorerVirtualMachine.cc:453:	this[01;31m-[00m>_ScorerState = this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_ScorerState>();
scorerVirtualMachine.cc:454:	this[01;31m-[00m>_ProgramCounter = false;
scorerVirtualMachine.cc:455:	this[01;31m-[00m>_RunFlag = false;
scorerVirtualMachine.cc:460:	this[01;31m-[00m>Base::archiveBase(node);
scorerVirtualMachine.cc:470:	this[01;31m-[00m>_Program.push_back(one);
scorerVirtualMachine.cc:475:	ASSERTF(this[01;31m-[00m>_AppendingSetupCommands,BF("You cannot appendSetupCommands after you started appending Scorer commands"));
scorerVirtualMachine.cc:476:	this[01;31m-[00m>_appendCommand(op,arrayId,index);
scorerVirtualMachine.cc:478:	this[01;31m-[00m>_ScorerProgramCounterStart = this[01;31m-[00m>_Program.size();
scorerVirtualMachine.cc:483:	this[01;31m-[00m>_appendCommand(op,arrayId,index);
scorerVirtualMachine.cc:484:	this[01;31m-[00m>_AppendingSetupCommands = false;
scorerVirtualMachine.cc:494:	AliasReferencerHolder& target = this[01;31m-[00m>_AliasReferencers[arrayId];
scorerVirtualMachine.cc:498:	    if ( target.vectors()[i]._AtomReference[01;31m-[00m>equal(atomRef) ) return i;
scorerVirtualMachine.cc:509:	SVM_ASSERT(arrayId<this[01;31m-[00m>_AliasReferencers.size());
scorerVirtualMachine.cc:510:	return this[01;31m-[00m>_AliasReferencers[arrayId];
scorerVirtualMachine.cc:521:	SByte arrayId = (SByte)(builder[01;31m-[00m>getScorerHandle());
scorerVirtualMachine.cc:522:	for ( uint i=this[01;31m-[00m>_ScorerProgramCounterStart; i!=this[01;31m-[00m>_Program.size(); i++ )
scorerVirtualMachine.cc:524:	    ScoreCommand& cmd = this[01;31m-[00m>_Program[i];
scorerVirtualMachine.cc:550:	return this[01;31m-[00m>_ProgramCounter;
scorerVirtualMachine.cc:556:	SVM_ASSERT(arrayId<this[01;31m-[00m>_SuperposeEngines.size());
scorerVirtualMachine.cc:557:	this[01;31m-[00m>_SelectedSuperposeEngine = this[01;31m-[00m>_SuperposeEngines[arrayId];
scorerVirtualMachine.cc:562:	return this[01;31m-[00m>_SelectedSuperposeEngine;
scorerVirtualMachine.cc:567:	RPCons cur = this[01;31m-[00m>lisp()[01;31m-[00m>cnil();
scorerVirtualMachine.cc:568:	for ( vector<SReal>::iterator it=this[01;31m-[00m>_RealStack.begin(); it!= this[01;31m-[00m>_RealStack.end(); it++)
scorerVirtualMachine.cc:570:	    cur = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Real>(*it),cur);
scorerVirtualMachine.cc:578:	SVM_ASSERT(address._ArrayId<this[01;31m-[00m>_AliasReferencers.size());
scorerVirtualMachine.cc:579:	AliasReferencerHolder& referencer = this[01;31m-[00m>_AliasReferencers[address._ArrayId];
scorerVirtualMachine.cc:594:	for (uint i=0; i<this[01;31m-[00m>_RealConstants.size(); i++ )
scorerVirtualMachine.cc:596:	    if ( this[01;31m-[00m>_RealConstants[i] == value ) return i;
scorerVirtualMachine.cc:598:	uint idx = this[01;31m-[00m>_RealConstants.size();
scorerVirtualMachine.cc:599:	this[01;31m-[00m>_RealConstants.push_back(value);
scorerVirtualMachine.cc:606:	this[01;31m-[00m>_Program.clear();
scorerVirtualMachine.cc:607:	this[01;31m-[00m>_RealConstants.clear();
scorerVirtualMachine.cc:608:	this[01;31m-[00m>_AliasReferencers.clear();
scorerVirtualMachine.cc:613:	RPCons first = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>();
scorerVirtualMachine.cc:615:	for ( vector<ScoreCommand>::iterator it=this[01;31m-[00m>_Program.begin();
scorerVirtualMachine.cc:616:	      it!=this[01;31m-[00m>_Program.end(); it++ )
scorerVirtualMachine.cc:618:	    ScoreOperationEnum sop = (ScoreOperationEnum)(it[01;31m-[00m>_Operation);
scorerVirtualMachine.cc:619:	    RPCons oneOp = O_Cons::createList(symbolForScoreOperation(sop,this[01;31m-[00m>lisp()),
scorerVirtualMachine.cc:620:					      this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Int>((int)(it[01;31m-[00m>_ArrayId)),
scorerVirtualMachine.cc:621:					      this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Int>((int)(it[01;31m-[00m>_Index)), this[01;31m-[00m>lisp());
scorerVirtualMachine.cc:622:	    RPCons one = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>(oneOp);
scorerVirtualMachine.cc:623:	    cur[01;31m-[00m>setCdr(one);
scorerVirtualMachine.cc:626:	return first[01;31m-[00m>cdr();
scorerVirtualMachine.cc:631:	RPCons first = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>();
scorerVirtualMachine.cc:633:	for ( vector<ScoreCommand>::iterator it=this[01;31m-[00m>_Program.begin();
scorerVirtualMachine.cc:634:	      it!=this[01;31m-[00m>_Program.end(); it++ )
scorerVirtualMachine.cc:636:	    RPString oneCmd = O_String::create(scoreCommandAsString(*it,this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
scorerVirtualMachine.cc:637:	    RPCons oneOp = O_Cons::create(oneCmd,this[01;31m-[00m>lisp());
scorerVirtualMachine.cc:638:	    RPCons one = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Cons>(oneOp);
scorerVirtualMachine.cc:639:	    cur[01;31m-[00m>setCdr(one);
scorerVirtualMachine.cc:642:	return first[01;31m-[00m>cdr();
scorerVirtualMachine.cc:650:	this[01;31m-[00m>_RealStack.clear();
scorerVirtualMachine.cc:651:	this[01;31m-[00m>_AliasReferencerStack.clear();
scorerVirtualMachine.cc:652:	this[01;31m-[00m>_RunFlag = true;
scorerVirtualMachine.cc:657:	this[01;31m-[00m>_reset();
scorerVirtualMachine.cc:658:	this[01;31m-[00m>_ProgramCounter = 0; /* Setup is at 0 */
scorerVirtualMachine.cc:663:	this[01;31m-[00m>_reset();
scorerVirtualMachine.cc:664:	this[01;31m-[00m>_ScorerState = ss;
scorerVirtualMachine.cc:665:	this[01;31m-[00m>_ProgramCounter = this[01;31m-[00m>_ScorerProgramCounterStart;
scorerVirtualMachine.cc:672:	if ( this[01;31m-[00m>_ProgramCounter >= this[01;31m-[00m>_Program.size() ) return false;
scorerVirtualMachine.cc:673:	if ( !this[01;31m-[00m>_RunFlag ) return false;
scorerVirtualMachine.cc:674:	ScoreCommand& cmd = this[01;31m-[00m>_Program[this[01;31m-[00m>_ProgramCounter++];
scorerVirtualMachine.cc:681:	    TOSS(this[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Error while evaluating ScorerVirtualMachine: %s") % err.message() ));
scorerVirtualMachine.cc:687:	    TOSS(this[01;31m-[00m>lisp()[01;31m-[00m>error(BF("Unknown error while evaluating ScorerVirtualMachine")));
scorerVirtualMachine.cc:702:	this[01;31m-[00m>runScorer(scorerState);
scorerVirtualMachine.cc:709:	this[01;31m-[00m>prepareToRunSetup();
scorerVirtualMachine.cc:710:	while ( this[01;31m-[00m>step() );
scorerVirtualMachine.cc:715:	this[01;31m-[00m>prepareToRunScorer(scorerState);
scorerVirtualMachine.cc:716:	while ( this[01;31m-[00m>step() );
scorerVirtualMachine.cc:721:	lisp_ASSERT(this[01;31m-[00m>lisp(),index<this[01;31m-[00m>_RealConstants.size());
scorerVirtualMachine.cc:722:	return this[01;31m-[00m>_RealConstants[index];
scorerVirtualMachine.cc:729:	uint idx = this[01;31m-[00m>_AliasReferencerStack.size();
scorerVirtualMachine.cc:731:	this[01;31m-[00m>_AliasReferencers.push_back(holder);
scorerVirtualMachine.cc:732:	this[01;31m-[00m>_SymbolToAliasReferencersIndex[sym] = idx;
search.cc:31:    node[01;31m-[00m>attribute("Verbosity",this[01;31m-[00m>_Verbosity);
search.cc:32:    node[01;31m-[00m>archiveObject("BuilderScorer",this[01;31m-[00m>_BuilderScorer);
search.cc:33://    node[01;31m-[00m>archiveObject("Builder",this[01;31m-[00m>_Builder);
search.cc:34://    node[01;31m-[00m>archiveObject("Scorer",this[01;31m-[00m>_Scorer);
search.cc:35:    node[01;31m-[00m>archiveObject("HitList",this[01;31m-[00m>_HitList);
search.cc:41:    this[01;31m-[00m>Base::initialize();
search.cc:42:    this[01;31m-[00m>setDefaultOptions();
search.cc:48:    this[01;31m-[00m>_Verbosity = 0;
search.cc:54:    this[01;31m-[00m>_Verbosity = kargs[01;31m-[00m>getIntAndRemoveOrDefault("verbosity",0);
search.cc:68:	class_<O_Search>(this[01;31m-[00m>lisp())
searchStatistics.cc:19:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
searchStatistics.cc:25:    this[01;31m-[00m>Base::initialize();
searchStatistics.cc:26:    this[01;31m-[00m>_ReportFrequency = UndefinedUnsignedInt;
searchStatistics.cc:27:    this[01;31m-[00m>reset();
searchStatistics.cc:32:    this[01;31m-[00m>_Builds = 0;
searchStatistics.cc:33:    this[01;31m-[00m>_Rejects = 0;
searchStatistics.cc:34:    this[01;31m-[00m>_Hits = 0;
searchStatistics.cc:41:    this[01;31m-[00m>Base::archiveBase(node);
searchStatistics.cc:42:    node[01;31m-[00m>attribute("ReportFrequency",this[01;31m-[00m>_ReportFrequency);
searchStatistics.cc:43:    node[01;31m-[00m>attribute("Builds",this[01;31m-[00m>_Builds);
searchStatistics.cc:44:    node[01;31m-[00m>attribute("Rejects",this[01;31m-[00m>_Rejects);
searchStatistics.cc:45:    node[01;31m-[00m>attribute("Hits",this[01;31m-[00m>_Hits);
searchStatistics.cc:51:    this[01;31m-[00m>_ReportFrequency = i;
searchStatistics.cc:57:    this[01;31m-[00m>_Builds++;
searchStatistics.cc:58:    if ( this[01;31m-[00m>_ReportFrequency == UndefinedUnsignedInt ) return;
searchStatistics.cc:59:    if ( ( this[01;31m-[00m>_Builds % this[01;31m-[00m>_ReportFrequency ) == 0 )
searchStatistics.cc:61:        _lisp[01;31m-[00m>print(BF("O_SearchStatistics::incrementBuilds>>%s") % this[01;31m-[00m>description().c_str() );
searchStatistics.cc:67:    return this[01;31m-[00m>_Builds;
searchStatistics.cc:73:    this[01;31m-[00m>_Rejects++;
searchStatistics.cc:78:    return this[01;31m-[00m>_Rejects;
searchStatistics.cc:84:    this[01;31m-[00m>_Hits++;
searchStatistics.cc:89:    return this[01;31m-[00m>_Hits;
searchStatistics.cc:95:    fmt % this[01;31m-[00m>_Builds % this[01;31m-[00m>_Rejects % this[01;31m-[00m>_Hits;
searchStatistics.cc:103:    class_<O_SearchStatistics>(this[01;31m-[00m>lisp())
simulatedAnnealing.cc:28:    node[01;31m-[00m>attribute("s",this[01;31m-[00m>_Score);
simulatedAnnealing.cc:29:    node[01;31m-[00m>attribute("a",this[01;31m-[00m>_Accepted);
simulatedAnnealing.cc:34:    return O_Cons::createList(env[01;31m-[00m>create<O_Real>(this[01;31m-[00m>_Score),env[01;31m-[00m>create<O_Bool>(this[01;31m-[00m>_Accepted),env);
simulatedAnnealing.cc:40:    node[01;31m-[00m>attribute("temperature",this[01;31m-[00m>_Temperature);
simulatedAnnealing.cc:41:    node[01;31m-[00m>archiveVectorPlainObjects("scores",this[01;31m-[00m>_Scores);
simulatedAnnealing.cc:48:    for ( vector<ScorePoint>::iterator it=this[01;31m-[00m>_Scores.begin(); it!=this[01;31m-[00m>_Scores.end(); it++ )
simulatedAnnealing.cc:50:	RPCons one = O_Cons::create(it[01;31m-[00m>asCons(env),O_Cons::nil(env),env);
simulatedAnnealing.cc:51:	cur[01;31m-[00m>setCdr(one);
simulatedAnnealing.cc:54:    RPCons result = O_Cons::createList(env[01;31m-[00m>create<O_Real>(this[01;31m-[00m>_Temperature),dummy[01;31m-[00m>cdr(),env);
simulatedAnnealing.cc:62:    this[01;31m-[00m>Base::initialize();
simulatedAnnealing.cc:63:    this[01;31m-[00m>_CreationTime = O_PosixTime::nil(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:64:    this[01;31m-[00m>_LastUpdateTime = O_PosixTime::nil(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:69:    this[01;31m-[00m>Base::archiveBase(node);
simulatedAnnealing.cc:70:    node[01;31m-[00m>archiveVectorPlainObjects("temperatureScoreSeries",this[01;31m-[00m>_TemperatureScoreSeries);
simulatedAnnealing.cc:71:    node[01;31m-[00m>archiveObject("creationTime",this[01;31m-[00m>_CreationTime);
simulatedAnnealing.cc:72:    node[01;31m-[00m>archiveObject("lastUpdateTime",this[01;31m-[00m>_LastUpdateTime);
simulatedAnnealing.cc:78:    if ( this[01;31m-[00m>_CreationTime[01;31m-[00m>isNil() )
simulatedAnnealing.cc:80:	this[01;31m-[00m>_CreationTime[01;31m-[00m>setToLocalTime();
simulatedAnnealing.cc:81:	this[01;31m-[00m>_LastUpdateTime[01;31m-[00m>setToLocalTime();
simulatedAnnealing.cc:85:    this[01;31m-[00m>_TemperatureScoreSeries.push_back(one);
simulatedAnnealing.cc:89:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:90:    ASSERT(this[01;31m-[00m>_TemperatureScoreSeries.size()!=0);
simulatedAnnealing.cc:91:    OneTemperatureScoreSeries& one = this[01;31m-[00m>_TemperatureScoreSeries.back();
simulatedAnnealing.cc:96:    this[01;31m-[00m>_LastUpdateTime[01;31m-[00m>setToLocalTime();
simulatedAnnealing.cc:104:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:105:    RPCons dummy = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
simulatedAnnealing.cc:107:    for (vector<OneTemperatureScoreSeries>::iterator it=this[01;31m-[00m>_TemperatureScoreSeries.begin();
simulatedAnnealing.cc:108:    	    it!=this[01;31m-[00m>_TemperatureScoreSeries.end(); it++ )
simulatedAnnealing.cc:110:	RPCons one = O_Cons::create(it[01;31m-[00m>asCons(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
simulatedAnnealing.cc:111:	cur[01;31m-[00m>setCdr(one);
simulatedAnnealing.cc:114:    return dummy[01;31m-[00m>cdr();
simulatedAnnealing.cc:118:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:119:    RPPosixTimeDuration dur = this[01;31m-[00m>_LastUpdateTime[01;31m-[00m>sub(this[01;31m-[00m>_CreationTime);
simulatedAnnealing.cc:128:	enum_<SimulatedAnnealingSearchType>(MbbPackage,"SimulatedAnnealingSearchType",_sym_MbbPackage_simulatedAnnealingSearchTypeConverter,e[01;31m-[00m>lisp())
simulatedAnnealing.cc:136:    class_<O_ScoreLoggerList>(lisp[01;31m-[00m>lisp())
simulatedAnnealing.cc:140:    lisp[01;31m-[00m>installGlobalInitializationCallback(O_ScoreLoggerList::initializeGlobals);
simulatedAnnealing.cc:158:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
simulatedAnnealing.cc:163:    this[01;31m-[00m>_ScoreLoggers.clear();
simulatedAnnealing.cc:168:    this[01;31m-[00m>Base::archiveBase(node);
simulatedAnnealing.cc:169:    node[01;31m-[00m>archiveList("scoreLoggers",this[01;31m-[00m>_ScoreLoggers);
simulatedAnnealing.cc:175:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:176:    this[01;31m-[00m>_ScoreLoggers.append(logger);
simulatedAnnealing.cc:184:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:185:    RPCons first = O_Cons::create(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:187:    for (List<O_ScoreLogger>::iterator si=this[01;31m-[00m>_ScoreLoggers.begin(); si!=this[01;31m-[00m>_ScoreLoggers.end(); si++ )
simulatedAnnealing.cc:189:        RPCons one = O_Cons::create((*si)[01;31m-[00m>asCons(),this[01;31m-[00m>lisp());
simulatedAnnealing.cc:190:	cur[01;31m-[00m>setCdr(one);
simulatedAnnealing.cc:193:    return first[01;31m-[00m>cdr();
simulatedAnnealing.cc:211:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:212:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
simulatedAnnealing.cc:213:    RPBuilderScorer builderScorer = kargs[01;31m-[00m>getAndRemove("builderScorer")[01;31m-[00m>as<O_BuilderScorer>();
simulatedAnnealing.cc:214:    RPHitList hitList = kargs[01;31m-[00m>getAndRemove("hitList")[01;31m-[00m>as<O_HitList>();
simulatedAnnealing.cc:215:    int searchType = kargs[01;31m-[00m>getIntAndRemove("searchType");
simulatedAnnealing.cc:216:    RPCons options = kargs[01;31m-[00m>getAndRemoveOrDefault("options",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
simulatedAnnealing.cc:217:    this[01;31m-[00m>setBuilderScorer(builderScorer);
simulatedAnnealing.cc:218:    this[01;31m-[00m>setHitList(hitList);
simulatedAnnealing.cc:219:    this[01;31m-[00m>setOptions(options);
simulatedAnnealing.cc:220:    this[01;31m-[00m>setSearchType((SimulatedAnnealingSearchType)(searchType));
simulatedAnnealing.cc:221:    this[01;31m-[00m>takeInitialStep();
simulatedAnnealing.cc:226:    this[01;31m-[00m>Base::initialize();
simulatedAnnealing.cc:227:    this[01;31m-[00m>_TookInitialStep = false;
simulatedAnnealing.cc:228:    this[01;31m-[00m>_ScoreLogger = O_ScoreLogger::nil(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:229:    this[01;31m-[00m>setDefaultOptions();
simulatedAnnealing.cc:237:    this[01;31m-[00m>Base::setDefaultOptions();
simulatedAnnealing.cc:238:    this[01;31m-[00m>_UseRandomConformations = true;
simulatedAnnealing.cc:239:    this[01;31m-[00m>_MaxPerturbationsToFindStartingPoint = 10000;
simulatedAnnealing.cc:240:    this[01;31m-[00m>_NumberOfTemperatureEstimationSteps = 100;
simulatedAnnealing.cc:241:    this[01;31m-[00m>_NumberOfConformationsPerSequence= 100;
simulatedAnnealing.cc:242:    this[01;31m-[00m>_NumberOfTemperatureSteps= 100;
simulatedAnnealing.cc:243:    this[01;31m-[00m>_NumberOfStepsPerTemperature = 100;
simulatedAnnealing.cc:244:    this[01;31m-[00m>_EstimateInitialTemperature = true;
simulatedAnnealing.cc:245:    this[01;31m-[00m>_InitialTemperature = 1.0;
simulatedAnnealing.cc:246:    this[01;31m-[00m>_PerturbOligomerProbability = 0.01;
simulatedAnnealing.cc:247:    this[01;31m-[00m>_ShowProgress = true;
simulatedAnnealing.cc:248:    this[01;31m-[00m>_TemperatureStepScale = 0.9;
simulatedAnnealing.cc:249:    this[01;31m-[00m>_ScaleInitialTemperatureEstimate = 10.0;
simulatedAnnealing.cc:250:    this[01;31m-[00m>_MaxRejectsPerTemperatureEstimationStep = 1000;
simulatedAnnealing.cc:255:    this[01;31m-[00m>setKeyedOptions(options[01;31m-[00m>asKeyedArguments());
simulatedAnnealing.cc:260:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:262:    this[01;31m-[00m>Base::setKeyedOptions(koptions);
simulatedAnnealing.cc:263:    this[01;31m-[00m>_MaxPerturbationsToFindStartingPoint = koptions[01;31m-[00m>getIntAndRemoveOrDefault("MaxPerturbationsToFindStartingPoint",this[01;31m-[00m>_MaxPerturbationsToFindStartingPoint);
simulatedAnnealing.cc:264:    this[01;31m-[00m>_NumberOfConformationsPerSequence = koptions[01;31m-[00m>getIntAndRemoveOrDefault("NumberOfConformationsPerSequence",this[01;31m-[00m>_NumberOfConformationsPerSequence);
simulatedAnnealing.cc:265:    this[01;31m-[00m>_NumberOfTemperatureSteps = koptions[01;31m-[00m>getIntAndRemoveOrDefault("NumberOfTemperatureSteps",this[01;31m-[00m>_NumberOfTemperatureSteps);
simulatedAnnealing.cc:266:    this[01;31m-[00m>_NumberOfTemperatureEstimationSteps = koptions[01;31m-[00m>getIntAndRemoveOrDefault("NumberOfTemperatureEstimationSteps",this[01;31m-[00m>_NumberOfTemperatureEstimationSteps);
simulatedAnnealing.cc:267:    this[01;31m-[00m>_ScaleInitialTemperatureEstimate = koptions[01;31m-[00m>getDoubleAndRemoveOrDefault("ScaleInitialTemperatureEstimate",this[01;31m-[00m>_ScaleInitialTemperatureEstimate);
simulatedAnnealing.cc:268:    this[01;31m-[00m>_TemperatureStepScale = koptions[01;31m-[00m>getDoubleAndRemoveOrDefault("TemperatureStepScale",this[01;31m-[00m>_TemperatureStepScale);
simulatedAnnealing.cc:269:    this[01;31m-[00m>_NumberOfStepsPerTemperature = koptions[01;31m-[00m>getIntAndRemoveOrDefault("NumberOfStepsPerTemperature",this[01;31m-[00m>_NumberOfStepsPerTemperature);
simulatedAnnealing.cc:270:    this[01;31m-[00m>_UseRandomConformations = koptions[01;31m-[00m>getBoolAndRemoveOrDefault("UseRandomConformations",this[01;31m-[00m>_UseRandomConformations);
simulatedAnnealing.cc:271:    if ( koptions[01;31m-[00m>recognizesKey("InitialTemperature") )
simulatedAnnealing.cc:273:	this[01;31m-[00m>_EstimateInitialTemperature = false;
simulatedAnnealing.cc:275:    this[01;31m-[00m>_InitialTemperature = koptions[01;31m-[00m>getDoubleAndRemoveOrDefault("InitialTemperature",this[01;31m-[00m>_InitialTemperature);
simulatedAnnealing.cc:276:    this[01;31m-[00m>_PerturbOligomerProbability = koptions[01;31m-[00m>getDoubleAndRemoveOrDefault("PerturbOligomerProbability",this[01;31m-[00m>_PerturbOligomerProbability);
simulatedAnnealing.cc:277:    koptions[01;31m-[00m>throwOnUnusedArguments(0);
simulatedAnnealing.cc:278:    if ( this[01;31m-[00m>_UseRandomConformations && this[01;31m-[00m>_NumberOfConformationsPerSequence <= 0 )
simulatedAnnealing.cc:280:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("If you set UseRandomConformations to true then you must specify numberOfConformationsPerSequence>0"));
simulatedAnnealing.cc:289:    ss << this[01;31m-[00m>className();
simulatedAnnealing.cc:292:#define	VAR(x) boost::format("%1%:%2%") % #x % this[01;31m-[00m>x
simulatedAnnealing.cc:307:    if ( args[01;31m-[00m>length()<2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a BuilderScorer and a hitList and optional:options"));
simulatedAnnealing.cc:308:    RPSimulatedAnnealingSearch search = lisp[01;31m-[00m>create<O_SimulatedAnnealingSearch>();
simulatedAnnealing.cc:309:    search[01;31m-[00m>setBuilderScorer(args[01;31m-[00m>listref<O_BuilderScorer>(0));
simulatedAnnealing.cc:310://    search[01;31m-[00m>setScorer(args[01;31m-[00m>listref<O_ScorerBase>(1));
simulatedAnnealing.cc:311:    search[01;31m-[00m>setHitList(args[01;31m-[00m>listref<O_HitList>(1));
simulatedAnnealing.cc:312:    search[01;31m-[00m>setSearchType(sequenceWithBestConformation);
simulatedAnnealing.cc:313:    if ( args[01;31m-[00m>length() == 3 )
simulatedAnnealing.cc:315:	RPCons options = args[01;31m-[00m>listref<O_Cons>(2);
simulatedAnnealing.cc:316:	search[01;31m-[00m>setOptions(options);
simulatedAnnealing.cc:318:    search[01;31m-[00m>takeInitialStep();
simulatedAnnealing.cc:319:    search[01;31m-[00m>run();
simulatedAnnealing.cc:326:    if ( args[01;31m-[00m>length()<2 ) TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide a BuilderScorer and a hitList and optional:options"));
simulatedAnnealing.cc:327:    RPSimulatedAnnealingSearch search = lisp[01;31m-[00m>lisp()[01;31m-[00m>create<O_SimulatedAnnealingSearch>();
simulatedAnnealing.cc:328:    search[01;31m-[00m>setBuilderScorer(args[01;31m-[00m>listref<O_BuilderScorer>(0));
simulatedAnnealing.cc:329://    search[01;31m-[00m>setScorer(args[01;31m-[00m>listref<O_ScorerBase>(1));
simulatedAnnealing.cc:330:    search[01;31m-[00m>setHitList(args[01;31m-[00m>listref<O_HitList>(1));
simulatedAnnealing.cc:331:    search[01;31m-[00m>setSearchType(bestConformationOfOneSequence);
simulatedAnnealing.cc:332:    if ( args[01;31m-[00m>length() == 3 )
simulatedAnnealing.cc:334:	RPCons options = args[01;31m-[00m>listref<O_Cons>(2);
simulatedAnnealing.cc:335:	search[01;31m-[00m>setOptions(options);
simulatedAnnealing.cc:337:    search[01;31m-[00m>takeInitialStep();
simulatedAnnealing.cc:338:    search[01;31m-[00m>run();
simulatedAnnealing.cc:344:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:349:    if ( randomNumber01(_lisp)<this[01;31m-[00m>_PerturbOligomerProbability )
simulatedAnnealing.cc:351://	if (this[01;31m-[00m>_ShowProgress) _lisp[01;31m-[00m>print(BF( "      Perturbing oligomer/sequence" ));
simulatedAnnealing.cc:352:	builder[01;31m-[00m>perturbOligomer();
simulatedAnnealing.cc:355://	if ( this[01;31m-[00m>_ShowProgress ) _lisp[01;31m-[00m>print(BF( "      Perturbing sequence" ));
simulatedAnnealing.cc:356:	builder[01;31m-[00m>perturbSequence();
simulatedAnnealing.cc:363:    builderScorer[01;31m-[00m>perturbSequence();
simulatedAnnealing.cc:364:    if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:366:	string sequence = builderScorer[01;31m-[00m>getSequenceAsString();
simulatedAnnealing.cc:367:	_lisp[01;31m-[00m>print(BF("#  sequence = %s") % sequence.c_str() );
simulatedAnnealing.cc:374:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:377:    bestScorerState[01;31m-[00m>clear();
simulatedAnnealing.cc:378:    RPScorerState tempScorerState = builderScorer[01;31m-[00m>createScorerState();
simulatedAnnealing.cc:379:    LongLongInt numberOfConformations = this[01;31m-[00m>_NumberOfConformationsPerSequence;
simulatedAnnealing.cc:382:	numberOfConformations = builderScorer[01;31m-[00m>numberOfNecessaryConformationsInCurrentSequence();
simulatedAnnealing.cc:384:    if ( !this[01;31m-[00m>_UseRandomConformations )
simulatedAnnealing.cc:386:	builderScorer[01;31m-[00m>firstConformation();
simulatedAnnealing.cc:390:	if ( this[01;31m-[00m>_UseRandomConformations )
simulatedAnnealing.cc:392:	    builderScorer[01;31m-[00m>randomizeConformation();
simulatedAnnealing.cc:395:	    builderScorer[01;31m-[00m>incrementConformation();
simulatedAnnealing.cc:397:	this[01;31m-[00m>_NumberOfConformationsBuilt++;
simulatedAnnealing.cc:398:	tempScorerState[01;31m-[00m>clear();
simulatedAnnealing.cc:399:	LOG(BF("The builder is now ready to score in state: %s")% builderScorer[01;31m-[00m>stateIdentifier());
simulatedAnnealing.cc:400:	builderScorer[01;31m-[00m>buildNecessaryUntransformedAtomPositionsAndEvaluateScorer(tempScorerState);
simulatedAnnealing.cc:401:	if ( tempScorerState[01;31m-[00m>isBetterThan(bestScorerState) )
simulatedAnnealing.cc:402:	{_BLOCK_TRACEF(BF("Found the best score so far = %lf")% tempScorerState[01;31m-[00m>getScore());
simulatedAnnealing.cc:403:	    builderScorer[01;31m-[00m>saveBuilderState(bestBuilderState);
simulatedAnnealing.cc:404:	    bestScorerState[01;31m-[00m>copyFromOtherState(tempScorerState);
simulatedAnnealing.cc:407:	    builderScorer[01;31m-[00m>getBuilder()[01;31m-[00m>logFirstInterestingAtom("simulatedAnnealing(repeat: just found better scoring state and just saved it)");
simulatedAnnealing.cc:409:	    LOG(bestBuilderState[01;31m-[00m>asXmlString().c_str());
simulatedAnnealing.cc:413:    builderScorer[01;31m-[00m>restoreConformationOfBuilderState(bestBuilderState);
simulatedAnnealing.cc:415:    builderScorer[01;31m-[00m>getBuilder()[01;31m-[00m>logFirstInterestingAtom("simulatedAnnealing(just restored best scoring state)");
simulatedAnnealing.cc:417:    builderScorer[01;31m-[00m>streamDump(builderStateStream);
simulatedAnnealing.cc:420:    LOG(bestBuilderState[01;31m-[00m>asXmlString().c_str());
simulatedAnnealing.cc:426:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:427:    ASSERT(this[01;31m-[00m>_TookInitialStep);
simulatedAnnealing.cc:428:    if ( this[01;31m-[00m>_SearchType == sequenceWithBestConformation )
simulatedAnnealing.cc:430:	this[01;31m-[00m>perturbSequence(builderScorer);
simulatedAnnealing.cc:431:	this[01;31m-[00m>searchForBestConformation(builderScorer,bestBuilderState,bestScorerState);
simulatedAnnealing.cc:433:    } else if ( this[01;31m-[00m>_SearchType == bestConformationOfOneSequence )
simulatedAnnealing.cc:438:	builderScorer[01;31m-[00m>perturbConformation();
simulatedAnnealing.cc:439:	this[01;31m-[00m>_NumberOfConformationsBuilt++;
simulatedAnnealing.cc:444:	bestScorerState[01;31m-[00m>clear();
simulatedAnnealing.cc:445:	builderScorer[01;31m-[00m>buildNecessaryUntransformedAtomPositionsAndEvaluateScorer(bestScorerState);
simulatedAnnealing.cc:447:	if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:449:	    _lisp[01;31m-[00m>print(BF("#  conformation score = %lf") % bestScorerState[01;31m-[00m>getScore() );
simulatedAnnealing.cc:451:	builderScorer[01;31m-[00m>saveBuilderState(bestBuilderState);
simulatedAnnealing.cc:454:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Unknown _SearchType"));
simulatedAnnealing.cc:460:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:461:    if (!this[01;31m-[00m>_TookInitialStep)
simulatedAnnealing.cc:463:	this[01;31m-[00m>takeInitialStep();
simulatedAnnealing.cc:465:    RPBuilderScorer builderScorer = this[01;31m-[00m>getBuilderScorer();
simulatedAnnealing.cc:467:    if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:469:	_lisp[01;31m-[00m>print(BF("Estimating initial temperature"));
simulatedAnnealing.cc:471:    RPBuilderState builderState = O_BuilderState::create(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:472:    RPScorerState bestScorerState = builderScorer[01;31m-[00m>createScorerState();
simulatedAnnealing.cc:473:    this[01;31m-[00m>perturbStateAndScore(builderScorer,builderState,bestScorerState);
simulatedAnnealing.cc:474:    double previousScore = bestScorerState[01;31m-[00m>getScore();
simulatedAnnealing.cc:477:    this[01;31m-[00m>_InitialTemperatureBuilds = 0;
simulatedAnnealing.cc:478:    this[01;31m-[00m>_InitialTemperatureRejects = 0;
simulatedAnnealing.cc:479:    for ( int i=0; i<this[01;31m-[00m>_NumberOfTemperatureEstimationSteps; i++ )
simulatedAnnealing.cc:484:	for ( uint ai=0; ai<this[01;31m-[00m>_MaxRejectsPerTemperatureEstimationStep; ai++ )
simulatedAnnealing.cc:486:	    this[01;31m-[00m>_InitialTemperatureBuilds++;
simulatedAnnealing.cc:487:            this[01;31m-[00m>perturbStateAndScore(builderScorer,builderState,bestScorerState);
simulatedAnnealing.cc:488:	    stats[01;31m-[00m>incrementBuilds();
simulatedAnnealing.cc:489:	    if (!bestScorerState[01;31m-[00m>getReject()) 
simulatedAnnealing.cc:494:		stats[01;31m-[00m>incrementRejects();
simulatedAnnealing.cc:495:		this[01;31m-[00m>_InitialTemperatureRejects++;
simulatedAnnealing.cc:501:	if ( bestScorerState[01;31m-[00m>getReject() )
simulatedAnnealing.cc:505:	    ss << "Attempted " << this[01;31m-[00m>_MaxRejectsPerTemperatureEstimationStep;
simulatedAnnealing.cc:507:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
simulatedAnnealing.cc:509:	stats[01;31m-[00m>incrementHits();
simulatedAnnealing.cc:510:	double curScore = bestScorerState[01;31m-[00m>getScore();
simulatedAnnealing.cc:511:	delta = bestScorerState[01;31m-[00m>getScore() [01;31m-[00m previousScore;
simulatedAnnealing.cc:512:	previousScore = bestScorerState[01;31m-[00m>getScore();
simulatedAnnealing.cc:515:	if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:519:		_lisp[01;31m-[00m>print(BF("%5s %8s %8s %8s") % "Step"%"Score"% "Delta"% "MaxDelta" );
simulatedAnnealing.cc:521:	    _lisp[01;31m-[00m>print(BF("%5d %8.3lf %8.3lf %8.3lf") % i% curScore% absDelta% largestDelta );
simulatedAnnealing.cc:524:    double initTemp = largestDelta*this[01;31m-[00m>_ScaleInitialTemperatureEstimate;
simulatedAnnealing.cc:525:    if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:527:	_lisp[01;31m-[00m>print(BF( "Initial temperature estimation report"));
simulatedAnnealing.cc:528:	_lisp[01;31m-[00m>print(BF( "Initial temperature = %lf") % initTemp );
simulatedAnnealing.cc:529:	_lisp[01;31m-[00m>print(BF( "There were %d builds and %d rejects")
simulatedAnnealing.cc:530:	    % this[01;31m-[00m>_InitialTemperatureBuilds
simulatedAnnealing.cc:531:	    % this[01;31m-[00m>_InitialTemperatureRejects );
simulatedAnnealing.cc:534:    return largestDelta*this[01;31m-[00m>_ScaleInitialTemperatureEstimate;
simulatedAnnealing.cc:541:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:542:    RPBuilderScorer builderScorer = this[01;31m-[00m>getBuilderScorer();
simulatedAnnealing.cc:543:    if ( this[01;31m-[00m>_SearchType == sequenceWithBestConformation )
simulatedAnnealing.cc:545:        builderScorer[01;31m-[00m>perturbOligomer();
simulatedAnnealing.cc:546:        builderScorer[01;31m-[00m>firstSequence();
simulatedAnnealing.cc:549:	builderScorer[01;31m-[00m>setupCurrentOligomerAndSequence();
simulatedAnnealing.cc:551:    builderScorer[01;31m-[00m>firstConformation();
simulatedAnnealing.cc:552:    this[01;31m-[00m>_TookInitialStep = true;
simulatedAnnealing.cc:557:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:558:    RPBuilderScorer builderScorer = this[01;31m-[00m>getBuilderScorer();
simulatedAnnealing.cc:559:    if ( this[01;31m-[00m>_SearchType == sequenceWithBestConformation )
simulatedAnnealing.cc:561:        builderScorer[01;31m-[00m>perturbOligomer();
simulatedAnnealing.cc:562:        builderScorer[01;31m-[00m>firstSequence();
simulatedAnnealing.cc:564:    builderScorer[01;31m-[00m>firstConformation();
simulatedAnnealing.cc:565:    double temperature = this[01;31m-[00m>_estimateInitialTemperature(stats);
simulatedAnnealing.cc:571:    this[01;31m-[00m>_ScoreLogger = O_ScoreLogger::create(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:576:    return this[01;31m-[00m>_ScoreLogger;
simulatedAnnealing.cc:583:    double delta = scorerState[01;31m-[00m>getScore() [01;31m-[00m currentScore;
simulatedAnnealing.cc:584:    if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:586:	_lisp[01;31m-[00m>print(BF("delta = %lf") % delta );
simulatedAnnealing.cc:588:    if ( !scorerState[01;31m-[00m>getReject() )
simulatedAnnealing.cc:593:	    double exponent = [01;31m-[00m delta / temperature;
simulatedAnnealing.cc:596:	    if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:598:		_lisp[01;31m-[00m>print(BF("rand(%lf) < a(%lf) = %d") % rand% a% (rand<a) );
simulatedAnnealing.cc:606:    _lisp[01;31m-[00m>print(BF( "acceptStep = %d") % acceptStep );
simulatedAnnealing.cc:612:{_F(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:615:    this[01;31m-[00m>_NumberOfConformationsBuilt = 0;
simulatedAnnealing.cc:617:    ASSERT_NOT_NULL(this[01;31m-[00m>_BuilderScorer);
simulatedAnnealing.cc:618:    ASSERT_NOT_NULL(this[01;31m-[00m>_HitList);
simulatedAnnealing.cc:619:    RPBuilderScorer builderScorer = this[01;31m-[00m>getBuilderScorer();
simulatedAnnealing.cc:620:    RPHitList hitList = this[01;31m-[00m>_HitList;
simulatedAnnealing.cc:622:    ASSERT(hitList[01;31m-[00m>notNil());
simulatedAnnealing.cc:623:    RPRender bestScoreGraphics = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
simulatedAnnealing.cc:624:    bestScoreGraphics[01;31m-[00m>setName("bestScore");
simulatedAnnealing.cc:625:    ASSERT(this[01;31m-[00m>_TookInitialStep);
simulatedAnnealing.cc:626:    RPScorerState scorerState = builderScorer[01;31m-[00m>createScorerState();
simulatedAnnealing.cc:627:    RPScorerState currentScorerState = builderScorer[01;31m-[00m>createScorerState();
simulatedAnnealing.cc:628:    RPBuilderState currentState = O_BuilderState::create(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:629:    RPBuilderState builderState = O_BuilderState::create(this[01;31m-[00m>lisp());
simulatedAnnealing.cc:630:    if ( this[01;31m-[00m>_SearchType == sequenceWithBestConformation )
simulatedAnnealing.cc:632:	this[01;31m-[00m>searchForBestConformation(builderScorer,currentState,scorerState);
simulatedAnnealing.cc:634:    double temperature = this[01;31m-[00m>_InitialTemperature;
simulatedAnnealing.cc:635:    if ( this[01;31m-[00m>_EstimateInitialTemperature )
simulatedAnnealing.cc:637:	if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:639:	    _lisp[01;31m-[00m>print(BF("Estimating initial temperature"));
simulatedAnnealing.cc:641:	temperature = this[01;31m-[00m>estimateInitialTemperature(hitList[01;31m-[00m>getSearchStatistics());
simulatedAnnealing.cc:642:	if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:644:	    _lisp[01;31m-[00m>print(BF("Estimated initial temperature = %lf") % temperature);
simulatedAnnealing.cc:650:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Temperature cannot be zero!!!!!"));
simulatedAnnealing.cc:655:    builderScorer[01;31m-[00m>evaluateScorer(scorerState);
simulatedAnnealing.cc:656:    double currentScore = scorerState[01;31m-[00m>getScore();
simulatedAnnealing.cc:657:    this[01;31m-[00m>_Accepts = 0;
simulatedAnnealing.cc:658:    int maxInTempAccepts = MIN(10,((int)(0.1*this[01;31m-[00m>_NumberOfStepsPerTemperature)));
simulatedAnnealing.cc:659:    for ( int tempStep = 0; tempStep < this[01;31m-[00m>_NumberOfTemperatureSteps; tempStep++ )
simulatedAnnealing.cc:661:	if ( this[01;31m-[00m>_ScoreLogger[01;31m-[00m>notNil() )
simulatedAnnealing.cc:663:	    this[01;31m-[00m>_ScoreLogger[01;31m-[00m>newTemperature(temperature);
simulatedAnnealing.cc:666:        for ( int inTempStep = 0; inTempStep < this[01;31m-[00m>_NumberOfStepsPerTemperature; inTempStep++ )
simulatedAnnealing.cc:668:	    if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:670:		_lisp[01;31m-[00m>print(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m step start [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m"));
simulatedAnnealing.cc:671:		_lisp[01;31m-[00m>print(BF("Current state = %s   currentScore = %lf") % builderScorer[01;31m-[00m>changeCountersAsString().c_str()% currentScore );
simulatedAnnealing.cc:676:	    builderScorer[01;31m-[00m>saveBuilderState(currentState);
simulatedAnnealing.cc:682:                this[01;31m-[00m>perturbStateAndScore(builderScorer,builderState,scorerState);
simulatedAnnealing.cc:683:		LOG(BF("The best score I found was %lf")% scorerState[01;31m-[00m>getScore());
simulatedAnnealing.cc:685:	    if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:687:		_lisp[01;31m-[00m>print(BF("    Perturbed state %s    score = %lf") % builderState[01;31m-[00m>changeCountersAsString().c_str()% scorerState[01;31m-[00m>getScore() );
simulatedAnnealing.cc:689:			builderState[01;31m-[00m>changeCountersAsString().c_str()
simulatedAnnealing.cc:690:			% scorerState[01;31m-[00m>getScore() );
simulatedAnnealing.cc:693:	    builderScorer[01;31m-[00m>getBuilder()[01;31m-[00m>logFirstInterestingAtom("simulatedAnnealing(just left perturbStateAndScore)");
simulatedAnnealing.cc:695:	    builderScorer[01;31m-[00m>streamDump(log);
simulatedAnnealing.cc:696:	    LOG(BF("Just evaluated score(%lf) Logging state for OligomerBuilder")% scorerState[01;31m-[00m>getScore());
simulatedAnnealing.cc:701:	    if ( hitList[01;31m-[00m>isAHit(scorerState) )
simulatedAnnealing.cc:703:		LOG(BF("Adding hit with scorerState = %s")% scorerState[01;31m-[00m>summary());
simulatedAnnealing.cc:706:	    builderScorer[01;31m-[00m>getBuilder()[01;31m-[00m>logFirstInterestingAtom("simulatedAnnealing(about to call createHitWithStates)");
simulatedAnnealing.cc:708:		RPHit hit = hitList[01;31m-[00m>createHitWithStates(builderScorer,builderState,scorerState);
simulatedAnnealing.cc:714:	    acceptStep = this[01;31m-[00m>checkAccept(scorerState,temperature,currentScore);
simulatedAnnealing.cc:716:	    if ( this[01;31m-[00m>_ScoreLogger[01;31m-[00m>notNil() )
simulatedAnnealing.cc:718:		this[01;31m-[00m>_ScoreLogger[01;31m-[00m>appendScore(scorerState[01;31m-[00m>getScore(),acceptStep);
simulatedAnnealing.cc:722:		this[01;31m-[00m>_Accepts++;
simulatedAnnealing.cc:724:		currentScore = scorerState[01;31m-[00m>getScore();
simulatedAnnealing.cc:727:		builderScorer[01;31m-[00m>restoreState(currentState);
simulatedAnnealing.cc:735:	    if ( this[01;31m-[00m>_ShowProgress )
simulatedAnnealing.cc:740:        	int stepsLeft = this[01;31m-[00m>_NumberOfStepsPerTemperature[01;31m-[00minTempStep;
simulatedAnnealing.cc:741:		_lisp[01;31m-[00m>print(BF("  Step[%5d] Temp[%5.3lf] Prev.Score[%10.3lf] Score[%10.3lf] Accept[%3s] StepsLeft[%3d]") %  stepCount % temperature% prevScore% scorerState[01;31m-[00m>getScore()% acceptStr% stepsLeft  );
simulatedAnnealing.cc:746:	temperature *= this[01;31m-[00m>_TemperatureStepScale;
simulatedAnnealing.cc:748:    if ( this[01;31m-[00m>_ShowProgress ) 
simulatedAnnealing.cc:750:	_lisp[01;31m-[00m>print(BF("\nCarried out %d simulated annealing steps\n") % stepCount );
simulatedAnnealing.cc:751:	_lisp[01;31m-[00m>print(BF("\nBuild %d TOTAL structures\n") % this[01;31m-[00m>_NumberOfConformationsBuilt );
simulatedAnnealing.cc:760:	class_<O_ScoreLogger>(this[01;31m-[00m>lisp())
simulatedAnnealing.cc:783:	class_<O_SimulatedAnnealingSearch>(this[01;31m-[00m>lisp())
simulatedAnnealing.cc:791:	defNoWrapPackage(MbbPackage,"simulatedAnnealingSearchForSequenceWithBestConformation",&O_SimulatedAnnealingSearch::prim_simulatedAnnealingSearchForSequenceWithBestConformation,this[01;31m-[00m>lisp()); // ctor
simulatedAnnealing.cc:792:	defNoWrapPackage(MbbPackage,"simulatedAnnealingSearchForBestConformationOfOneSequence",&O_SimulatedAnnealingSearch::prim_simulatedAnnealingSearchForBestConformationOfOneSequence,this[01;31m-[00m>lisp()); // ctor
source.cc:46:	this[01;31m-[00m>out.insert(x);
source.cc:60:    for ( vi=this[01;31m-[00m>out.begin(); vi!=this[01;31m-[00m>out.end(); vi++ ) {
source.cc:104:    out << "CLASS name: " << this[01;31m-[00m>getName() 
source.cc:105:		<< "  pdbName: " << this[01;31m-[00m>getPdbName() 
source.cc:107:		<< this[01;31m-[00m>oligomerSequenceNumber
source.cc:109:    out << "   Mold name: " << this[01;31m-[00m>getMold()[01;31m-[00m>getName() << endl;
source.cc:110:    if ( this[01;31m-[00m>inCoupling[01;31m-[00m>notNil() )
source.cc:113:		<< this[01;31m-[00m>inCoupling[01;31m-[00m>getCouplingRule()[01;31m-[00m>getName() << endl;
source.cc:117:    for (oc=this[01;31m-[00m>outCouplings.begin(); oc!=this[01;31m-[00m>outCouplings.end(); oc++ ){
source.cc:119:		<< (*oc)[01;31m-[00m>getCouplingRule()[01;31m-[00m>getName() << endl;
source.cc:132:    this[01;31m-[00m>dumpToStream(cout);
spanningLoop.cc:31:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
spanningLoop.cc:32:    RPAtom root = kargs[01;31m-[00m>getAndRemoveOrDefault("root",O_Atom::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Atom>();
spanningLoop.cc:33:    this[01;31m-[00m>setTop(root);
spanningLoop.cc:48:{_F(this[01;31m-[00m>lisp());
spanningLoop.cc:51:    fFlags = aAtom[01;31m-[00m>getFlags();
spanningLoop.cc:52:    if ( (fFlags&this[01;31m-[00m>fVisibleFlagsOn)!=this[01;31m-[00m>fVisibleFlagsOn )
spanningLoop.cc:56:    if ( (fFlags|(~(this[01;31m-[00m>fVisibleFlagsOff)))!=(~(this[01;31m-[00m>fVisibleFlagsOff)) )
spanningLoop.cc:65:    if ( this[01;31m-[00m>fVisibilityFlags & TEMPINTUSED ) {
spanningLoop.cc:66:	if ( this[01;31m-[00m>fVisibilityFlags & TEMPINTINVISIBLE ) {
spanningLoop.cc:67:	    if ( aAtom[01;31m-[00m>getTempInt() == this[01;31m-[00m>iTempInt ) {
spanningLoop.cc:72:	    if ( aAtom[01;31m-[00m>getTempInt() != this[01;31m-[00m>iTempInt ) {
spanningLoop.cc:84:    if ( this[01;31m-[00m>aInvisibleAtom.use_count() != 0 )
spanningLoop.cc:86:	if ( this[01;31m-[00m>aInvisibleAtom == aAtom ) 
spanningLoop.cc:110:{_F(this[01;31m-[00m>lisp());
spanningLoop.cc:112:    if ( this[01;31m-[00m>_OnlyFollowRealBonds )
spanningLoop.cc:119:    if ( aAtom[01;31m-[00m>getSeenId() == this[01;31m-[00m>iSeenId ) {
spanningLoop.cc:127:    if ( this[01;31m-[00m>iMaxDistanceFromRoot >=0 ) {
spanningLoop.cc:128:	if ( this[01;31m-[00m>iMaxDistanceFromRoot <
spanningLoop.cc:129:		this[01;31m-[00m>aCurSpan[01;31m-[00m>getBackCount()+1 ) {
spanningLoop.cc:133:    return(this[01;31m-[00m>bLoopAtomVisible( aAtom ));
spanningLoop.cc:148:{_F(this[01;31m-[00m>lisp());
spanningLoop.cc:149:    this[01;31m-[00m>top = 	c;
spanningLoop.cc:150:    this[01;31m-[00m>initialized = false;
spanningLoop.cc:151:    this[01;31m-[00m>done	= 	false;
spanningLoop.cc:156:    this[01;31m-[00m>iTempInt = 0;
spanningLoop.cc:157:    this[01;31m-[00m>fVisibilityFlags = 0;
spanningLoop.cc:162:    LOG(BF("O_SpanningLoop::setTop atom moeIndex =%d") % (c[01;31m-[00m>getMoeIndex() ) ); // vp0(("O_SpanningLoop::setTop atom moeIndex =%d",c[01;31m-[00m>getMoeIndex() ));
spanningLoop.cc:163:    this[01;31m-[00m>iMaxDistanceFromRoot = [01;31m-[00m1;
spanningLoop.cc:164:    this[01;31m-[00m>aCurSpan = c;
spanningLoop.cc:165:    this[01;31m-[00m>aLastSpan = c;
spanningLoop.cc:168:    this[01;31m-[00m>iSeenId = SiNextSeenId;
spanningLoop.cc:169:    this[01;31m-[00m>iInvisibleCollisions = 0;
spanningLoop.cc:170:    this[01;31m-[00m>aLastCollision = RPAtom();
spanningLoop.cc:171:    this[01;31m-[00m>fVisibilityFlags = 0;
spanningLoop.cc:172:    this[01;31m-[00m>fVisibleFlagsOn = 0;
spanningLoop.cc:173:    this[01;31m-[00m>fVisibleFlagsOff = 0;
spanningLoop.cc:179:{_F(this[01;31m-[00m>lisp());
spanningLoop.cc:180:    return downcast<O_Atom>(this[01;31m-[00m>currentObject);
spanningLoop.cc:184:{_F(this[01;31m-[00m>lisp());
spanningLoop.cc:185:  if ( !this[01;31m-[00m>done) {
spanningLoop.cc:186:      this[01;31m-[00m>advanceLoop();
spanningLoop.cc:195:    this[01;31m-[00m>Base::initialize();
spanningLoop.cc:196:    this[01;31m-[00m>initialized = false;
spanningLoop.cc:197:    this[01;31m-[00m>_OnlyFollowRealBonds = false;
spanningLoop.cc:207:{_F(this[01;31m-[00m>lisp());
spanningLoop.cc:217:    if ( !this[01;31m-[00m>initialized ) {
spanningLoop.cc:218:	downcast<O_Atom>(this[01;31m-[00m>top)[01;31m-[00m>invalidateBackSpan();
spanningLoop.cc:219:	downcast<O_Atom>(this[01;31m-[00m>top)[01;31m-[00m>setBackCount(0);
spanningLoop.cc:220:	downcast<O_Atom>(this[01;31m-[00m>top)[01;31m-[00m>setSeenId(this[01;31m-[00m>iSeenId);
spanningLoop.cc:221:	this[01;31m-[00m>initialized = true;
spanningLoop.cc:224:    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m Entered nextSpanningAtom aCurSpan = %d; nextSpan valid?=%d") 
spanningLoop.cc:225:	% this[01;31m-[00m>aCurSpan[01;31m-[00m>getMoeIndex() % this[01;31m-[00m>aCurSpan[01;31m-[00m>isNextSpanValid() );
spanningLoop.cc:226:    ASSERT(this[01;31m-[00m>aCurSpan[01;31m-[00m>notNil());
spanningLoop.cc:227://    if (IsNull(this[01;31m-[00m>aCurSpan)) {
spanningLoop.cc:228://	LOG(BF("this[01;31m-[00m>aCurSpan is NULL") ); // vp0(( "this[01;31m-[00m>aCurSpan is NULL" ));
spanningLoop.cc:230://	this[01;31m-[00m>done = true;
spanningLoop.cc:237:    aPrev = this[01;31m-[00m>aLastSpan;
spanningLoop.cc:238:    aPrev[01;31m-[00m>invalidateNextSpan();
spanningLoop.cc:239:    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m Invalidated nextSpan for atom: %d") % (aPrev[01;31m-[00m>getMoeIndex() ) ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m Invalidated nextSpan for atom: %d", aPrev[01;31m-[00m>getMoeIndex() ));
spanningLoop.cc:240:    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m Currently on atom: %d") % (this[01;31m-[00m>aCurSpan[01;31m-[00m>getMoeIndex() ) ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m Currently on atom: %d", this[01;31m-[00m>aCurSpan[01;31m-[00m>getMoeIndex() ));
spanningLoop.cc:241:    for ( i=0; i<this[01;31m-[00m>aCurSpan[01;31m-[00m>coordination(); i++ ) {
spanningLoop.cc:242:	aBond = this[01;31m-[00m>aCurSpan[01;31m-[00m>bondedNeighbor( i );
spanningLoop.cc:243:	BondOrder order = this[01;31m-[00m>aCurSpan[01;31m-[00m>bondedOrder(i);
spanningLoop.cc:246:	if ( this[01;31m-[00m>bSpanAtomVisible( aBond, order, &bSeenBefore ) ) {
spanningLoop.cc:247:	    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m looking at bonded atom: %d") % (aBond[01;31m-[00m>getMoeIndex() ) ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m looking at bonded atom: %d", aBond[01;31m-[00m>getMoeIndex() ));
spanningLoop.cc:248:	    aBond[01;31m-[00m>setSeenId( this[01;31m-[00m>iSeenId );
spanningLoop.cc:249:	    aBond[01;31m-[00m>setBackCount( this[01;31m-[00m>aCurSpan[01;31m-[00m>getBackCount()+1 );
spanningLoop.cc:250:	    aBond[01;31m-[00m>setBackSpan( this[01;31m-[00m>aCurSpan );
spanningLoop.cc:251:	    aPrev[01;31m-[00m>setNextSpan( aBond );
spanningLoop.cc:252:	    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m Setting atom: %d nextSpan to: %d") % (aPrev[01;31m-[00m>getMoeIndex()) % (aBond[01;31m-[00m>getMoeIndex() ) ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m Setting atom: %d nextSpan to: %d", aPrev[01;31m-[00m>getMoeIndex(), aBond[01;31m-[00m>getMoeIndex() ));
spanningLoop.cc:254:	    aBond[01;31m-[00m>invalidateNextSpan();
spanningLoop.cc:255:	    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m Is atom: %d nextSpan valid? ==> %d") % (aPrev[01;31m-[00m>getMoeIndex()) % (aPrev[01;31m-[00m>isNextSpanValid() ) ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m Is atom: %d nextSpan valid? ==> %d", aPrev[01;31m-[00m>getMoeIndex(), aPrev[01;31m-[00m>isNextSpanValid() ));
spanningLoop.cc:258:	    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m NOT Visible") ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m NOT Visible" ));
spanningLoop.cc:265:		LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m COLLISION!") ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m COLLISION!" ));
spanningLoop.cc:266:		this[01;31m-[00m>iInvisibleCollisions++;
spanningLoop.cc:267:		this[01;31m-[00m>aLastCollision = aBond;
spanningLoop.cc:274:    this[01;31m-[00m>aLastSpan = aPrev;
spanningLoop.cc:275:    oObject = this[01;31m-[00m>aCurSpan;
spanningLoop.cc:276:    if ( this[01;31m-[00m>aCurSpan[01;31m-[00m>isNextSpanValid() ) {
spanningLoop.cc:277:        this[01;31m-[00m>aCurSpan = this[01;31m-[00m>aCurSpan[01;31m-[00m>getNextSpan();
spanningLoop.cc:278:	LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m Setting this[01;31m-[00m>aCurSpan to: %d") % (this[01;31m-[00m>aCurSpan[01;31m-[00m>getMoeIndex() ) ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m Setting this[01;31m-[00m>aCurSpan to: %d", this[01;31m-[00m>aCurSpan[01;31m-[00m>getMoeIndex() ));
spanningLoop.cc:279:	LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m Is atom: %d nextSpan valid? ==> %d") % (this[01;31m-[00m>aCurSpan[01;31m-[00m>getMoeIndex()) % (this[01;31m-[00m>aCurSpan[01;31m-[00m>isNextSpanValid() ) ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m Is atom: %d nextSpan valid? ==> %d", this[01;31m-[00m>aCurSpan[01;31m-[00m>getMoeIndex(), this[01;31m-[00m>aCurSpan[01;31m-[00m>isNextSpanValid() ));
spanningLoop.cc:281:	LOG(BF("atom %d does not have a next span atom, loop done") % (this[01;31m-[00m>aCurSpan[01;31m-[00m>getMoeIndex() ) ); // vp0(( "atom %d does not have a next span atom, loop done", this[01;31m-[00m>aCurSpan[01;31m-[00m>getMoeIndex() ));
spanningLoop.cc:282:	this[01;31m-[00m>done = true;
spanningLoop.cc:298:// At the end of this function either this[01;31m-[00m>currentObject is the next object
spanningLoop.cc:299:// or this[01;31m-[00m>done == true, in which case this[01;31m-[00m>currentObject is invalid.
spanningLoop.cc:302:{_F(this[01;31m-[00m>lisp());
spanningLoop.cc:305:    LOG(BF("O_SpanningLoop::advanceLoop STARTING [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m ") ); // vp0(( "O_SpanningLoop::advanceLoop STARTING [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m " ));
spanningLoop.cc:306:    if ( this[01;31m-[00m>done ) {
spanningLoop.cc:313:    retVal = this[01;31m-[00m>nextSpanningAtom();
spanningLoop.cc:314:    LOG(BF("O_SpanningLoop::advanceLoop advanced to moeIndex =%d") % (retVal[01;31m-[00m>getMoeIndex() ) ); // vp0(("O_SpanningLoop::advanceLoop advanced to moeIndex =%d",retVal[01;31m-[00m>getMoeIndex() ));
spanningLoop.cc:317:    this[01;31m-[00m>currentObject = retVal;
spanningLoop.cc:318:    LOG(BF("O_SpanningLoop::advanceLoop returning [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m") ); // vp0(( "O_SpanningLoop::advanceLoop returning [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" ));
spanningLoop.cc:325:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
spanningLoop.cc:327:    RPAtom theTop = this[01;31m-[00m>top;
spanningLoop.cc:328:    this[01;31m-[00m>setTop(theTop);
spanningLoop.cc:329:    while ( this[01;31m-[00m>advanceLoopAndProcess() )
spanningLoop.cc:331:	RPCons one = O_Cons::create(this[01;31m-[00m>getAtom(),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
spanningLoop.cc:332:	cur[01;31m-[00m>setCdr(one);
spanningLoop.cc:335:    return first[01;31m-[00m>cdr();
spanningLoop.cc:343:    class_<O_SpanningLoop>(this[01;31m-[00m>lisp())
sparseMatrix.cc:49:    this[01;31m-[00m>_RowMatrix = true;
sparseMatrix.cc:50:    this[01;31m-[00m>_MatrixType = type;
sparseMatrix.cc:51:    this[01;31m-[00m>_Columns = cols;
sparseMatrix.cc:52:    this[01;31m-[00m>_Rows = rows;
sparseMatrix.cc:53:    this[01;31m-[00m>_Values.empty();
sparseMatrix.cc:54:    this[01;31m-[00m>_SliceStarts.resize(rows+1);
sparseMatrix.cc:55:    this[01;31m-[00m>_SliceStarts.fill(0);	// Fill with zero
sparseMatrix.cc:67:    this[01;31m-[00m>_Columns = 0;
sparseMatrix.cc:68:    this[01;31m-[00m>_Rows = 0;
sparseMatrix.cc:69:    this[01;31m-[00m>_Values.empty();
sparseMatrix.cc:70:    this[01;31m-[00m>_SliceStarts.empty(0);
sparseMatrix.cc:74://    THE NONZERO ENTRIES OF THE SPARSE MATRIX ARE STORED ROW[01;31m-[00mBY[01;31m-[00mROW IN THE
sparseMatrix.cc:80://    I.E., IF M(I,J) IS THE FIRST NONZERO ENTRY (STORED) IN THE I[01;31m-[00mTH ROW
sparseMatrix.cc:83://    THUS, THE NUMBER OF ENTRIES IN THE I[01;31m-[00mTH ROW IS  IA(I+1) [01;31m-[00m IA(I),
sparseMatrix.cc:84://    THE NONZERO ENTRIES IN THE I[01;31m-[00mTH ROW ARE STORED CONSECUTIVELY IN
sparseMatrix.cc:86://            A(IA(I)),  A(IA(I)+1),  ..., A(IA(I+1)[01;31m-[00m1),
sparseMatrix.cc:90://            JA(IA(I)), JA(IA(I)+1), ..., JA(IA(I+1)[01;31m-[00m1).
sparseMatrix.cc:104://         [01;31m-[00m[01;31m-[00m[01;31m-[00m+[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
sparseMatrix.cc:112://         [01;31m-[00m[01;31m-[00m[01;31m-[00m+[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
sparseMatrix.cc:123:    this[01;31m-[00m>_orderIndices(c,r);
sparseMatrix.cc:125:    if ( c >= this[01;31m-[00m>_Columns || r >= this[01;31m-[00m>_Rows ) {
sparseMatrix.cc:126:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Overflow in matrix operation"));
sparseMatrix.cc:128:    ssstart = &(this[01;31m-[00m>_Values[this[01;31m-[00m>_SliceStarts[r]];
sparseMatrix.cc:129:    send = &(this[01;31m-[00m>_Values[this[01;31m-[00m>_SliceStarts[r+1][01;31m-[00m1];
sparseMatrix.cc:130:    if ( c < sstart[01;31m-[00m>_Offset ) return NULL;
sparseMatrix.cc:131:    if ( c > send[01;31m-[00m>_Offset ) return NULL;
sparseMatrix.cc:132:    if ( c == ss[01;31m-[00m>this[01;31m-[00m>_Values[sliceStart]._Offset ) return &this[01;31m-[00m>_Values[sliceStart]._Value;
sparseMatrix.cc:133:    if ( c == this[01;31m-[00m>_Values[sliceEnd]._Offset ) return &this[01;31m-[00m>_Values[sliceEnd]._Value;
sparseMatrix.cc:140:	if ( c == this[01;31m-[00m>_Values
sparseMatrix.cc:149:    return this[01;31m-[00m>_dPValues+(r)*this[01;31m-[00m>_Columns+(c);
specialForm.cc:19:    class_<O_SpecialForm>(lisp[01;31m-[00m>lisp())
specialForm.cc:37:    RPSpecialForm sf = env[01;31m-[00m>create<O_SpecialForm>();
specialForm.cc:38:    sf[01;31m-[00m>setSpecialSymbol(symbol);
specialForm.cc:39:    sf[01;31m-[00m>setForm(form);
specialForm.cc:46:    ASSERTP(this[01;31m-[00m>_Functoid!=NULL,"Functoid can not be NULL");
specialForm.cc:47:    return this[01;31m-[00m>_Functoid[01;31m-[00m>invoke(this[01;31m-[00m>sharedThis<O_SpecialForm>(),args,environment,lisp);
specialForm.cc:53:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
specialForm.cc:59:    this[01;31m-[00m>Base::initialize();
specialForm.cc:65:    this[01;31m-[00m>Base::archiveBase(node);
specialForm.cc:72:    return this[01;31m-[00m>_SpecialSymbol[01;31m-[00m>fullName();
specificContext.cc:18:    this[01;31m-[00m>_SelfName = ss._SelfName;
specificContext.cc:19:    this[01;31m-[00m>_Neighbors = ss._Neighbors;
specificContext.cc:24:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
specificContext.cc:30:    this[01;31m-[00m>Base::initialize();
specificContext.cc:31:    this[01;31m-[00m>_Neighbors.clear();
specificContext.cc:32:    this[01;31m-[00m>_SelfName = "";
specificContext.cc:38:    this[01;31m-[00m>_Neighbors.clear();
specificContext.cc:39:    this[01;31m-[00m>_SelfName = "";
specificContext.cc:49:{_F(this[01;31m-[00m>lisp());
specificContext.cc:50:   this[01;31m-[00m>_SelfName = selfName; 
specificContext.cc:54:{_F(this[01;31m-[00m>lisp());
specificContext.cc:58:    this[01;31m-[00m>_Neighbors.push_back(one);
specificContext.cc:62:{_F(this[01;31m-[00m>lisp());
specificContext.cc:63:    ASSERT_gt(this[01;31m-[00m>_Neighbors.size(),0);
specificContext.cc:64:    KeyEntry& one = this[01;31m-[00m>_Neighbors.back();
specificContext.cc:69:{_F(this[01;31m-[00m>lisp());
specificContext.cc:70:    this[01;31m-[00m>_Neighbors.pop_back();
specificContext.cc:76:{_F(this[01;31m-[00m>lisp());
specificContext.cc:77:    if ( !bdb[01;31m-[00m>recognizesMonomerName(this[01;31m-[00m>_SelfName) ) return false;
specificContext.cc:78:    for ( vector<KeyEntry>::iterator it = this[01;31m-[00m>_Neighbors.begin();
specificContext.cc:79:    		it!=this[01;31m-[00m>_Neighbors.end(); it++ )
specificContext.cc:81:	if ( !bdb[01;31m-[00m>recognizesMonomerName(it[01;31m-[00m>_Monomer) ) return false;
specificContext.cc:87:{_F(this[01;31m-[00m>lisp());
specificContext.cc:90:    ss << this[01;31m-[00m>_SelfName;
specificContext.cc:92:    for ( vector<KeyEntry>::iterator it = this[01;31m-[00m>_Neighbors.begin();
specificContext.cc:93:    		it!=this[01;31m-[00m>_Neighbors.end(); it++ )
specificContext.cc:95:	ss << it[01;31m-[00m>_Coupling;
specificContext.cc:98:	ss << it[01;31m-[00m>_Monomer;
specificContext.cc:107:{_F(this[01;31m-[00m>lisp());
specificContext.cc:120:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
specificContext.cc:127:    this[01;31m-[00m>Base::initialize();
specificContext.cc:137:{_F(this[01;31m-[00m>lisp());
specificContext.cc:139:    this[01;31m-[00m>_KeySets.set(keyKey, key );
specificContext.cc:144:{_F(this[01;31m-[00m>lisp());
specificContext.cc:145:    LOG(BF("adding SpecificContext |%s|") % key[01;31m-[00m>asString().c_str()  ); // vp0(( "adding SpecificContext |%s|", key[01;31m-[00m>asString().c_str() ));
specificContext.cc:146:    this[01;31m-[00m>addWithKey(key[01;31m-[00m>asString(),key);
specificContext.cc:151:{_F(this[01;31m-[00m>lisp());
specificContext.cc:152:    return this[01;31m-[00m>_KeySets.count(key[01;31m-[00m>asString())>0;
specificContext.cc:156:{_F(this[01;31m-[00m>lisp());
specificContext.cc:158:    for ( it=s[01;31m-[00m>begin(); it!=s[01;31m-[00m>end(); it++ )
specificContext.cc:160:	this[01;31m-[00m>addWithKey(it[01;31m-[00m>first,it[01;31m-[00m>second);
specificContext.cc:166:{_F(this[01;31m-[00m>lisp());
specificContext.cc:168:    for ( it=s[01;31m-[00m>begin(); it!=s[01;31m-[00m>end(); it++ )
specificContext.cc:170:	string key = it[01;31m-[00m>second[01;31m-[00m>asString();
specificContext.cc:171:	if ( this[01;31m-[00m>_KeySets.count(key)>0 )
specificContext.cc:173:	    this[01;31m-[00m>_KeySets.remove(key);
specificContext.cc:179:{_F(this[01;31m-[00m>lisp());
specificContext.cc:180:    RPStringSet keys = O_StringSet::create(this[01;31m-[00m>lisp());
specificContext.cc:182:    for ( it=this[01;31m-[00m>begin(); it!=this[01;31m-[00m>end(); it++ )
specificContext.cc:184:	keys[01;31m-[00m>insert(it[01;31m-[00m>first);
specificContext.cc:192:{_F(this[01;31m-[00m>lisp());
specificContext.cc:193:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
specificContext.cc:196:    for ( it=this[01;31m-[00m>begin(); it!=this[01;31m-[00m>end(); it++ )
specificContext.cc:198:	RPCons one = O_Cons::create(it[01;31m-[00m>second,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
specificContext.cc:199:	cur[01;31m-[00m>setCdr(one);
specificContext.cc:202:    return first[01;31m-[00m>cdr();
specificContext.cc:214:    class_<O_SpecificContext>(this[01;31m-[00m>lisp())
specificContext.cc:246:	class_<O_SpecificContextSet>(this[01;31m-[00m>lisp())
spline.cc:40:	double mSpline[] = { 	[01;31m-[00m1,  2, [01;31m-[00m1,  0,
spline.cc:41:				 3, [01;31m-[00m5,  0,  2,
spline.cc:42:				[01;31m-[00m3,  4,  1,  0,
spline.cc:43:				 1, [01;31m-[00m1,  0,  0 };
spline.cc:47:	this[01;31m-[00m>mbAMatrix = m;
spline.cc:48:	this[01;31m-[00m>mbBMatrix = m;
spline.cc:49:	this[01;31m-[00m>mbsMatrix = m;
spline.cc:50:	this[01;31m-[00m>mbYMatrix = m;
spline.cc:51:	this[01;31m-[00m>mbZMatrix = m;
spline.cc:62:    this[01;31m-[00m>iType = iSplineType;
spline.cc:63:    this[01;31m-[00m>defineMatrices(iSplineType);
spline.cc:64:    this[01;31m-[00m>definePoints(points);
spline.cc:74:   p1 = points[i4[01;31m-[00m3];
spline.cc:75:   p2 = points[i4[01;31m-[00m2];
spline.cc:76:   p3 = points[i4[01;31m-[00m1];
spline.cc:108:    gmSize = points.size() [01;31m-[00m 3;
spline.cc:110:    this[01;31m-[00m>gmMatrices.resize(gmSize,m);
spline.cc:112:	m = this[01;31m-[00m>mbsMatrix;
spline.cc:114:	    m = this[01;31m-[00m>mbBMatrix;
spline.cc:116:	    m = this[01;31m-[00m>mbAMatrix;
spline.cc:117:	} else if (i == gmSize[01;31m-[00m2) {
spline.cc:118:	    m = this[01;31m-[00m>mbYMatrix;
spline.cc:119:	} else if (i == gmSize[01;31m-[00m1) {
spline.cc:120:	    m = this[01;31m-[00m>mbZMatrix;
spline.cc:122:	g = this[01;31m-[00m>gMatrixForPoints( points, i+3 );
spline.cc:123:	this[01;31m-[00m>gmMatrices[i] = g * m;
spline.cc:131:    _lisp[01;31m-[00m>print(BF( "spline type = %d") % this[01;31m-[00m>iType );
spline.cc:132:    _lisp[01;31m-[00m>print(BF( "gmMatrices ======>" ));
spline.cc:133:    for ( i=0; i<this[01;31m-[00m>gmMatrices.size(); i++ ) {
spline.cc:134:	this[01;31m-[00m>gmMatrices[i].dump();
spline.cc:135:	_lisp[01;31m-[00m>print(BF( "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m" ));
spline.cc:137:    _lisp[01;31m-[00m>print(BF( "mbAMatrix ======>" ));
spline.cc:138:    this[01;31m-[00m>mbAMatrix.dump();
spline.cc:139:    _lisp[01;31m-[00m>print(BF( "mbBMatrix ======>" ));
spline.cc:140:    this[01;31m-[00m>mbBMatrix.dump();
spline.cc:141:    _lisp[01;31m-[00m>print(BF( "mbsMatrix ======>" ));
spline.cc:142:    this[01;31m-[00m>mbsMatrix.dump();
spline.cc:143:    _lisp[01;31m-[00m>print(BF( "mbYMatrix ======>" ));
spline.cc:144:    this[01;31m-[00m>mbYMatrix.dump();
spline.cc:145:    _lisp[01;31m-[00m>print(BF( "mbZMatrix ======>" ));
spline.cc:146:    this[01;31m-[00m>mbZMatrix.dump();
spline.cc:165:    if ( i>=this[01;31m-[00m>gmMatrices.size() ) {
spline.cc:166:	i = this[01;31m-[00m>gmMatrices.size()[01;31m-[00m1;
spline.cc:169:	t = ti [01;31m-[00m i;
spline.cc:171:    m = this[01;31m-[00m>gmMatrices[i];
spline.cc:189:    sp = this[01;31m-[00m>evaluateAtIndex(index);
spline.cc:190:    diff = pnt [01;31m-[00m sp;
statusTracker.cc:23:    this[01;31m-[00m>Base::initialize();
statusTracker.cc:24:    this[01;31m-[00m>_HasError = false;
statusTracker.cc:25:    this[01;31m-[00m>_ErrorStream.str("");
statusTracker.cc:26:    this[01;31m-[00m>_MessageStream.str("");
statusTracker.cc:34:    this[01;31m-[00m>_HasError = ss._HasError;
statusTracker.cc:35:    this[01;31m-[00m>_MessageStream.str(ss._MessageStream.str());
statusTracker.cc:36:    this[01;31m-[00m>_ErrorStream.str(ss._ErrorStream.str());
statusTracker.cc:51:{_F(this[01;31m-[00m>lisp());
statusTracker.cc:52:    node[01;31m-[00m>attribute("hasError", this[01;31m-[00m>_HasError );
statusTracker.cc:53:    node[01;31m-[00m>archiveStringStreamIfDefined("ErrorMessages",this[01;31m-[00m>_ErrorStream);
statusTracker.cc:54:    node[01;31m-[00m>archiveStringStreamIfDefined("Messages",this[01;31m-[00m>_MessageStream);
statusTracker.cc:62:{_F(this[01;31m-[00m>lisp());
statusTracker.cc:64:    this[01;31m-[00m>_MessageStream << msg << endl;
statusTracker.cc:72:{_F(this[01;31m-[00m>lisp());
statusTracker.cc:74:    this[01;31m-[00m>_HasError = true;
statusTracker.cc:75:    this[01;31m-[00m>_ErrorStream << msg << endl;
statusTracker.cc:84:{_F(this[01;31m-[00m>lisp());
statusTracker.cc:85:    this[01;31m-[00m>_HasError = false;
statusTracker.cc:86:    this[01;31m-[00m>_ErrorStream.str("");
statusTracker.cc:87:    this[01;31m-[00m>_MessageStream.str("");
statusTracker.cc:91:{_F(this[01;31m-[00m>lisp());
statusTracker.cc:94:    stuff << this[01;31m-[00m>_MessageStream.str();
statusTracker.cc:95:    if ( this[01;31m-[00m>_HasError )
statusTracker.cc:97:        stuff << this[01;31m-[00m>_ErrorStream.str();
statusTracker.cc:105:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:26:/*! Return +1 for "R" and [01;31m-[00m1 for "S"
stereochemistry.cc:30:    if ( this[01;31m-[00m>_Configuration == "R" ) {
stereochemistry.cc:34:    return [01;31m-[00m1;
stereochemistry.cc:40:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:41:    node[01;31m-[00m>attribute("atom",this[01;31m-[00m>_AtomName);
stereochemistry.cc:42:    node[01;31m-[00m>attribute("config",this[01;31m-[00m>_Configuration);
stereochemistry.cc:51:Provide the atom name and the stereo[01;31m-[00mconfiguration \sa{configuration} of "R" or "S".
stereochemistry.cc:55:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:56:    this[01;31m-[00m>Base::oldLispInitialize(dict, env );
stereochemistry.cc:57:    this[01;31m-[00m>_AtomName = dict[01;31m-[00m>getStringAndRemove("atomName");
stereochemistry.cc:58:    this[01;31m-[00m>_Configuration = dict[01;31m-[00m>getStringAndRemove("config");
stereochemistry.cc:66:    ASSERT_eq(atomNames[01;31m-[00m>length(), configurations[01;31m-[00m>length() );
stereochemistry.cc:70:    while ( curName[01;31m-[00m>notNil() )
stereochemistry.cc:73:	one[01;31m-[00m>setAtomName(curName[01;31m-[00m>car<O_String>()[01;31m-[00m>get());
stereochemistry.cc:74:	one[01;31m-[00m>setConfiguration(curConfig[01;31m-[00m>car<O_String>()[01;31m-[00m>get());
stereochemistry.cc:76:	curName = curName[01;31m-[00m>cdr();
stereochemistry.cc:77:	curConfig = curConfig[01;31m-[00m>cdr();
stereochemistry.cc:85:    RPCons atomNames = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Cons>();
stereochemistry.cc:86:    RPCons configurations = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Cons>();
stereochemistry.cc:102:		one = O_Cons::create(lisp[01;31m-[00m>create<O_String>("R"),one,lisp);
stereochemistry.cc:105:		one = O_Cons::create(lisp[01;31m-[00m>create<O_String>("S"),one,lisp);
stereochemistry.cc:117:    uint numberOfCenters = args[01;31m-[00m>ocar()[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
stereochemistry.cc:126:    node[01;31m-[00m>attribute( "center",this[01;31m-[00m>_CentralAtomName );
stereochemistry.cc:127:    node[01;31m-[00m>attribute( "diastereotopic1", this[01;31m-[00m>_Diastereotopic1 );
stereochemistry.cc:128:    node[01;31m-[00m>attribute( "diastereotopic2", this[01;31m-[00m>_Diastereotopic2 );
stereochemistry.cc:133:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
stereochemistry.cc:134:    this[01;31m-[00m>_CentralAtomName = dict[01;31m-[00m>getStringAndRemove("atomName"); 
stereochemistry.cc:135:    this[01;31m-[00m>_Diastereotopic1 = dict[01;31m-[00m>getStringAndRemove("dia1"); 
stereochemistry.cc:136:    this[01;31m-[00m>_Diastereotopic2 = dict[01;31m-[00m>getStringAndRemove("dia2"); 
stereochemistry.cc:144:    this[01;31m-[00m>Base::initialize();
stereochemistry.cc:145:    this[01;31m-[00m>_WeakConstitution = O_Constitution::nil(this[01;31m-[00m>lisp());
stereochemistry.cc:151:    if ( node[01;31m-[00m>saving() ) this[01;31m-[00m>getConstitution();
stereochemistry.cc:152:    this[01;31m-[00m>Base::archiveBase(node);
stereochemistry.cc:153:    node[01;31m-[00m>archiveWeakPointer("constitution",this[01;31m-[00m>_WeakConstitution);
stereochemistry.cc:154:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name );
stereochemistry.cc:155:    node[01;31m-[00m>attribute("pdb", this[01;31m-[00m>_Pdb );
stereochemistry.cc:156:    node[01;31m-[00m>attributeIfNotDefault<string>("enantiomer", this[01;31m-[00m>_Enantiomer, "" );
stereochemistry.cc:157:    node[01;31m-[00m>archiveListOfObjectsSubClassOf<O_StereoConfiguration>( this[01;31m-[00m>_Configurations );
stereochemistry.cc:161:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:163:    ss = O_StringSet::create(this[01;31m-[00m>lisp());
stereochemistry.cc:164:    ss[01;31m-[00m>insert(this[01;31m-[00m>getName());
stereochemistry.cc:173:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:176:    gr = O_MonomerGroup::create(this[01;31m-[00m>lisp()); //,this[01;31m-[00m>getBuilderDatabase());
stereochemistry.cc:177:    gr[01;31m-[00m>setName(this[01;31m-[00m>getName());
stereochemistry.cc:178:    gr[01;31m-[00m>setRepresentative(this[01;31m-[00m>getName());
stereochemistry.cc:179:    gr[01;31m-[00m>addMonomerName(this[01;31m-[00m>getName());
stereochemistry.cc:180:    ss = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectList>();
stereochemistry.cc:181:    ss[01;31m-[00m>append(gr);
stereochemistry.cc:189:    ss << "Stereoisomer[01;31m-[00mname(" << this[01;31m-[00m>_Name << ")[01;31m-[00mpdbName(" << this[01;31m-[00m>_Pdb << ")";
stereochemistry.cc:194:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:195:    for ( List<O_StereoConfiguration>::iterator it=this[01;31m-[00m>_Configurations.begin();
stereochemistry.cc:196:          it!=this[01;31m-[00m>_Configurations.end(); it++ )
stereochemistry.cc:198:	if ( (*it)[01;31m-[00m>getAtomName() == centerName )
stereochemistry.cc:200:	    return (*it)[01;31m-[00m>getConfiguration();
stereochemistry.cc:207:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:208:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakConstitution);
stereochemistry.cc:211:    if ( this[01;31m-[00m>_WeakConstitution.lock()[01;31m-[00m>isNil() )
stereochemistry.cc:213:	this[01;31m-[00m>_WeakConstitution = this[01;31m-[00m>ownerWithClass<O_Constitution>();
stereochemistry.cc:215:    return this[01;31m-[00m>_WeakConstitution.lock();
stereochemistry.cc:225:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:226:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
stereochemistry.cc:227:    this[01;31m-[00m>_Name = dict[01;31m-[00m>getStringAndRemove("name");
stereochemistry.cc:228:    this[01;31m-[00m>_Pdb = dict[01;31m-[00m>getStringAndRemove("pdb");
stereochemistry.cc:229:    RPCons configs = dict[01;31m-[00m>getAndRemove("configs")[01;31m-[00m>as<O_Cons>();
stereochemistry.cc:230:    configs[01;31m-[00m>setOwnerOfAllEntries(this[01;31m-[00m>sharedThis<O_Stereoisomer>());
stereochemistry.cc:231:    this[01;31m-[00m>_Configurations.clear();
stereochemistry.cc:232:    for ( ; configs[01;31m-[00m>notNil(); configs = configs[01;31m-[00m>cdr() )
stereochemistry.cc:234:	this[01;31m-[00m>_Configurations.push_back(configs[01;31m-[00m>car<O_StereoConfiguration>() );
stereochemistry.cc:247:    RPKeyedArguments dict = args[01;31m-[00m>asKeyedArguments();
stereochemistry.cc:248:    string name = dict[01;31m-[00m>getStringAndRemove("nameTemplate");
stereochemistry.cc:249:    RPCons centers = dict[01;31m-[00m>getAndRemove("centers")[01;31m-[00m>as<O_Cons>();
stereochemistry.cc:250:    RPCons configs = dict[01;31m-[00m>getAndRemove("configs")[01;31m-[00m>as<O_Cons>();
stereochemistry.cc:259:    if ( this[01;31m-[00m>_NameOrPdbToStereoisomer.count(s[01;31m-[00m>getName())>0 ) {
stereochemistry.cc:260:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("addStereoisomer monomer name (%s) has already been used") % s[01;31m-[00m>getName()));
stereochemistry.cc:262:    if ( this[01;31m-[00m>_NameOrPdbToStereoisomer.count(s[01;31m-[00m>getPdb())>0 ) {
stereochemistry.cc:263:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("addStereoisomer pdb name (%s) has already been used") % s[01;31m-[00m>getPdb() ));
stereochemistry.cc:265:    this[01;31m-[00m>_NameOrPdbToStereoisomer.set(s[01;31m-[00m>getName(),s);
stereochemistry.cc:266:    this[01;31m-[00m>_NameOrPdbToStereoisomer.set(s[01;31m-[00m>getPdb(),s);
stereochemistry.cc:267:    this[01;31m-[00m>_Stereoisomers.append(s);
stereochemistry.cc:273:    for ( List<O_Stereoisomer>::iterator it=this[01;31m-[00m>_Stereoisomers.begin(); it!=this[01;31m-[00m>_Stereoisomers.end(); it++ )
stereochemistry.cc:275:	if ( (*it)[01;31m-[00m>getName() == "" ) 
stereochemistry.cc:277:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("StereoInformation has stereoisomer with blank name"));
stereochemistry.cc:279:	if ( (*it)[01;31m-[00m>getPdb() == "" ) 
stereochemistry.cc:281:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("StereoInformation has stereoisomer with blank pdb name"));
stereochemistry.cc:298:    this[01;31m-[00m>_ProChiralCenters.push_back(s);
stereochemistry.cc:305:    return this[01;31m-[00m>_NameOrPdbToStereoisomer.get(nameOrPdb);
stereochemistry.cc:309:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:310:    node[01;31m-[00m>archiveListOfObjectsSubClassOf<O_Stereoisomer>(this[01;31m-[00m>_Stereoisomers);
stereochemistry.cc:311://    node[01;31m-[00m>archiveListOfObjectsSubClassOf<O_ProChiralCenter>( this[01;31m-[00m>_ProChiralCenters);
stereochemistry.cc:312:    node[01;31m-[00m>archiveList( "complexRestraints", this[01;31m-[00m>_ComplexRestraints);
stereochemistry.cc:313:    node[01;31m-[00m>needsFinalization();
stereochemistry.cc:317:{_F(this[01;31m-[00m>lisp());
stereochemistry.cc:319:    for ( si=this[01;31m-[00m>_Stereoisomers.begin(); si!=this[01;31m-[00m>_Stereoisomers.end(); si++ )
stereochemistry.cc:321:    	LOG(BF("Adding stereoisomer with name: %s") % (*si)[01;31m-[00m>getName().c_str()  ); // vp0(( "Adding stereoisomer with name: %s", (*si)[01;31m-[00m>getName().c_str() ));
stereochemistry.cc:322:        this[01;31m-[00m>_NameOrPdbToStereoisomer.set((*si)[01;31m-[00m>getName(), (*si));
stereochemistry.cc:323:        this[01;31m-[00m>_NameOrPdbToStereoisomer.set((*si)[01;31m-[00m>getPdb(), (*si));
stereochemistry.cc:340:    this[01;31m-[00m>Base::oldLispInitialize(dict,env);
stereochemistry.cc:341:    RPCons stereoisomers = dict[01;31m-[00m>getAndRemove("stereoisomers")[01;31m-[00m>as<O_Cons>();
stereochemistry.cc:342:    this[01;31m-[00m>_Stereoisomers.fillFromCons(stereoisomers);
stereochemistry.cc:343:    stereoisomers[01;31m-[00m>setOwnerOfAllEntries(this[01;31m-[00m>sharedThis<O_StereoInformation>());
stereochemistry.cc:344:    this[01;31m-[00m>_NameOrPdbToStereoisomer.clear();
stereochemistry.cc:345:    for ( List<O_Stereoisomer>::iterator it = this[01;31m-[00m>_Stereoisomers.begin();
stereochemistry.cc:346:    		it != this[01;31m-[00m>_Stereoisomers.end(); it++ )
stereochemistry.cc:348:	if ( this[01;31m-[00m>_NameOrPdbToStereoisomer.count((*it)[01;31m-[00m>getName()) >0 )
stereochemistry.cc:350:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Stereoisomer name: "+(*it)[01;31m-[00m>getName()+" has already been defined"));
stereochemistry.cc:352:	if ( this[01;31m-[00m>_NameOrPdbToStereoisomer.count((*it)[01;31m-[00m>getPdb()) >0 )
stereochemistry.cc:354:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Stereoisomer pdb: "+(*it)[01;31m-[00m>getPdb()+" has already been defined"));
stereochemistry.cc:356:	this[01;31m-[00m>_NameOrPdbToStereoisomer.set((*it)[01;31m-[00m>getName(), (*it));
stereochemistry.cc:357:	this[01;31m-[00m>_NameOrPdbToStereoisomer.set((*it)[01;31m-[00m>getPdb(), (*it));
stereochemistry.cc:359://    RPCons proChiralCenters = dict[01;31m-[00m>getAndRemoveOrDefault("proChiralCenters",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
stereochemistry.cc:360://    proChiralCenters[01;31m-[00m>setOwnerOfAllEntries(this[01;31m-[00m>sharedThis<O_StereoInformation>());
stereochemistry.cc:361://    this[01;31m-[00m>_ProChiralCenters.fillFromCons(proChiralCenters);
stereochemistry.cc:362:    RPCons restraints = dict[01;31m-[00m>getAndRemoveOrDefault("restraints",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
stereochemistry.cc:363:    restraints[01;31m-[00m>setOwnerOfAllEntries(this[01;31m-[00m>sharedThis<O_StereoInformation>());
stereochemistry.cc:364:    this[01;31m-[00m>_ComplexRestraints.fillFromCons(restraints);
stereochemistry.cc:377:    names = O_StringList::create(this[01;31m-[00m>lisp());
stereochemistry.cc:378:    for ( mnpi=this[01;31m-[00m>_Stereoisomers.begin();
stereochemistry.cc:379:		mnpi!=this[01;31m-[00m>_Stereoisomers.end(); mnpi++ ) {
stereochemistry.cc:380:	names[01;31m-[00m>append((*mnpi)[01;31m-[00m>getName());
stereochemistry.cc:393:    names = O_StringSet::create(this[01;31m-[00m>lisp());
stereochemistry.cc:394:    for ( mnpi=this[01;31m-[00m>_Stereoisomers.begin();
stereochemistry.cc:395:		mnpi!=this[01;31m-[00m>_Stereoisomers.end(); mnpi++ ) {
stereochemistry.cc:396:	names[01;31m-[00m>insert((*mnpi)[01;31m-[00m>getName());
stereochemistry.cc:411:    names = O_StringList::create(this[01;31m-[00m>lisp());
stereochemistry.cc:412:    for ( mnpi=this[01;31m-[00m>_Stereoisomers.begin();
stereochemistry.cc:413:		mnpi!=this[01;31m-[00m>_Stereoisomers.end(); mnpi++ ) {
stereochemistry.cc:414:	names[01;31m-[00m>append((*mnpi)[01;31m-[00m>getPdb());
stereochemistry.cc:437:	class_<O_StereoConfiguration>(this[01;31m-[00m>lisp())
stereochemistry.cc:444:	defNoWrapPackage(MbbPackage,"stereochemicalPermutations",&prim_stereochemicalPermutations,this[01;31m-[00m>lisp());
stereochemistry.cc:445:	defNoWrapPackage(MbbPackage,"StereoConfiguration_createMultiple",&prim_StereoConfiguration_create_multiple,this[01;31m-[00m>lisp());
stereochemistry.cc:446://	def("stereochemicalPermutations",&O_StereoConfiguration::stereochemicalPermutations,this[01;31m-[00m>lisp());
stereochemistry.cc:448:	this[01;31m-[00m>lisp()[01;31m-[00m>installGlobalInitializationCallback(&O_StereoConfiguration::initializeGlobals);
stereochemistry.cc:472:	class_<O_ProChiralCenter>(this[01;31m-[00m>lisp())
stereochemistry.cc:508:	class_<O_Stereoisomer>(this[01;31m-[00m>lisp())
stereochemistry.cc:539:	class_<O_StereoInformation>(this[01;31m-[00m>lisp())
stringList.cc:26:{_F(this[01;31m-[00m>lisp());
stringList.cc:29:    this[01;31m-[00m>setFromVectorStrings(parts);
stringList.cc:34:{_F(this[01;31m-[00m>lisp());
stringList.cc:39:    for ( si = this[01;31m-[00m>_Contents.begin(); si!=this[01;31m-[00m>_Contents.end(); si++ ) {
stringList.cc:40:	if ( si!=this[01;31m-[00m>_Contents.begin() ) {
stringList.cc:51:    if ( node[01;31m-[00m>loading() ) {
stringList.cc:53:	v_Contents = node[01;31m-[00m>getDataAsVectorOfStrings();
stringList.cc:54:	this[01;31m-[00m>_Contents.clear();
stringList.cc:55:	this[01;31m-[00m>setFromVectorStrings(v_Contents);
stringList.cc:57:        node[01;31m-[00m>setCharacters(this[01;31m-[00m>asString());
stringList.cc:65:    LOG(BF("StringList::clear size=%d") % (this[01;31m-[00m>_Contents.size() ) ); // vp0(( "StringList::clear size=%d", this[01;31m-[00m>_Contents.size() ));
stringList.cc:66:    if ( this[01;31m-[00m>_Contents.size() == 0 ) return;
stringList.cc:67:    this[01;31m-[00m>_Contents.clear();
stringList.cc:72:{_F(this[01;31m-[00m>lisp());
stringList.cc:73:    this[01;31m-[00m>_Contents.insert(this[01;31m-[00m>_Contents.begin(),str);
stringList.cc:78:{_F(this[01;31m-[00m>lisp());
stringList.cc:79:    this[01;31m-[00m>_Contents.push_back(str);
stringList.cc:84:{_F(this[01;31m-[00m>lisp());
stringList.cc:86:    for ( ic=s[01;31m-[00m>begin(); ic!=s[01;31m-[00m>end(); ic++ )
stringList.cc:88:	this[01;31m-[00m>_Contents.push_back(*ic);
stringList.cc:93:{_F(this[01;31m-[00m>lisp());
stringList.cc:94:    for ( RPCons cur=s; cur[01;31m-[00m>notNil(); cur=cur[01;31m-[00m>cdr() )
stringList.cc:96:	this[01;31m-[00m>_Contents.push_back(cur[01;31m-[00m>car<O_Text>()[01;31m-[00m>get());
stringList.cc:104:{_F(this[01;31m-[00m>lisp());
stringList.cc:106:   this[01;31m-[00m>clear();
stringList.cc:109:        this[01;31m-[00m>append(*it);
stringList.cc:124:{_F(this[01;31m-[00m>lisp());
stringList.cc:126:    for ( it=this[01;31m-[00m>begin(); it!=this[01;31m-[00m>end(); it++ )
stringList.cc:135:{_F(this[01;31m-[00m>lisp());
stringList.cc:139:    for ( it=this[01;31m-[00m>begin(),idx=0; it!=this[01;31m-[00m>end(); it++,idx++ )
stringList.cc:148:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("StringList does not contain: "+nm));
stringList.cc:189:    this[01;31m-[00m>clear();
stringList.cc:194:	this[01;31m-[00m>append(x);
stringList.cc:207:    for ( vi=this[01;31m-[00m>_Contents.begin(); vi!=this[01;31m-[00m>_Contents.end(); vi++ ) {
stringSet.cc:33:{_F(this[01;31m-[00m>lisp());
stringSet.cc:34:    this[01;31m-[00m>Base::oldLispInitialize(args,env);
stringSet.cc:35:    RPCons entries = args[01;31m-[00m>getAndRemoveOrDefault("entries",O_Cons::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Cons>();
stringSet.cc:36:    this[01;31m-[00m>insertConsStrings(entries);
stringSet.cc:41:    for ( RPCons p=vals; p[01;31m-[00m>notNil(); p=p[01;31m-[00m>cdr())
stringSet.cc:43:        RPText t = p[01;31m-[00m>car<O_Text>();
stringSet.cc:44:	this[01;31m-[00m>insert(t[01;31m-[00m>get());
stringSet.cc:46:    return this[01;31m-[00m>sharedThis<O_StringSet>();
stringSet.cc:53:	this[01;31m-[00m>insert(*i);
stringSet.cc:60:    for ( si=s[01;31m-[00m>strs.begin(); si!= s[01;31m-[00m>strs.end(); si++ ) {
stringSet.cc:61:	this[01;31m-[00m>insert(*si);
stringSet.cc:68:    for ( si=s[01;31m-[00m>begin(); si!= s[01;31m-[00m>end(); si++ ) {
stringSet.cc:69:	this[01;31m-[00m>insert(*si);
stringSet.cc:75:{_F(this[01;31m-[00m>lisp());
stringSet.cc:79:    snew[01;31m-[00m>clear();
stringSet.cc:80:    for ( it=this[01;31m-[00m>begin(); it!=this[01;31m-[00m>end(); it++ )
stringSet.cc:82:	snew[01;31m-[00m>insert(*it);
stringSet.cc:93:    for ( si = this[01;31m-[00m>strs.begin(); si!=this[01;31m-[00m>strs.end(); si++ ) {
stringSet.cc:94:	if ( si!=this[01;31m-[00m>strs.begin() ) {
stringSet.cc:107:    for ( si = this[01;31m-[00m>strs.begin(); si!=this[01;31m-[00m>strs.end(); si++ ) {
stringSet.cc:108:	if ( si!=this[01;31m-[00m>strs.begin() ) {
stringSet.cc:119:    if ( node[01;31m-[00m>loading() ) {
stringSet.cc:121:	vstrs = node[01;31m-[00m>getDataAsVectorOfStrings();
stringSet.cc:122:	this[01;31m-[00m>strs.clear();
stringSet.cc:123:	this[01;31m-[00m>insertVectorStrings(vstrs);
stringSet.cc:125:        node[01;31m-[00m>setCharacters(this[01;31m-[00m>asString());
stringSet.cc:136:{_F(this[01;31m-[00m>lisp());
stringSet.cc:138:    ye = this[01;31m-[00m>strs.count(s);
stringSet.cc:146:    for ( si=sub[01;31m-[00m>begin(); si!=sub[01;31m-[00m>end(); si++ ) {
stringSet.cc:147:	if ( !this[01;31m-[00m>contains(*si) ) {
stringSet.cc:158:    LOG(BF("StringSet::clear size=%d") % (this[01;31m-[00m>strs.size() ) ); // vp0(( "StringSet::clear size=%d", this[01;31m-[00m>strs.size() ));
stringSet.cc:159:    if ( this[01;31m-[00m>strs.size() == 0 ) return;
stringSet.cc:160:    this[01;31m-[00m>strs.clear();
stringSet.cc:167:    if ( this[01;31m-[00m>eqV(obj) ) return true;
stringSet.cc:168:    if ( obj[01;31m-[00m>isAssignableTo<O_StringSet>() )
stringSet.cc:171:        RPStringSet ss = obj[01;31m-[00m>as<O_StringSet>();
stringSet.cc:172:	if ( this[01;31m-[00m>strs.size() != ss[01;31m-[00m>strs.size() ) return false;
stringSet.cc:173:	for (si=this[01;31m-[00m>strs.begin();si!=this[01;31m-[00m>strs.end();si++)
stringSet.cc:175:	    if ( !ss[01;31m-[00m>contains(*si) ) 
stringSet.cc:189:    if ( this[01;31m-[00m>strs.count(s)!=1 ) {
stringSet.cc:190:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("The string: %s was not found in StringSet") % s ));
stringSet.cc:193:    this[01;31m-[00m>strs.erase(s);
stringSet.cc:201:    this[01;31m-[00m>rest = false;
stringSet.cc:206:    this[01;31m-[00m>rest = ss.rest;
stringSet.cc:207:    this[01;31m-[00m>strs = ss.strs;
stringSet.cc:213:{_F(this[01;31m-[00m>lisp());
stringSet.cc:216:    this[01;31m-[00m>clear();
stringSet.cc:217:    this[01;31m-[00m>insertVectorStrings(words);
stringSet.cc:224:{_F(this[01;31m-[00m>lisp());
stringSet.cc:227:    nset = O_StringSet::create(this[01;31m-[00m>lisp());
stringSet.cc:228:    for (si=this[01;31m-[00m>strs.begin();si!=this[01;31m-[00m>strs.end();si++){
stringSet.cc:229:	nset[01;31m-[00m>insert(*si);
stringSet.cc:231:    for (si=b[01;31m-[00m>strs.begin();si!=b[01;31m-[00m>strs.end();si++){
stringSet.cc:232:	nset[01;31m-[00m>insert(*si);
stringSet.cc:239:{_F(this[01;31m-[00m>lisp());
stringSet.cc:242:    nset = O_StringSet::create(this[01;31m-[00m>lisp());
stringSet.cc:243:    for (si=this[01;31m-[00m>strs.begin();si!=this[01;31m-[00m>strs.end();si++){
stringSet.cc:245:	if ( b[01;31m-[00m>contains(*si) ) {
stringSet.cc:247:	    nset[01;31m-[00m>insert(*si);
stringSet.cc:260:    nset = O_StringSet::create(this[01;31m-[00m>lisp());
stringSet.cc:261:    for (si=this[01;31m-[00m>strs.begin();si!=this[01;31m-[00m>strs.end();si++){
stringSet.cc:262:	if ( !b[01;31m-[00m>contains(*si) ) {
stringSet.cc:263:	    nset[01;31m-[00m>insert(*si);
stringSet.cc:274:{_F(this[01;31m-[00m>lisp());
stringSet.cc:278:    nset = O_StringSet::create(this[01;31m-[00m>lisp());
stringSet.cc:279:    for (si=this[01;31m-[00m>strs.begin();si!=this[01;31m-[00m>strs.end();si++){
stringSet.cc:280:        for (bi=b[01;31m-[00m>strs.begin();bi!=b[01;31m-[00m>strs.end();bi++){
stringSet.cc:283:	    nset[01;31m-[00m>insert(sstr.str());
stringSet.cc:290:{_F(this[01;31m-[00m>lisp());
stringSet.cc:291:RPCons cur = O_Cons::nil(this[01;31m-[00m>lisp());
stringSet.cc:293:    for (si=this[01;31m-[00m>strs.begin();si!=this[01;31m-[00m>strs.end();si++){
stringSet.cc:294:	RPString s = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(*si);
stringSet.cc:295:	cur = O_Cons::create(s,cur,this[01;31m-[00m>lisp());
stringSet.cc:305:    class_<O_StringSet>(this[01;31m-[00m>lisp())
stringSet.cc:378:	this[01;31m-[00m>strs.insert(x);
stringSet.cc:392:    for ( vi=this[01;31m-[00m>strs.begin(); vi!=this[01;31m-[00m>strs.end(); vi++ ) {
structureComparer.cc:31:    this[01;31m-[00m>Base::initialize();
structureComparer.cc:32:    this[01;31m-[00m>_AllAtoms.clear();
structureComparer.cc:33:    this[01;31m-[00m>_SuperposeAtoms.clear();
structureComparer.cc:40:{_F(this[01;31m-[00m>lisp());
structureComparer.cc:43:    this[01;31m-[00m>_Matter = matter;
structureComparer.cc:44:    this[01;31m-[00m>_AllAtoms.clear();
structureComparer.cc:48:	this[01;31m-[00m>_AllAtoms.insert(a);
structureComparer.cc:50:    this[01;31m-[00m>_SuperposeAtoms.clear();
structureComparer.cc:55:{_F(this[01;31m-[00m>lisp());
structureComparer.cc:57:    this[01;31m-[00m>_FixedCoordinates = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>(this[01;31m-[00m>_SuperposeAtoms.size());
structureComparer.cc:59:    for ( oa=this[01;31m-[00m>_SuperposeAtoms.begin(),ia=0; oa!=this[01;31m-[00m>_SuperposeAtoms.end(); oa++,ia++ )
structureComparer.cc:61:        this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>setElement(ia,(*oa)[01;31m-[00m>getPosition());
structureComparer.cc:67:{_F(this[01;31m-[00m>lisp());
structureComparer.cc:68:    this[01;31m-[00m>_SuperposeAtoms = atoms;
structureComparer.cc:69:    this[01;31m-[00m>initializeFixedCoordinates();
structureComparer.cc:73:{_F(this[01;31m-[00m>lisp());
structureComparer.cc:75:    this[01;31m-[00m>_SuperposeAtoms.clear();
structureComparer.cc:76:    for ( oa=this[01;31m-[00m>_AllAtoms.begin(); oa!=this[01;31m-[00m>_AllAtoms.end(); oa++ )
structureComparer.cc:78:        if ( (*oa)[01;31m-[00m>getElement() != element_H )
structureComparer.cc:80:	    this[01;31m-[00m>_SuperposeAtoms.insert(*oa);
structureComparer.cc:83:    this[01;31m-[00m>initializeFixedCoordinates();
structureComparer.cc:91:{_F(this[01;31m-[00m>lisp());
structureComparer.cc:99:    if ( matter != this[01;31m-[00m>_Matter )
structureComparer.cc:101:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("The Matter passed must be the same as the one defined for the StructureComparer"));
structureComparer.cc:104:    if ( this[01;31m-[00m>_SuperposeAtoms.size() < 3 )
structureComparer.cc:106:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must have defined at least three atoms to superpose"));
structureComparer.cc:108:    LOG(BF("Number of superpose atoms = %d") % this[01;31m-[00m>_SuperposeAtoms.size()  ); // vp0(("Number of superpose atoms = %d",this[01;31m-[00m>_SuperposeAtoms.size() ));
structureComparer.cc:115:    moveableCoordinates= this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>(this[01;31m-[00m>_SuperposeAtoms.size());
structureComparer.cc:116:    for ( ai=this[01;31m-[00m>_SuperposeAtoms.begin(), i=0;
structureComparer.cc:117:		ai!=this[01;31m-[00m>_SuperposeAtoms.end(); ai++, i++)
structureComparer.cc:119:	LOG(BF("Extracting coordinate for superpose atom(%s)") % (*ai)[01;31m-[00m>getName().c_str()  ); // vp0(("Extracting coordinate for superpose atom(%s)",(*ai)[01;31m-[00m>getName().c_str() ));
structureComparer.cc:120:	moveableCoordinates[01;31m-[00m>setElement(i,(*ai)[01;31m-[00m>getPosition());
structureComparer.cc:122:    LOG(BF("There are %d superposable atoms") % this[01;31m-[00m>_SuperposeAtoms.size()  ); // vp0(("There are %d superposable atoms",this[01;31m-[00m>_SuperposeAtoms.size() ));
structureComparer.cc:127:    superposer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SuperposeEngine>();
structureComparer.cc:128:    superposer[01;31m-[00m>setFixedAllPoints(this[01;31m-[00m>_FixedCoordinates);
structureComparer.cc:129:    superposer[01;31m-[00m>setMoveableAllPoints(moveableCoordinates);
structureComparer.cc:131:    this[01;31m-[00m>_TransformToFixed = superposer[01;31m-[00m>superpose();
structureComparer.cc:132:    rms = superposer[01;31m-[00m>rootMeanSquareDifference();
structureComparer.cc:139:{_F(this[01;31m-[00m>lisp());
structureComparer.cc:140:    node[01;31m-[00m>archiveObject( "Matter", this[01;31m-[00m>_Matter );
structureComparer.cc:141:    node[01;31m-[00m>archiveOrderedSet( "AllAtoms", this[01;31m-[00m>_AllAtoms );
structureComparer.cc:142:    node[01;31m-[00m>archiveOrderedSet( "SuperposeAtoms", this[01;31m-[00m>_SuperposeAtoms );
structureComparer.cc:143:    node[01;31m-[00m>archiveObject("FixedCoordinates",this[01;31m-[00m>_FixedCoordinates);
structureList.cc:41:    this[01;31m-[00m>Base::initialize();
structureList.cc:43:    this[01;31m-[00m>_Members = 0;
structureList.cc:44:    this[01;31m-[00m>_AllCoordinates = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>();
structureList.cc:45:    this[01;31m-[00m>_SuperposeCoordinates = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>();
structureList.cc:46:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
structureList.cc:52:{_F(this[01;31m-[00m>lisp());
structureList.cc:53:    node[01;31m-[00m>archiveWeakPointer( "structureList", this[01;31m-[00m>_WeakStructureList );
structureList.cc:54:    node[01;31m-[00m>archiveObject("allCoords", this[01;31m-[00m>_AllCoordinates );
structureList.cc:55:    node[01;31m-[00m>archiveObject("superposeCoords", this[01;31m-[00m>_SuperposeCoordinates );
structureList.cc:56:    node[01;31m-[00m>archiveObject("data",this[01;31m-[00m>_Data);
structureList.cc:57:    if ( node[01;31m-[00m>loading() )
structureList.cc:60:	LOG(BF("allCoords =%s") % (this[01;31m-[00m>_AllCoordinates[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("allCoords =%s",this[01;31m-[00m>_AllCoordinates[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:61:	LOG(BF("superposeCoords =%s") % (this[01;31m-[00m>_SuperposeCoordinates[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("superposeCoords =%s",this[01;31m-[00m>_SuperposeCoordinates[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:65:	LOG(BF("allCoords =%s") % (this[01;31m-[00m>_AllCoordinates[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("allCoords =%s",this[01;31m-[00m>_AllCoordinates[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:66:	LOG(BF("superposeCoords =%s") % (this[01;31m-[00m>_SuperposeCoordinates[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("superposeCoords =%s",this[01;31m-[00m>_SuperposeCoordinates[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:71:{_F(this[01;31m-[00m>lisp());
structureList.cc:73:    LOG(BF("setAllCoordinates:%s") % (ac[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("setAllCoordinates:%s",ac[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:75:    this[01;31m-[00m>_AllCoordinates = ac;
structureList.cc:79:{_F(this[01;31m-[00m>lisp());
structureList.cc:80:    LOG(BF("setSuperposeCoordinates:%s") % (ac[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("setSuperposeCoordinates:%s",ac[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:81:    this[01;31m-[00m>_SuperposeCoordinates = ac;
structureList.cc:87:{_F(this[01;31m-[00m>lisp());
structureList.cc:97:    this[01;31m-[00m>Base::initialize();
structureList.cc:98:    this[01;31m-[00m>_RmsCutOff = 0.05;
structureList.cc:99:    this[01;31m-[00m>_Matter = O_Matter::nil(this[01;31m-[00m>lisp());
structureList.cc:100:    this[01;31m-[00m>_SuperposeAtoms.clear();
structureList.cc:101:    this[01;31m-[00m>_AllAtoms.clear();
structureList.cc:102:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
structureList.cc:103:    this[01;31m-[00m>clearEntries();
structureList.cc:112:    sl = this[01;31m-[00m>getStructureList();
structureList.cc:113:    for ( ai=sl[01;31m-[00m>begin_AllAtoms(),ci=this[01;31m-[00m>_AllCoordinates[01;31m-[00m>begin(); ai!=sl[01;31m-[00m>end_AllAtoms(); ai++, ci++ )
structureList.cc:115:        (*ai)[01;31m-[00m>setPosition(*ci);
structureList.cc:124:    for ( ci=this[01;31m-[00m>_AllCoordinates[01;31m-[00m>begin(); ci!=this[01;31m-[00m>_AllCoordinates[01;31m-[00m>end(); ci++ )
structureList.cc:128:    for ( ci=this[01;31m-[00m>_SuperposeCoordinates[01;31m-[00m>begin(); ci!=this[01;31m-[00m>_SuperposeCoordinates[01;31m-[00m>end(); ci++ )
structureList.cc:142:    this[01;31m-[00m>_Status[01;31m-[00m>addMessage("extractCoordinatesFromMatter");
structureList.cc:144:    sl = this[01;31m-[00m>getStructureList();
structureList.cc:145:    for ( ai=sl[01;31m-[00m>begin_AllAtoms(),ci=this[01;31m-[00m>_AllCoordinates[01;31m-[00m>begin(); ai!=sl[01;31m-[00m>end_AllAtoms(); ai++, ci++ )
structureList.cc:147:        *ci = (*ai)[01;31m-[00m>getPosition();
structureList.cc:149:    for ( ai=sl[01;31m-[00m>begin_SuperposeAtoms(),ci=this[01;31m-[00m>_SuperposeCoordinates[01;31m-[00m>begin(); ai!=sl[01;31m-[00m>end_SuperposeAtoms(); ai++, ci++ )
structureList.cc:151:        *ci = (*ai)[01;31m-[00m>getPosition();
structureList.cc:156:{_F(this[01;31m-[00m>lisp());
structureList.cc:157:    this[01;31m-[00m>_Entries.clear();
structureList.cc:164:{_F(this[01;31m-[00m>lisp());
structureList.cc:167:    this[01;31m-[00m>_Matter = matter;
structureList.cc:168:    this[01;31m-[00m>_AllAtoms.clear();
structureList.cc:172:	this[01;31m-[00m>_AllAtoms.insert(a);
structureList.cc:174:    this[01;31m-[00m>_SuperposeAtoms.clear();
structureList.cc:182:{_F(this[01;31m-[00m>lisp());
structureList.cc:191:    if ( matter != this[01;31m-[00m>_Matter )
structureList.cc:193:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("The Matter passed must be the same as the one defined for the StructureList"));
structureList.cc:196:    if ( this[01;31m-[00m>_SuperposeAtoms.size() < 4 )
structureList.cc:198:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must have defined at least three atoms to superpose"));
structureList.cc:200:    LOG(BF("Number of superpose atoms = %d") % this[01;31m-[00m>_SuperposeAtoms.size()  ); // vp0(("Number of superpose atoms = %d",this[01;31m-[00m>_SuperposeAtoms.size() ));
structureList.cc:207:    newConf = O_CoordinateArray::create(this[01;31m-[00m>_SuperposeAtoms.size(),this[01;31m-[00m>lisp());
structureList.cc:208:    for ( ai=this[01;31m-[00m>_SuperposeAtoms.begin(), i=0;
structureList.cc:209:		ai!=this[01;31m-[00m>_SuperposeAtoms.end(); ai++, i++)
structureList.cc:211:	LOG(BF("Extracting coordinate for superpose atom(%s)") % (*ai)[01;31m-[00m>getName().c_str()  ); // vp0(("Extracting coordinate for superpose atom(%s)",(*ai)[01;31m-[00m>getName().c_str() ));
structureList.cc:212:	newConf[01;31m-[00m>setElement(i,(*ai)[01;31m-[00m>getPosition());
structureList.cc:214:    LOG(BF("There are %d superposable atoms") % this[01;31m-[00m>_SuperposeAtoms.size()  ); // vp0(("There are %d superposable atoms",this[01;31m-[00m>_SuperposeAtoms.size() ));
structureList.cc:218:	LOG(BF("Fixed points at the start of superposer: %s") % (newConf[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Fixed points at the start of superposer: %s",newConf[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:225:	    superposer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SuperposeEngine>();
structureList.cc:226:	    superposer[01;31m-[00m>setFixedAllPoints(newConf);
structureList.cc:232:		// Loop through the low[01;31m-[00mhigh entry range and compare the structures
structureList.cc:235:	    for ( ci=this[01;31m-[00m>_Entries.begin(); ci!=this[01;31m-[00m>_Entries.end(); ci++ )
structureList.cc:237:	        moveable = (*ci)[01;31m-[00m>getSuperposeCoordinates();
structureList.cc:238:		LOG(BF("Moveable points before superpose:%s") % (moveable[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Moveable points before superpose:%s",moveable[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:239:		superposer[01;31m-[00m>setMoveableAllPoints(moveable);
structureList.cc:240:		transform = superposer[01;31m-[00m>superpose();
structureList.cc:241:		rms = superposer[01;31m-[00m>rootMeanSquareDifference();
structureList.cc:242:		LOG(BF("The rms difference(%lf) with structure(%d) " "compared to _RmsCutOff(%lf)") % rms % i % this[01;31m-[00m>_RmsCutOff  ); // vp0(("The rms difference(%lf) with structure(%d) " "compared to _RmsCutOff(%lf)",rms,i,this[01;31m-[00m>_RmsCutOff ));
structureList.cc:243:		if ( rms < this[01;31m-[00m>_RmsCutOff )
structureList.cc:247:		    (*ci)[01;31m-[00m>setMembers((*ci)[01;31m-[00m>getMembers()+1);
structureList.cc:249:		    zilch = O_Structure_Old_ListEntry::nil(this[01;31m-[00m>lisp());
structureList.cc:250:	    	    LOG(BF("Fixed points at the end of superposer: %s") % (newConf[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Fixed points at the end of superposer: %s",newConf[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:253:		LOG(BF("Moveable points after superpose:%s") % (moveable[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Moveable points after superpose:%s",moveable[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:255:	    LOG(BF("Fixed points at the end of superposer: %s") % (newConf[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Fixed points at the end of superposer: %s",newConf[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:262:    entry = O_Structure_Old_ListEntry::create(this[01;31m-[00m>sharedThis<O_Structure_Old_List>(),this[01;31m-[00m>lisp());
structureList.cc:263:    entry[01;31m-[00m>setMembers(1);
structureList.cc:268:    newConf = O_CoordinateArray::create(this[01;31m-[00m>_AllAtoms.size(),this[01;31m-[00m>lisp());
structureList.cc:269:    for ( lai=this[01;31m-[00m>_AllAtoms.begin(),i=0;
structureList.cc:270:		lai!=this[01;31m-[00m>_AllAtoms.end(); lai++, i++)
structureList.cc:272:	newConf[01;31m-[00m>setElement(i,(*lai)[01;31m-[00m>getPosition());
structureList.cc:274:    entry[01;31m-[00m>setAllCoordinates(newConf);
structureList.cc:279:    newConf = O_CoordinateArray::create(this[01;31m-[00m>_SuperposeAtoms.size(),this[01;31m-[00m>lisp());
structureList.cc:280:    for ( ai=this[01;31m-[00m>_SuperposeAtoms.begin(),i=0;
structureList.cc:281:		ai!=this[01;31m-[00m>_SuperposeAtoms.end(); ai++, i++)
structureList.cc:283:	newConf[01;31m-[00m>setElement(i,(*ai)[01;31m-[00m>getPosition());
structureList.cc:285:    LOG(BF("Writing superpose coordinates to entry:%s") % (newConf[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Writing superpose coordinates to entry:%s",newConf[01;31m-[00m>asXmlString().c_str() ));
structureList.cc:286:    entry[01;31m-[00m>setSuperposeCoordinates(newConf);
structureList.cc:291:{_F(this[01;31m-[00m>lisp());
structureList.cc:292:    this[01;31m-[00m>_Entries.append(entry);
structureList.cc:303:    matter = orig[01;31m-[00m>getMatter();
structureList.cc:304:    ASSERTP(matter==this[01;31m-[00m>getMatter(),"The Matter objects must match");
structureList.cc:305:    for ( si=orig[01;31m-[00m>begin_Entries(); si!=orig[01;31m-[00m>end_Entries(); si++ )
structureList.cc:307:        (*si)[01;31m-[00m>writeCoordinatesToMatter(matter);
structureList.cc:308:	entry = this[01;31m-[00m>createStructureListEntryIfConformationIsNew(matter);
structureList.cc:310:	if ( entry[01;31m-[00m>notNil() )
structureList.cc:312:            this[01;31m-[00m>addEntry(entry);
structureList.cc:324:{_F(this[01;31m-[00m>lisp());
structureList.cc:325:    this[01;31m-[00m>_SuperposeAtoms = atoms;
structureList.cc:330:{_F(this[01;31m-[00m>lisp());
structureList.cc:331:    this[01;31m-[00m>_SuperposeAtoms.insert(a);
structureList.cc:337:{_F(this[01;31m-[00m>lisp());
structureList.cc:339:    this[01;31m-[00m>_SuperposeAtoms.clear();
structureList.cc:340:    for ( oa=this[01;31m-[00m>_AllAtoms.begin(); oa!=this[01;31m-[00m>_AllAtoms.end(); oa++ )
structureList.cc:342:        if ( (*oa)[01;31m-[00m>getElement() != element_H )
structureList.cc:344:	    this[01;31m-[00m>_SuperposeAtoms.insert(*oa);
structureList.cc:354:    node[01;31m-[00m>archiveObject( "Matter", this[01;31m-[00m>_Matter );
structureList.cc:355:    node[01;31m-[00m>archiveObjectIfDefined( "Data", this[01;31m-[00m>_Data );
structureList.cc:356:    node[01;31m-[00m>archiveList( "Entries", this[01;31m-[00m>_Entries );
structureList.cc:357:    node[01;31m-[00m>archiveOrderedSet( "AllAtoms", this[01;31m-[00m>_AllAtoms );
structureList.cc:358:    node[01;31m-[00m>archiveOrderedSet( "SuperposeAtoms", this[01;31m-[00m>_SuperposeAtoms );
structureList.cc:359:    node[01;31m-[00m>attribute( "RmsCutOff", this[01;31m-[00m>_RmsCutOff );
structureList.cc:364:    this[01;31m-[00m>archiveBase(node);
structureList.cc:374:    xml = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_XmlLoadArchive>();
structureList.cc:375:    xml[01;31m-[00m>parse(fn);
structureList.cc:376:    res = downcast<O_Structure_Old_List>(xml[01;31m-[00m>get("structureList"));
structureList.cc:384:{_F(this[01;31m-[00m>lisp());
structureList.cc:387:    xml = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_XmlSaveArchive>();
structureList.cc:388:    xml[01;31m-[00m>put("structureList",this[01;31m-[00m>sharedThis<O_Structure_Old_List>());
structureList.cc:389:    xml[01;31m-[00m>saveAs(fn);
structureList.cc:395:{_F(this[01;31m-[00m>lisp());
structureList.cc:406:    frames = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderFrameList>();
structureList.cc:407:    matter = this[01;31m-[00m>getMatter();
structureList.cc:408:    if ( this[01;31m-[00m>_Entries.size() == 0 )
structureList.cc:410:	dlMatter = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderMatter>();
structureList.cc:411:	dlMatter[01;31m-[00m>setName("molecule");
structureList.cc:412:	dlMatter[01;31m-[00m>setFromMatter(matter);
structureList.cc:413:	frames[01;31m-[00m>add(dlMatter);
structureList.cc:416:	for ( si=this[01;31m-[00m>begin_Entries(); si!=this[01;31m-[00m>end_Entries(); si++ )
structureList.cc:418:	    parts = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
structureList.cc:419:	    (*si)[01;31m-[00m>writeCoordinatesToMatter(matter);
structureList.cc:420:	    dlMatter = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderMatter>();
structureList.cc:421:	    dlMatter[01;31m-[00m>setName("molecule");
structureList.cc:422:	    dlMatter[01;31m-[00m>setFromMatter(matter);
structureList.cc:423:	    parts[01;31m-[00m>append(dlMatter);
structureList.cc:424:	    dlSuperpose = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
structureList.cc:425:	    dlSuperpose[01;31m-[00m>setName("superpose");
structureList.cc:426:	    grColor = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("green");
structureList.cc:427:	    dlSuperpose[01;31m-[00m>append(grColor);
structureList.cc:428:	    superposeCoords = (*si)[01;31m-[00m>getSuperposeCoordinates();
structureList.cc:429:	    grSpheres = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrSphereList>();
structureList.cc:430:	    grSpheres[01;31m-[00m>setRadius(0.2);
structureList.cc:431:	    for ( ci=superposeCoords[01;31m-[00m>begin(); ci!=superposeCoords[01;31m-[00m>end(); ci++ )
structureList.cc:433:		grSpheres[01;31m-[00m>addVertex(*ci);
structureList.cc:435:	    dlSuperpose[01;31m-[00m>append(grSpheres);
structureList.cc:436:	    parts[01;31m-[00m>append(dlSuperpose);
structureList.cc:437:	    frames[01;31m-[00m>add(parts);
structureList.cc:449:    ASSERT_lessThan(i,this[01;31m-[00m>_Entries.size());
structureList.cc:451:    e = this[01;31m-[00m>_Entries[i];
superposableConformationCollection.cc:26:    this[01;31m-[00m>Base::initialize();
superposableConformationCollection.cc:27:    this[01;31m-[00m>_SuperposeAtomIndices = O_IntArray::create(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:28:    this[01;31m-[00m>_RmsCutOff = 0.1;
superposableConformationCollection.cc:41:    this[01;31m-[00m>O_ConformationCollection::archive(node);
superposableConformationCollection.cc:42:    node[01;31m-[00m>attribute("RmsCutOff",this[01;31m-[00m>_RmsCutOff);
superposableConformationCollection.cc:43:    node[01;31m-[00m>archiveObject("SuperposeAtomIndices",this[01;31m-[00m>_SuperposeAtomIndices);
superposableConformationCollection.cc:50:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:51:    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeAtomIndices);
superposableConformationCollection.cc:52:    this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>clear();
superposableConformationCollection.cc:58:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:61:    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeAtomIndices);
superposableConformationCollection.cc:62:    for ( idx=0,ai=this[01;31m-[00m>begin_AllAtoms(); ai!=this[01;31m-[00m>end_AllAtoms(); idx++,ai++ )
superposableConformationCollection.cc:66:	    this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>append(idx);
superposableConformationCollection.cc:70:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("You cannot add superpose atom: "+a[01;31m-[00m>description()+" because it isn't in the ConformationCollection"));
superposableConformationCollection.cc:75:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:77:    this[01;31m-[00m>clearSuperposeAtoms();
superposableConformationCollection.cc:80:        this[01;31m-[00m>addSuperposeAtom(*ai);
superposableConformationCollection.cc:85:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:88:    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeAtomIndices);
superposableConformationCollection.cc:89:    this[01;31m-[00m>clearSuperposeAtoms();
superposableConformationCollection.cc:90:    for ( idx=0,ai=this[01;31m-[00m>begin_AllAtoms(); ai!=this[01;31m-[00m>end_AllAtoms(); idx++,ai++ )
superposableConformationCollection.cc:92:        if ( (*ai)[01;31m-[00m>getElement() != element_H )
superposableConformationCollection.cc:94:	    this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>append(idx);
superposableConformationCollection.cc:101:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:105:    ASSERT_NOT_NULL(this[01;31m-[00m>_SuperposeAtomIndices);
superposableConformationCollection.cc:106:    for ( si=this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>begin();si!=this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>end(); si++ )
superposableConformationCollection.cc:108:        a = this[01;31m-[00m>_AllAtoms[*si];
superposableConformationCollection.cc:116:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:117:    return this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>size();
superposableConformationCollection.cc:123:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:132:    ASSERT(matter==this[01;31m-[00m>_Matter);
superposableConformationCollection.cc:133:    LOG(BF("Number of superpose atoms = %d") % this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>size()  ); // vp0(("Number of superpose atoms = %d",this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>size() ));
superposableConformationCollection.cc:134:    ASSERT(this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>size() >= 4 );
superposableConformationCollection.cc:141:    newConf = this[01;31m-[00m>_extractCoordinateArray(matter);
superposableConformationCollection.cc:145:	LOG(BF("Fixed points at the start of superposer: %s") % (newConf[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Fixed points at the start of superposer: %s",newConf[01;31m-[00m>asXmlString().c_str() ));
superposableConformationCollection.cc:152:	    superposer = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SuperposeEngine>();
superposableConformationCollection.cc:153:	    superposer[01;31m-[00m>setFixedPoints(this[01;31m-[00m>_SuperposeAtomIndices,newConf);
superposableConformationCollection.cc:159:		// Loop through the low[01;31m-[00mhigh entry range and compare the structures
superposableConformationCollection.cc:162:	    for ( ci=this[01;31m-[00m>_Entries.begin(); ci!=this[01;31m-[00m>_Entries.end(); ci++ )
superposableConformationCollection.cc:164:	        moveable = (*ci)[01;31m-[00m>getAllCoordinates();
superposableConformationCollection.cc:165:		LOG(BF("Moveable points before superpose:%s") % (moveable[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Moveable points before superpose:%s",moveable[01;31m-[00m>asXmlString().c_str() ));
superposableConformationCollection.cc:166:		superposer[01;31m-[00m>setMoveablePoints(this[01;31m-[00m>_SuperposeAtomIndices, moveable);
superposableConformationCollection.cc:168:		transform = superposer[01;31m-[00m>superpose();
superposableConformationCollection.cc:169:		rms = superposer[01;31m-[00m>rootMeanSquareDifference();
superposableConformationCollection.cc:170:		LOG(BF("The rms difference(%lf) with structure(%d) " "compared to _RmsCutOff(%lf)") % rms % i % this[01;31m-[00m>_RmsCutOff  ); // vp0(("The rms difference(%lf) with structure(%d) " "compared to _RmsCutOff(%lf)",rms,i,this[01;31m-[00m>_RmsCutOff ));
superposableConformationCollection.cc:171:		if ( rms < this[01;31m-[00m>_RmsCutOff )
superposableConformationCollection.cc:176:		    zilch = O_ConformationCollectionEntry::nil(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:177:	    	    LOG(BF("Fixed points at the end of superposer: %s") % (newConf[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Fixed points at the end of superposer: %s",newConf[01;31m-[00m>asXmlString().c_str() ));
superposableConformationCollection.cc:180:		LOG(BF("Moveable points after superpose:%s") % (moveable[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Moveable points after superpose:%s",moveable[01;31m-[00m>asXmlString().c_str() ));
superposableConformationCollection.cc:182:	    LOG(BF("Fixed points at the end of superposer: %s") % (newConf[01;31m-[00m>asXmlString().c_str() ) ); // vp0(("Fixed points at the end of superposer: %s",newConf[01;31m-[00m>asXmlString().c_str() ));
superposableConformationCollection.cc:189:    entry = this[01;31m-[00m>createEntry();
superposableConformationCollection.cc:190:    entry[01;31m-[00m>setAllCoordinates(newConf);
superposableConformationCollection.cc:195:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:207:    frames = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderFrameList>();
superposableConformationCollection.cc:208:    matter = this[01;31m-[00m>getMatter();
superposableConformationCollection.cc:209:    for ( si=this[01;31m-[00m>begin_Entries(); si!=this[01;31m-[00m>end_Entries(); si++ )
superposableConformationCollection.cc:211:        (*si)[01;31m-[00m>writeCoordinatesToMatter(matter);
superposableConformationCollection.cc:212:	dlAll = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
superposableConformationCollection.cc:213:	dlMatter = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderMatter>();
superposableConformationCollection.cc:214:	dlMatter[01;31m-[00m>setName("minimized");
superposableConformationCollection.cc:215:	dlMatter[01;31m-[00m>setFromMatter(matter);
superposableConformationCollection.cc:216:	dlAll[01;31m-[00m>add(dlMatter);
superposableConformationCollection.cc:217:	dlSuperpose = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_RenderDisplayList>();
superposableConformationCollection.cc:218:	dlSuperpose[01;31m-[00m>setName("superposeAtoms");
superposableConformationCollection.cc:219:	dlSuperpose[01;31m-[00m>add(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>("yellow"));
superposableConformationCollection.cc:220:	RPGrSphereList sphereList = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrSphereList>();
superposableConformationCollection.cc:221:	sphereList[01;31m-[00m>setRadius(0.2);
superposableConformationCollection.cc:222:	for ( ii=this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>begin(); ii!=this[01;31m-[00m>_SuperposeAtomIndices[01;31m-[00m>end(); ii++ )
superposableConformationCollection.cc:224:	    sphereList[01;31m-[00m>addVertex(this[01;31m-[00m>_AllAtoms[*ii][01;31m-[00m>getPosition());
superposableConformationCollection.cc:226:	dlSuperpose[01;31m-[00m>add(sphereList);
superposableConformationCollection.cc:227:	dlAll[01;31m-[00m>add(dlSuperpose);
superposableConformationCollection.cc:228:	frames[01;31m-[00m>add(dlAll);
superposableConformationCollection.cc:239:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:240:    superposer[01;31m-[00m>setFixedPoints(this[01;31m-[00m>_SuperposeAtomIndices,
superposableConformationCollection.cc:241:    				entry[01;31m-[00m>getAllCoordinates());
superposableConformationCollection.cc:248:{_F(this[01;31m-[00m>lisp());
superposableConformationCollection.cc:249:    superposer[01;31m-[00m>setMoveablePoints(this[01;31m-[00m>_SuperposeAtomIndices,
superposableConformationCollection.cc:250:    				entry[01;31m-[00m>getAllCoordinates());
superposeEngine.cc:38:    class_<O_SuperposeEngine>(e[01;31m-[00m>lisp())
superposeEngine.cc:81:{ _F(indices[01;31m-[00m>lisp());
superposeEngine.cc:85:    ASSERTP(indices[01;31m-[00m>size()<=pnts[01;31m-[00m>size(),"There must be at least as many indices as coordinates");
superposeEngine.cc:87:    if ( indices[01;31m-[00m>size() == 0 ) return pos;
superposeEngine.cc:89:    for ( it=indices[01;31m-[00m>begin();
superposeEngine.cc:90:		it!=indices[01;31m-[00m>end();
superposeEngine.cc:92:	pos = pos + pnts[01;31m-[00m>getElement(*it);
superposeEngine.cc:94:    pos = pos.multiplyByScalar(1.0/((double)(indices[01;31m-[00m>size())));
superposeEngine.cc:99:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:100:    this[01;31m-[00m>Base::initialize();
superposeEngine.cc:101:    this[01;31m-[00m>_State = init;
superposeEngine.cc:109:	this[01;31m-[00m>_MoveableIndices[01;31m-[00m>clear();
superposeEngine.cc:110:	this[01;31m-[00m>_MoveableCoordinates[01;31m-[00m>clear();
superposeEngine.cc:115:	this[01;31m-[00m>_FixedIndices[01;31m-[00m>clear();
superposeEngine.cc:116:	this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>clear();
superposeEngine.cc:121:	int idx = this[01;31m-[00m>_MoveableCoordinates[01;31m-[00m>size();
superposeEngine.cc:122:	this[01;31m-[00m>_MoveableIndices[01;31m-[00m>append(idx);
superposeEngine.cc:123:	this[01;31m-[00m>_MoveableCoordinates[01;31m-[00m>push_back(pos);
superposeEngine.cc:128:	int idx = this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>size();
superposeEngine.cc:129:	this[01;31m-[00m>_FixedIndices[01;31m-[00m>append(idx);
superposeEngine.cc:130:	this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>push_back(pos);
superposeEngine.cc:136:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:137:    return this[01;31m-[00m>_FixedIndices[01;31m-[00m>size();
superposeEngine.cc:142:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:143:    return this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size();
superposeEngine.cc:148:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:162:    fixedIndicesSize = this[01;31m-[00m>_FixedIndices[01;31m-[00m>size();
superposeEngine.cc:163:    moveableIndicesSize = this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size();
superposeEngine.cc:167:    Sj.resize(this[01;31m-[00m>_FixedIndices[01;31m-[00m>size());
superposeEngine.cc:168:    if ( this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size() < 3 )
superposeEngine.cc:170:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Number of MoveableIndices must be greater than 3"));
superposeEngine.cc:172:    Si.resize(this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size());
superposeEngine.cc:173:    LOG(BF("this[01;31m-[00m>_FixedIndices[01;31m-[00m>size()=%d") % this[01;31m-[00m>_FixedIndices[01;31m-[00m>size()  ); // vp0(( "this[01;31m-[00m>_FixedIndices[01;31m-[00m>size()=%d", this[01;31m-[00m>_FixedIndices[01;31m-[00m>size() ));
superposeEngine.cc:174:    LOG(BF("this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size()=%d") % this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size()  ); // vp0(( "this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size()=%d", this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size() ));
superposeEngine.cc:177:	fixedCenter = geometricCenterOfPointsIndirect(this[01;31m-[00m>_FixedIndices,this[01;31m-[00m>_FixedCoordinates);
superposeEngine.cc:180:	for ( iaV=this[01;31m-[00m>_FixedIndices[01;31m-[00m>begin(),itS=Sj.begin();
superposeEngine.cc:181:		    iaV!=this[01;31m-[00m>_FixedIndices[01;31m-[00m>end();
superposeEngine.cc:183:	    LOG(BF("index=%d   *iaV=%d    pnt=%s") % (iaV[01;31m-[00mthis[01;31m-[00m>_FixedIndices[01;31m-[00m>begin()) 
superposeEngine.cc:184:		% *iaV % this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>getElement(*iaV).asString().c_str() ); 
superposeEngine.cc:185:	    *itS = this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>getElement(*iaV) [01;31m-[00m fixedCenter;
superposeEngine.cc:190:	for ( iaV=this[01;31m-[00m>_MoveableIndices[01;31m-[00m>begin(); iaV !=this[01;31m-[00m>_MoveableIndices[01;31m-[00m>end(); iaV++ ) {
superposeEngine.cc:191:	    moveableCenter = this[01;31m-[00m>_MoveableCoordinates[01;31m-[00m>getElement(*iaV) + moveableCenter;
superposeEngine.cc:193:	moveableCenter = moveableCenter.multiplyByScalar(1.0/(double)(this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size()));
superposeEngine.cc:195:	for ( iaV=this[01;31m-[00m>_MoveableIndices[01;31m-[00m>begin(),itS=Si.begin();
superposeEngine.cc:198:	    *itS = this[01;31m-[00m>_MoveableCoordinates[01;31m-[00m>getElement(*iaV) [01;31m-[00m moveableCenter;
superposeEngine.cc:200:		% (iaV[01;31m-[00mthis[01;31m-[00m>_MoveableIndices[01;31m-[00m>begin())
superposeEngine.cc:202:		% this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>getElement(*iaV).asString().c_str() );
superposeEngine.cc:211:	X0 = itSj[01;31m-[00m>getX();
superposeEngine.cc:212:	X1 = itSj[01;31m-[00m>getY();
superposeEngine.cc:213:	X2 = itSj[01;31m-[00m>getZ();
superposeEngine.cc:214:	x0 = itSi[01;31m-[00m>getX();
superposeEngine.cc:215:	x1 = itSi[01;31m-[00m>getY();
superposeEngine.cc:216:	x2 = itSi[01;31m-[00m>getZ();
superposeEngine.cc:240:    P = M + (MT [01;31m-[00m (trM*2.0));
superposeEngine.cc:241:    P.atRowColPut(0,3,M.atRowCol(1,2)[01;31m-[00mM.atRowCol(2,1));
superposeEngine.cc:243:    P.atRowColPut(1,3,M.atRowCol(2,0)[01;31m-[00mM.atRowCol(0,2));
superposeEngine.cc:245:    P.atRowColPut(2,3,M.atRowCol(0,1)[01;31m-[00mM.atRowCol(1,0));
superposeEngine.cc:269:    rot.atRowColPut( 0,0, ll [01;31m-[00m mm [01;31m-[00m nn + ss );
superposeEngine.cc:270:    rot.atRowColPut( 0,1,  2*(l*m [01;31m-[00m n*s));
superposeEngine.cc:273:    rot.atRowColPut( 1,1,  [01;31m-[00mll + mm [01;31m-[00m nn + ss);
superposeEngine.cc:274:    rot.atRowColPut( 1,2,  2*(m*n [01;31m-[00m l*s));
superposeEngine.cc:275:    rot.atRowColPut( 2,0,  2*(l*n [01;31m-[00m m*s));
superposeEngine.cc:277:    rot.atRowColPut( 2,2,  [01;31m-[00mll [01;31m-[00m mm + nn + ss);
superposeEngine.cc:280:    vTemp = moveableCenter*[01;31m-[00m1.0;
superposeEngine.cc:288:    this[01;31m-[00m>_Transform = trans*mat;
superposeEngine.cc:298:{ _F(this[01;31m-[00m>lisp());
superposeEngine.cc:304:ASSERT_NOT_NULL(this[01;31m-[00m>_MoveableIndices);
superposeEngine.cc:305:ASSERT_NOT_NULL(this[01;31m-[00m>_FixedIndices);
superposeEngine.cc:308:    LOG_SCORE(scorerState,BF("There are %d moveable indices")%this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size() );
superposeEngine.cc:309:    LOG_SCORE(scorerState,BF("There are %d fixed indices")%this[01;31m-[00m>_FixedIndices[01;31m-[00m>size() );
superposeEngine.cc:310:    for ( ititMoved = this[01;31m-[00m>_MoveableIndices[01;31m-[00m>begin(),
superposeEngine.cc:311:			itFixed = this[01;31m-[00m>_FixedIndices[01;31m-[00m>begin();
superposeEngine.cc:312:		itFixed != this[01;31m-[00m>_FixedIndices[01;31m-[00m>end();
superposeEngine.cc:316:		this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>getElement(*itFixed).asString()
superposeEngine.cc:317:		% this[01;31m-[00m>_MoveableCoordinates[01;31m-[00m>getElement(*ititMoved).asString()
superposeEngine.cc:320:    LOG_SCORE(BF(scorerState,"O_SuperposeEngine calculated transform\n%s")% this[01;31m-[00m>_Transform.asString());
superposeEngine.cc:322:    double result = this[01;31m-[00m>sumOfSquaresOfDifferences();
superposeEngine.cc:334:{ _F(this[01;31m-[00m>lisp());
superposeEngine.cc:341:ASSERT_NOT_NULL(this[01;31m-[00m>_MoveableIndices);
superposeEngine.cc:342:ASSERT_NOT_NULL(this[01;31m-[00m>_FixedIndices);
superposeEngine.cc:344:    LOG(BF("There are %d moveable indices") % this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size()  ); // vp0(("There are %d moveable indices",this[01;31m-[00m>_MoveableIndices[01;31m-[00m>size() ));
superposeEngine.cc:345:    LOG(BF("There are %d fixed indices") % this[01;31m-[00m>_FixedIndices[01;31m-[00m>size()  ); // vp0(("There are %d fixed indices",this[01;31m-[00m>_FixedIndices[01;31m-[00m>size() ));
superposeEngine.cc:346:    for ( ititMoved = this[01;31m-[00m>_MoveableIndices[01;31m-[00m>begin(),
superposeEngine.cc:347:			itFixed = this[01;31m-[00m>_FixedIndices[01;31m-[00m>begin();
superposeEngine.cc:348:		itFixed != this[01;31m-[00m>_FixedIndices[01;31m-[00m>end();
superposeEngine.cc:351:	LOG(BF("Superpose fixed%s with moveable%s") % this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>getElement(*itFixed).asString().c_str() % this[01;31m-[00m>_MoveableCoordinates[01;31m-[00m>getElement(*ititMoved).asString().c_str() ); // vp0(("Superpose fixed%s with moveable%s",this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>getElement(*itFixed).asString().c_str(),this[01;31m-[00m>_MoveableCoordinates[01;31m-[00m>getElement(*ititMoved).asString().c_str()));
superposeEngine.cc:354:    ASSERT(this[01;31m-[00m>_FixedIndices[01;31m-[00m>size()!=0);
superposeEngine.cc:356:    for ( ititMoved = this[01;31m-[00m>_MoveableIndices[01;31m-[00m>begin(),
superposeEngine.cc:357:			itFixed = this[01;31m-[00m>_FixedIndices[01;31m-[00m>begin();
superposeEngine.cc:358:		itFixed != this[01;31m-[00m>_FixedIndices[01;31m-[00m>end();
superposeEngine.cc:360:	moved = this[01;31m-[00m>_Transform.multiplyByVector3(this[01;31m-[00m>_MoveableCoordinates[01;31m-[00m>getElement(*ititMoved));
superposeEngine.cc:361:	diff = this[01;31m-[00m>_FixedCoordinates[01;31m-[00m>getElement(*itFixed)[01;31m-[00mmoved;
superposeEngine.cc:374:{ _F(this[01;31m-[00m>lisp());
superposeEngine.cc:376:    rms = sqrt(this[01;31m-[00m>sumOfSquaresOfDifferences());
superposeEngine.cc:386:{ _F(this[01;31m-[00m>lisp());
superposeEngine.cc:387:    LOG(BF("O_SuperposeEngine::setFixedPoints [01;31m-[00m[01;31m-[00m> number of points=%d") % fc[01;31m-[00m>size()  ); // vp0(( "O_SuperposeEngine::setFixedPoints [01;31m-[00m[01;31m-[00m> number of points=%d", fc[01;31m-[00m>size() ));
superposeEngine.cc:388:    if ( !((fi[01;31m-[00m>size()>=3) && ((fi[01;31m-[00m>size()<=fc[01;31m-[00m>size()))) )
superposeEngine.cc:391:	ss << "In SuperposeEngine setFixedPoints [01;31m-[00m number of indices fi[01;31m-[00m>size() = ";
superposeEngine.cc:392:	ss << fi[01;31m-[00m>size() << " must be at least 3"<< endl;
superposeEngine.cc:393:	ss << "Number of coordinates [01;31m-[00m[01;31m-[00m> fc[01;31m-[00m>size() = ";
superposeEngine.cc:394:	ss << fc[01;31m-[00m>size() << " must be greator than or equal to fi[01;31m-[00m>size(";
superposeEngine.cc:395:	ss << fi[01;31m-[00m>size() << ")" << endl;
superposeEngine.cc:397:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>(ss.str()));
superposeEngine.cc:399:    this[01;31m-[00m>_FixedIndices = fi;
superposeEngine.cc:400:    this[01;31m-[00m>_FixedCoordinates = fc;
superposeEngine.cc:401:    this[01;31m-[00m>_State = gotFixed;
superposeEngine.cc:407:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:410:    this[01;31m-[00m>_FixedCoordinates = fc;
superposeEngine.cc:411:    this[01;31m-[00m>_FixedIndices = O_IntArray::create(fc[01;31m-[00m>size(),this[01;31m-[00m>lisp());
superposeEngine.cc:413:    for ( ii=0; ii<fc[01;31m-[00m>size(); ii++ )
superposeEngine.cc:415:        this[01;31m-[00m>_FixedIndices[01;31m-[00m>put(ii,ii);
superposeEngine.cc:418:    this[01;31m-[00m>_State = gotFixed;
superposeEngine.cc:424:{ _F(this[01;31m-[00m>lisp());
superposeEngine.cc:426:    LOG(BF("O_SuperposeEngine::setMoveablePoints [01;31m-[00m[01;31m-[00m> number of points=%d") % mc[01;31m-[00m>size()  ); // vp0(( "O_SuperposeEngine::setMoveablePoints [01;31m-[00m[01;31m-[00m> number of points=%d", mc[01;31m-[00m>size() ));
superposeEngine.cc:427:    if ( this[01;31m-[00m>_State == init ) {
superposeEngine.cc:428:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( "You must define a SuperposeEngines fixed points before you define the moveable ones" ) );
superposeEngine.cc:430:    ASSERTP( (mi[01;31m-[00m>size()>=3), "There must be at least three indices" );
superposeEngine.cc:431:    ASSERTP( mi[01;31m-[00m>size()<=mc[01;31m-[00m>size(), "There must be at least as many coordinates as indices");
superposeEngine.cc:432:    this[01;31m-[00m>_MoveableIndices = mi;
superposeEngine.cc:433:    this[01;31m-[00m>_MoveableCoordinates = mc[01;31m-[00m>copy();
superposeEngine.cc:434:    this[01;31m-[00m>_State = gotMoveable;
superposeEngine.cc:438:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:441:    if ( this[01;31m-[00m>_State == init ) {
superposeEngine.cc:442:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( "You must define a SuperposeEngines fixed points before you define the moveable ones" ) );
superposeEngine.cc:444:    ASSERTF(mc[01;31m-[00m>size()>=3,BF("You must have at least three moveable points and there are only %d") % mc[01;31m-[00m>size() );
superposeEngine.cc:445:    this[01;31m-[00m>_MoveableCoordinates = mc;
superposeEngine.cc:446:    this[01;31m-[00m>_MoveableIndices = O_IntArray::create(mc[01;31m-[00m>size(),this[01;31m-[00m>lisp());
superposeEngine.cc:447:    for ( ii=0; ii<mc[01;31m-[00m>size(); ii++ )
superposeEngine.cc:449:        this[01;31m-[00m>_MoveableIndices[01;31m-[00m>put(ii,ii);
superposeEngine.cc:452:    this[01;31m-[00m>_State = gotMoveable;
superposeEngine.cc:462:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:464:    if ( this[01;31m-[00m>_State == init ) {
superposeEngine.cc:465:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( "SuperposeEngine::You must setup the fixed and moveable points first before calling superpose" ));
superposeEngine.cc:468:    if ( this[01;31m-[00m>_State == gotFixed ) {
superposeEngine.cc:469:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( "SuperposeEngine::You must setup the moveable points first before calling superpose" ));
superposeEngine.cc:472:    if ( this[01;31m-[00m>_State == gotMoveable ) {
superposeEngine.cc:474:	this[01;31m-[00m>doSuperpose();
superposeEngine.cc:476:	LOG(BF("DID NOT GET MOVEABLE state(%d), returning") % this[01;31m-[00m>_State ); // vp0(( "DID NOT GET MOVEABLE state(%d), returning",this[01;31m-[00m>_State));
superposeEngine.cc:477:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( "SuperposeEngine::You must define the moveable points before calling superpose" ));
superposeEngine.cc:479:    LOG(BF("Carried out superpose and the transform is:%s") % (this[01;31m-[00m>_Transform.asString().c_str() ) ); // vp0(("Carried out superpose and the transform is:%s",this[01;31m-[00m>_Transform.asString().c_str() ));
superposeEngine.cc:480:    return this[01;31m-[00m>_Transform;
superposeEngine.cc:485:    class_<O_SuperposeSelectedAtoms>(e[01;31m-[00m>lisp())
superposeEngine.cc:507:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:508:    this[01;31m-[00m>Base::initialize();
superposeEngine.cc:509:    this[01;31m-[00m>_Matter = O_Matter::nil(this[01;31m-[00m>lisp());
superposeEngine.cc:510:    this[01;31m-[00m>_SuperposeAtoms.clear();
superposeEngine.cc:515:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:516:    this[01;31m-[00m>Base::archiveBase(node);
superposeEngine.cc:517:    node[01;31m-[00m>archiveObject("matter",this[01;31m-[00m>_Matter);
superposeEngine.cc:518:    node[01;31m-[00m>archiveList("superposeAtoms",this[01;31m-[00m>_SuperposeAtoms);
superposeEngine.cc:523:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:525:    this[01;31m-[00m>_SuperposeAtoms.clear();
superposeEngine.cc:526:    lAtoms.loopTopGoal(this[01;31m-[00m>_Matter,ATOMS);
superposeEngine.cc:529:    RPSymbol superposeSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>predefinedSymbol(_sym_kw_superpose);
superposeEngine.cc:533:	if ( a[01;31m-[00m>getPropertyOrDefault(superposeSymbol,this[01;31m-[00m>lisp()[01;31m-[00m>_boolean(true))[01;31m-[00m>isTrue() )
superposeEngine.cc:535:	    this[01;31m-[00m>_SuperposeAtoms.push_back(a);
superposeEngine.cc:542:    ASSERT_gt(this[01;31m-[00m>_SuperposeAtoms.size(),0);
superposeEngine.cc:547:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:548:    this[01;31m-[00m>_Matter = matter[01;31m-[00m>copy();
superposeEngine.cc:549:    this[01;31m-[00m>_SuperposeAtoms.clear();
superposeEngine.cc:553:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:554:    this[01;31m-[00m>setMatter(matter);
superposeEngine.cc:555:    this[01;31m-[00m>updateSuperposeAtoms();
superposeEngine.cc:561:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:562:    if ( !this[01;31m-[00m>_Matter[01;31m-[00m>equal(matter) )
superposeEngine.cc:564:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The Matters are not equal"));
superposeEngine.cc:566:    this[01;31m-[00m>_Matter[01;31m-[00m>transferCoordinates(matter);
superposeEngine.cc:567:    ASSERT_gt(this[01;31m-[00m>_SuperposeAtoms.size(),0);
superposeEngine.cc:568:    RPCoordinateArray coords = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>(this[01;31m-[00m>_SuperposeAtoms.size());
superposeEngine.cc:570:    for (List<O_Atom>::iterator ai=this[01;31m-[00m>_SuperposeAtoms.begin(); ai!=this[01;31m-[00m>_SuperposeAtoms.end(); ai++, idx++ )
superposeEngine.cc:572:	coords[01;31m-[00m>setElement(idx,(*ai)[01;31m-[00m>getPosition());
superposeEngine.cc:579:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:580:    return this[01;31m-[00m>_Matter;
superposeEngine.cc:584:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:585:    RPCoordinateArray ca = this[01;31m-[00m>extractCoordinates(matter);
superposeEngine.cc:586:    ASSERT_gt(ca[01;31m-[00m>size(),0);
superposeEngine.cc:587:    this[01;31m-[00m>setFixedAllPoints(ca);
superposeEngine.cc:591:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:592:    RPCoordinateArray ca = this[01;31m-[00m>extractCoordinates(matter);
superposeEngine.cc:593:    ASSERT_gt(ca[01;31m-[00m>size(),0);
superposeEngine.cc:594:    this[01;31m-[00m>setMoveableAllPoints(ca);
superposeEngine.cc:635:{_F(this[01;31m-[00m>lisp());
superposeEngine.cc:640:    if ( ll != this[01;31m-[00m>_Fixed[01;31m-[00m>size() ) {
superposeEngine.cc:641:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Superpose must have the same number of moveable indexes as fixed points"));
superposeEngine.cc:643:    this[01;31m-[00m>_MoveableLookup.clear();
superposeEngine.cc:649:    this[01;31m-[00m>setMoveableIndex(vi);
symbol.cc:23:	class_<O_Symbol>(e[01;31m-[00m>lisp())
symbol.cc:40:	    TOSS(lisp[01;31m-[00m>create<O_LispError>(BF("A symbol is being defined with a double quote in the name(%s)") % nm ));
symbol.cc:42:	n[01;31m-[00m>_Name = nm;
symbol.cc:49:	this[01;31m-[00m>_Name = "notYetDefined";
symbol.cc:50:	this[01;31m-[00m>_WeakPackage.reset();
symbol.cc:51:	this[01;31m-[00m>_IsDynamic = false;
symbol.cc:57:    {_F(this[01;31m-[00m>lisp());
symbol.cc:58:	LOG(BF("Evaluating symbol: %s") % this[01;31m-[00m>_Value.c_str()  ); // vp0(("Evaluating symbol: %s", this[01;31m-[00m>_Value.c_str() ));
symbol.cc:59:	RPObject res = env[01;31m-[00m>environment()[01;31m-[00m>oget(this[01;31m-[00m>sharedThis<O_Symbol>());
symbol.cc:68:	return this[01;31m-[00m>_WeakPackage.lock()[01;31m-[00m>isAmpPackage();
symbol.cc:73:	return this[01;31m-[00m>_WeakPackage.lock()[01;31m-[00m>isKeywordPackage();
symbol.cc:77:    {_F(this[01;31m-[00m>lisp());
symbol.cc:78:	IMPLEMENT_ME(); // [01;31m-[00m somehow I have to tie symbols into the existing environment
symbol.cc:79:	this[01;31m-[00m>Base::archiveBase(node);
symbol.cc:80:	node[01;31m-[00m>attribute("pn",this[01;31m-[00m>_Name);
symbol.cc:81:	node[01;31m-[00m>archiveWeakPointer("pkg",this[01;31m-[00m>_WeakPackage);
symbol.cc:86:	if ( this[01;31m-[00m>_WeakPackage.lock()[01;31m-[00m>isKeywordPackage() ) return this[01;31m-[00m>sharedThis<O_Symbol>();
symbol.cc:87:	RPSymbol kwSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(this[01;31m-[00m>identifierName());
symbol.cc:95:	return this[01;31m-[00m>_IsDynamic;
symbol.cc:100:	this[01;31m-[00m>_IsDynamic = dyn;
symbol.cc:101:	this[01;31m-[00m>_DynamicBindingStack.clear();
symbol.cc:106:	ASSERT(this[01;31m-[00m>_IsDynamic);
symbol.cc:107:	ASSERT(this[01;31m-[00m>_DynamicBindingStack.size()>0);
symbol.cc:108:	*(this[01;31m-[00m>_DynamicBindingStack.end()[01;31m-[00m1)=val;
symbol.cc:113:	ASSERT(this[01;31m-[00m>_IsDynamic);
symbol.cc:114:	ASSERT(this[01;31m-[00m>_DynamicBindingStack.size()>0);
symbol.cc:115:	return this[01;31m-[00m>_DynamicBindingStack.back();
symbol.cc:121:	this[01;31m-[00m>_DynamicBindingStack.push_back(obj);
symbol.cc:126:	ASSERT(this[01;31m-[00m>_IsDynamic);
symbol.cc:127:	ASSERT(this[01;31m-[00m>_DynamicBindingStack.size()>0);
symbol.cc:128:	this[01;31m-[00m>_DynamicBindingStack.pop_back();
symbol.cc:134:    {_F(this[01;31m-[00m>lisp());
symbol.cc:135:	LOG(BF("Dumping symbol with name: %s")% this[01;31m-[00m>_Name);
symbol.cc:136:	if ( this[01;31m-[00m>isNil() ) return ClPackage+":nil";
symbol.cc:138:	RPPackage myPackage = this[01;31m-[00m>_WeakPackage.lock();
symbol.cc:139:	if ( this[01;31m-[00m>_WeakPackage.use_count() == 0 )
symbol.cc:142:	    ss << "#:" << this[01;31m-[00m>_Name;
symbol.cc:143:	} else if ( myPackage[01;31m-[00m>isKeywordPackage() )
symbol.cc:146:	    ss << ":" << this[01;31m-[00m>_Name;
symbol.cc:147:	} else if ( myPackage[01;31m-[00m>isAmpPackage() )
symbol.cc:150:	    ss << "&" << this[01;31m-[00m>_Name;
symbol.cc:152:	    LOG(BF("In package: %s")% myPackage[01;31m-[00m>getName());
symbol.cc:153:	    RPLisp lisp = myPackage[01;31m-[00m>lisp();
symbol.cc:154:	    RPPackage currentPackage = lisp[01;31m-[00m>getCurrentPackage();
symbol.cc:158:		ss << this[01;31m-[00m>_Name;
symbol.cc:162:		ss << myPackage[01;31m-[00m>getName() << ":" << this[01;31m-[00m>_Name;
symbol.cc:173:	return this[01;31m-[00m>formattedName(false);
symbol.cc:178:	string formattedName = this[01;31m-[00m>formattedName(false);
symbol.cc:185:	string formattedName = this[01;31m-[00m>formattedName(true);
symbol.cc:193:	return this[01;31m-[00m>_Name;
symbol.cc:198:    {_F(this[01;31m-[00m>lisp());
symbol.cc:199:	if ( this[01;31m-[00m>_WeakPackage.use_count() == 0 ) return O_Package::nil(this[01;31m-[00m>lisp());
symbol.cc:200:	return this[01;31m-[00m>_WeakPackage.lock();
symbol.cc:204:    {_F(this[01;31m-[00m>lisp());
symbol.cc:205:	this[01;31m-[00m>_WeakPackage = p;
symbolToEnumConverter.cc:20:    class_<O_SymbolToEnumConverter>(e[01;31m-[00m>lisp())
symbolToEnumConverter.cc:38:    RPSymbolToEnumConverter c = lisp[01;31m-[00m>create<O_SymbolToEnumConverter>();
symbolToEnumConverter.cc:39:    c[01;31m-[00m>setWhatTheEnumsRepresent(whatDoesEnumRepresent);
symbolToEnumConverter.cc:45:    this[01;31m-[00m>_WhatTheEnumsRepresent = what;
symbolToEnumConverter.cc:50:    if ( sym[01;31m-[00m>isNil() )
symbolToEnumConverter.cc:52:	sym = this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(archiveString);
symbolToEnumConverter.cc:54:    this[01;31m-[00m>_EnumToSymbol[enumIndex] = sym;
symbolToEnumConverter.cc:55:    this[01;31m-[00m>_ArchiveStringToEnum[archiveString] = enumIndex;
symbolToEnumConverter.cc:56:    this[01;31m-[00m>_EnumToArchiveString[enumIndex] = archiveString;
symbolToEnumConverter.cc:57:    this[01;31m-[00m>_SymbolToEnum[01;31m-[00m>extend(sym,this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Int>(enumIndex));
symbolToEnumConverter.cc:63:    ASSERT(this[01;31m-[00m>_SymbolToEnum[01;31m-[00m>contains(sym));
symbolToEnumConverter.cc:64:    return this[01;31m-[00m>_SymbolToEnum[01;31m-[00m>lookup(sym)[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
symbolToEnumConverter.cc:69:    ASSERT(this[01;31m-[00m>_ArchiveStringToEnum.count(str)>0);
symbolToEnumConverter.cc:70:    return this[01;31m-[00m>_ArchiveStringToEnum[str];
symbolToEnumConverter.cc:76:    ASSERT(this[01;31m-[00m>_EnumToSymbol.count(index)>0);
symbolToEnumConverter.cc:77:    return this[01;31m-[00m>_EnumToSymbol[index];
symbolToEnumConverter.cc:83:    ASSERT(this[01;31m-[00m>_EnumToArchiveString.count(index)>0);
symbolToEnumConverter.cc:84:    return this[01;31m-[00m>_EnumToArchiveString[index];
symbolToEnumConverter.cc:89:    if ( !this[01;31m-[00m>recognizesEnumIndex(ei) )
symbolToEnumConverter.cc:94:	ss << this[01;31m-[00m>legalEnumValuesAndSymbols() << endl;
symbolToEnumConverter.cc:95:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
symbolToEnumConverter.cc:102:    for ( map<int,string>::iterator it=this[01;31m-[00m>_EnumToArchiveString.begin();
symbolToEnumConverter.cc:103:    		it!=this[01;31m-[00m>_EnumToArchiveString.end(); it++ )
symbolToEnumConverter.cc:105:	ss << "(" << it[01;31m-[00m>first << "/" << it[01;31m-[00m>second << ") ";
symbolToEnumConverter.cc:113:    return this[01;31m-[00m>_ArchiveStringToEnum.count(enumStr)>0;
symbolToEnumConverter.cc:118:    return this[01;31m-[00m>_EnumToSymbol.count(ei)>0;
symbolToEnumConverter.cc:123:    return this[01;31m-[00m>_SymbolToEnum[01;31m-[00m>contains(sym);
symbolToEnumConverter.cc:132:    this[01;31m-[00m>Base::initialize();
symbolToEnumConverter.cc:133:    this[01;31m-[00m>_SymbolToEnum = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Binder>();
symbolToEnumConverter.cc:138:    this[01;31m-[00m>Base::archiveBase(node);
table.cc:24:    class_<O_TableEntry>(e[01;31m-[00m>lisp())
table.cc:55:    RPTableEntry entry = lisp[01;31m-[00m>create<O_TableEntry>();
table.cc:56:    entry[01;31m-[00m>setOwner(owner);
table.cc:57:    entry[01;31m-[00m>_Fields.resize(numFields,lisp[01;31m-[00m>onil());
table.cc:65:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
table.cc:71:    this[01;31m-[00m>Base::initialize();
table.cc:75:{_F(this[01;31m-[00m>lisp());
table.cc:76:    return this[01;31m-[00m>owner()[01;31m-[00m>as<O_Table>();
table.cc:83:    this[01;31m-[00m>Base::archiveBase(node);
table.cc:84:    node[01;31m-[00m>archiveList("fields",this[01;31m-[00m>_Fields);
table.cc:89:{_F(this[01;31m-[00m>lisp());
table.cc:90:    RPTable table = this[01;31m-[00m>getTable();
table.cc:91:    uint fieldIdx = table[01;31m-[00m>indexOfField(fieldSymbol);
table.cc:92:    return this[01;31m-[00m>_Fields.get(fieldIdx);
table.cc:96:{_F(this[01;31m-[00m>lisp());
table.cc:97:    ASSERT_lt(fieldIndex,this[01;31m-[00m>_Fields.size());
table.cc:98:    return this[01;31m-[00m>_Fields.get(fieldIndex);
table.cc:102:{_F(this[01;31m-[00m>lisp());
table.cc:103:    RPTable table = this[01;31m-[00m>getTable();
table.cc:104:    uint fieldIdx = table[01;31m-[00m>indexOfField(fieldSymbol);
table.cc:105:    this[01;31m-[00m>_Fields.set(fieldIdx,obj);
table.cc:109:{_F(this[01;31m-[00m>lisp());
table.cc:110:    ASSERT_lt(fieldIndex,this[01;31m-[00m>_Fields.size());
table.cc:111:    this[01;31m-[00m>_Fields.set(fieldIndex,obj);
table.cc:118:{_F(this[01;31m-[00m>lisp());
table.cc:119:    this[01;31m-[00m>_Fields.push_back(val);
table.cc:120:    return this[01;31m-[00m>_Fields.size()[01;31m-[00m1;
table.cc:126:{_F(this[01;31m-[00m>lisp());
table.cc:127:    ASSERT_lt(position,this[01;31m-[00m>_Fields.size());
table.cc:129:    it = this[01;31m-[00m>_Fields.begin()+position;
table.cc:130:    this[01;31m-[00m>_Fields.insert(it,val);
table.cc:136:{_F(this[01;31m-[00m>lisp());
table.cc:138:    dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
table.cc:141:    for ( si=this[01;31m-[00m>_Fields.begin(), idx=0; si!=this[01;31m-[00m>_Fields.end(); si++,idx++ )
table.cc:143:	if ( (*si)[01;31m-[00m>canRender() )
table.cc:145:	    RPRender rend = (*si)[01;31m-[00m>rendered(opts);
table.cc:146:	    rend[01;31m-[00m>setName(this[01;31m-[00m>getTable()[01;31m-[00m>fieldSymbol(idx)[01;31m-[00m>fullName());
table.cc:147:	    dl[01;31m-[00m>add(rend);
table.cc:151:	    ss << this[01;31m-[00m>getTable()[01;31m-[00m>fieldSymbol(idx)[01;31m-[00m>fullName() << " [01;31m-[00m> ";
table.cc:152:	    ss << (*si)[01;31m-[00m>__repr__() << endl;
table.cc:153:	    RPGrInformation info = O_GrInformation::create(ss.str(),this[01;31m-[00m>lisp());
table.cc:154:	    dl[01;31m-[00m>add(info);
table.cc:162:{_F(this[01;31m-[00m>lisp());
table.cc:165:    for ( List<O_Object>::const_iterator fi=this[01;31m-[00m>_Fields.const_begin(); fi!=this[01;31m-[00m>_Fields.const_end(); fi++, idx++ )
table.cc:167:	ss << this[01;31m-[00m>getTable()[01;31m-[00m>fieldSymbol(idx)[01;31m-[00m>fullName() << " [01;31m-[00m> " << (*fi)[01;31m-[00m>__repr__() << endl;
table.cc:177:    class_<O_Table>(e[01;31m-[00m>lisp())
table.cc:212:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
table.cc:218:    this[01;31m-[00m>Base::initialize();
table.cc:223:    this[01;31m-[00m>Base::archiveBase(node);
table.cc:224:    if ( node[01;31m-[00m>saving() )
table.cc:227:	for ( List<O_Symbol>::iterator si=this[01;31m-[00m>_FieldSymbols.begin(); si!=this[01;31m-[00m>_FieldSymbols.end(); si++ )
table.cc:229:	    symbolNames.push_back((*si)[01;31m-[00m>fullName());
table.cc:231:	node[01;31m-[00m>archiveVectorStrings("symbolNames",symbolNames);
table.cc:233:	for ( List<O_MetaClass>::iterator ci=this[01;31m-[00m>_FieldClasses.begin(); ci!=this[01;31m-[00m>_FieldClasses.end(); ci++ )
table.cc:235:	    classNames.push_back((*ci)[01;31m-[00m>instanceClassName());
table.cc:237:	node[01;31m-[00m>archiveVectorStrings("classNames",classNames);
table.cc:241:	node[01;31m-[00m>archiveVectorStrings("symbolNames",symbolNames);
table.cc:243:	node[01;31m-[00m>archiveVectorStrings("classNames",classNames);
table.cc:245:	this[01;31m-[00m>_FieldSymbols.clear();
table.cc:246:	this[01;31m-[00m>_FieldClasses.clear();
table.cc:247:	this[01;31m-[00m>_FieldIndices.clear();
table.cc:251:	    RPSymbol fieldSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>intern(*si);
table.cc:252:	    this[01;31m-[00m>_FieldSymbols.push_back(fieldSymbol);
table.cc:253:	    RPMetaClass mc = this[01;31m-[00m>lisp()[01;31m-[00m>classFromClassName(*ci);
table.cc:254:	    if ( mc[01;31m-[00m>isNil() )
table.cc:256:		RPSymbol classSymbol = this[01;31m-[00m>lisp()[01;31m-[00m>intern(*ci);
table.cc:257:		mc = this[01;31m-[00m>lisp()[01;31m-[00m>defineCandoClass(classSymbol);
table.cc:259:	    this[01;31m-[00m>_FieldClasses.push_back(mc);
table.cc:260:	    this[01;31m-[00m>_FieldIndices[fieldSymbol] = idx;
table.cc:263:    node[01;31m-[00m>archiveList("entries",this[01;31m-[00m>_Entries);
table.cc:264:    if ( node[01;31m-[00m>loading() )
table.cc:266:	this[01;31m-[00m>_Entries.setOwnerOfAll(this[01;31m-[00m>sharedThis<O_Table>());
table.cc:271:{_F(this[01;31m-[00m>lisp());
table.cc:272:    ASSERT_lt(idx,this[01;31m-[00m>_FieldSymbols.size());
table.cc:273:    return this[01;31m-[00m>_FieldSymbols.get(idx);
table.cc:279:    map<RPSymbol,uint>::iterator pi = this[01;31m-[00m>_FieldIndices.find(positionSymbol);
table.cc:280:    if ( pi==this[01;31m-[00m>_FieldIndices.end() )
table.cc:282:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("This table doesn't contain the field(%s)") % positionSymbol[01;31m-[00m>fullName() ));
table.cc:284:    return pi[01;31m-[00m>second;
table.cc:289:{_F(this[01;31m-[00m>lisp());
table.cc:290:    return (this[01;31m-[00m>_FieldIndices.count(fieldSymbol) != 0);
table.cc:294:{_F(this[01;31m-[00m>lisp());
table.cc:295:    if ( this[01;31m-[00m>hasField(fieldSymbol) )
table.cc:297:	return this[01;31m-[00m>_FieldClasses[this[01;31m-[00m>_FieldIndices[fieldSymbol]];
table.cc:299:    return this[01;31m-[00m>lisp()[01;31m-[00m>nil<O_MetaClass>();
table.cc:304:{_F(this[01;31m-[00m>lisp());
table.cc:305:    if ( this[01;31m-[00m>_FieldIndices.count(fieldSymbol) != 0 )
table.cc:307:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("This table already contains a field named(%s)") % fieldSymbol[01;31m-[00m>fullName() ));
table.cc:309:    uint idx = this[01;31m-[00m>_FieldSymbols.size();
table.cc:310:    this[01;31m-[00m>_FieldSymbols.push_back(fieldSymbol);
table.cc:311:    this[01;31m-[00m>_FieldClasses.push_back(fieldClass);
table.cc:312:    for ( uint idx=0; idx<this[01;31m-[00m>numberOfEntries(); idx++ )
table.cc:314:	this[01;31m-[00m>_Entries.get(idx)[01;31m-[00m>appendField(this[01;31m-[00m>lisp()[01;31m-[00m>onil());
table.cc:316:    this[01;31m-[00m>_FieldIndices[fieldSymbol] = idx;
table.cc:321:{_F(this[01;31m-[00m>lisp());
table.cc:322:    uint pos = this[01;31m-[00m>indexOfField(positionSymbol);
table.cc:323:    this[01;31m-[00m>_FieldSymbols.insert(this[01;31m-[00m>_FieldSymbols.begin()+pos,fieldSymbol);
table.cc:324:    this[01;31m-[00m>_FieldClasses.insert(this[01;31m-[00m>_FieldClasses.begin()+pos,fieldClass);
table.cc:329:    for ( pi=this[01;31m-[00m>_FieldIndices.begin(); pi!=this[01;31m-[00m>_FieldIndices.end(); pi++ )
table.cc:331:	if ( pos <= pi[01;31m-[00m>second )
table.cc:333:	    pi[01;31m-[00m>second++;
table.cc:336:    this[01;31m-[00m>_FieldIndices[fieldSymbol] = pos;
table.cc:341:    for ( uint idx=0; idx<this[01;31m-[00m>numberOfEntries(); idx++ )
table.cc:343:	this[01;31m-[00m>_Entries.get(idx)[01;31m-[00m>insertField(pos,this[01;31m-[00m>lisp()[01;31m-[00m>onil());
table.cc:351:    ASSERT_lt(entryIdx,this[01;31m-[00m>_Entries.size());
table.cc:352:    uint fieldIdx =  this[01;31m-[00m>indexOfField(field);
table.cc:353:    RPTableEntry entry = this[01;31m-[00m>_Entries[entryIdx];
table.cc:354:    if ( !val[01;31m-[00m>isAssignableToClass(this[01;31m-[00m>_FieldClasses[fieldIdx]) )
table.cc:356:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("You tried to put a value of class(%s) into a field of a table that expected a %s") % val[01;31m-[00m>className() % this[01;31m-[00m>_FieldClasses[fieldIdx][01;31m-[00m>instanceClassName() ));
table.cc:358:    entry[01;31m-[00m>putField(fieldIdx,val);
table.cc:363:    ASSERT_lt(entryIdx,this[01;31m-[00m>_Entries.size());
table.cc:364:    while ( values[01;31m-[00m>notNil() )
table.cc:366:	RPSymbol sym = values[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
table.cc:367:	values = values[01;31m-[00m>cdr();
table.cc:368:	RPObject obj = values[01;31m-[00m>ocar();
table.cc:369:	values = values[01;31m-[00m>cdr();
table.cc:370:	this[01;31m-[00m>writeField(entryIdx,sym,obj);
table.cc:376:{_F(this[01;31m-[00m>lisp());
table.cc:377:    RPTableEntry entry = O_TableEntry::createWithFields(this[01;31m-[00m>_FieldSymbols.size(),this[01;31m-[00m>sharedThis<O_Table>(),this[01;31m-[00m>lisp());
table.cc:378:    this[01;31m-[00m>_Entries.push_back(entry);
table.cc:383:{_F(this[01;31m-[00m>lisp());
table.cc:384:    RPTableEntry entry = this[01;31m-[00m>appendEntry();
table.cc:385:    while ( values[01;31m-[00m>notNil() )
table.cc:387:	RPSymbol sym = values[01;31m-[00m>ocar()[01;31m-[00m>as<O_Symbol>();
table.cc:388:	values = values[01;31m-[00m>cdr();
table.cc:389:	RPObject obj = values[01;31m-[00m>ocar();
table.cc:390:	values = values[01;31m-[00m>cdr();
table.cc:391:	entry[01;31m-[00m>write(sym,obj);
table.cc:397:{_F(this[01;31m-[00m>lisp());
table.cc:398:    return this[01;31m-[00m>_Entries.asCons(this[01;31m-[00m>lisp());
table.cc:403:{_F(this[01;31m-[00m>lisp());
table.cc:404:    ASSERT_lt(position,this[01;31m-[00m>_Entries.size());
table.cc:405:    List<O_TableEntry>::iterator it = this[01;31m-[00m>_Entries.begin()+position;
table.cc:406:    RPTableEntry entry = O_TableEntry::createWithFields(this[01;31m-[00m>_FieldSymbols.size(),this[01;31m-[00m>sharedThis<O_Table>(),this[01;31m-[00m>lisp());
table.cc:407:    this[01;31m-[00m>_Entries.insert(it,entry);
table.cc:412:{_F(this[01;31m-[00m>lisp());
table.cc:413:    return this[01;31m-[00m>_Entries.size();
table.cc:418:{_F(this[01;31m-[00m>lisp());
table.cc:419:    ASSERT_lt(idx,this[01;31m-[00m>_Entries.size());
table.cc:420:    return this[01;31m-[00m>_Entries.get(idx);
table.cc:424:{_F(this[01;31m-[00m>lisp());
table.cc:425:    ASSERT_lt(entryIdx,this[01;31m-[00m>_Entries.size());
table.cc:426:    uint fieldIdx =  this[01;31m-[00m>indexOfField(field);
table.cc:427:    RPTableEntry entry = this[01;31m-[00m>_Entries[entryIdx];
table.cc:428:    return entry[01;31m-[00m>getField(fieldIdx);
table.cc:433:{_F(this[01;31m-[00m>lisp());
table.cc:434:    if ( this[01;31m-[00m>_FieldSymbols.size() != other[01;31m-[00m>_FieldSymbols.size() ) return false;
table.cc:437:    for ( ms=this[01;31m-[00m>_FieldSymbols.begin(), os = other[01;31m-[00m>_FieldSymbols.begin(), 
table.cc:438:		mc = this[01;31m-[00m>_FieldClasses.begin(), oc = other[01;31m-[00m>_FieldClasses.begin();
table.cc:439:		ms < this[01;31m-[00m>_FieldSymbols.end(); ms++, os++, mc++, oc++ )
table.cc:448:{_F(this[01;31m-[00m>lisp());
table.cc:449:    if ( !this[01;31m-[00m>fieldsMatch(other) )
table.cc:453:	ss << "this: " << this[01;31m-[00m>__repr__() << endl;
table.cc:454:	ss << "other: " << other[01;31m-[00m>__repr__() << endl;
table.cc:455:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
table.cc:458:    for ( it=other[01;31m-[00m>_Entries.begin(); it!=other[01;31m-[00m>_Entries.end(); it++ )
table.cc:460:	RPTableEntry one = this[01;31m-[00m>appendEntry();
table.cc:461:	for ( uint i=0; i<this[01;31m-[00m>_FieldSymbols.size(); i++ )
table.cc:463:	    one[01;31m-[00m>putField(i,(*it)[01;31m-[00m>getField(i));
table.cc:472:{_F(this[01;31m-[00m>lisp());
table.cc:474:    sout << (BF("Table number of fields: %d") % this[01;31m-[00m>_FieldSymbols.size() ) << endl;
table.cc:477:    for ( List<O_Symbol>::const_iterator it = this[01;31m-[00m>_FieldSymbols.const_begin(); it!=this[01;31m-[00m>_FieldSymbols.const_end(); it++ )
table.cc:480:	sout << " " << (*it)[01;31m-[00m>fullName();
table.cc:481:	map<RPSymbol,uint>::const_iterator fi = this[01;31m-[00m>_FieldIndices.find(sym);
table.cc:482:	ASSERT(fi!=this[01;31m-[00m>_FieldIndices.end());
table.cc:483:	uint fieldIdx = fi[01;31m-[00m>second;
table.cc:487:	    sout << "<[01;31m-[00mINDEX_WRONG!";
table.cc:493:    for ( List<O_MetaClass>::const_iterator mi = this[01;31m-[00m>_FieldClasses.const_begin(); mi!=this[01;31m-[00m>_FieldClasses.const_end(); mi++ )
table.cc:495:	sout << " " << (*mi)[01;31m-[00m>instanceClassName();
table.cc:497:    sout << "Number of entries: " << this[01;31m-[00m>_Entries.size() << endl;
table.cc:502:{_F(this[01;31m-[00m>lisp());
table.cc:504:    frames = O_RenderFrameList::create(this[01;31m-[00m>lisp());
table.cc:506:    for ( si=this[01;31m-[00m>_Entries.begin(); si!=this[01;31m-[00m>_Entries.end(); si++ )
table.cc:508:	if ( (*si)[01;31m-[00m>canRender() )
table.cc:510:	    RPRender rend = (*si)[01;31m-[00m>rendered(opts);
table.cc:511:	    frames[01;31m-[00m>add(rend);
table.cc:519:{_F(this[01;31m-[00m>lisp());
table.cc:522:    for (List<O_TableEntry>::iterator ei=this[01;31m-[00m>_Entries.begin(); ei!=this[01;31m-[00m>_Entries.end(); ei++,idx++ )
table.cc:524:	ss << "entry("<<idx<<"):: " << (*ei)[01;31m-[00m>__repr__();
tableOperations.cc:21:	if ( table[01;31m-[00m>numberOfEntries() <= 1 ) return true;
tableOperations.cc:22:	RPTableEntry firstEntry = *(table[01;31m-[00m>beginEntry());
tableOperations.cc:23:	RPObject firstObject = firstEntry[01;31m-[00m>read(field);
tableOperations.cc:25:	for (O_Table::entryIterator it=table[01;31m-[00m>beginEntry()+1; it!=table[01;31m-[00m>endEntry(); it++,idx++ ) 
tableOperations.cc:27:	    RPObject otherObject = (*it)[01;31m-[00m>read(field);
tableOperations.cc:28:	    if ( !firstObject[01;31m-[00m>equal(otherObject) ) 
tableOperations.cc:30:		LOG(BF("The firstEntry field(%s)/value(%s) is not equal to that of entry(%d)/value(%s)") % field[01;31m-[00m>fullName() % firstObject[01;31m-[00m>__repr__() % idx % otherObject[01;31m-[00m>__repr__() );
tableOperations.cc:42:    if ( !table[01;31m-[00m>hasField(writeRmsd) )
tableOperations.cc:44:	table[01;31m-[00m>appendField(writeRmsd,table[01;31m-[00m>lisp()[01;31m-[00m>classObject<O_Real>());
tableOperations.cc:46:    if ( !(table[01;31m-[00m>fieldClass(writeRmsd) == table[01;31m-[00m>lisp()[01;31m-[00m>classObject<O_Real>()) )
tableOperations.cc:48:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("The tables field for writing the RMSD is not Real!"));
tableOperations.cc:52:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("If you want to superpose fields of a table they must all be equal and these are not"));
tableOperations.cc:54:    RPTableEntry first = *(table[01;31m-[00m>beginEntry());
tableOperations.cc:58:    RPReal val0 = table[01;31m-[00m>lisp()[01;31m-[00m>create<O_Real>(0.0);
tableOperations.cc:59:    first[01;31m-[00m>write(writeRmsd,val0);
tableOperations.cc:60:    if ( table[01;31m-[00m>numberOfEntries() <= 1 ) return false;
tableOperations.cc:64:    RPSuperposeSelectedAtoms sm = O_SuperposeSelectedAtoms::create(table[01;31m-[00m>lisp());
tableOperations.cc:65:    sm[01;31m-[00m>setMatter(first[01;31m-[00m>read(matterField)[01;31m-[00m>as<O_Matter>());
tableOperations.cc:66:    Loop lAtoms(sm[01;31m-[00m>getMatter(),ATOMS);
tableOperations.cc:67:    RPSymbol superposeSymbol = table[01;31m-[00m>lisp()[01;31m-[00m>predefinedSymbol(_sym_kw_superpose);
tableOperations.cc:71:	a[01;31m-[00m>clearProperty(superposeSymbol);
tableOperations.cc:72:	if ( a[01;31m-[00m>isHeavyAtom() )
tableOperations.cc:74:	    a[01;31m-[00m>setPropertyTrue(superposeSymbol);
tableOperations.cc:77:    sm[01;31m-[00m>updateSuperposeAtoms();
tableOperations.cc:78:    sm[01;31m-[00m>copyMatterCoordinatesIntoFixedCoordinates(first[01;31m-[00m>read(matterField)[01;31m-[00m>as<O_Matter>());
tableOperations.cc:80:    for ( ei=table[01;31m-[00m>beginEntry()+1; ei!=table[01;31m-[00m>endEntry(); ei++ )
tableOperations.cc:82:	sm[01;31m-[00m>copyMatterCoordinatesIntoMoveableCoordinates((*ei)[01;31m-[00m>read(matterField)[01;31m-[00m>as<O_Matter>());
tableOperations.cc:83:	sm[01;31m-[00m>doSuperpose();
tableOperations.cc:84:	(*ei)[01;31m-[00m>write(writeRmsd,table[01;31m-[00m>lisp()[01;31m-[00m>create<O_Real>(sm[01;31m-[00m>rootMeanSquareDifference()));
tableOperations.cc:85:	(*ei)[01;31m-[00m>read(matterField)[01;31m-[00m>as<O_Matter>()[01;31m-[00m>applyTransformToAtoms(sm[01;31m-[00m>superpose());
tableOperations.cc:103:	this[01;31m-[00m>_compareForm = compareForm;
tableOperations.cc:104:	this[01;31m-[00m>_lisp = lisp;
tableOperations.cc:108:	RPCons form = O_Cons::createList(this[01;31m-[00m>_compareForm,x,y,this[01;31m-[00m>_lisp);
tableOperations.cc:109:	RPObject result = eval::evaluate(form, this[01;31m-[00m>_lisp[01;31m-[00m>nil<O_Environment>(), this[01;31m-[00m>_lisp);
tableOperations.cc:110:	if ( result[01;31m-[00m>isTrue() ) return true;
tableOperations.cc:123:	sort::quickSort(table[01;31m-[00m>beginEntry(), table[01;31m-[00m>endEntry(),orderer, table[01;31m-[00m>lisp());
tableOperations.cc:133:    for ( O_Table::entryIterator ei=table[01;31m-[00m>beginEntry(); ei!=table[01;31m-[00m>endEntry(); ei++ )
tableOperations.cc:135:	RPCons form = O_Cons::createList(eval,*ei,table[01;31m-[00m>lisp());
tableOperations.cc:136:	eval::evaluate(form,table[01;31m-[00m>lisp()[01;31m-[00m>nil<O_Environment>(),table[01;31m-[00m>lisp());
topology.cc:27:{_F(this[01;31m-[00m>lisp());
topology.cc:28:    if ( node[01;31m-[00m>saving() ) this[01;31m-[00m>getConstitution();
topology.cc:29:    node[01;31m-[00m>archiveWeakPointer("constitution",this[01;31m-[00m>_WeakConstitution);
topology.cc:31:    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
topology.cc:33:    if ( node[01;31m-[00m>loading() )
topology.cc:35:	if ( node[01;31m-[00m>hasAttribute("name") )
topology.cc:37:	    node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
topology.cc:40:	    node[01;31m-[00m>attribute("_key",this[01;31m-[00m>_Name);
topology.cc:44:	node[01;31m-[00m>attribute("name",this[01;31m-[00m>_Name);
topology.cc:47:    node[01;31m-[00m>attributeIfNotDefault("ResidueNetCharge",this[01;31m-[00m>_ResidueNetCharge,0);
topology.cc:48:    node[01;31m-[00m>archiveMap( "plugs", this[01;31m-[00m>_Plugs );
topology.cc:49:    LOG(BF("About to get core for topology (%s)") % this[01;31m-[00m>_Name.c_str()  ); // vp0(("About to get core for topology (%s)",this[01;31m-[00m>_Name.c_str() ));
topology.cc:50:    node[01;31m-[00m>archiveObject( "coreFragment", this[01;31m-[00m>_ExtractCoreFragment );
topology.cc:51:    node[01;31m-[00m>archiveObject( "scaffold", this[01;31m-[00m>_ExtractScaffold);
topology.cc:52:    node[01;31m-[00m>archiveList( "fragments", this[01;31m-[00m>_ExtractFragments );
topology.cc:53:    node[01;31m-[00m>archiveObjectIfDefined( "alignTo",this[01;31m-[00m>_AlignTo);
topology.cc:58:{_F(this[01;31m-[00m>lisp());
topology.cc:59:    this[01;31m-[00m>Base::oldLispInitialize(keyed,env);
topology.cc:60:    this[01;31m-[00m>_Name = keyed[01;31m-[00m>getStringAndRemove("name");
topology.cc:61:    this[01;31m-[00m>_ResidueNetCharge = keyed[01;31m-[00m>getIntAndRemoveOrDefault("netCharge",0);
topology.cc:66:    RPCons curPlug = keyed[01;31m-[00m>getAndRemove("plugs")[01;31m-[00m>as<O_Cons>();
topology.cc:67:    this[01;31m-[00m>_Plugs.clear();
topology.cc:68:    for ( ; curPlug[01;31m-[00m>notNil(); curPlug = curPlug[01;31m-[00m>cdr() )
topology.cc:70:	plugType p = curPlug[01;31m-[00m>car<plugOType>();
topology.cc:71:	this[01;31m-[00m>addPlug(p[01;31m-[00m>getName(),p);
topology.cc:73:    RPResidue residue = keyed[01;31m-[00m>getAndRemove("residue")[01;31m-[00m>as<O_Residue>();
topology.cc:74:    this[01;31m-[00m>_ExtractScaffold = keyed[01;31m-[00m>getAndRemove("scaffold")[01;31m-[00m>as<O_ExtractScaffold>();
topology.cc:75:    this[01;31m-[00m>_ExtractCoreFragment = keyed[01;31m-[00m>getAndRemove("coreFragment")[01;31m-[00m>as<O_ExtractCoreFragment>();
topology.cc:76:    this[01;31m-[00m>_AlignTo = keyed[01;31m-[00m>getAndRemoveOrDefault("alignTo",O_FrameBase::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_FrameBase>();
topology.cc:77:    RPCons frags = keyed[01;31m-[00m>getAndRemove("fragments")[01;31m-[00m>as<O_Cons>();
topology.cc:78:    this[01;31m-[00m>_ExtractFragments.fillFromCons(frags);
topology.cc:79:    this[01;31m-[00m>throwIfExtractFragmentsAreNotExclusive(residue);
topology.cc:89:{_F(extractFrag[01;31m-[00m>lisp());
topology.cc:91:    RPFragment frag = extractFrag[01;31m-[00m>getFragment();
topology.cc:92:    RPStringSet atomNames = frag[01;31m-[00m>getAtomNames();
topology.cc:93:    for ( O_StringSet::iterator ni = atomNames[01;31m-[00m>begin(); ni!=atomNames[01;31m-[00m>end(); ni++ )
topology.cc:95:	if ( missingAtomNames[01;31m-[00m>contains(*ni) )
topology.cc:97:	    missingAtomNames[01;31m-[00m>remove(*ni);
topology.cc:103:	    over._Fragments.insert(frag[01;31m-[00m>getName());
topology.cc:109:	    over._Fragments.insert(frag[01;31m-[00m>getName());
topology.cc:116:{_F(this[01;31m-[00m>lisp());
topology.cc:119:    RPStringSet missingAtomNames = residue[01;31m-[00m>getAtomNamesAsStringSet();
topology.cc:121:    __checkExtractFragment(this[01;31m-[00m>_ExtractCoreFragment,missingAtomNames,overlaps);
topology.cc:122:    for ( List<O_ExtractFragment>::iterator it=this[01;31m-[00m>_ExtractFragments.begin();
topology.cc:123:    		it!=this[01;31m-[00m>_ExtractFragments.end(); it++ )
topology.cc:127:    if ( missingAtomNames[01;31m-[00m>size() != 0 )
topology.cc:130:	ss << "The Topology " << this[01;31m-[00m>getName() << " ExtractFragments do not include all atoms" << endl;
topology.cc:131:	ss << " of the Constitution.  The following atom names are missing: " << missingAtomNames[01;31m-[00m>asString();
topology.cc:132:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(ss.str()));
topology.cc:138:	if ( oi[01;31m-[00m>second._TimesSeen > 1 )
topology.cc:141:	    so << "Multiple references for atom(" <<oi[01;31m-[00m>first<<") in fragments: ";
topology.cc:142:	    for ( set<string>::iterator si=oi[01;31m-[00m>second._Fragments.begin(); si!=oi[01;31m-[00m>second._Fragments.end();si++ )
topology.cc:151:	se << "In definition of Topology(" << this[01;31m-[00m>getName() << ") there were overlapping ExtractFragment definitions"<<endl;
topology.cc:153:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(se.str()));
topology.cc:160:{_F(this[01;31m-[00m>lisp());
topology.cc:161:    RPMonomerContext context = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_MonomerContext>();
topology.cc:162:    RPMonomerSet selfSet = O_MonomerSet::create(this[01;31m-[00m>lisp());
topology.cc:163:    RPConstitution constitution = this[01;31m-[00m>getConstitution();
topology.cc:164:    context[01;31m-[00m>setFocus(selfSet);
topology.cc:171:{_F(this[01;31m-[00m>lisp());
topology.cc:172:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Depreciated, all Topology's have inPlug now"));
topology.cc:173:    for ( Map<plugOType>::iterator i=this[01;31m-[00m>_Plugs.begin(); i!= this[01;31m-[00m>_Plugs.end(); i++)
topology.cc:175:	if ( i[01;31m-[00m>second[01;31m-[00m>getIsIn() ) return true;
topology.cc:184:{_F(this[01;31m-[00m>lisp());
topology.cc:185:    for ( Map<plugOType>::iterator i=this[01;31m-[00m>_Plugs.begin(); i!= this[01;31m-[00m>_Plugs.end(); i++)
topology.cc:187:	if ( i[01;31m-[00m>second[01;31m-[00m>getIsIn() ) 
topology.cc:189:	    return i[01;31m-[00m>second;
topology.cc:192:    return plugOType::nil(this[01;31m-[00m>lisp());
topology.cc:196:{_F(this[01;31m-[00m>lisp());
topology.cc:197:    return this[01;31m-[00m>_ExtractFragments.asCons(this[01;31m-[00m>lisp());
topology.cc:203:{_F(this[01;31m-[00m>lisp());
topology.cc:204:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
topology.cc:206:    LOG(BF("The number of plugs = %d") % this[01;31m-[00m>_Plugs.size()  ); // vp0(( "The number of plugs = %d", this[01;31m-[00m>_Plugs.size() ));
topology.cc:207:    for ( Map<plugOType>::iterator i=this[01;31m-[00m>_Plugs.begin(); i!= this[01;31m-[00m>_Plugs.end(); i++)
topology.cc:209:	LOG(BF("Adding plug: %s") % i[01;31m-[00m>second[01;31m-[00m>getName().c_str()  ); // vp0(( "Adding plug: %s", i[01;31m-[00m>second[01;31m-[00m>getName().c_str() ));
topology.cc:210:	RPCons one = O_Cons::create(i[01;31m-[00m>second,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
topology.cc:211:	cur[01;31m-[00m>setCdr(one);
topology.cc:215:    return first[01;31m-[00m>cdr();
topology.cc:220:{_F(this[01;31m-[00m>lisp());
topology.cc:221:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
topology.cc:223:    LOG(BF("The number of plugs = %d") % this[01;31m-[00m>_Plugs.size()  ); // vp0(( "The number of plugs = %d", this[01;31m-[00m>_Plugs.size() ));
topology.cc:224:    for ( Map<plugOType>::iterator i=this[01;31m-[00m>_Plugs.begin(); i!= this[01;31m-[00m>_Plugs.end(); i++)
topology.cc:227:	if ( !i[01;31m-[00m>second[01;31m-[00m>isAssignableTo<O_PlugWithMates>() ) continue;
topology.cc:228:	LOG(BF("Adding plug: %s") % i[01;31m-[00m>second[01;31m-[00m>getName().c_str()  ); // vp0(( "Adding plug: %s", i[01;31m-[00m>second[01;31m-[00m>getName().c_str() ));
topology.cc:229:	RPCons one = O_Cons::create(i[01;31m-[00m>second,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
topology.cc:230:	cur[01;31m-[00m>setCdr(one);
topology.cc:234:    return first[01;31m-[00m>cdr();
topology.cc:238:{_F(this[01;31m-[00m>lisp());
topology.cc:239:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
topology.cc:241:    for ( Map<plugOType>::iterator i=this[01;31m-[00m>_Plugs.begin(); i!= this[01;31m-[00m>_Plugs.end(); i++)
topology.cc:243:	RPPlug plug = i[01;31m-[00m>second;
topology.cc:244:	if ( !plug[01;31m-[00m>getIsIn() )
topology.cc:246:	    RPCons one = O_Cons::create(i[01;31m-[00m>second,O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
topology.cc:247:	    cur[01;31m-[00m>setCdr(one);
topology.cc:251:    return first[01;31m-[00m>cdr();
topology.cc:258:    ASSERT_NOT_NULL(this[01;31m-[00m>_WeakConstitution);
topology.cc:259:    if ( this[01;31m-[00m>_WeakConstitution.lock()[01;31m-[00m>isNil() )
topology.cc:263:	this[01;31m-[00m>_WeakConstitution = this[01;31m-[00m>ownerWithClass<O_Constitution>();
topology.cc:265:    return this[01;31m-[00m>_WeakConstitution.lock();
topology.cc:271:    ss << this[01;31m-[00m>O_Object::description();
topology.cc:273:    ss << " Name(" << me[01;31m-[00m>getName() << ")";
topology.cc:274:    ss << " Constitution("<< me[01;31m-[00m>getConstitution()[01;31m-[00m>getName() << ")" << endl;
topology.cc:275:    ss << "  Topology[01;31m-[00m>(" << this[01;31m-[00m>_ExtractScaffold[01;31m-[00m>description() << ")";
topology.cc:281:{_F(this[01;31m-[00m>lisp());
topology.cc:283:    for ( Map<plugOType>::iterator i=this[01;31m-[00m>_Plugs.begin();
topology.cc:284:		i!= this[01;31m-[00m>_Plugs.end(); i++)
topology.cc:286:	if (!i[01;31m-[00m>second[01;31m-[00m>isAssignableTo<O_PlugWithMates>() ) continue;
topology.cc:287:	if ( !mon[01;31m-[00m>hasCouplingWithPlugName(i[01;31m-[00m>second[01;31m-[00m>getName()) ) return false;
topology.cc:290:    if ( numPlugsWithMates != mon[01;31m-[00m>numberOfCouplings() ) return false;
topology.cc:297:{_F(this[01;31m-[00m>lisp());
topology.cc:298:    RPRingClosingPlug missingRingClosingPlug = O_RingClosingPlug::nil(this[01;31m-[00m>lisp());
topology.cc:300:    for ( Map<plugOType>::iterator i=this[01;31m-[00m>_Plugs.begin();
topology.cc:301:		i!= this[01;31m-[00m>_Plugs.end(); i++)
topology.cc:303:	if (!i[01;31m-[00m>second[01;31m-[00m>isAssignableTo<O_PlugWithMates>() ) continue;
topology.cc:304:	if ( i[01;31m-[00m>second[01;31m-[00m>isAssignableTo<O_RingClosingPlug>() )
topology.cc:306:	    missingRingClosingPlug = i[01;31m-[00m>second[01;31m-[00m>as<O_RingClosingPlug>();
topology.cc:309:	if ( !mon[01;31m-[00m>hasCouplingWithPlugName(i[01;31m-[00m>second[01;31m-[00m>getName()) ) return O_RingClosingPlug::nil(this[01;31m-[00m>lisp());
topology.cc:312:    if ( numPlugsWithMates != mon[01;31m-[00m>numberOfCouplings() ) return O_RingClosingPlug::nil(this[01;31m-[00m>lisp());
topology.cc:320:    for ( Map<plugOType>::iterator i=this[01;31m-[00m>_Plugs.begin();
topology.cc:321:		i!= this[01;31m-[00m>_Plugs.end(); i++)
topology.cc:323:	if (!i[01;31m-[00m>second[01;31m-[00m>isAssignableTo<O_PlugWithMates>() ) continue;
topology.cc:324:	if ( !cm[01;31m-[00m>hasNeighborWithCouplingName(i[01;31m-[00m>second[01;31m-[00m>getName()) ) return false;
topology.cc:327:    if ( numPlugsWithMates != cm[01;31m-[00m>numberOfNeighbors() ) return false;
topology.cc:332:{_F(this[01;31m-[00m>lisp());
topology.cc:333:    return this[01;31m-[00m>_Plugs.contains(name);
topology.cc:339:{_F(this[01;31m-[00m>lisp());
topology.cc:340:    return this[01;31m-[00m>_ExtractScaffold[01;31m-[00m>hasExtractIncompleteFrameWithAlias(name);
topology.cc:345:{_F(this[01;31m-[00m>lisp());
topology.cc:346:    return this[01;31m-[00m>_ExtractScaffold[01;31m-[00m>hasExtractCompleteFrameWithName(name);
topology.cc:354:    this[01;31m-[00m>Base::initialize();
topology.cc:355:    this[01;31m-[00m>_WeakConstitution = O_Constitution::nil(this[01;31m-[00m>lisp());
topology.cc:356:    this[01;31m-[00m>_Flags = O_StringSet::create(this[01;31m-[00m>lisp());
topology.cc:357:    this[01;31m-[00m>_Name = "";
topology.cc:358:    this[01;31m-[00m>_ResidueNetCharge = 0;
topology.cc:359:    this[01;31m-[00m>_Plugs.clear();
topology.cc:360:    this[01;31m-[00m>_AlignTo = O_FrameBase::nil(this[01;31m-[00m>lisp());
topology.cc:361:    this[01;31m-[00m>_TemporaryObject = O_Object::nil(this[01;31m-[00m>lisp());
topology.cc:367:{_F(this[01;31m-[00m>lisp());
topology.cc:369:    this[01;31m-[00m>_TemporaryObject = o;
topology.cc:373:{_F(this[01;31m-[00m>lisp());
topology.cc:374:    ASSERT_NOT_NULL(this[01;31m-[00m>_TemporaryObject);
topology.cc:375:    return this[01;31m-[00m>_TemporaryObject;
topology.cc:391:    class_<O_Topology>(this[01;31m-[00m>lisp())
topology.cc:447:    for ( vi=this[01;31m-[00m>_Plugs.begin(); vi!=this[01;31m-[00m>_Plugs.end(); vi++ ) {
topology.cc:448:	res.append(boost::python::object(vi[01;31m-[00m>second));
torsionDriver.cc:65:	if ( a[01;31m-[00m>getName() == name ) count++;
torsionDriver.cc:84:	if ( a[01;31m-[00m>getName() == name ) {
torsionDriver.cc:90:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not find atom with name: ", name ));
torsionDriver.cc:126:    for ( pos=this[01;31m-[00m>torsions.begin()+1;
torsionDriver.cc:127:		pos!=this[01;31m-[00m>torsions.end();
torsionDriver.cc:129:	if ( fixed[01;31m-[00m>getTempInt() < pos[01;31m-[00m>fixed[01;31m-[00m>getTempInt() ) break;
torsionDriver.cc:134:    torsion.parent = [01;31m-[00m1;
torsionDriver.cc:135:    if ( pos==this[01;31m-[00m>torsions.end() ) {
torsionDriver.cc:136:	this[01;31m-[00m>torsions.push_back(torsion);
torsionDriver.cc:138:	this[01;31m-[00m>torsions.insert(pos,torsion);
torsionDriver.cc:154:    for ( segment=this[01;31m-[00m>torsions.begin()+start;
torsionDriver.cc:155:		segment != this[01;31m-[00m>torsions.end();
torsionDriver.cc:157:	parent = &(this[01;31m-[00m>torsions[segment[01;31m-[00m>parent]);
torsionDriver.cc:158:	mat = segment[01;31m-[00m>relative*(*(segment[01;31m-[00m>rotation));
torsionDriver.cc:159:	segment[01;31m-[00m>accumulated = parent[01;31m-[00m>accumulated*mat;
torsionDriver.cc:165:    segment = &(this[01;31m-[00m>torsions[start]);
torsionDriver.cc:166:    parent = &(this[01;31m-[00m>torsions[segment[01;31m-[00m>parent]);
torsionDriver.cc:167:    mat = segment[01;31m-[00m>relative*(*(segment[01;31m-[00m>rotation));
torsionDriver.cc:168:    segment[01;31m-[00m>accumulated = parent[01;31m-[00m>accumulated*mat;
torsionDriver.cc:173:	segment[01;31m-[00m>rotation[01;31m-[00m>dump();
torsionDriver.cc:175:	segment[01;31m-[00m>accumulated.dump();
torsionDriver.cc:181:    for ( pos=this[01;31m-[00m>torsions[start].children.begin();
torsionDriver.cc:182:	    pos!=this[01;31m-[00m>torsions[start].children.end();
torsionDriver.cc:184:	this[01;31m-[00m>updateAccumulatedTransforms(*pos);
torsionDriver.cc:206:    this[01;31m-[00m>driveMode = false;	// We are about to start adding torsions
torsionDriver.cc:207:    this[01;31m-[00m>torsions.erase(this[01;31m-[00m>torsions.begin(),this[01;31m-[00m>torsions.end());
torsionDriver.cc:208:    this[01;31m-[00m>aggregate = agg; // Should I use a copy?
torsionDriver.cc:210:    lAtoms.loopTopGoal( this[01;31m-[00m>aggregate, ATOMS );
torsionDriver.cc:213:	if ( atom[01;31m-[00m>getName() == rootName ) {
torsionDriver.cc:219:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Could not find atom name: %s in aggregate") % rootName ));
torsionDriver.cc:230:    spanning = agg[01;31m-[00m>lisp()[01;31m-[00m>create<O_SpanningLoop>();
torsionDriver.cc:231:    spanning[01;31m-[00m>setTop(root);
torsionDriver.cc:233:    while ( spanning[01;31m-[00m>advanceLoopAndProcess() ) {
torsionDriver.cc:234:	atom = spanning[01;31m-[00m>getAtom();
torsionDriver.cc:235:	atom[01;31m-[00m>setTempInt(spanningIndex);
torsionDriver.cc:244:    this[01;31m-[00m>torsions.push_back(torsion);
torsionDriver.cc:260:    if ( this[01;31m-[00m>driveMode ) {
torsionDriver.cc:261:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( "You can't add torsions once you've started driving torsions" ));
torsionDriver.cc:263:    ANN(this[01;31m-[00m>aggregate);
torsionDriver.cc:264:    if ( this[01;31m-[00m>aggregate[01;31m-[00m>isNil() )
torsionDriver.cc:266:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( "You must have defined the aggregate and root before adding torsions to drive."));
torsionDriver.cc:268:    if ( this[01;31m-[00m>countOfAtomsWithName(this[01;31m-[00m>aggregate,atom1 ) != 1 ) {
torsionDriver.cc:269:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( boost::format("There must be a unique atom with the name: %s") % atom1 ));
torsionDriver.cc:271:    if ( this[01;31m-[00m>countOfAtomsWithName(this[01;31m-[00m>aggregate,atom2 ) != 1 ) {
torsionDriver.cc:272:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( boost::format("There must be a unique atom with the name: ") % atom2 ));
torsionDriver.cc:274:    a1 = this[01;31m-[00m>aggregate[01;31m-[00m>firstAtomWithName(atom1);
torsionDriver.cc:275:    a2 = this[01;31m-[00m>aggregate[01;31m-[00m>firstAtomWithName(atom2);
torsionDriver.cc:276:    backSpan = a2[01;31m-[00m>getBackSpan();
torsionDriver.cc:277:    if ( a1 == a2[01;31m-[00m>getBackSpan() ) {
torsionDriver.cc:278:	this[01;31m-[00m>insertTorsion( a1, a2, steps );
torsionDriver.cc:281:    if ( a2 == a1[01;31m-[00m>getBackSpan() ) {
torsionDriver.cc:282:	this[01;31m-[00m>insertTorsion( a2, a1, steps );
torsionDriver.cc:284:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Movable atom has to point back to the fixed atom" ));
torsionDriver.cc:312:    if ( this[01;31m-[00m>driveMode ) {
torsionDriver.cc:313:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( "You can't prepare to drive torsions when you're already driving them" ));
torsionDriver.cc:320:    for ( pos=this[01;31m-[00m>torsions.begin()+1;
torsionDriver.cc:321:		pos!=this[01;31m-[00m>torsions.end();
torsionDriver.cc:323:	bo = pos[01;31m-[00m>movable[01;31m-[00m>bondOrderTo(pos[01;31m-[00m>fixed);
torsionDriver.cc:325:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("The two atoms of a torsion must be bonded. Atom: %s is not bonded to %s") % pos[01;31m-[00m>fixed[01;31m-[00m>getName() % pos[01;31m-[00m>movable[01;31m-[00m>getName() ));
torsionDriver.cc:327:	pos[01;31m-[00m>order = bo;
torsionDriver.cc:328:	pos[01;31m-[00m>fixed[01;31m-[00m>removeBondTo(pos[01;31m-[00m>movable);
torsionDriver.cc:345:    spanning = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SpanningLoop>();
torsionDriver.cc:346:    for ( pos=this[01;31m-[00m>torsions.begin()+1;
torsionDriver.cc:347:		pos!=this[01;31m-[00m>torsions.end();
torsionDriver.cc:349:	spanning[01;31m-[00m>setTop(pos[01;31m-[00m>movable);
torsionDriver.cc:350:	while ( spanning[01;31m-[00m>advanceLoopAndProcess() ) {
torsionDriver.cc:351:	    a = spanning[01;31m-[00m>getAtom();
torsionDriver.cc:354:	    pos[01;31m-[00m>atoms.push_back(tatom);
torsionDriver.cc:355:	    a[01;31m-[00m>setTempInt(pos[01;31m-[00mthis[01;31m-[00m>torsions.begin());
torsionDriver.cc:363:    LOG(BF("Constructing the matrix update tree [01;31m-[00m parents") ); // vp0(( "Constructing the matrix update tree [01;31m-[00m parents" ));
torsionDriver.cc:364:    for ( pos=this[01;31m-[00m>torsions.begin(), index = 0;
torsionDriver.cc:365:		pos!=this[01;31m-[00m>torsions.end();
torsionDriver.cc:368:		// That will be [01;31m-[00m1 if the segment is the first one
torsionDriver.cc:370:	if ( pos == this[01;31m-[00m>torsions.begin() ) {
torsionDriver.cc:371:	    pos[01;31m-[00m>parent = [01;31m-[00m1;
torsionDriver.cc:372:	} else if ( pos== this[01;31m-[00m>torsions.begin()+1 ) {
torsionDriver.cc:373:	    pos[01;31m-[00m>parent = 0;
torsionDriver.cc:375:	    pos[01;31m-[00m>parent = pos[01;31m-[00m>fixed[01;31m-[00m>getTempInt();
torsionDriver.cc:381:    LOG(BF("Constructing the matrix update tree [01;31m-[00m children") ); // vp0(( "Constructing the matrix update tree [01;31m-[00m children" ));
torsionDriver.cc:382:    for ( pos=this[01;31m-[00m>torsions.begin()+1, index = 1;
torsionDriver.cc:383:		pos!=this[01;31m-[00m>torsions.end();
torsionDriver.cc:386:		// That will be [01;31m-[00m1 if the segment is the first one
torsionDriver.cc:388:	this[01;31m-[00m>torsions[pos[01;31m-[00m>parent].children.push_back(index);
torsionDriver.cc:393:	// with its Z[01;31m-[00maxis along the line joining the fixed atom to the
torsionDriver.cc:394:	// movable one and its X[01;31m-[00maxis perpendicular to the Z[01;31m-[00maxis.
torsionDriver.cc:397:    for ( pos=this[01;31m-[00m>torsions.begin();
torsionDriver.cc:398:		pos!=this[01;31m-[00m>torsions.end();
torsionDriver.cc:404:	if ( pos==this[01;31m-[00m>torsions.begin() ) {
torsionDriver.cc:408:	    pos[01;31m-[00m>coord = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
torsionDriver.cc:409:	    pos[01;31m-[00m>coord[01;31m-[00m>defineForVectorsOriginXDirZDir(origin,xDir,zDir);
torsionDriver.cc:412:	    origin = pos[01;31m-[00m>fixed[01;31m-[00m>getPosition();
torsionDriver.cc:413:	    zDir = pos[01;31m-[00m>movable[01;31m-[00m>getPosition()[01;31m-[00mpos[01;31m-[00m>fixed[01;31m-[00m>getPosition();
torsionDriver.cc:414:	    zDir = zDir.normalized(this[01;31m-[00m>lisp());
torsionDriver.cc:415:	    if ( pos[01;31m-[00m>movable[01;31m-[00m>numberOfBonds() == 0 ) {
torsionDriver.cc:416:		TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("The torsion around %s and %s won't roate anything. Please remove it") 
torsionDriver.cc:417:					% pos[01;31m-[00m>fixed[01;31m-[00m>getName() % pos[01;31m-[00m>movable[01;31m-[00m>getName() ));
torsionDriver.cc:419:	    vTemp = pos[01;31m-[00m>movable[01;31m-[00m>bondedNeighbor(0)[01;31m-[00m>getPosition()
torsionDriver.cc:420:			    [01;31m-[00m pos[01;31m-[00m>movable[01;31m-[00m>getPosition();
torsionDriver.cc:422:	    xDir = xDir.normalized(this[01;31m-[00m>lisp());
torsionDriver.cc:427:	    pos[01;31m-[00m>coord = O_CoordinateSystem::create(this[01;31m-[00m>lisp());
torsionDriver.cc:428:	    pos[01;31m-[00m>coord[01;31m-[00m>defineForVectorsOriginXDirZDir( origin, xDir, zDir );
torsionDriver.cc:433:	    pos[01;31m-[00m>fixed[01;31m-[00m>bondTo( pos[01;31m-[00m>movable, pos[01;31m-[00m>order );
torsionDriver.cc:441:    for ( pos=this[01;31m-[00m>torsions.begin()+1;
torsionDriver.cc:442:		pos!=this[01;31m-[00m>torsions.end();
torsionDriver.cc:444:	LOG(BF("  for pos=%d") % (pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ) ); // vp0(( "  for pos=%d", pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ));
torsionDriver.cc:445:	LOG(BF("  Parent =%d") % (pos[01;31m-[00m>parent ) ); // vp0(( "  Parent =%d", pos[01;31m-[00m>parent ));
torsionDriver.cc:446:	parent = this[01;31m-[00m>torsions.begin()+pos[01;31m-[00m>parent;
torsionDriver.cc:448:	coord = parent[01;31m-[00m>coord;
torsionDriver.cc:450:	pos[01;31m-[00m>relative = coord[01;31m-[00m>matrixForTransformTo(pos[01;31m-[00m>coord);
torsionDriver.cc:459:    for ( pos=this[01;31m-[00m>torsions.begin();
torsionDriver.cc:460:		pos!=this[01;31m-[00m>torsions.end();
torsionDriver.cc:462:	LOG(BF("Generating rotation matrices for segment: %d") % (pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ) ); // vp0(( "Generating rotation matrices for segment: %d", pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ));
torsionDriver.cc:463:	for ( i=0; i<pos[01;31m-[00m>steps; i++ ) {
torsionDriver.cc:464:	    angle = i*(0.0174533*360.0/pos[01;31m-[00m>steps);
torsionDriver.cc:466:	    rot.rightHandedRotationZ([01;31m-[00mangle);
torsionDriver.cc:467:	    pos[01;31m-[00m>rotations.push_back(rot);
torsionDriver.cc:469:        pos[01;31m-[00m>rotation = pos[01;31m-[00m>rotations.begin();
torsionDriver.cc:479:    pos = this[01;31m-[00m>torsions.begin()+1;
torsionDriver.cc:480:    this[01;31m-[00m>torsions.begin()[01;31m-[00m>accumulated.identity(); // = pos[01;31m-[00m>coord[01;31m-[00m>matrixFromCanonical();
torsionDriver.cc:483:    this[01;31m-[00m>updateAccumulatedTransforms(1);
torsionDriver.cc:491:    for ( pos=this[01;31m-[00m>torsions.begin()+1; pos!=this[01;31m-[00m>torsions.end(); pos++ ) {
torsionDriver.cc:492:	toCanonical = pos[01;31m-[00m>coord[01;31m-[00m>matrixToCanonical();
torsionDriver.cc:493:	for ( tai=pos[01;31m-[00m>atoms.begin(); tai!=pos[01;31m-[00m>atoms.end(); tai++ ) {
torsionDriver.cc:494:	    tai[01;31m-[00m>setUntransformed(toCanonical*(tai[01;31m-[00m>getAtom()[01;31m-[00m>getPosition()));
torsionDriver.cc:498:    this[01;31m-[00m>driveMode = true;
torsionDriver.cc:523:    if ( !this[01;31m-[00m>driveMode ) {
torsionDriver.cc:524:	TOSS(_lisp[01;31m-[00m>create<O_LispError>( "TorsionDriver must be in drive mode to render graphics" ) );
torsionDriver.cc:533:    aggGraphics = this[01;31m-[00m>aggregate[01;31m-[00m>asXmlWithCoordinates();
torsionDriver.cc:534:    graphics[01;31m-[00m>addChild(aggGraphics);
torsionDriver.cc:541:    for ( pos=this[01;31m-[00m>torsions.begin(); pos!=this[01;31m-[00m>torsions.end(); pos++ ) {
torsionDriver.cc:542:	gr = pos[01;31m-[00m>coord[01;31m-[00m>renderXml(1.0,1.0);
torsionDriver.cc:543:	graphics[01;31m-[00m>addChild(gr);
torsionDriver.cc:544:	for ( tai=pos[01;31m-[00m>atoms.begin(); tai!=pos[01;31m-[00m>atoms.end(); tai++ ) {
torsionDriver.cc:545:	    gr = xmlSphere(XML_YELLOW,tai[01;31m-[00m>getUntransformed(),0.3);
torsionDriver.cc:546:	    graphics[01;31m-[00m>addChild(gr);
torsionDriver.cc:554:    coords[01;31m-[00m>addChild(gr);
torsionDriver.cc:557:    coords[01;31m-[00m>addChild(gr);
torsionDriver.cc:560:    coords[01;31m-[00m>addChild(gr);
torsionDriver.cc:561:    graphics[01;31m-[00m>addChild(coords);
torsionDriver.cc:578:    for ( pos=this[01;31m-[00m>torsions.begin()+start; pos!=this[01;31m-[00m>torsions.end(); pos++ ) {
torsionDriver.cc:579:	LOG(BF("Applying matrix at segment: %d") % (pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ) ); // vp0(( "Applying matrix at segment: %d", pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ));
torsionDriver.cc:581:	pos[01;31m-[00m>accumulated.dump();
torsionDriver.cc:583:	for ( tai=pos[01;31m-[00m>atoms.begin(); tai!=pos[01;31m-[00m>atoms.end(); tai++ ) {
torsionDriver.cc:584:	    LOG(BF("Transforming atom: %s") % (tai[01;31m-[00m>getAtom()[01;31m-[00m>getName().c_str() ) ); // vp0(( "Transforming atom: %s", tai[01;31m-[00m>getAtom()[01;31m-[00m>getName().c_str() ));
torsionDriver.cc:585:	    trans = pos[01;31m-[00m>accumulated*(tai[01;31m-[00m>getUntransformed());
torsionDriver.cc:586:	    tai[01;31m-[00m>getAtom()[01;31m-[00m>setPosition(trans);
torsionDriver.cc:605:    LOG(BF("[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mAdvancing from segment: %d highest: %d") % (segment) % (this[01;31m-[00m>torsions.end()[01;31m-[00mthis[01;31m-[00m>torsions.begin()[01;31m-[00m1) ); // vp0(( "[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00mAdvancing from segment: %d highest: %d", segment, this[01;31m-[00m>torsions.end()[01;31m-[00mthis[01;31m-[00m>torsions.begin()[01;31m-[00m1));
torsionDriver.cc:606:    if (segment > this[01;31m-[00m>highestSegmentIndex() ) {
torsionDriver.cc:607:	segment = this[01;31m-[00m>highestSegmentIndex();
torsionDriver.cc:609:    } else if ( segment < this[01;31m-[00m>highestSegmentIndex()) {
torsionDriver.cc:611:	for ( pos=this[01;31m-[00m>torsions.begin()+segment+1;
torsionDriver.cc:612:		pos!=this[01;31m-[00m>torsions.end();
torsionDriver.cc:614:	    pos[01;31m-[00m>rotation = pos[01;31m-[00m>rotations.begin();
torsionDriver.cc:617:        for ( cpos=this[01;31m-[00m>torsions[segment].children.begin();
torsionDriver.cc:618:		cpos!=this[01;31m-[00m>torsions[segment].children.end();
torsionDriver.cc:620:	    this[01;31m-[00m>resetRotation(*cpos);
torsionDriver.cc:625:    pos = this[01;31m-[00m>torsions.begin()+segment; // this[01;31m-[00m>torsions.end()[01;31m-[00m1;
torsionDriver.cc:626:    while ( pos > this[01;31m-[00m>torsions.begin() ) {
torsionDriver.cc:627:	LOG(BF("Incrementing segment: %d") % (pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ) ); // vp0(( "Incrementing segment: %d", pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ));
torsionDriver.cc:629:	pos[01;31m-[00m>rotation++;
torsionDriver.cc:630:	LOG(BF("Incremented rotation %d of %d") % (pos[01;31m-[00m>rotation[01;31m-[00mpos[01;31m-[00m>rotations.begin()) % (pos[01;31m-[00m>rotations.end()[01;31m-[00mpos[01;31m-[00m>rotations.begin() ) ); // vp0(( "Incremented rotation %d of %d", pos[01;31m-[00m>rotation[01;31m-[00mpos[01;31m-[00m>rotations.begin(), pos[01;31m-[00m>rotations.end()[01;31m-[00mpos[01;31m-[00m>rotations.begin() ));
torsionDriver.cc:631:	if ( pos[01;31m-[00m>rotation != pos[01;31m-[00m>rotations.end() ) break;
torsionDriver.cc:633:	pos[01;31m-[00m>rotation = pos[01;31m-[00m>rotations.begin();
torsionDriver.cc:634:	pos[01;31m-[00m[01;31m-[00m;
torsionDriver.cc:636:    if ( pos > this[01;31m-[00m>torsions.begin() ) {
torsionDriver.cc:637:	LOG(BF("Updating transforms and coordinates from segment: %d") % (pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ) ); // vp0(( "Updating transforms and coordinates from segment: %d", pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() ));
torsionDriver.cc:638:	this[01;31m-[00m>updateAccumulatedTransforms(pos[01;31m-[00mthis[01;31m-[00m>torsions.begin());
torsionDriver.cc:639:	this[01;31m-[00m>calculateNewCoordinates(pos[01;31m-[00mthis[01;31m-[00m>torsions.begin());
torsionDriver.cc:640:	return pos[01;31m-[00mthis[01;31m-[00m>torsions.begin();
torsionDriver.cc:660:    if ( this[01;31m-[00m>driveMode ) {
torsionDriver.cc:661:	_lisp[01;31m-[00m>print(BF( "Torsion driver in DRIVE mode" ));
torsionDriver.cc:663:	_lisp[01;31m-[00m>print(BF( "Torsion driver in ADD_TORSION mode" ));
torsionDriver.cc:665:    for ( pos=this[01;31m-[00m>torsions.begin(); pos != this[01;31m-[00m>torsions.end(); pos++ ) {
torsionDriver.cc:666://	printf( "Driven torsion #%lX\n", (pos[01;31m-[00mthis[01;31m-[00m>torsions.begin() );
torsionDriver.cc:667:	if ( pos!=this[01;31m-[00m>torsions.begin() ) {
torsionDriver.cc:668:	    _lisp[01;31m-[00m>print(BF( "  Parent: %d") % pos[01;31m-[00m>parent );
torsionDriver.cc:669:	    _lisp[01;31m-[00m>print(BF( "      Fixed: %s") % pos[01;31m-[00m>fixed[01;31m-[00m>getName().c_str() );
torsionDriver.cc:670:	    _lisp[01;31m-[00m>print(BF( "    Movable: %s") % pos[01;31m-[00m>movable[01;31m-[00m>getName().c_str() );
torsionDriver.cc:671:	    _lisp[01;31m-[00m>print(BF( "      Steps: %d") % pos[01;31m-[00m>steps );
torsionDriver.cc:672:	    _lisp[01;31m-[00m>print(BF("      Atoms: " );
torsionDriver.cc:673:	    for ( ap=pos[01;31m-[00m>atoms.begin(); ap!=pos[01;31m-[00m>atoms.end(); ap++ ) {
torsionDriver.cc:674:		_lisp[01;31m-[00m>print(BF(" %s", ap[01;31m-[00m>getAtom()[01;31m-[00m>getName().c_str() );
torsionDriver.cc:676:	    _lisp[01;31m-[00m>print(BF( "" ));
torsionDriver.cc:677:		_lisp[01;31m-[00m>print(BF("      Children: " );
torsionDriver.cc:678:	    for ( ip=pos[01;31m-[00m>children.begin(); ip!=pos[01;31m-[00m>children.end(); ip++ ) {
torsionDriver.cc:679:		_lisp[01;31m-[00m>print(BF(" %3d", *ip );
torsionDriver.cc:681:	    _lisp[01;31m-[00m>print(BF( "" ));
torsionDriver.cc:682:	    _lisp[01;31m-[00m>print(BF( "      coordinate system:" ));
torsionDriver.cc:683:	    pos[01;31m-[00m>coord[01;31m-[00m>dump();
torsionDriver.cc:684:	    _lisp[01;31m-[00m>print(BF( "      relative matrix: " ));
torsionDriver.cc:685:	    pos[01;31m-[00m>relative.dump();
torsionDriver.cc:686:	    for (mp=pos[01;31m-[00m>rotations.begin(); mp!=pos[01;31m-[00m>rotations.end(); mp++ ) {
torsionDriver.cc:687://		_lisp[01;31m-[00m>print(BF( "      rotation matrix %d: ") % mp[01;31m-[00mpos[01;31m-[00m>rotations.begin() );
torsionDriver.cc:688:	        mp[01;31m-[00m>dump();
torsionDriver.cc:690://	    _lisp[01;31m-[00m>print(BF( "      current rotation: %d") % pos[01;31m-[00m>rotation[01;31m-[00mpos[01;31m-[00m>rotations.begin() );
torsionDriver.cc:693:	_lisp[01;31m-[00m>print(BF( "      accumulated matrix: " ));
torsionDriver.cc:694:	pos[01;31m-[00m>accumulated.dump();
torsionDriver.cc:695:	_lisp[01;31m-[00m>print(BF( "" ));
torsionDriver.cc:712:    for ( pos=this[01;31m-[00m>torsions.begin()+1; pos < this[01;31m-[00m>torsions.end(); pos++ ) {
torsionDriver.cc:713:	ss << pos[01;31m-[00m>fixed[01;31m-[00m>getName();
torsionDriver.cc:714:	ss << "[01;31m-[00m";
torsionDriver.cc:715:	ss << pos[01;31m-[00m>movable[01;31m-[00m>getName();
torsionDriver.cc:717:	ss << (pos[01;31m-[00m>rotation[01;31m-[00mpos[01;31m-[00m>rotations.begin()) << ") ";
torsionDriver.cc:738:    count = this[01;31m-[00m>torsions[segment].steps;
torsionDriver.cc:739:    for ( child=this[01;31m-[00m>torsions[segment].children.begin();
torsionDriver.cc:740:		child!=this[01;31m-[00m>torsions[segment].children.end();
torsionDriver.cc:742:	count *= this[01;31m-[00m>basicCountConformations(*child);
trainer.cc:18:    return this[01;31m-[00m>_UniqueIndex;
trainer.cc:23:    return this[01;31m-[00m>_History;
trainer.cc:27:    return this[01;31m-[00m>_Data;
trainer.cc:32:{_F(this[01;31m-[00m>lisp());
trainer.cc:33:    this[01;31m-[00m>_MostConformationalSearchFailsSeen = 0;
trainer.cc:37:{_F(this[01;31m-[00m>lisp());
trainer.cc:38:    if ( i > this[01;31m-[00m>_MostConformationalSearchFailsSeen )
trainer.cc:40:	this[01;31m-[00m>_MostConformationalSearchFailsSeen = i;
trainer.cc:45:{_F(this[01;31m-[00m>lisp());
trainer.cc:46:    return this[01;31m-[00m>_MostConformationalSearchFailsSeen;
trainer.cc:50:{_F(this[01;31m-[00m>lisp());
trainer.cc:51:    return this[01;31m-[00m>_MostConformationalSearchFailsSeen<this[01;31m-[00m>_MaxConformationalSearchFailsRequired;
trainer.cc:56:{_F(this[01;31m-[00m>lisp());
trainer.cc:57:    this[01;31m-[00m>_MaxConformationalSearchFailsRequired = i;
trainer.cc:61:{_F(this[01;31m-[00m>lisp());
trainer.cc:62:    return this[01;31m-[00m>_MaxConformationalSearchFailsRequired;
trainer.cc:67:{_F(this[01;31m-[00m>lisp());
trainer.cc:68:    this[01;31m-[00m>_SecondsSpentConformationalSearching = i;
trainer.cc:72:{_F(this[01;31m-[00m>lisp());
trainer.cc:73:    return this[01;31m-[00m>_SecondsSpentConformationalSearching;
trainer.cc:84:    this[01;31m-[00m>_Data[01;31m-[00m>set(key,val);
trainer.cc:89:    return this[01;31m-[00m>_Data[01;31m-[00m>get(key);
trainer.cc:94:    return this[01;31m-[00m>_Data[01;31m-[00m>contains(key);
trainer.cc:99:    return this[01;31m-[00m>_Context;
trainer.cc:103:    this[01;31m-[00m>_Context = co;
trainer.cc:107:{_F(this[01;31m-[00m>lisp());
trainer.cc:108:    this[01;31m-[00m>_State = str;
trainer.cc:112:{_F(this[01;31m-[00m>lisp());
trainer.cc:113:    this[01;31m-[00m>setState(str);
trainer.cc:114:    this[01;31m-[00m>setStateMessage(msg);
trainer.cc:120:{_F(this[01;31m-[00m>lisp());
trainer.cc:121:    this[01;31m-[00m>_UniqueIndex = i;
trainer.cc:126:    this[01;31m-[00m>Base::initialize();
trainer.cc:127:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
trainer.cc:128:    this[01;31m-[00m>_Context = O_MonomerContext::nil(this[01;31m-[00m>lisp());
trainer.cc:129:    this[01;31m-[00m>_History = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_TrainerHistory>();
trainer.cc:130:    this[01;31m-[00m>_TopDirectory = "";
trainer.cc:131:    this[01;31m-[00m>_FileName = "";
trainer.cc:132:    this[01;31m-[00m>_State = "";
trainer.cc:133:    this[01;31m-[00m>_StateMessage = "";
trainer.cc:134:    this[01;31m-[00m>_History[01;31m-[00m>clear();
trainer.cc:135:    this[01;31m-[00m>_Data[01;31m-[00m>clear();
trainer.cc:136:    this[01;31m-[00m>_Context = O_MonomerContext::nil(this[01;31m-[00m>lisp());
trainer.cc:137:    this[01;31m-[00m>_MostConformationalSearchFailsSeen = 0;
trainer.cc:138:    this[01;31m-[00m>_MaxConformationalSearchFailsRequired = DEFAULT_MAX_CONFORMATIONAL_SEARCH_FAILS_REQUIRED;
trainer.cc:139:    this[01;31m-[00m>_SecondsSpentConformationalSearching = 0;
trainer.cc:145:{_F(this[01;31m-[00m>lisp());
trainer.cc:146:    node[01;31m-[00m>attribute("TopDirectory", this[01;31m-[00m>_TopDirectory );
trainer.cc:147:    node[01;31m-[00m>attribute("FileName", this[01;31m-[00m>_FileName );
trainer.cc:148:    node[01;31m-[00m>attribute("State", this[01;31m-[00m>_State );
trainer.cc:149:    node[01;31m-[00m>archiveStringIfNotDefault("StateMessage", this[01;31m-[00m>_StateMessage, "" );
trainer.cc:150:    node[01;31m-[00m>attributeIfNotDefault("NotPartOfSeedDatabase", this[01;31m-[00m>_NotPartOfSeedDatabase, true);
trainer.cc:151:    node[01;31m-[00m>archiveObject("data",this[01;31m-[00m>_Data);
trainer.cc:152:    node[01;31m-[00m>archiveObject("context",this[01;31m-[00m>_Context);
trainer.cc:153:    node[01;31m-[00m>attribute("UniqueIndex", this[01;31m-[00m>_UniqueIndex );
trainer.cc:154:    node[01;31m-[00m>archiveObject("history",this[01;31m-[00m>_History);
trainer.cc:155:    node[01;31m-[00m>attributeIfNotDefault("MostConformationalSearchFailsSeen",this[01;31m-[00m>_MostConformationalSearchFailsSeen,(uint)(0));
trainer.cc:156:    node[01;31m-[00m>attributeIfNotDefault("MaxConformationalSearchFailsRequired",this[01;31m-[00m>_MaxConformationalSearchFailsRequired,(uint)(DEFAULT_MAX_CONFORMATIONAL_SEARCH_FAILS_REQUIRED));
trainer.cc:157:    node[01;31m-[00m>attributeIfNotDefault<LongLongInt>("SecondsSpentConformationalSearching",this[01;31m-[00m>_SecondsSpentConformationalSearching,(LongLongInt)(0));
trainer.cc:161:{_F(this[01;31m-[00m>lisp());
trainer.cc:162:    LOG(BF("Generating file name directory(%s)") % this[01;31m-[00m>_TopDirectory.c_str() ); // vp0(("Generating file name directory(%s)", this[01;31m-[00m>_TopDirectory.c_str()));
trainer.cc:163:    LOG(BF("Generating file name fileNamePrefix(%s)") % this[01;31m-[00m>getTrainerFileNamePrefix().c_str()  ); // vp0(("Generating file name fileNamePrefix(%s)", this[01;31m-[00m>getTrainerFileNamePrefix().c_str() ));
trainer.cc:165:    sprintf( fileName, "%s/%s.cxml", this[01;31m-[00m>_TopDirectory.c_str(),
trainer.cc:166:		this[01;31m-[00m>getTrainerFileNamePrefix().c_str() );
trainer.cc:173:{_F(this[01;31m-[00m>lisp());
trainer.cc:174:    return this[01;31m-[00m>_Context[01;31m-[00m>getKey();
trainer.cc:183:    this[01;31m-[00m>Base::initialize();
trainer.cc:184:    this[01;31m-[00m>_Data = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_ObjectDictionary>();
trainer.cc:185:    this[01;31m-[00m>_Data[01;31m-[00m>clear();
trainer.cc:189:{_F(this[01;31m-[00m>lisp());
trainer.cc:190:    node[01;31m-[00m>archiveObject("header",this[01;31m-[00m>_Header);
trainer.cc:191:    node[01;31m-[00m>archiveObject("data",this[01;31m-[00m>_Data);
trainer.cc:195:{_F(this[01;31m-[00m>lisp());
trainer.cc:196:    writeTrainer(this[01;31m-[00m>getHeader()[01;31m-[00m>getFileName(),this[01;31m-[00m>sharedThis<O_Trainer>(),_lisp );
trainer.cc:201:    return downcast<O_ConformationExplorer>(this[01;31m-[00m>getData("_Structures"));
trainer.cc:205:    this[01;31m-[00m>setData("_Structures",str);
trainer.cc:210:{_F(this[01;31m-[00m>lisp());
trainer.cc:211:    return this[01;31m-[00m>_Data[01;31m-[00m>rendered(opts);
trainer.cc:216:    this[01;31m-[00m>_Header = head;
trainer.cc:220:    return this[01;31m-[00m>_Header;
trainer.cc:225:    this[01;31m-[00m>_Data[01;31m-[00m>set(key,data);
trainer.cc:229:    return this[01;31m-[00m>_Data[01;31m-[00m>contains(key);
trainer.cc:233:    return this[01;31m-[00m>_Data[01;31m-[00m>get(key);
trainer.cc:238:    return this[01;31m-[00m>_Data;
trainer.cc:248:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("Could not open file: "+fileName));
trainer.cc:252:    RPMetaClass trainerHeaderClass = lisp[01;31m-[00m>classFromClassName(O_TrainerHeader::static_className());
trainer.cc:253:    string search = trainerHeaderClass[01;31m-[00m>getPackagedName();
trainer.cc:259:	    TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Could not find (%s) in the first 100 lines")%search));
trainer.cc:267:	    trimmed = trimmed.substr(0,trimmed.size()[01;31m-[00m1); // remove ">"
trainer.cc:279:	dict[01;31m-[00m>put(onePair[0],lisp[01;31m-[00m>create<O_String>(onePair[1].substr(1,onePair[1].size()[01;31m-[00m2)));
trainer.cc:287:    ASSERTP(args[01;31m-[00m>notNil(), "You must provide the file name");
trainer.cc:288:    return readTrainerHeader(args[01;31m-[00m>car<O_String>()[01;31m-[00m>get(),lisp);
trainer.cc:299:    a = lisp[01;31m-[00m>create<O_XmlLoadArchive>();
trainer.cc:300:    a[01;31m-[00m>parse(fileName);
trainer.cc:301:    job = downcast<O_Trainer>(a[01;31m-[00m>get("job"));
trainer.cc:309:{_F(this[01;31m-[00m>lisp());
trainer.cc:313:    jobHeader = job[01;31m-[00m>getHeader();
trainer.cc:318:    RPResidue focusResidue = safe_downcast<O_Residue>(job[01;31m-[00m>getData("FocusResidue"));
trainer.cc:319:    RPConstitution focusResidueConstitution = focusResidue[01;31m-[00m>getConstitution();
trainer.cc:320:    string constitutionName = focusResidueConstitution[01;31m-[00m>getName();
trainer.cc:321:    mbb::RPBuilderDatabase oldTrainerBuilderDatabase = job[01;31m-[00m>getBuilderDatabase();
trainer.cc:323:    oldTrainerBuilderDatabase[01;31m-[00m>giveYourDependantObjectsTo(bdh);
trainer.cc:324:    RPConstitution newFocusResidueConstitution = bdh[01;31m-[00m>monomerConstitutionForName(constitutionName);
trainer.cc:325:    LOG(BF("Setting constitution for FocusResidue to: %s") % newFocusResidueConstitution[01;31m-[00m>description().c_str()  ); // vp0(("Setting constitution for FocusResidue to: %s", newFocusResidueConstitution[01;31m-[00m>description().c_str() ));
trainer.cc:326:    focusResidue[01;31m-[00m>setConstitution(newFocusResidueConstitution);
trainer.cc:327:    LOG(BF("Setting constitution for FocusResidue: %s") % focusResidue[01;31m-[00m>description().c_str()  ); // vp0(("Setting constitution for FocusResidue: %s", focusResidue[01;31m-[00m>description().c_str() ));
trainer.cc:328:    LOG(BF("    constitution = %s") % newFocusResidueConstitution[01;31m-[00m>description().c_str()  ); // vp0(("    constitution = %s", newFocusResidueConstitution[01;31m-[00m>description().c_str() ));
trainer.cc:329:    job[01;31m-[00m>setBuilderDatabase(bdh);
trainer.cc:340:    job[01;31m-[00m>getHeader()[01;31m-[00m>setFileName(fileName);
trainer.cc:341:    a = job[01;31m-[00m>lisp()[01;31m-[00m>create<O_XmlSaveArchive>();
trainer.cc:342:    a[01;31m-[00m>put("job",job);
trainer.cc:344:    a[01;31m-[00m>saveAs(fileName);
trainer.cc:356:    this[01;31m-[00m>Base::initialize();
trainer.cc:357:    this[01;31m-[00m>_Data = O_ObjectDictionary::create(this[01;31m-[00m>lisp());
trainer.cc:362:{_F(this[01;31m-[00m>lisp());
trainer.cc:363:    node[01;31m-[00m>archiveMap("entries",this[01;31m-[00m>_Entries);
trainer.cc:364:    node[01;31m-[00m>archiveObject("data",this[01;31m-[00m>_Data);
trainer.cc:369:    return this[01;31m-[00m>_Entries.size(); 
trainer.cc:375:    this[01;31m-[00m>_Data[01;31m-[00m>set(key,data);
trainer.cc:379:    return this[01;31m-[00m>_Data[01;31m-[00m>contains(key);
trainer.cc:383:    return this[01;31m-[00m>_Data[01;31m-[00m>get(key);
trainer.cc:387:Map<O_TrainerHeader>::value_iterator O_TrainerOrganizer::begin_Entries() { return this[01;31m-[00m>_Entries.begin_value(); };
trainer.cc:388:Map<O_TrainerHeader>::value_iterator O_TrainerOrganizer::end_Entries() { return this[01;31m-[00m>_Entries.end_value(); };
trainer.cc:393:   val = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(topDir);
trainer.cc:394:   this[01;31m-[00m>_Data[01;31m-[00m>set("_TopDirectory", val );
trainer.cc:398:    return (downcast<O_String>(this[01;31m-[00m>_Data[01;31m-[00m>get("_TopDirectory")))[01;31m-[00m>get();
trainer.cc:403:   val = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(str);
trainer.cc:404:   this[01;31m-[00m>_Data[01;31m-[00m>set("_BuilderDatabaseFileName", val );
trainer.cc:408:    return (downcast<O_String>(this[01;31m-[00m>_Data[01;31m-[00m>get("_BuilderDatabaseFileName")))[01;31m-[00m>get();
trainer.cc:414:    this[01;31m-[00m>_Entries.set(head[01;31m-[00m>getContextKey(),head);
trainer.cc:418:    return this[01;31m-[00m>_Entries.get(key);
trainer.cc:424:    key = context[01;31m-[00m>getKey();
trainer.cc:425:    return this[01;31m-[00m>_Entries.contains(key);
trainer.cc:432:{_F(this[01;31m-[00m>lisp());
trainer.cc:433:    ASSERT(this[01;31m-[00m>_Entries.contains(key));
trainer.cc:434:    return this[01;31m-[00m>_Entries.get(key);
trainer.cc:441:    for ( entryIterator ei=this[01;31m-[00m>_Entries.begin_value(); 
trainer.cc:442:    		ei!=this[01;31m-[00m>_Entries.end_value(); ei++ )
trainer.cc:444:        RPMonomerContext organizerContext = (*ei)[01;31m-[00m>getContext();
trainer.cc:445:	if ( context[01;31m-[00m>containsMonomerContext(organizerContext) )
trainer.cc:450:    return O_TrainerHeader::nil(this[01;31m-[00m>lisp());
trainer.cc:455:{_F(this[01;31m-[00m>lisp());
trainer.cc:458:    for ( ei=this[01;31m-[00m>_Entries.begin_value(); ei!=this[01;31m-[00m>_Entries.end_value(); ei++ )
trainer.cc:460:	highestUniqueIndex = max(highestUniqueIndex,(*ei)[01;31m-[00m>getUniqueIndex());
trainer.cc:469:{_F(this[01;31m-[00m>lisp());
trainer.cc:472:    entries = O_Cons::nil(this[01;31m-[00m>lisp());
trainer.cc:473:    for ( it=this[01;31m-[00m>_Entries.begin(); it!=this[01;31m-[00m>_Entries.end(); it++ )
trainer.cc:475:	RPCons one = O_Cons::createList(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(it[01;31m-[00m>first),it[01;31m-[00m>second,this[01;31m-[00m>lisp());
trainer.cc:476:	cur = O_Cons::create(one,this[01;31m-[00m>lisp());
trainer.cc:477:	if ( entries[01;31m-[00m>isNil() )
trainer.cc:483:	    tail[01;31m-[00m>setCdr(cur);
trainer.cc:493:    archive = org[01;31m-[00m>lisp()[01;31m-[00m>create<O_XmlSaveArchive>();
trainer.cc:494:    archive[01;31m-[00m>put("organizer",org);
trainer.cc:495:    archive[01;31m-[00m>saveAs("_organizer.cxml");
trainer.cc:504:    archive = lisp[01;31m-[00m>create<O_XmlLoadArchive>();
trainer.cc:505:    archive[01;31m-[00m>parse("_organizer.cxml");
trainer.cc:506:    org = downcast<O_TrainerOrganizer>(archive[01;31m-[00m>get("organizer"));
trainer.cc:515:    RPTrainer train = readTrainer(args[01;31m-[00m>car<O_Text>()[01;31m-[00m>get(), lisp );
trainer.cc:524:    class_<O_TrainerHeader>(this[01;31m-[00m>lisp())
trainer.cc:601:    class_<O_Trainer>(this[01;31m-[00m>lisp())
trainer.cc:614:    defInPackage(MbbPackage,"writeTrainer",&writeTrainer,this[01;31m-[00m>lisp());
trainer.cc:615:    defNoWrapPackage(MbbPackage,"readTrainerHeader",&prim_readTrainerHeader,this[01;31m-[00m>lisp());
trainer.cc:616:    defNoWrapPackage(MbbPackage,"readTrainer",&prim_readTrainer,this[01;31m-[00m>lisp());
trainer.cc:650:    class_<O_TrainerOrganizer>(this[01;31m-[00m>lisp())
trainer.cc:672://    def("create_TrainerOrganizer",&create_TrainerOrganizer,this[01;31m-[00m>lisp());
trainer.cc:673:    defInPackage(MbbPackage,"writeTrainerOrganizer",&writeTrainerOrganizer,this[01;31m-[00m>lisp());
trainer.cc:674:    defInPackage(MbbPackage,"readTrainerOrganizer",&readTrainerOrganizer,this[01;31m-[00m>lisp());
trainerArchive.cc:23:    this[01;31m-[00m>Base::initialize();
trainerArchive.cc:24:    this[01;31m-[00m>_BuilderDatabase = O_BuilderDatabase::nil(this[01;31m-[00m>lisp());
trainerArchive.cc:25:    this[01;31m-[00m>_Trainers.clear();
trainerArchive.cc:29:{_F(this[01;31m-[00m>lisp());
trainerArchive.cc:30:    node[01;31m-[00m>archiveObject("BuilderDatabase",this[01;31m-[00m>_BuilderDatabase);
trainerArchive.cc:31:    node[01;31m-[00m>archiveMap("Trainers",this[01;31m-[00m>_Trainers);
trainerArchive.cc:37:{_F(this[01;31m-[00m>lisp());
trainerArchive.cc:39:    this[01;31m-[00m>_BuilderDatabase = hold;
trainerArchive.cc:44:{_F(this[01;31m-[00m>lisp());
trainerArchive.cc:46:    key = job[01;31m-[00m>getHeader()[01;31m-[00m>getContextKey();
trainerArchive.cc:47:    this[01;31m-[00m>_Trainers.set(key,job);
trainerArchive.cc:52:{_F(this[01;31m-[00m>lisp());
trainerArchive.cc:53:    return this[01;31m-[00m>_Trainers.contains(key);
trainerArchive.cc:57:{_F(this[01;31m-[00m>lisp());
trainerArchive.cc:58:    return this[01;31m-[00m>_Trainers.get(key);
trajectory.cc:31:    class_<O_TrajectoryFrame>(e[01;31m-[00m>lisp())
trajectory.cc:49:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
trajectory.cc:55:    this[01;31m-[00m>Base::initialize();
trajectory.cc:60:    this[01;31m-[00m>Base::archiveBase(node);
trajectory.cc:61:    node[01;31m-[00m>archiveObject("coords",this[01;31m-[00m>_Coordinates);
trajectory.cc:67:    this[01;31m-[00m>_Coordinates = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_CoordinateArray>(atomList.size());
trajectory.cc:70:    for ( ai=atomList.begin(), ci = this[01;31m-[00m>_Coordinates[01;31m-[00m>begin(); ai!=atomList.end(); ai++, ci++ )
trajectory.cc:72:	(*ci) = (*ai)[01;31m-[00m>getPosition();
trajectory.cc:80:    ASSERT_eq(this[01;31m-[00m>_Coordinates[01;31m-[00m>size(),atomList.size());
trajectory.cc:83:    for ( ai=atomList.begin(), ci = this[01;31m-[00m>_Coordinates[01;31m-[00m>begin(); ai!=atomList.end(); ai++, ci++ )
trajectory.cc:85:	(*ai)[01;31m-[00m>setPosition(*ci);
trajectory.cc:92:    O_Trajectory::expose(class_<O_Trajectory>(e[01;31m-[00m>lisp()));
trajectory.cc:110:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
trajectory.cc:111:    RPMatter matter = kargs[01;31m-[00m>getAndRemove("matter")[01;31m-[00m>as<O_Matter>();
trajectory.cc:112:    this[01;31m-[00m>_setupAtomList(matter);
trajectory.cc:117:    this[01;31m-[00m>Base::initialize();
trajectory.cc:118:    this[01;31m-[00m>_Matter = O_Matter::nil(this[01;31m-[00m>lisp());
trajectory.cc:119:    this[01;31m-[00m>_Namespace = O_ObjectDictionary::create(this[01;31m-[00m>lisp());
trajectory.cc:125:    this[01;31m-[00m>_Matter = matter;
trajectory.cc:126:    this[01;31m-[00m>_AtomList.clear();
trajectory.cc:128:    lAtoms.loopTopGoal(this[01;31m-[00m>_Matter,ATOMS);
trajectory.cc:131:	this[01;31m-[00m>_AtomList.push_back(lAtoms.getAtom());
trajectory.cc:133:    this[01;31m-[00m>_Frames.clear();
trajectory.cc:139:    this[01;31m-[00m>Base::archiveBase(node);
trajectory.cc:140:    node[01;31m-[00m>archiveObject("matter",this[01;31m-[00m>_Matter);
trajectory.cc:141:    node[01;31m-[00m>archiveObject("namespace",this[01;31m-[00m>_Namespace);
trajectory.cc:142:    node[01;31m-[00m>archiveList("atomList",this[01;31m-[00m>_AtomList);
trajectory.cc:143:    node[01;31m-[00m>archiveList("frames",this[01;31m-[00m>_Frames);
trajectory.cc:149:{_F(this[01;31m-[00m>lisp());
trajectory.cc:150:    ASSERTP(matter == this[01;31m-[00m>_Matter,"The matter argument must match the Matter used to define this trajectory");
trajectory.cc:151:    RPTrajectoryFrame frame = O_TrajectoryFrame::create(this[01;31m-[00m>lisp());
trajectory.cc:152:    frame[01;31m-[00m>fillFromMatter(this[01;31m-[00m>_AtomList);
trajectory.cc:153:    this[01;31m-[00m>_Frames.push_back(frame);
trajectory.cc:159:{_F(this[01;31m-[00m>lisp());
trajectory.cc:160:    return this[01;31m-[00m>_Frames.size();
trajectory.cc:165:{_F(this[01;31m-[00m>lisp());
trajectory.cc:166:    ASSERT_lt(i,this[01;31m-[00m>_Frames.size());
trajectory.cc:167:    return this[01;31m-[00m>_Frames[i];
trajectory.cc:172:{_F(this[01;31m-[00m>lisp());
trajectory.cc:173:    RPRenderFrameList frames = O_RenderFrameList::create(this[01;31m-[00m>lisp());
trajectory.cc:174:    for ( List<O_TrajectoryFrame>::iterator it=this[01;31m-[00m>_Frames.begin(); it!=this[01;31m-[00m>_Frames.end(); it++ )
trajectory.cc:176:	this[01;31m-[00m>applyTrajectoryFrameToMatter(*it);
trajectory.cc:177:	frames[01;31m-[00m>add(this[01;31m-[00m>_Matter[01;31m-[00m>rendered(kargs));
trajectory.cc:184:{_F(this[01;31m-[00m>lisp());
trajectory.cc:185:    f[01;31m-[00m>applyToMatter(this[01;31m-[00m>_AtomList);
transformCascade.cc:52:    ce.buildFrom = [01;31m-[00m1; // There is always this entry in the table
transformCascade.cc:57:    this[01;31m-[00m>entries.push_back(ce);
transformCascade.cc:79:    ASSERT_lessThan(bf,this[01;31m-[00m>entries.size());
transformCascade.cc:84:    this[01;31m-[00m>entries.push_back(ce);
transformCascade.cc:85:    return this[01;31m-[00m>entries.size()[01;31m-[00m1;
transformCascade.cc:92:    ASSERT_lessThan(i,this[01;31m-[00m>entries.size());
transformCascade.cc:93:    this[01;31m-[00m>entries[i].transform = m;
transformCascade.cc:94:    this[01;31m-[00m>entries[i].recalculate = true;
transformCascade.cc:101:    ASSERT_lessThan(i,this[01;31m-[00m>entries.size());
transformCascade.cc:102:    return this[01;31m-[00m>entries[i].resultTransform;
transformCascade.cc:108:{_F(this[01;31m-[00m>lisp());
transformCascade.cc:115:    is = this[01;31m-[00m>entries.size();
transformCascade.cc:116:    for (i=1; i<this[01;31m-[00m>entries.size(); i++ ) {
transformCascade.cc:117:	if ( this[01;31m-[00m>entries[i].recalculate ) {
transformCascade.cc:124:    if ( is >= this[01;31m-[00m>entries.size() ) return;
transformCascade.cc:126:    for ( i=is,cecur=this[01;31m-[00m>entries.begin()+is;
transformCascade.cc:127:		i < this[01;31m-[00m>entries.size(); cecur++,i++ ) {
transformCascade.cc:129:	bf = cecur[01;31m-[00m>buildFrom;
transformCascade.cc:130:	ceprev = this[01;31m-[00m>entries.begin()+bf;
transformCascade.cc:133:	cecur[01;31m-[00m>resultTransform = ceprev[01;31m-[00m>resultTransform * cecur[01;31m-[00m>transform;
transformCascade.cc:136:	cf = this[01;31m-[00m>entries[bf].coordSys;
transformCascade.cc:137:	cecur[01;31m-[00m>coordSys[01;31m-[00m>canonical();
transformCascade.cc:138:	cecur[01;31m-[00m>coordSys[01;31m-[00m>transformWithMatrix(cecur[01;31m-[00m>transform);
transformCascade.cc:139:	cecur[01;31m-[00m>coordSys[01;31m-[00m>transformWithMatrix(cf[01;31m-[00m>matrixFromCanonical());
transformCascade.cc:142:	cecur[01;31m-[00m>recalculate = false;
twister.cc:33:    this[01;31m-[00m>Base::initialize();
twister.cc:34:    this[01;31m-[00m>_FixedRef = O_Atom::nil(this[01;31m-[00m>lisp());
twister.cc:35:    this[01;31m-[00m>_Fixed = O_Atom::nil(this[01;31m-[00m>lisp());
twister.cc:36:    this[01;31m-[00m>_Movable = O_Atom::nil(this[01;31m-[00m>lisp());
twister.cc:37:    this[01;31m-[00m>_MovableRef = O_Atom::nil(this[01;31m-[00m>lisp());
twister.cc:38:    this[01;31m-[00m>_Atoms.clear();
twister.cc:45:    node[01;31m-[00m>archiveObject("Fixed",this[01;31m-[00m>_Fixed);
twister.cc:46:    node[01;31m-[00m>archiveObject("Movable",this[01;31m-[00m>_Movable);
twister.cc:47:    node[01;31m-[00m>archiveList("MoveAtoms",this[01;31m-[00m>_Atoms);
twister.cc:54:    this[01;31m-[00m>_Fixed = fixed;
twister.cc:55:    this[01;31m-[00m>_Movable = movable;
twister.cc:60:    this[01;31m-[00m>_Atoms.push_back(a);
twister.cc:68:{_F(this[01;31m-[00m>lisp());
twister.cc:69:    BondOrder bo = a1[01;31m-[00m>bondOrderTo(a2);
twister.cc:70:    bool hasBond = a1[01;31m-[00m>isBondedTo(a2);
twister.cc:73:	a1[01;31m-[00m>removeBondTo(a2);
twister.cc:78:    RPCons a1Atoms = O_Cons::nil(this[01;31m-[00m>lisp());
twister.cc:79:    RPSpanningLoop span1 = O_SpanningLoop::create(this[01;31m-[00m>lisp());
twister.cc:80:    span1[01;31m-[00m>setTop(a1);
twister.cc:81:    while ( span1[01;31m-[00m>advance() )
twister.cc:83:	a1Atoms = O_Cons::create(span1[01;31m-[00m>getAtom(),a1Atoms,this[01;31m-[00m>lisp());
twister.cc:85:    RPCons a2Atoms = O_Cons::nil(this[01;31m-[00m>lisp());
twister.cc:86:    RPSpanningLoop span2 = O_SpanningLoop::create(this[01;31m-[00m>lisp());
twister.cc:87:    span2[01;31m-[00m>setTop(a2);
twister.cc:88:    while ( span2[01;31m-[00m>advance() )
twister.cc:90:	a2Atoms = O_Cons::create(span2[01;31m-[00m>getAtom(),a2Atoms,this[01;31m-[00m>lisp());
twister.cc:103:	if ( a1Atoms[01;31m-[00m>length() < a2Atoms[01;31m-[00m>length() )
twister.cc:124:	a1[01;31m-[00m>bondTo(a2,bo);
twister.cc:126:    this[01;31m-[00m>_Atoms.clear();
twister.cc:127:    this[01;31m-[00m>setFixedAndMovable(twistFixed,twistMovable);
twister.cc:128:    this[01;31m-[00m>_FixedRef = twistFixedRef;
twister.cc:129:    this[01;31m-[00m>_MovableRef = twistMovableRef;
twister.cc:130:    for ( RPCons cur=twistAtoms; cur[01;31m-[00m>notNil(); cur = cur[01;31m-[00m>cdr() )
twister.cc:132:	this[01;31m-[00m>addAtom(cur[01;31m-[00m>car<O_Atom>());
twister.cc:139:{_F(this[01;31m-[00m>lisp());
twister.cc:140:    this[01;31m-[00m>_defineForDihedral(a1ref,a1,a2,a2ref,false);
twister.cc:148:    this[01;31m-[00m>_defineForDihedral(O_Atom::nil(this[01;31m-[00m>lisp()),a1,a2,O_Atom::nil(this[01;31m-[00m>lisp()),false);
twister.cc:154:    this[01;31m-[00m>_defineForDihedral(O_Atom::nil(this[01;31m-[00m>lisp()),afixed,amobile,O_Atom::nil(this[01;31m-[00m>lisp()), true);
twister.cc:164:    ASSERT_NOT_NULLP(this[01;31m-[00m>_Fixed,"Fixed atom undefined");
twister.cc:165:    ASSERT_NOT_NULLP(this[01;31m-[00m>_Movable,"Movable atom is undefined");
twister.cc:166:    ASSERTP(this[01;31m-[00m>_Atoms.size()>0,"There must be atoms to rotate");
twister.cc:167:    rotVec = this[01;31m-[00m>_Movable[01;31m-[00m>getPosition()[01;31m-[00mthis[01;31m-[00m>_Fixed[01;31m-[00m>getPosition();
twister.cc:168:    rotVec = rotVec.normalized(this[01;31m-[00m>lisp());
twister.cc:169:    tv = this[01;31m-[00m>_Movable[01;31m-[00m>getPosition();
twister.cc:170:    tv = tv.multiplyByScalar([01;31m-[00m1.0);
twister.cc:175:    tv = this[01;31m-[00m>_Movable[01;31m-[00m>getPosition();
twister.cc:180:    for ( vector<RPAtom>::iterator ai=this[01;31m-[00m>_Atoms.begin();
twister.cc:181:	  ai!=this[01;31m-[00m>_Atoms.end(); ai++ ) {
twister.cc:182:	LOG(BF("Perturbing atom(%s)  start position = %lf, %lf, %lf") % (*ai)[01;31m-[00m>description().c_str() % (*ai)[01;31m-[00m>getPosition().getX() % (*ai)[01;31m-[00m>getPosition().getY() % (*ai)[01;31m-[00m>getPosition().getZ()  ); // vp0(( "Perturbing atom(%s)  start position = %lf, %lf, %lf", (*ai)[01;31m-[00m>description().c_str(), (*ai)[01;31m-[00m>getPosition().getX(), (*ai)[01;31m-[00m>getPosition().getY(), (*ai)[01;31m-[00m>getPosition().getZ() ));
twister.cc:183:	tv = (*ai)[01;31m-[00m>getPosition();
twister.cc:185:	(*ai)[01;31m-[00m>setPosition(tv);
twister.cc:186:	LOG(BF("                     pert. position = %lf, %lf, %lf") % (*ai)[01;31m-[00m>getPosition().getX() % (*ai)[01;31m-[00m>getPosition().getY() % (*ai)[01;31m-[00m>getPosition().getZ()  ); // vp0(( "                     pert. position = %lf, %lf, %lf", (*ai)[01;31m-[00m>getPosition().getX(), (*ai)[01;31m-[00m>getPosition().getY(), (*ai)[01;31m-[00m>getPosition().getZ() ));
twister.cc:194:{_F(this[01;31m-[00m>lisp());
twister.cc:195:    if (this[01;31m-[00m>_FixedRef[01;31m-[00m>isNil() )
twister.cc:197:	TOSS(_lisp[01;31m-[00m>create<O_ContentException>("For absolute rotations the reference atoms of the twister must be defined"));
twister.cc:199:    Vector3 v1 = this[01;31m-[00m>_FixedRef[01;31m-[00m>getPosition();
twister.cc:200:    Vector3 v2 = this[01;31m-[00m>_Fixed[01;31m-[00m>getPosition();
twister.cc:201:    Vector3 v3 = this[01;31m-[00m>_Movable[01;31m-[00m>getPosition();
twister.cc:202:    Vector3 v4 = this[01;31m-[00m>_MovableRef[01;31m-[00m>getPosition();
twister.cc:204:    double currentAngle = calculateDihedral(v1,v2,v3,v4,this[01;31m-[00m>lisp());
twister.cc:205:    double delta = angle [01;31m-[00m currentAngle;
twister.cc:206:    _lisp[01;31m-[00m>print(BF("current dihedral = %8.3lf  desired dihedral = %8.3lf delta=%8.3lf") % (currentAngle/0.0174533) % (angle/0.0174533) % (delta/0.0174533) );
twister.cc:207:    this[01;31m-[00m>rotate(delta);
twister.cc:209:    v1 = this[01;31m-[00m>_FixedRef[01;31m-[00m>getPosition();
twister.cc:210:    v2 = this[01;31m-[00m>_Fixed[01;31m-[00m>getPosition();
twister.cc:211:    v3 = this[01;31m-[00m>_Movable[01;31m-[00m>getPosition();
twister.cc:212:    v4 = this[01;31m-[00m>_MovableRef[01;31m-[00m>getPosition();
twister.cc:213:    double resultAngle = calculateDihedral(v1,v2,v3,v4,this[01;31m-[00m>lisp());
twister.cc:214:    _lisp[01;31m-[00m>print(BF("      result dihedral = %8.3lf") % (resultAngle/0.0174533) );
twister.cc:222:    ss << "Twister[Fixed[" << this[01;31m-[00m>_Fixed[01;31m-[00m>description();
twister.cc:223:    ss << "] Moveable[" << this[01;31m-[00m>_Movable[01;31m-[00m>description() << "]";
twister.cc:231:    node[01;31m-[00m>archiveObject("Aggregate",this[01;31m-[00m>_Aggregate);
twister.cc:232:    node[01;31m-[00m>archiveList("Twisters",this[01;31m-[00m>_Twisters);
twister.cc:238:    this[01;31m-[00m>_Twisters.push_back(twister);
twister.cc:244:    ASSERT_lessThan(i,this[01;31m-[00m>_Twisters.size());
twister.cc:245:    return this[01;31m-[00m>_Twisters[i];
twister.cc:252:    if ( this[01;31m-[00m>_Twisters.size() == 0 )
twister.cc:257:    it = randomNumber01(_lisp)*this[01;31m-[00m>_Twisters.size();
twister.cc:260:    LOG(BF("Perturbing twister#%d of %d by %lf degrees") % it % this[01;31m-[00m>_Twisters.size() % (ang/0.0174533)  );
twister.cc:261:    this[01;31m-[00m>_Twisters[it][01;31m-[00m>rotate(ang);
twister.cc:267:    ss << "TwisterDriver[#twisters("<<this[01;31m-[00m>_Twisters.size()<<")]";
twister.cc:277:    class_<O_Twister>(this[01;31m-[00m>lisp())
twister.cc:313:    class_<O_TwisterDriver>(this[01;31m-[00m>lisp())
typeAssignmentRules.cc:19:    this[01;31m-[00m>Base::initialize();
typeAssignmentRules.cc:20:    this[01;31m-[00m>_Match = O_ChemInfo::nil(this[01;31m-[00m>lisp());
typeAssignmentRules.cc:25:    node[01;31m-[00m>attribute("assignTypeName",this[01;31m-[00m>_AssignTypeName);
typeAssignmentRules.cc:26:    node[01;31m-[00m>archiveObject("match",this[01;31m-[00m>_Match);
typeAssignmentRules.cc:32:    return this[01;31m-[00m>_Match[01;31m-[00m>matches(atom);
typeAssignmentRules.cc:40:    this[01;31m-[00m>Base::initialize();
typeAssignmentRules.cc:41:    this[01;31m-[00m>_WildElementDict = O_WildElementDict::nil(this[01;31m-[00m>lisp());
typeAssignmentRules.cc:46:    node[01;31m-[00m>archiveObject("WildElementDict",this[01;31m-[00m>_WildElementDict);
typeAssignmentRules.cc:47:    node[01;31m-[00m>archiveList("Rules",this[01;31m-[00m>_Rules);
typeAssignmentRules.cc:53:    for ( List<O_OneTypeRule>::iterator it=this[01;31m-[00m>_Rules.begin();
typeAssignmentRules.cc:54:    		it!=this[01;31m-[00m>_Rules.end(); it++ )
typeAssignmentRules.cc:56:	if ( (*it)[01;31m-[00m>testMatch(a) )
typeAssignmentRules.cc:58:	    return (*it)[01;31m-[00m>getAssignTypeName();
typeAssignmentRules.cc:61:    return "UNASSIGNED[01;31m-[00mTYPE";
values.cc:24:    Ty y = (oy[01;31m-[00m>as<oTy>()[01;31m-[00m>get());
values.cc:25:    return oTr::create(x+y,oy[01;31m-[00m>lisp());
values.cc:30:    Ty y = (oy[01;31m-[00m>as<oTy>()[01;31m-[00m>get());
values.cc:31:    return oTr::create(x[01;31m-[00my,oy[01;31m-[00m>lisp());
values.cc:36:    Ty y = (oy[01;31m-[00m>as<oTy>()[01;31m-[00m>get());
values.cc:37:    return oTr::create(x*y,oy[01;31m-[00m>lisp());
values.cc:42:    Ty y = (oy[01;31m-[00m>as<oTy>()[01;31m-[00m>get());
values.cc:43:    return oTr::create(x/y,oy[01;31m-[00m>lisp());
values.cc:48:    if ( this[01;31m-[00m>isNil() ) { return "nil";};
values.cc:50:    ss << "Value_of_class(" << this[01;31m-[00m>className() << ")";
values.cc:60:    node[01;31m-[00m>archiveString("block",this[01;31m-[00m>_Value);
values.cc:65:    this[01;31m-[00m>archiveBase(node);
values.cc:72:    i = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Int>(atoi(this[01;31m-[00m>_Value.c_str()));
values.cc:82:    n = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_Real>(atof(this[01;31m-[00m>_Value.c_str()));
values.cc:90:    string::size_type found = this[01;31m-[00m>_Value.find_first_of(chars);
values.cc:94:	found = this[01;31m-[00m>_Value.find_first_of(chars,found+1);
values.cc:102:	string res = this[01;31m-[00m>_Value.substr(0,num);
values.cc:108:    string res = this[01;31m-[00m>_Value.substr(this[01;31m-[00m>_Value.size()[01;31m-[00mnum,num);
values.cc:116:	size_t res = this[01;31m-[00m>_Value.find(substring,start);
values.cc:117:	if ( res != string::npos ) return O_Int::create(res,this[01;31m-[00m>lisp());
values.cc:118:	return O_Int::nil(this[01;31m-[00m>lisp());
values.cc:123:    string res = this[01;31m-[00m>_Value.substr(start,num);
values.cc:130:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>intern(this[01;31m-[00m>_Value);
values.cc:136:    RPSymbol sym = this[01;31m-[00m>lisp()[01;31m-[00m>internKeyword(this[01;31m-[00m>_Value);
values.cc:145:    if ( obj[01;31m-[00m>isAssignableTo<O_Text>() )
values.cc:148:	return this[01;31m-[00m>_Value < t[01;31m-[00m>_Value;
values.cc:150:    return this[01;31m-[00m>Base::lt(obj);
values.cc:155:    if ( obj[01;31m-[00m>isAssignableTo<O_Text>() )
values.cc:158:	return this[01;31m-[00m>_Value <= t[01;31m-[00m>_Value;
values.cc:160:    return this[01;31m-[00m>Base::le(obj);
values.cc:165:    vector<string> parts = mbb::split(this[01;31m-[00m>_Value," \n\t");
values.cc:166:    RPCons first = O_Cons::create(O_Object::nil(this[01;31m-[00m>lisp()),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
values.cc:170:	RPCons one = O_Cons::create(this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(*it),O_Cons::nil(this[01;31m-[00m>lisp()),this[01;31m-[00m>lisp());
values.cc:171:	cur[01;31m-[00m>setCdr(one);
values.cc:174:    return first[01;31m-[00m>cdr();
values.cc:179:    vector<string> parts = mbb::split(this[01;31m-[00m>_Value,chars);
values.cc:180:    return O_Cons::createFromRangeObjectify< vector<string>::iterator, string >(parts.begin(),parts.end(),this[01;31m-[00m>lisp());
values.cc:185:    if ( obj[01;31m-[00m>isAssignableTo<O_Text>() )
values.cc:188:	return this[01;31m-[00m>_Value == t[01;31m-[00m>_Value;
values.cc:190:    return this[01;31m-[00m>Base::eql(obj);
values.cc:196:    if ( obj[01;31m-[00m>isAssignableTo<O_Text>() )
values.cc:199:	return this[01;31m-[00m>_Value > t[01;31m-[00m>_Value;
values.cc:201:    return this[01;31m-[00m>Base::gt(obj);
values.cc:206:    if ( obj[01;31m-[00m>isAssignableTo<O_Text>() )
values.cc:209:	return this[01;31m-[00m>_Value >= t[01;31m-[00m>_Value;
values.cc:211:    return this[01;31m-[00m>Base::ge(obj);
values.cc:224:It generates formatted output similar to the C[01;31m-[00mprintf function.
values.cc:230:    if ( args[01;31m-[00m>length()<1 )
values.cc:231:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide at least the format string"));
values.cc:232:    RPText fmt = args[01;31m-[00m>listref<O_Text>(0);
values.cc:236:	boost::format fmter(fmt[01;31m-[00m>get());
values.cc:238:	for( RPCons farg=args[01;31m-[00m>cdr(); farg[01;31m-[00m>notNil(); farg = farg[01;31m-[00m>cdr() )
values.cc:240:	    RPObject fobj = farg[01;31m-[00m>ocar();
values.cc:241:	    if ( fobj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:244:		fmter % fint[01;31m-[00m>get();
values.cc:245:	    } else if ( fobj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:248:		fmter % flli[01;31m-[00m>get();
values.cc:249:	    } else if ( fobj[01;31m-[00m>isOfClass<O_Text>() )
values.cc:252:		fmter % ftext[01;31m-[00m>get();
values.cc:253:	    } else if ( fobj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:256:		fmter % freal[01;31m-[00m>get();
values.cc:257:	    } else if ( fobj[01;31m-[00m>isOfClass<O_Bool>() )
values.cc:260:		fmter % fbool[01;31m-[00m>get();
values.cc:263:		fmter % fobj[01;31m-[00m>__str__();
values.cc:266:	result = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(fmter.str());
values.cc:269:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("format/% command error: bad format string" ));
values.cc:272:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("format/% command error: too few args" ));
values.cc:275:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("format/% command error: too many args" ));
values.cc:278:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("format/% command error: out of range" ));
values.cc:291:It generates formatted output similar to the C[01;31m-[00mprintf function.
values.cc:297:    if ( args[01;31m-[00m>length()!=2 )
values.cc:298:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You must provide the format string and arguments as a cons"));
values.cc:299:    RPString fmt = args[01;31m-[00m>listref<O_String>(0);
values.cc:300:    RPCons cargs = args[01;31m-[00m>listref<O_Cons>(1);
values.cc:304:	boost::format fmter(fmt[01;31m-[00m>get());
values.cc:306:	for( RPCons farg=cargs; farg[01;31m-[00m>notNil(); farg = farg[01;31m-[00m>cdr() )
values.cc:308:	    RPObject fobj = farg[01;31m-[00m>car<O_Value>();
values.cc:309:	    if ( fobj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:312:		fmter % fint[01;31m-[00m>get();
values.cc:313:	    } else if ( fobj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:316:		fmter % flli[01;31m-[00m>get();
values.cc:317:	    } else if ( fobj[01;31m-[00m>isOfClass<O_Text>() )
values.cc:320:		fmter % ftext[01;31m-[00m>get();
values.cc:321:	    } else if ( fobj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:324:		fmter % freal[01;31m-[00m>get();
values.cc:325:	    } else if ( fobj[01;31m-[00m>isOfClass<O_Bool>() )
values.cc:328:		fmter % fbool[01;31m-[00m>get();
values.cc:331:		fmter % fobj[01;31m-[00m>__str__();
values.cc:334:	result = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_String>(fmter.str());
values.cc:337:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("format/% command error: bad format string" ));
values.cc:340:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("format/% command error: too few args" ));
values.cc:343:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("format/% command error: too many args" ));
values.cc:346:        TOSS(_lisp[01;31m-[00m>create<O_LispError>("format/% command error: out of range" ));
values.cc:358:    v[01;31m-[00m>set(nm);
values.cc:366:    v[01;31m-[00m>set(nm);
values.cc:373:    node[01;31m-[00m>archiveString("block",this[01;31m-[00m>_Value);
values.cc:379:    node[01;31m-[00m>attribute("val",this[01;31m-[00m>_Value);
values.cc:384:    if ( this[01;31m-[00m>eqV(obj) ) return true;
values.cc:385:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:388:	return this[01;31m-[00m>get() == t[01;31m-[00m>get();
values.cc:395:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:398:	return this[01;31m-[00m>get() == t[01;31m-[00m>get();
values.cc:399:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:402:	return this[01;31m-[00m>get() == t[01;31m-[00m>get();
values.cc:404:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:411:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:414:	return this[01;31m-[00m>get() <  t[01;31m-[00m>get();
values.cc:415:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:418:	return this[01;31m-[00m>get() <  t[01;31m-[00m>get();
values.cc:420:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:421:    return this[01;31m-[00m>Base::lt(obj);
values.cc:426:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:429:	return this[01;31m-[00m>get() <= t[01;31m-[00m>get();
values.cc:430:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:433:	return this[01;31m-[00m>get() <= t[01;31m-[00m>get();
values.cc:435:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:436:    return this[01;31m-[00m>Base::le(obj);
values.cc:441:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:444:	return this[01;31m-[00m>get() >  t[01;31m-[00m>get();
values.cc:445:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:448:	return this[01;31m-[00m>get() >  t[01;31m-[00m>get();
values.cc:450:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:451:    return this[01;31m-[00m>Base::gt(obj);
values.cc:456:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:459:	return this[01;31m-[00m>get() >= t[01;31m-[00m>get();
values.cc:460:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:463:	return this[01;31m-[00m>get() >= t[01;31m-[00m>get();
values.cc:465:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:466:    return this[01;31m-[00m>Base::ge(obj);
values.cc:476:    node[01;31m-[00m>attribute("val",this[01;31m-[00m>_Value);
values.cc:493:{_F(this[01;31m-[00m>lisp());
values.cc:494:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:496:	return t_add<O_Int,int,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:497:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:499:	return t_add<O_Int,int,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:500:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:502:	return t_add<O_Int,int,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:504:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for add"));
values.cc:508:{_F(this[01;31m-[00m>lisp());
values.cc:509:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:511:	return t_add<O_LongLongInt,LongLongInt,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:512:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:514:	return t_add<O_LongLongInt,LongLongInt,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:515:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:517:	return t_add<O_LongLongInt,LongLongInt,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:519:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for add"));
values.cc:522:{_F(this[01;31m-[00m>lisp());
values.cc:523:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:525:	return t_add<O_Real,double,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:526:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:528:	return t_add<O_Real,double,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:529:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:531:	return t_add<O_Real,double,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:533:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for add"));
values.cc:545:{_F(this[01;31m-[00m>lisp());
values.cc:546:    if ( args[01;31m-[00m>cdr()[01;31m-[00m>isNil() )
values.cc:548:	return O_Int::create([01;31m-[00mthis[01;31m-[00m>_Value,_lisp);
values.cc:550:    RPNumber y = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Number>();
values.cc:551:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:553:	return t_sub<O_Int,int,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:554:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:556:	return t_sub<O_Int,int,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:557:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:559:	return t_sub<O_Int,int,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:561:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for sub"));
values.cc:566:{_F(this[01;31m-[00m>lisp());
values.cc:567:    if ( args[01;31m-[00m>cdr()[01;31m-[00m>isNil() )
values.cc:569:	return O_LongLongInt::create([01;31m-[00mthis[01;31m-[00m>_Value,_lisp);
values.cc:571:    RPNumber y = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Number>();
values.cc:572:    ASSERT(args[01;31m-[00m>cddr()[01;31m-[00m>isNil());
values.cc:573:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:575:	return t_sub<O_LongLongInt,LongLongInt,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:576:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:578:	return t_sub<O_LongLongInt,LongLongInt,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:579:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:581:	return t_sub<O_LongLongInt,LongLongInt,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:583:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for sub"));
values.cc:588:{_F(this[01;31m-[00m>lisp());
values.cc:589:    RPObject y = args[01;31m-[00m>ocadr();
values.cc:591:    if ( y[01;31m-[00m>isAssignableTo<O_Int>() )
values.cc:593:	res = this[01;31m-[00m>_Value % y[01;31m-[00m>as<O_Int>()[01;31m-[00m>get();
values.cc:594:    } else if ( y[01;31m-[00m>isAssignableTo<O_LongLongInt>() )
values.cc:596:	res = this[01;31m-[00m>_Value % y[01;31m-[00m>as<O_LongLongInt>()[01;31m-[00m>get();
values.cc:599:	TOSS(lisp[01;31m-[00m>error(BF("Illegal argument for mod class: %s") % y[01;31m-[00m>className() ));
values.cc:601:    return lisp[01;31m-[00m>create<O_LongLongInt>(res);
values.cc:606:{_F(this[01;31m-[00m>lisp());
values.cc:607:    if ( args[01;31m-[00m>cdr()[01;31m-[00m>isNil() )
values.cc:609:	return O_Real::create([01;31m-[00mthis[01;31m-[00m>_Value,_lisp);
values.cc:611:    RPNumber y = args[01;31m-[00m>ocadr()[01;31m-[00m>as<O_Number>();
values.cc:612:    ASSERT(args[01;31m-[00m>cddr()[01;31m-[00m>isNil());
values.cc:613:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:615:	return t_sub<O_Real,double,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:616:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:618:	return t_sub<O_Real,double,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:619:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:621:	return t_sub<O_Real,double,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:623:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for sub"));
values.cc:639:{_F(this[01;31m-[00m>lisp());
values.cc:640:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:642:	return t_mul<O_Int,int,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:643:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:645:	return t_mul<O_Int,int,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:646:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:648:	return t_mul<O_Int,int,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:650:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for mul"));
values.cc:654:{_F(this[01;31m-[00m>lisp());
values.cc:655:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:657:	return t_mul<O_LongLongInt,LongLongInt,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:658:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:660:	return t_mul<O_LongLongInt,LongLongInt,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:661:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:663:	return t_mul<O_LongLongInt,LongLongInt,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:665:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for mul"));
values.cc:668:{_F(this[01;31m-[00m>lisp());
values.cc:669:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:671:	return t_mul<O_Real,double,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:672:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:674:	return t_mul<O_Real,double,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:675:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:677:	return t_mul<O_Real,double,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:679:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for mul"));
values.cc:695:{_F(this[01;31m-[00m>lisp());
values.cc:696:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:698:	return t_div<O_Int,int,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:699:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:701:	return t_div<O_Int,int,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:702:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:704:	return t_div<O_Int,int,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:706:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for div"));
values.cc:710:{_F(this[01;31m-[00m>lisp());
values.cc:711:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:713:	return t_div<O_LongLongInt,LongLongInt,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:714:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:716:	return t_div<O_LongLongInt,LongLongInt,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:717:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:719:	return t_div<O_LongLongInt,LongLongInt,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:721:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for div"));
values.cc:724:{_F(this[01;31m-[00m>lisp());
values.cc:725:    if ( y[01;31m-[00m>isOfClass<O_Int>() )
values.cc:728:	return t_div<O_Real,double,O_Int,int>(this[01;31m-[00m>_Value,y);
values.cc:729:    } else if ( y[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:732:	return t_div<O_Real,double,O_LongLongInt,LongLongInt>(this[01;31m-[00m>_Value,y);
values.cc:733:    } else if ( y[01;31m-[00m>isOfClass<O_Real>() )
values.cc:736:	return t_div<O_Real,double,O_Real,double>(this[01;31m-[00m>_Value,y);
values.cc:738:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Illegal arguments for div"));
values.cc:751:{_F(this[01;31m-[00m>lisp());
values.cc:752:    if ( this[01;31m-[00m>eqV(obj) ) return true;
values.cc:753:    if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:756:	return this[01;31m-[00m>get() == t[01;31m-[00m>get();
values.cc:762:{_F(this[01;31m-[00m>lisp());
values.cc:763:    if ( this[01;31m-[00m>eqV(obj) ) return true;
values.cc:764:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:767:	return this[01;31m-[00m>get() == t[01;31m-[00m>get();
values.cc:768:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:771:	bool b = (this[01;31m-[00m>get() == t[01;31m-[00m>get());
values.cc:772:	LOG(BF("Compared if %d == %d [01;31m-[00m> %d") % this[01;31m-[00m>get() % t[01;31m-[00m>get() % b  ); // vp0(("Compared if %d == %d [01;31m-[00m> %d", this[01;31m-[00m>get(), t[01;31m-[00m>get(), b ));
values.cc:774:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:777:	bool b = (this[01;31m-[00m>get() == t[01;31m-[00m>get());
values.cc:778:	LOG(BF("Compared if %d == %d [01;31m-[00m> %d") % this[01;31m-[00m>get() % t[01;31m-[00m>get() % b  ); // vp0(("Compared if %d == %d [01;31m-[00m> %d", this[01;31m-[00m>get(), t[01;31m-[00m>get(), b ));
values.cc:781:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:788:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:791:	return this[01;31m-[00m>get() <  t[01;31m-[00m>get();
values.cc:792:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:795:	return this[01;31m-[00m>get() <  t[01;31m-[00m>get();
values.cc:796:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:799:	return this[01;31m-[00m>get() < t[01;31m-[00m>get();
values.cc:801:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:802:    return this[01;31m-[00m>Base::lt(obj);
values.cc:807:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:810:	return this[01;31m-[00m>get() <= t[01;31m-[00m>get();
values.cc:811:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:814:	return this[01;31m-[00m>get() <= t[01;31m-[00m>get();
values.cc:815:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:818:	return this[01;31m-[00m>get() <= t[01;31m-[00m>get();
values.cc:820:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:821:    return this[01;31m-[00m>Base::le(obj);
values.cc:826:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:829:	return this[01;31m-[00m>get() >  t[01;31m-[00m>get();
values.cc:830:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:833:	return this[01;31m-[00m>get() >  t[01;31m-[00m>get();
values.cc:834:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:837:	return this[01;31m-[00m>get() > t[01;31m-[00m>get();
values.cc:839:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:840:    return this[01;31m-[00m>Base::gt(obj);
values.cc:845:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:848:	return this[01;31m-[00m>get() >= t[01;31m-[00m>get();
values.cc:849:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:852:	return this[01;31m-[00m>get() >= t[01;31m-[00m>get();
values.cc:853:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:856:	return this[01;31m-[00m>get() >= t[01;31m-[00m>get();
values.cc:858:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:859:    return this[01;31m-[00m>Base::ge(obj);
values.cc:868:    ss >> this[01;31m-[00m>_Value;
values.cc:875:    node[01;31m-[00m>attribute("val",this[01;31m-[00m>_Value);
values.cc:879:{_F(this[01;31m-[00m>lisp());
values.cc:880:    if ( this[01;31m-[00m>eqV(obj) ) return true;
values.cc:881:    if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:883:	RPLongLongInt t = obj[01;31m-[00m>as<O_LongLongInt>();
values.cc:884:	return this[01;31m-[00m>get() == t[01;31m-[00m>get();
values.cc:890:{_F(this[01;31m-[00m>lisp());
values.cc:891:    if ( this[01;31m-[00m>eqV(obj) ) return true;
values.cc:892:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:895:	return this[01;31m-[00m>get() == t[01;31m-[00m>get();
values.cc:896:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:899:	bool b = (this[01;31m-[00m>get() == t[01;31m-[00m>get());
values.cc:900:	LOG(BF("Compared if %d == %d [01;31m-[00m> %d") % this[01;31m-[00m>get() % t[01;31m-[00m>get() % b  ); // vp0(("Compared if %d == %d [01;31m-[00m> %d", this[01;31m-[00m>get(), t[01;31m-[00m>get(), b ));
values.cc:903:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:910:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:913:	return this[01;31m-[00m>get() <  t[01;31m-[00m>get();
values.cc:914:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:917:	return this[01;31m-[00m>get() <  t[01;31m-[00m>get();
values.cc:918:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:921:	return this[01;31m-[00m>get() <  t[01;31m-[00m>get();
values.cc:923:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:924:    return this[01;31m-[00m>Base::lt(obj);
values.cc:929:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:932:	return this[01;31m-[00m>get() <= t[01;31m-[00m>get();
values.cc:933:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:936:	return this[01;31m-[00m>get() <= t[01;31m-[00m>get();
values.cc:937:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:940:	return this[01;31m-[00m>get() <= t[01;31m-[00m>get();
values.cc:942:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:943:    return this[01;31m-[00m>Base::le(obj);
values.cc:948:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:951:	return this[01;31m-[00m>get() >  t[01;31m-[00m>get();
values.cc:952:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:955:	return this[01;31m-[00m>get() >  t[01;31m-[00m>get();
values.cc:956:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:959:	return this[01;31m-[00m>get() >  t[01;31m-[00m>get();
values.cc:961:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:962:    return this[01;31m-[00m>Base::gt(obj);
values.cc:967:    if ( obj[01;31m-[00m>isOfClass<O_Real>() )
values.cc:970:	return this[01;31m-[00m>get() >= t[01;31m-[00m>get();
values.cc:971:    } else if ( obj[01;31m-[00m>isOfClass<O_LongLongInt>() )
values.cc:974:	return this[01;31m-[00m>get() >= t[01;31m-[00m>get();
values.cc:975:    } else if ( obj[01;31m-[00m>isOfClass<O_Int>() )
values.cc:978:	return this[01;31m-[00m>get() >= t[01;31m-[00m>get();
values.cc:980:    ASSERT(!obj[01;31m-[00m>isOfClass<O_Number>());
values.cc:981:    return this[01;31m-[00m>Base::ge(obj);
values.cc:990:    node[01;31m-[00m>attribute("val",this[01;31m-[00m>_Value);
values.cc:996:    if ( obj[01;31m-[00m>isOfClass<O_Bool>() )
values.cc:999:	return this[01;31m-[00m>get() == t[01;31m-[00m>get();
values.cc:1001:    if ( this[01;31m-[00m>get() )
values.cc:1003:	if ( ! obj[01;31m-[00m>isNil() ) return true;
values.cc:1007:	if ( obj[01;31m-[00m>isNil() ) return true;
values.cc:1010:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Should never get here"));
values.cc:1015:    return this[01;31m-[00m>eql(o);
values.cc:1024:        class_<O_Value>(this[01;31m-[00m>lisp())
values.cc:1040:        mbb::class_<O_LongLongInt>(this[01;31m-[00m>lisp())
values.cc:1067:        mbb::class_<O_Int>(this[01;31m-[00m>lisp())
values.cc:1095:        class_<O_Text>(this[01;31m-[00m>lisp())
values.cc:1138:        mbb::class_<O_String>(this[01;31m-[00m>lisp())
values.cc:1155:    mbb::class_<O_TextBlock>(this[01;31m-[00m>lisp())
values.cc:1173:    class_<O_Real>(this[01;31m-[00m>lisp())
values.cc:1199:    class_<O_Number>(this[01;31m-[00m>lisp())
values.cc:1204:	.defNoWrap("[01;31m-[00m",&O_Number::sub)
values.cc:1231:    class_<O_Bool>(this[01;31m-[00m>lisp())
vdwCollisionRejector.cc:51:    return b[01;31m-[00m>getScoreTransformedAtomPosition(this[01;31m-[00m>_BuilderAtomIndex,ss);
vdwCollisionRejector.cc:56:    this[01;31m-[00m>_Atom = O_Atom::nil(env);
vdwCollisionRejector.cc:65:    this[01;31m-[00m>Base::initialize();
vdwCollisionRejector.cc:66:    this[01;31m-[00m>_OligomerChangeCounter = UndefinedUnsignedInt;
vdwCollisionRejector.cc:67:    this[01;31m-[00m>_SequenceChangeCounter = UndefinedUnsignedInt;
vdwCollisionRejector.cc:68:    this[01;31m-[00m>_TemporaryBuiltMolecule = O_Molecule::nil(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:69:    this[01;31m-[00m>_FixedMatter = O_Matter::nil(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:70:    this[01;31m-[00m>_LockFixedMatter = false;
vdwCollisionRejector.cc:71:    this[01;31m-[00m>_MaxCollisions = 0;
vdwCollisionRejector.cc:72:    this[01;31m-[00m>_RadiiScale = DEFAULT_RADIUS_SCALE;
vdwCollisionRejector.cc:79:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:80:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
vdwCollisionRejector.cc:81:    this[01;31m-[00m>_RadiiScale = kargs[01;31m-[00m>getDoubleAndRemoveOrDefault("radiiScale",DEFAULT_RADIUS_SCALE);
vdwCollisionRejector.cc:82:    this[01;31m-[00m>_MaxCollisions = kargs[01;31m-[00m>getIntAndRemoveOrDefault("maxCollisions",0);
vdwCollisionRejector.cc:83:    RPMatter agg = kargs[01;31m-[00m>getAndRemoveOrDefault("fixedMatter",O_Matter::nil(this[01;31m-[00m>lisp()))[01;31m-[00m>as<O_Matter>();
vdwCollisionRejector.cc:84:    this[01;31m-[00m>setFixedMatter(agg);
vdwCollisionRejector.cc:90:    this[01;31m-[00m>Base::archiveBase(node);
vdwCollisionRejector.cc:91:    node[01;31m-[00m>attribute("lockFixedMatter",this[01;31m-[00m>_LockFixedMatter);
vdwCollisionRejector.cc:92:    node[01;31m-[00m>attribute("RadiiScale",this[01;31m-[00m>_RadiiScale);
vdwCollisionRejector.cc:93://    node[01;31m-[00m>archiveObject("builtMolecule",this[01;31m-[00m>_BuiltMolecule);
vdwCollisionRejector.cc:94:    node[01;31m-[00m>archiveObject("fixedMatter",this[01;31m-[00m>_FixedMatter);
vdwCollisionRejector.cc:95:    node[01;31m-[00m>needsFinalization();
vdwCollisionRejector.cc:101:    this[01;31m-[00m>setFixedMatter(this[01;31m-[00m>_FixedMatter);
vdwCollisionRejector.cc:108:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:109:    this[01;31m-[00m>_OligomerChangeCounter = builder[01;31m-[00m>getOligomerChangeCounter();
vdwCollisionRejector.cc:113:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:114:    ASSERTP(aliasRef[01;31m-[00m>isOfClass<O_Builder>(),"Must pass Builder");
vdwCollisionRejector.cc:115:    RPBuilder builder = aliasRef[01;31m-[00m>as<O_Builder>();
vdwCollisionRejector.cc:116:    ASSERT(this[01;31m-[00m>_OligomerChangeCounter == builder[01;31m-[00m>getOligomerChangeCounter());
vdwCollisionRejector.cc:120:    if ( this[01;31m-[00m>_SequenceChangeCounter == builder[01;31m-[00m>getSequenceChangeCounter() ) return;
vdwCollisionRejector.cc:121:    this[01;31m-[00m>_SequenceChangeCounter = builder[01;31m-[00m>getSequenceChangeCounter();
vdwCollisionRejector.cc:122:    if ( ! builder[01;31m-[00m>buildsAllAtoms() )
vdwCollisionRejector.cc:134:	TOSS(_lisp[01;31m-[00m>create<O_LispError>("You have are scoring a Builder with a VdwCollisionRejector that requires all atoms to be built but the Builder doesn't build all atoms [01;31m-[00m Tell the builder to create all atoms"));
vdwCollisionRejector.cc:137:        this[01;31m-[00m>setBuiltMolecule(builder[01;31m-[00m>getBuiltMolecule());
vdwCollisionRejector.cc:143:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:144:    if ( !this[01;31m-[00m>_LockFixedMatter )
vdwCollisionRejector.cc:146:        this[01;31m-[00m>_LockFixedMatter = true;
vdwCollisionRejector.cc:148:    this[01;31m-[00m>_defineBondedBuiltAtoms(molecule);
vdwCollisionRejector.cc:149:    this[01;31m-[00m>updateBuiltVdwPairs();
vdwCollisionRejector.cc:154:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:155:    this[01;31m-[00m>_FixedMatter = agg;
vdwCollisionRejector.cc:157:    this[01;31m-[00m>_FixedAtoms.clear();
vdwCollisionRejector.cc:158:    if ( agg[01;31m-[00m>isNil() ) return;
vdwCollisionRejector.cc:164:	    if ( a[01;31m-[00m>isAssignableTo<O_VirtualAtom>() ) continue; // skip virtuals
vdwCollisionRejector.cc:165:	    FixedAtomVdwEntry atomEntry(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:167:	    atomEntry.setRadius(vdwRadiusForElement(a[01;31m-[00m>getElement()));
vdwCollisionRejector.cc:168:	    atomEntry._Position = a[01;31m-[00m>getPosition();
vdwCollisionRejector.cc:169:	    this[01;31m-[00m>_FixedAtoms.push_back(atomEntry);
vdwCollisionRejector.cc:176:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:179:    if ( matter[01;31m-[00m>isNil() ) return;
vdwCollisionRejector.cc:180:    this[01;31m-[00m>_BuiltAtoms.clear();
vdwCollisionRejector.cc:186:	    if ( a[01;31m-[00m>isAssignableTo<O_VirtualAtom>() ) continue; // skip virtuals
vdwCollisionRejector.cc:187:	    BuiltAtomVdwEntry atomEntry(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:189:	    atomEntry.setRadius(vdwRadiusForElement(a[01;31m-[00m>getElement()));
vdwCollisionRejector.cc:193:	    	atomEntry.setBuilderIndex(a[01;31m-[00m>getAtomHolderIndex());
vdwCollisionRejector.cc:194:		idx = this[01;31m-[00m>_BuiltAtoms.size();
vdwCollisionRejector.cc:195:		this[01;31m-[00m>_BuiltAtoms.push_back(atomEntry);
vdwCollisionRejector.cc:198:            LOG(BF("Adding atom %s with idx=%u") % a[01;31m-[00m>__repr__().c_str() % idx  ); // vp0(("Adding atom %s with idx=%u", a[01;31m-[00m>__repr__().c_str(), idx ));
vdwCollisionRejector.cc:209:	    this[01;31m-[00m>_BuiltAtoms[ea1[01;31m-[00m>second]._CloserThan15.insert(a2);
vdwCollisionRejector.cc:210:	    this[01;31m-[00m>_BuiltAtoms[ea2[01;31m-[00m>second]._CloserThan15.insert(a1);
vdwCollisionRejector.cc:222:	    this[01;31m-[00m>_BuiltAtoms[ea1[01;31m-[00m>second]._CloserThan15.insert(a3);
vdwCollisionRejector.cc:223:	    this[01;31m-[00m>_BuiltAtoms[ea3[01;31m-[00m>second]._CloserThan15.insert(a1);
vdwCollisionRejector.cc:236:	    this[01;31m-[00m>_BuiltAtoms[ea1[01;31m-[00m>second]._CloserThan15.insert(a4);
vdwCollisionRejector.cc:237:	    this[01;31m-[00m>_BuiltAtoms[ea4[01;31m-[00m>second]._CloserThan15.insert(a1);
vdwCollisionRejector.cc:246:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:249:LOG(BF("this[01;31m-[00m>_BuiltAtoms.size() = %u") % this[01;31m-[00m>_BuiltAtoms.size() ); // vp0(("this[01;31m-[00m>_BuiltAtoms.size() = %u", this[01;31m-[00m>_BuiltAtoms.size()));
vdwCollisionRejector.cc:251:for ( uint zii=0; zii != this[01;31m-[00m>_BuiltAtoms.size(); zii++ )
vdwCollisionRejector.cc:253:    LOG(BF("Built atom(%5s) idx(%4u)") % this[01;31m-[00m>_BuiltAtoms[zii].getAtom()[01;31m-[00m>__repr__().c_str() % zii  ); // vp0(("Built atom(%5s) idx(%4u)", this[01;31m-[00m>_BuiltAtoms[zii].getAtom()[01;31m-[00m>__repr__().c_str(), zii ));
vdwCollisionRejector.cc:256:    this[01;31m-[00m>_BuiltVdwPairs.clear();
vdwCollisionRejector.cc:260:	for ( iea1 = 0; iea1<this[01;31m-[00m>_BuiltAtoms.size(); iea1++ )
vdwCollisionRejector.cc:262:	    for ( iea2 = iea1+1; iea2<this[01;31m-[00m>_BuiltAtoms.size(); iea2++ )
vdwCollisionRejector.cc:264:		if ( !this[01;31m-[00m>_BuiltAtoms[iea1].closerThan15().count(this[01;31m-[00m>_BuiltAtoms[iea2].getAtom()) ) 
vdwCollisionRejector.cc:267:		    LOG(BF("Nonbond term between atom(%s)idx(%u) and atom(%s)idx(%u)") % this[01;31m-[00m>_BuiltAtoms[iea1].getAtom()[01;31m-[00m>__repr__().c_str() % iea1 % this[01;31m-[00m>_BuiltAtoms[iea2].getAtom()[01;31m-[00m>__repr__().c_str() % iea2  ); // vp0(( "Nonbond term between atom(%s)idx(%u) and atom(%s)idx(%u)", this[01;31m-[00m>_BuiltAtoms[iea1].getAtom()[01;31m-[00m>__repr__().c_str(), iea1, this[01;31m-[00m>_BuiltAtoms[iea2].getAtom()[01;31m-[00m>__repr__().c_str(), iea2 ));
vdwCollisionRejector.cc:272:		    RPAtom atom1 = this[01;31m-[00m>_BuiltAtoms[iea1].getAtom();
vdwCollisionRejector.cc:273:		    RPAtom atom2 = this[01;31m-[00m>_BuiltAtoms[iea2].getAtom();
vdwCollisionRejector.cc:274:		    Element element1 = atom1[01;31m-[00m>getElement();
vdwCollisionRejector.cc:275:		    Element element2 = atom2[01;31m-[00m>getElement();
vdwCollisionRejector.cc:278:		    pair._RadiusSumSquaredScaled = (radius1+radius2)*(radius1+radius2)*this[01;31m-[00m>_RadiiScale*this[01;31m-[00m>_RadiiScale;
vdwCollisionRejector.cc:279:		    this[01;31m-[00m>_BuiltVdwPairs.push_back(pair);
vdwCollisionRejector.cc:290:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:291:    RPBuilder builder = aliasRef[01;31m-[00m>as<O_Builder>();
vdwCollisionRejector.cc:292:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
vdwCollisionRejector.cc:293:    					this[01;31m-[00m>sharedThis<O_VdwCollisionRejector>());
vdwCollisionRejector.cc:294:    return this[01;31m-[00m>countVdwCollisions(builder,scorerState) > this[01;31m-[00m>_MaxCollisions;
vdwCollisionRejector.cc:301:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:302:    ASSERTP(aliasRef[01;31m-[00m>isOfClass<O_Builder>(),"You must provide a builder");
vdwCollisionRejector.cc:303:    RPBuilder builder = aliasRef[01;31m-[00m>as<O_Builder>();
vdwCollisionRejector.cc:304:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
vdwCollisionRejector.cc:305:    					this[01;31m-[00m>sharedThis<O_VdwCollisionRejector>());
vdwCollisionRejector.cc:306:    return this[01;31m-[00m>countVdwCollisions(builder,scorerState);
vdwCollisionRejector.cc:311:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:312:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
vdwCollisionRejector.cc:313:    					this[01;31m-[00m>sharedThis<O_VdwCollisionRejector>());
vdwCollisionRejector.cc:321:    isize = this[01;31m-[00m>_BuiltVdwPairs.size();
vdwCollisionRejector.cc:322:    LOG_SCORE(scorerState,BF("O_VdwCollisionRejector [01;31m-[00m[01;31m-[00m _BuiltVdwPairs.size() = %d")% this[01;31m-[00m>_BuiltVdwPairs.size() );
vdwCollisionRejector.cc:329:	    BuiltVdwPair& it = this[01;31m-[00m>_BuiltVdwPairs[itidx];
vdwCollisionRejector.cc:330:	    Vector3 v1 = this[01;31m-[00m>_BuiltAtoms[it._BuiltAtom1Index].builtPosition(builder,scorerState);
vdwCollisionRejector.cc:331:	    Vector3 v2 = this[01;31m-[00m>_BuiltAtoms[it._BuiltAtom2Index].builtPosition(builder,scorerState);
vdwCollisionRejector.cc:333:	    float dX = v1.getX()[01;31m-[00mv2.getX();
vdwCollisionRejector.cc:334:	    float dY = v1.getY()[01;31m-[00mv2.getY();
vdwCollisionRejector.cc:335:	    float dZ = v1.getZ()[01;31m-[00mv2.getZ();
vdwCollisionRejector.cc:353:			BF(" [01;31m-[00mno[01;31m-[00m   Vdw collision between built atoms(%d @ %lf,%lf,%lf) and (%d @ %lf,%lf,%lf) distSquared(%lf) limitSquared(%lf)")
vdwCollisionRejector.cc:373:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:374:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
vdwCollisionRejector.cc:375:    					this[01;31m-[00m>sharedThis<O_VdwCollisionRejector>());
vdwCollisionRejector.cc:378:    double radiiScaleSquared = this[01;31m-[00m>_RadiiScale*this[01;31m-[00m>_RadiiScale;
vdwCollisionRejector.cc:379:    LOG_SCORE(scorerState,BF("O_VdwCollisionRejector [01;31m-[00m[01;31m-[00m radiiScaleSquared = %lf")% radiiScaleSquared );
vdwCollisionRejector.cc:385:    isize = this[01;31m-[00m>_BuiltVdwPairs.size();
vdwCollisionRejector.cc:386:    LOG_SCORE(scorerState,BF("O_VdwCollisionRejector [01;31m-[00m[01;31m-[00m _BuiltVdwPairs.size() = %d")% this[01;31m-[00m>_BuiltVdwPairs.size() );
vdwCollisionRejector.cc:391:    LOG_SCORE(scorerState,BF("There are %d _FixedAtoms")% this[01;31m-[00m>_FixedAtoms.size() );
vdwCollisionRejector.cc:392:    LOG_SCORE(scorerState,BF("There are %d _BuiltAtoms")% this[01;31m-[00m>_BuiltAtoms.size() );
vdwCollisionRejector.cc:394:    for ( fi=this[01;31m-[00m>_FixedAtoms.begin(); fi!=this[01;31m-[00m>_FixedAtoms.end(); fi++ )
vdwCollisionRejector.cc:396:	Vector3& vf = fi[01;31m-[00m>_Position;
vdwCollisionRejector.cc:397:	double rf = fi[01;31m-[00m>getRadius();
vdwCollisionRejector.cc:399:	bsize = this[01;31m-[00m>_BuiltAtoms.size();
vdwCollisionRejector.cc:405:		BuiltAtomVdwEntry& bi = this[01;31m-[00m>_BuiltAtoms[bidx];
vdwCollisionRejector.cc:420:				% (fi[01;31m-[00mthis[01;31m-[00m>_FixedAtoms.begin())
vdwCollisionRejector.cc:430:		    		BF( " [01;31m-[00mno[01;31m-[00m Vdw collision between moveable atom#%d  pos(%s) radius(%lf) and fixed atom#%d pos(%s) radius(%lf) distSquared(%lf) limitSquared(%lf)")
vdwCollisionRejector.cc:434:				% (fi[01;31m-[00mthis[01;31m-[00m>_FixedAtoms.begin())
vdwCollisionRejector.cc:452:    uint countbb = this[01;31m-[00m>countIntraMolecularVdwCollisions(builder,scorerState);
vdwCollisionRejector.cc:453:    uint countbf = this[01;31m-[00m>countInterMolecularVdwCollisions(builder,scorerState);
vdwCollisionRejector.cc:463:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:464:    LOG(BF("Evaluating VdwCollisionRejector for builder in state %s")% builder[01;31m-[00m>stateIdentifier() );
vdwCollisionRejector.cc:465:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
vdwCollisionRejector.cc:466:    					this[01;31m-[00m>sharedThis<O_VdwCollisionRejector>());
vdwCollisionRejector.cc:467:    return this[01;31m-[00m>countVdwCollisions(builder,scorerState)>this[01;31m-[00m>_MaxCollisions;
vdwCollisionRejector.cc:473:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:474:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
vdwCollisionRejector.cc:475:    					this[01;31m-[00m>sharedThis<O_VdwCollisionRejector>());
vdwCollisionRejector.cc:477:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:478:    dl[01;31m-[00m>setName("vdwCollisions");
vdwCollisionRejector.cc:480:    double radiiScaleSquared = this[01;31m-[00m>_RadiiScale*this[01;31m-[00m>_RadiiScale;
vdwCollisionRejector.cc:486:    for ( it=this[01;31m-[00m>_BuiltVdwPairs.begin(); it!=this[01;31m-[00m>_BuiltVdwPairs.end(); it++ )
vdwCollisionRejector.cc:488:	Vector3 v1 = this[01;31m-[00m>_BuiltAtoms[it[01;31m-[00m>_BuiltAtom1Index].builtPosition(builder,scorerState);
vdwCollisionRejector.cc:489:	Vector3 v2 = this[01;31m-[00m>_BuiltAtoms[it[01;31m-[00m>_BuiltAtom2Index].builtPosition(builder,scorerState);
vdwCollisionRejector.cc:492:	double limitSquared = it[01;31m-[00m>_RadiusSumSquaredScaled;
vdwCollisionRejector.cc:500:	        renderDistanceDeviation(dl,v1,v2,sqrt(it[01;31m-[00m>_RadiusSumSquaredScaled),
vdwCollisionRejector.cc:501:		    		this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>(RGB_chartreuse));
vdwCollisionRejector.cc:504:			% it[01;31m-[00m>_BuiltAtom1Index
vdwCollisionRejector.cc:506:			% it[01;31m-[00m>_BuiltAtom2Index
vdwCollisionRejector.cc:519:{_F(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:520:    builder[01;31m-[00m>throwIfSequenceChangeCounterOutOfSync(this[01;31m-[00m>_SequenceChangeCounter,
vdwCollisionRejector.cc:521:    					this[01;31m-[00m>sharedThis<O_VdwCollisionRejector>());
vdwCollisionRejector.cc:523:    RPRenderDisplayList dl = O_RenderDisplayList::create(this[01;31m-[00m>lisp());
vdwCollisionRejector.cc:524:    dl[01;31m-[00m>setName("vdwCollisions");
vdwCollisionRejector.cc:526:    double radiiScaleSquared = this[01;31m-[00m>_RadiiScale*this[01;31m-[00m>_RadiiScale;
vdwCollisionRejector.cc:535:    for ( fi=this[01;31m-[00m>_FixedAtoms.begin(); fi!=this[01;31m-[00m>_FixedAtoms.end(); fi++ )
vdwCollisionRejector.cc:537:	Vector3& vf = fi[01;31m-[00m>_Position;
vdwCollisionRejector.cc:538:	double rf = fi[01;31m-[00m>getRadius();
vdwCollisionRejector.cc:539:	for ( bi=this[01;31m-[00m>_BuiltAtoms.begin(); bi!=this[01;31m-[00m>_BuiltAtoms.end(); bi++ )
vdwCollisionRejector.cc:541:	    Vector3 vb = bi[01;31m-[00m>builtPosition(builder,scorerState);
vdwCollisionRejector.cc:542:	    double rb = bi[01;31m-[00m>getRadius();
vdwCollisionRejector.cc:555:		    		this[01;31m-[00m>lisp()[01;31m-[00m>create<O_GrColor>(RGB_chartreuse));
vdwCollisionRejector.cc:558:			    % (bi[01;31m-[00mthis[01;31m-[00m>_BuiltAtoms.begin())
vdwCollisionRejector.cc:560:			    % (fi[01;31m-[00mthis[01;31m-[00m>_FixedAtoms.begin())
vdwCollisionRejector.cc:576:    class_<O_VdwCollisionRejector>(this[01;31m-[00m>lisp())
vector2.cc:53:    this[01;31m-[00m>coords[0] = 0.0;
vector2.cc:54:    this[01;31m-[00m>coords[1] = 0.0;
vector2.cc:68:    this[01;31m-[00m>coords[0] = x;
vector2.cc:69:    this[01;31m-[00m>coords[1] = y;
vector2.cc:75:    return this[01;31m-[00m>coords[i];
vector2.cc:81:{_F(node[01;31m-[00m>lisp());
vector2.cc:82:    node[01;31m-[00m>attribute("x",this[01;31m-[00m>coords[0]);
vector2.cc:83:    node[01;31m-[00m>attribute("y",this[01;31m-[00m>coords[1]);
vector2.cc:84:    LOG(BF("Serialized vector@%X = %lf, %lf") % this % this[01;31m-[00m>coords[0] % this[01;31m-[00m>coords[1]  ); // vp0(( "Serialized vector@%X = %lf, %lf", this,  this[01;31m-[00m>coords[0], this[01;31m-[00m>coords[1] ));
vector2.cc:91:    cout << this[01;31m-[00m>asString() << endl;
vector2.cc:103:    l = this[01;31m-[00m>length();
vector2.cc:105:	v.coords[0] = this[01;31m-[00m>coords[0]/l;
vector2.cc:106:	v.coords[1] = this[01;31m-[00m>coords[1]/l;
vector2.cc:115:    return(this[01;31m-[00m>getX()*v.getX() +this[01;31m-[00m>getY()*v.getY() );
vector2.cc:121:    return(sqrt(this[01;31m-[00m>getX()*this[01;31m-[00m>getX()+this[01;31m-[00m>getY()*this[01;31m-[00m>getY() ));
vector2.cc:130:    ss << "(" << this[01;31m-[00m>getX()
vector2.cc:131:	<< "," <<this[01;31m-[00m>getY()
vector3.cc:28:    this[01;31m-[00m>coords[0] = 0.0;
vector3.cc:29:    this[01;31m-[00m>coords[1] = 0.0;
vector3.cc:30:    this[01;31m-[00m>coords[2] = 0.0;
vector3.cc:45:    this[01;31m-[00m>coords[0] = x;
vector3.cc:46:    this[01;31m-[00m>coords[1] = y;
vector3.cc:47:    this[01;31m-[00m>coords[2] = z;
vector3.cc:53:    lisp[01;31m-[00m>print(BF("<%lf,%lf,%lf>") % this[01;31m-[00m>coords[0] % this[01;31m-[00m>coords[1] % this[01;31m-[00m>coords[2] );
vector3.cc:59:	out << this[01;31m-[00m>coords[0] << "@";
vector3.cc:60:	out << this[01;31m-[00m>coords[1] << "@";
vector3.cc:61:	out << this[01;31m-[00m>coords[2] << ")";
vector3.cc:71:	x = this[01;31m-[00m>getY()*v.getZ()[01;31m-[00mthis[01;31m-[00m>getZ()*v.getY();
vector3.cc:72:	y = this[01;31m-[00m>getZ()*v.getX()[01;31m-[00mthis[01;31m-[00m>getX()*v.getZ();
vector3.cc:73:	z = this[01;31m-[00m>getX()*v.getY()[01;31m-[00mthis[01;31m-[00m>getY()*v.getX();
vector3.cc:82:    l = this[01;31m-[00m>length();
vector3.cc:84:	v.coords[0] = this[01;31m-[00m>coords[0]/l;
vector3.cc:85:	v.coords[1] = this[01;31m-[00m>coords[1]/l;
vector3.cc:86:	v.coords[2] = this[01;31m-[00m>coords[2]/l;
vector3.cc:89:    TOSS(_lisp[01;31m-[00m>create<O_MathException>("Attempted to normalize the vector (0,0,0)"));
vector3.cc:97:    l = this[01;31m-[00m>length();
vector3.cc:99:	v.coords[0] = this[01;31m-[00m>coords[0]/l;
vector3.cc:100:	v.coords[1] = this[01;31m-[00m>coords[1]/l;
vector3.cc:101:	v.coords[2] = this[01;31m-[00m>coords[2]/l;
vector3.cc:114:	return(this[01;31m-[00m>getX()*v.getX()
vector3.cc:115:		+this[01;31m-[00m>getY()*v.getY()
vector3.cc:116:		+this[01;31m-[00m>getZ()*v.getZ());
vector3.cc:122:	return(sqrt(this[01;31m-[00m>getX()*this[01;31m-[00m>getX()
vector3.cc:123:		+this[01;31m-[00m>getY()*this[01;31m-[00m>getY()
vector3.cc:124:		+this[01;31m-[00m>getZ()*this[01;31m-[00m>getZ()));
vector3.cc:134:    ss << "(" <<this[01;31m-[00m>getX()
vector3.cc:135:	<< "," <<this[01;31m-[00m>getY()
vector3.cc:136:	<< "," <<this[01;31m-[00m>getZ()
vector3.cc:153:    this[01;31m-[00m>set(x,y,z);
vector3.cc:170:    this[01;31m-[00m>set(x,y,z);
vector3.cc:182:    nd = O_QDomNode::create(this[01;31m-[00m>lisp(),nm);
vector3.cc:183:    nd[01;31m-[00m>addAttributeDoubleScientific("x",this[01;31m-[00m>getX());
vector3.cc:184:    nd[01;31m-[00m>addAttributeDoubleScientific("y",this[01;31m-[00m>getY());
vector3.cc:185:    nd[01;31m-[00m>addAttributeDoubleScientific("z",this[01;31m-[00m>getZ());
vector3.cc:192:    double x = node[01;31m-[00m>getAttributeDouble("x");
vector3.cc:193:    double y = node[01;31m-[00m>getAttributeDouble("y");
vector3.cc:194:    double z = node[01;31m-[00m>getAttributeDouble("z");
vector3.cc:195:    this[01;31m-[00m>set(x,y,z);
vector3.cc:205:    diff = this[01;31m-[00m>sub(v);
vector3.cc:217:	Vector3 men = this[01;31m-[00m>normalizedOrZero();
vector3.cc:223:	if ( fabs(cosTheta[01;31m-[00m1.0)<0.00001 )  return 0.0;
vector3.cc:230:	double theta = (dir>=0.0)?acos(cosTheta):(6.2831853[01;31m-[00macos(cosTheta));
vector3.cc:238:{_F(node[01;31m-[00m>lisp());
vector3.cc:239:    node[01;31m-[00m>attribute("x",this[01;31m-[00m>coords[0]);
vector3.cc:240:    node[01;31m-[00m>attribute("y",this[01;31m-[00m>coords[1]);
vector3.cc:241:    node[01;31m-[00m>attribute("z",this[01;31m-[00m>coords[2]);
vector3.cc:242:    LOG(BF("Serialized vector@%X = %lf, %lf, %lf") % this % this[01;31m-[00m>coords[0] % this[01;31m-[00m>coords[1] % this[01;31m-[00m>coords[2]  ); // vp0(( "Serialized vector@%X = %lf, %lf, %lf", this,  this[01;31m-[00m>coords[0], this[01;31m-[00m>coords[1], this[01;31m-[00m>coords[2] ));
vector3.cc:252:    Vector3 vc = va [01;31m-[00m vb;
vector3.cc:259:    Vector3 vc = va [01;31m-[00m vb;
vector3.cc:271:    Vector3	vab = (va[01;31m-[00mvb).normalized(lisp);
vector3.cc:272:    Vector3	vcb = (vc[01;31m-[00mvb).normalized(lisp);
vector3.cc:286:    Vector3 vab = (va [01;31m-[00m vb);
vector3.cc:287:    Vector3 vcb = (vc [01;31m-[00m vb);
vector3.cc:288:    Vector3 vdc = (vd [01;31m-[00m vc);
vector3.cc:297:    double sgn = (vCross.dotProduct(vcb))<0.0?[01;31m-[00m1.0:+1.0;
vector3.cc:298://    if ( enantiomer ) return [01;31m-[00mdih*sgn;
vector3.cc:323:    vd = va[01;31m-[00mvb;
vector3.cc:328:		[01;31m-[00mvdn.getX()*sin(angle)+vdn.getY()*cos(angle), 0.0);
vector3.cc:339:    Vector3 bcDir = vb[01;31m-[00mvc;
vector3.cc:346:    Vector3	abDir = va[01;31m-[00mvb;
vector3.cc:360:    dihedralRotation.rotationAxis([01;31m-[00mdihedral,&bcDirNorm);
vector4.cc:24:    this[01;31m-[00m>coords[0] = 0.0;
vector4.cc:25:    this[01;31m-[00m>coords[1] = 0.0;
vector4.cc:26:    this[01;31m-[00m>coords[2] = 0.0;
vector4.cc:27:    this[01;31m-[00m>coords[3] = 0.0;
vector4.cc:41:    this[01;31m-[00m>coords[0] = w;
vector4.cc:42:    this[01;31m-[00m>coords[1] = x;
vector4.cc:43:    this[01;31m-[00m>coords[2] = y;
vector4.cc:44:    this[01;31m-[00m>coords[3] = z;
vector4.cc:50:    _lisp[01;31m-[00m>print(BF("<%lf,%lf,%lf,%lf>")
vector4.cc:51:		% this[01;31m-[00m>coords[0]
vector4.cc:52:		% this[01;31m-[00m>coords[1]
vector4.cc:53:		% this[01;31m-[00m>coords[2]
vector4.cc:54:		% this[01;31m-[00m>coords[3] );
vector4.cc:61:    ss << "(" << this[01;31m-[00m>coords[0] << ",";
vector4.cc:62:    ss << this[01;31m-[00m>coords[1] << ",";
vector4.cc:63:    ss << this[01;31m-[00m>coords[2] << ",";
vector4.cc:64:    ss << this[01;31m-[00m>coords[3] << ")";
vector4.cc:71:	out << this[01;31m-[00m>coords[0] << "@";
vector4.cc:72:	out << this[01;31m-[00m>coords[1] << "@";
vector4.cc:73:	out << this[01;31m-[00m>coords[2] << "@";
vector4.cc:74:	out << this[01;31m-[00m>coords[3] << ")";
vector4.cc:86:    l = this[01;31m-[00m>length();
vector4.cc:88:	v.coords[0] = this[01;31m-[00m>coords[0]/l;
vector4.cc:89:	v.coords[1] = this[01;31m-[00m>coords[1]/l;
vector4.cc:90:	v.coords[2] = this[01;31m-[00m>coords[2]/l;
vector4.cc:91:	v.coords[3] = this[01;31m-[00m>coords[3]/l;
vector4.cc:94:    TOSS(_lisp[01;31m-[00m>create<O_LispError>("Attempted to normalize a zero vector"));
vector4.cc:100:	return(  this[01;31m-[00m>getW()*v.getW()
vector4.cc:101:		+this[01;31m-[00m>getX()*v.getX()
vector4.cc:102:		+this[01;31m-[00m>getY()*v.getY()
vector4.cc:103:		+this[01;31m-[00m>getZ()*v.getZ());
vector4.cc:110:		 this[01;31m-[00m>getW()*this[01;31m-[00m>getW()
vector4.cc:111:		+this[01;31m-[00m>getX()*this[01;31m-[00m>getX()
vector4.cc:112:		+this[01;31m-[00m>getY()*this[01;31m-[00m>getY()
vector4.cc:113:		+this[01;31m-[00m>getZ()*this[01;31m-[00m>getZ()));
vector4.cc:121:    dMax = [01;31m-[00m9999999.9;
vector4.cc:123:	if ( dMax < this[01;31m-[00m>coords[i] ) {
vector4.cc:124:	    dMax = this[01;31m-[00m>coords[i];
virtualAtom.cc:27:    va[01;31m-[00m>setName(name);
virtualAtom.cc:29:    va[01;31m-[00m>_CalculatePosition = proc;
virtualAtom.cc:40:    this[01;31m-[00m>_CalculatePosition = ss._CalculatePosition;
virtualAtom.cc:41://    this[01;31m-[00m>_Environment = ss._Environment;
virtualAtom.cc:51:{_TF(this[01;31m-[00m>lisp(),BF("%s")%this[01;31m-[00m>description());
virtualAtom.cc:55:    this[01;31m-[00m>copyAtom = aNew;
virtualAtom.cc:56:    LOG(BF("    copy atom== %s") % aNew[01;31m-[00m>description().c_str() ); // vp0(( "    copy atom== %s",aNew[01;31m-[00m>description().c_str()));
virtualAtom.cc:69:{ _TF(this[01;31m-[00m>lisp(),BF("%s")%this[01;31m-[00m>description());
virtualAtom.cc:70:    return this[01;31m-[00m>copy()[01;31m-[00m>as<O_Atom>();
virtualAtom.cc:76:    this[01;31m-[00m>Base::initialize();
virtualAtom.cc:77:    this[01;31m-[00m>_CalculatePosition = O_CalculatePosition::nil(this[01;31m-[00m>lisp());
virtualAtom.cc:82:    if ( this[01;31m-[00m>eqV(obj) ) return true;
virtualAtom.cc:83:    if ( !obj[01;31m-[00m>isOfClass<O_VirtualAtom>() )
virtualAtom.cc:85:	RPVirtualAtom other = obj[01;31m-[00m>as<O_VirtualAtom>();
virtualAtom.cc:86:	if ( other[01;31m-[00m>getName() != this[01;31m-[00m>getName() ) return false;
virtualAtom.cc:87:	if ( other[01;31m-[00m>numberOfBonds() != this[01;31m-[00m>numberOfBonds() ) return false;
virtualAtom.cc:98:    this[01;31m-[00m>Base::archive(node);
virtualAtom.cc:99:    node[01;31m-[00m>archiveObjectIfDefined("calculatePosition",this[01;31m-[00m>_CalculatePosition);
virtualAtom.cc:100://    node[01;31m-[00m>archiveObject("environment",this[01;31m-[00m>_Environment);
virtualAtom.cc:106:{_F(this[01;31m-[00m>lisp());
virtualAtom.cc:107:    ASSERT_NOT_NULL(this[01;31m-[00m>_CalculatePosition);
virtualAtom.cc:108://    ASSERT_NOT_NULL(this[01;31m-[00m>_Environment);
virtualAtom.cc:109:    WPMatter wmres = this[01;31m-[00m>containedBy();
virtualAtom.cc:112:    ASSERT(mres[01;31m-[00m>notNil());
virtualAtom.cc:113:    RPResidue res = mres[01;31m-[00m>as<O_Residue>();
virtualAtom.cc:114:    Vector3 vpos = this[01;31m-[00m>_CalculatePosition[01;31m-[00m>calculatePosition(res);
virtualAtom.cc:115:    this[01;31m-[00m>setPosition(vpos);
virtualAtom.cc:126:	class_<O_VirtualAtom>(this[01;31m-[00m>lisp())
virtualSphere.cc:65:	c[0] = a[1] * b[2] [01;31m-[00m a[2] * b[1];
virtualSphere.cc:66:	c[1] = a[2] * b[0] [01;31m-[00m a[0] * b[2];
virtualSphere.cc:67:	c[2] = a[0] * b[1] [01;31m-[00m a[1] * b[0];
virtualSphere.cc:88: *	Convert X[01;31m-[00mY coordinates into a 4x4 rotation matrix
virtualSphere.cc:107:		return [01;31m-[00m2;
virtualSphere.cc:109:		return [01;31m-[00m3;
virtualSphere.cc:113:		f[2] = sqrt(1 [01;31m-[00m d1);
virtualSphere.cc:124:		t[2] = sqrt(1 [01;31m-[00m d2);
virtualSphere.cc:138:		return [01;31m-[00m1;
virtualSphere.cc:148:	 * the from[01;31m-[00mvector to xyz[01;31m-[00mspace) and the transform matrix
virtualSphere.cc:149:	 * (to go from xyz[01;31m-[00mspace to to[01;31m-[00mvector).  The product of
virtualSphere.cc:179:    halfWidth = this[01;31m-[00m>windowWidth/2;
virtualSphere.cc:180:    halfHeight = this[01;31m-[00m>windowHeight/2;
virtualSphere.cc:182:    rx = (ax[01;31m-[00mhalfWidth)/radius;
virtualSphere.cc:183:    ry = (halfHeight [01;31m-[00m ay)/radius;
virtualSphere.cc:184://    rx = (halfWidth[01;31m-[00max)/radius;
virtualSphere.cc:185://    ry = (ay[01;31m-[00mhalfHeight)/radius;
virtualSphere.cc:197:    node[01;31m-[00m>attribute("windowHeight",this[01;31m-[00m>windowHeight);
virtualSphere.cc:198:    node[01;31m-[00m>attribute("windowWidth",this[01;31m-[00m>windowWidth);
virtualSphere.cc:199:    node[01;31m-[00m>attribute("startX",this[01;31m-[00m>startX);
virtualSphere.cc:200:    node[01;31m-[00m>attribute("startY",this[01;31m-[00m>startY);
virtualSphere.cc:201:    node[01;31m-[00m>attribute("mouseX",this[01;31m-[00m>mouseX);
virtualSphere.cc:202:    node[01;31m-[00m>attribute("mouseY",this[01;31m-[00m>mouseY);
virtualSphere.cc:203:    node[01;31m-[00m>attribute("mouseMode",this[01;31m-[00m>mouseMode);
virtualSphere.cc:204:    node[01;31m-[00m>attribute("recalculate",this[01;31m-[00m>recalculate);
virtualSphere.cc:205:    node[01;31m-[00m>attribute("scale",this[01;31m-[00m>scale);
virtualSphere.cc:206:    node[01;31m-[00m>archivePlainObject<Vector3>( "translate","Vector3",this[01;31m-[00m>translate);
virtualSphere.cc:207:    node[01;31m-[00m>archivePlainObject<Vector3>( "center","Vector3",this[01;31m-[00m>center);
virtualSphere.cc:208:    node[01;31m-[00m>archivePlainObject( "rotate","Matrix",this[01;31m-[00m>rotate);
virtualSphere.cc:209:    node[01;31m-[00m>archivePlainObject( "overall","Matrix",this[01;31m-[00m>overall);
virtualSphere.cc:215:    this[01;31m-[00m>Base::initialize();
virtualSphere.cc:216:    this[01;31m-[00m>mouseMode = VS_IDLE;
virtualSphere.cc:217:    this[01;31m-[00m>recalculate = true;
virtualSphere.cc:218:    this[01;31m-[00m>scale = 0.25;
virtualSphere.cc:219:    this[01;31m-[00m>translate.set(0.0,0.0,0.0);
virtualSphere.cc:220:    this[01;31m-[00m>center.set(0.0,0.0,0.0);
virtualSphere.cc:221:    this[01;31m-[00m>rotate.identity();
virtualSphere.cc:232:    this[01;31m-[00m>mouseX = x;
virtualSphere.cc:233:    this[01;31m-[00m>mouseY = y;
virtualSphere.cc:234:    switch ( this[01;31m-[00m>mouseMode ) {
virtualSphere.cc:236:	    this[01;31m-[00m>convertToRelative( this[01;31m-[00m>startX, this[01;31m-[00m>startY, sx,sy );
virtualSphere.cc:237:	    this[01;31m-[00m>convertToRelative( this[01;31m-[00m>mouseX, this[01;31m-[00m>mouseY, tx,ty );
virtualSphere.cc:241:	        this[01;31m-[00m>rotate = mtemp.multiplyByMatrix(this[01;31m-[00m>rotate);
virtualSphere.cc:242://	        this[01;31m-[00m>rotate = this[01;31m-[00m>rotate.multiplyByMatrix(mtemp);
virtualSphere.cc:244:	    this[01;31m-[00m>startX = this[01;31m-[00m>mouseX;
virtualSphere.cc:245:	    this[01;31m-[00m>startY = this[01;31m-[00m>mouseY;
virtualSphere.cc:246:	    this[01;31m-[00m>recalculate = true;
virtualSphere.cc:249:	    this[01;31m-[00m>convertToRelative( this[01;31m-[00m>startX, this[01;31m-[00m>startY, sx,sy );
virtualSphere.cc:250:	    this[01;31m-[00m>convertToRelative( this[01;31m-[00m>mouseX, this[01;31m-[00m>mouseY, tx,ty );
virtualSphere.cc:251:	    delta.set(tx[01;31m-[00msx,ty[01;31m-[00msy,0.0);
virtualSphere.cc:252:	    this[01;31m-[00m>translate = this[01;31m-[00m>translate.add(delta*10);
virtualSphere.cc:253://	    printf("translation delta = %f,%f,%f\n", tx[01;31m-[00msx,ty[01;31m-[00msy,0.0 );
virtualSphere.cc:255://				this[01;31m-[00m>translate.getX(),
virtualSphere.cc:256://				this[01;31m-[00m>translate.getY(),
virtualSphere.cc:257://				this[01;31m-[00m>translate.getZ() );
virtualSphere.cc:258:	    this[01;31m-[00m>startX = this[01;31m-[00m>mouseX;
virtualSphere.cc:259:	    this[01;31m-[00m>startY = this[01;31m-[00m>mouseY;
virtualSphere.cc:260:	    this[01;31m-[00m>recalculate = true;
virtualSphere.cc:263:	    this[01;31m-[00m>convertToRelative( this[01;31m-[00m>startX, this[01;31m-[00m>startY, sx,sy );
virtualSphere.cc:264:	    this[01;31m-[00m>convertToRelative( this[01;31m-[00m>mouseX, this[01;31m-[00m>mouseY, tx,ty );
virtualSphere.cc:265:	    scaleDelta = sy [01;31m-[00m ty;
virtualSphere.cc:271:	    this[01;31m-[00m>scale *= scaleDelta;
virtualSphere.cc:272://	    printf( "this[01;31m-[00m>scale = %f\n", this[01;31m-[00m>scale);
virtualSphere.cc:273:	    this[01;31m-[00m>scale = MAX(this[01;31m-[00m>scale,0.005);
virtualSphere.cc:274:	    this[01;31m-[00m>scale = MIN(this[01;31m-[00m>scale,50.0);
virtualSphere.cc:275:	    this[01;31m-[00m>startX = this[01;31m-[00m>mouseX;
virtualSphere.cc:276:	    this[01;31m-[00m>startY = this[01;31m-[00m>mouseY;
virtualSphere.cc:277:	    this[01;31m-[00m>recalculate = true;
virtualSphere.cc:284:{_F(this[01;31m-[00m>lisp());
virtualSphere.cc:286:    this[01;31m-[00m>center.set(x,y,z); 
virtualSphere.cc:287:    this[01;31m-[00m>recalculate = true;
virtualSphere.cc:292:{_F(this[01;31m-[00m>lisp());
virtualSphere.cc:294:    this[01;31m-[00m>translate.set(x,y,z); 
virtualSphere.cc:295:    this[01;31m-[00m>recalculate = true; 
virtualSphere.cc:303:    if ( this[01;31m-[00m>scale < minScale )
virtualSphere.cc:305:	this[01;31m-[00m>scale = minScale;
virtualSphere.cc:307:    if ( this[01;31m-[00m>scale > maxScale )
virtualSphere.cc:309:	this[01;31m-[00m>scale = maxScale;
virtualSphere.cc:311:    return this[01;31m-[00m>scale;
virtualSphere.cc:317:{_F(this[01;31m-[00m>lisp());
virtualSphere.cc:321:    if (this[01;31m-[00m>recalculate == false ) {
virtualSphere.cc:322:        LOG(BF("Returning pre[01;31m-[00mcalculated matrix") ); // vp0(("Returning pre[01;31m-[00mcalculated matrix"));
virtualSphere.cc:323:	result = this[01;31m-[00m>overall;
virtualSphere.cc:338:    vCent = this[01;31m-[00m>center.multiplyByScalar([01;31m-[00m1.0);
virtualSphere.cc:341:    mTranslateOriginToCenter.translate(&this[01;31m-[00m>center);
virtualSphere.cc:342:    mTranslate.translate(&this[01;31m-[00m>translate);
virtualSphere.cc:344:    mA = this[01;31m-[00m>rotate.multiplyByMatrix(mTranslateCenterToOrigin);
virtualSphere.cc:346:    mScale.scale(this[01;31m-[00m>scale);
virtualSphere.cc:355:    mA = this[01;31m-[00m>rotate.multiplyByMatrix(mTranslateCenterToOrigin);
virtualSphere.cc:365://    vCent = this[01;31m-[00m>center.multiplyByScalar([01;31m-[00m1.0);
virtualSphere.cc:368://    work1 = this[01;31m-[00m>rotate.multiplyByMatrix(cent);
virtualSphere.cc:370://    cent.translate(&(this[01;31m-[00m>center));
virtualSphere.cc:373://    scale.scale(this[01;31m-[00m>scale);
virtualSphere.cc:376://    trans.translate(&(this[01;31m-[00m>translate));
virtualSphere.cc:380:    this[01;31m-[00m>overall = result;
virtualSphere.cc:381:    this[01;31m-[00m>recalculate = false;
xmlLoadArchive.cc:22:    	void	setNode(RPNode n) { this[01;31m-[00m>node = n;};
xmlLoadArchive.cc:23:	Dumb_Node* getNode() { return this[01;31m-[00m>node;};
xmlLoadArchive.cc:26:	string characters() { return this[01;31m-[00m>dataBuffer.str().substr(0,this[01;31m-[00m>lastSolidIndex+1);};
xmlLoadArchive.cc:29:	    this[01;31m-[00m>dataBuffer.str("");
xmlLoadArchive.cc:30:	    this[01;31m-[00m>lastSolidIndex = 0;
xmlLoadArchive.cc:31:	    this[01;31m-[00m>recording = false;
xmlLoadArchive.cc:32:	    this[01;31m-[00m>charactersAdded = 0;
xmlLoadArchive.cc:36:	    this[01;31m-[00m>node = n.node;
xmlLoadArchive.cc:37:	    this[01;31m-[00m>dataBuffer.str(n.dataBuffer.str());
xmlLoadArchive.cc:38:	    this[01;31m-[00m>recording = n.recording;
xmlLoadArchive.cc:39:	    this[01;31m-[00m>lastSolidIndex = n.lastSolidIndex;
xmlLoadArchive.cc:40:	    this[01;31m-[00m>charactersAdded = n.charactersAdded;
xmlLoadArchive.cc:45:/* Only append characters after the first non[01;31m-[00mwhite[01;31m-[00mspace character is
xmlLoadArchive.cc:62:	this[01;31m-[00m>dataBuffer << *cur;
xmlLoadArchive.cc:65:	    this[01;31m-[00m>lastSolidIndex = this[01;31m-[00m>charactersAdded;
xmlLoadArchive.cc:67:	this[01;31m-[00m>charactersAdded++;
xmlLoadArchive.cc:69:	left[01;31m-[00m[01;31m-[00m;
xmlLoadArchive.cc:71://    LOG(BF("After _rawAppendData the dataBuffer is(%s)")% this[01;31m-[00m>dataBuffer.str() );
xmlLoadArchive.cc:78:    if ( this[01;31m-[00m>recording ) 
xmlLoadArchive.cc:80:	this[01;31m-[00m>_rawAppendData(chrs,length);
xmlLoadArchive.cc:84:    for ( ; *chrs; chrs++, left[01;31m-[00m[01;31m-[00m )
xmlLoadArchive.cc:88:	    this[01;31m-[00m>recording = true;
xmlLoadArchive.cc:89:	    this[01;31m-[00m>_rawAppendData(chrs,left);
xmlLoadArchive.cc:104:    // [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
xmlLoadArchive.cc:106:    // [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
xmlLoadArchive.cc:113:	np[01;31m-[00m>setNode(node);
xmlLoadArchive.cc:114:	this[01;31m-[00m>_NodeStack.push_back(np); 
xmlLoadArchive.cc:118:	ASSERT(this[01;31m-[00m>_NodeStack.size()>0);
xmlLoadArchive.cc:119:	NodeHolder* np = this[01;31m-[00m>stackTop();
xmlLoadArchive.cc:121:	this[01;31m-[00m>_NodeStack.pop_back();
xmlLoadArchive.cc:125:	ASSERT(this[01;31m-[00m>_NodeStack.size()>0);
xmlLoadArchive.cc:126:	return this[01;31m-[00m>_NodeStack.back();
xmlLoadArchive.cc:131:    // [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
xmlLoadArchive.cc:133:    // [01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m[01;31m-[00m
xmlLoadArchive.cc:138:    RPNode	getTopNode() {return this[01;31m-[00m>_TopNode;}
xmlLoadArchive.cc:139:    void	setTopNode(RPNode n) {this[01;31m-[00m>_TopNode = n; this[01;31m-[00m>_CurrentNode = NULL; };
xmlLoadArchive.cc:140:    void	setArchive(RPXmlLoadArchive a) { this[01;31m-[00m>_Archive = a; };
xmlLoadArchive.cc:152:    if ( this[01;31m-[00m>_CurrentNode == NULL )
xmlLoadArchive.cc:154:	nd = this[01;31m-[00m>_TopNode;
xmlLoadArchive.cc:158:	nd = this[01;31m-[00m>_Archive[01;31m-[00m>newArchiveNode();
xmlLoadArchive.cc:161:    this[01;31m-[00m>stackPushNode(nd);
xmlLoadArchive.cc:163:    LOG(BF("Setting up node: %px  localName=%s") % (nd) % (this[01;31m-[00m>getLocalName() ) ); // vp0(( "Setting up node: %px  localName=%s", nd, this[01;31m-[00m>getLocalName() ));
xmlLoadArchive.cc:164:    nd[01;31m-[00m>setRawNodeName(this[01;31m-[00m>getLocalName());
xmlLoadArchive.cc:165:    nd[01;31m-[00m>setLineNumber(this[01;31m-[00m>getLineNumber());
xmlLoadArchive.cc:167:    for ( i = 0; i<this[01;31m-[00m>getAttributeCount(); i++ ) 
xmlLoadArchive.cc:169:	this[01;31m-[00m>getAttributeAtIndex( i, attrName, attrVal );
xmlLoadArchive.cc:173:	    nd[01;31m-[00m>setTextUniqueId(attrVal);
xmlLoadArchive.cc:176:	    nd[01;31m-[00m>addAttribute( attrName, attrVal );
xmlLoadArchive.cc:179:    this[01;31m-[00m>_CurrentNode = nd;
xmlLoadArchive.cc:184:{ _F(this[01;31m-[00m>lisp());
xmlLoadArchive.cc:185:    RPNode nd = this[01;31m-[00m>_CurrentNode;
xmlLoadArchive.cc:186:    LOG(BF("endElement with _CurrentNode = %s") % this[01;31m-[00m>_CurrentNode[01;31m-[00m>getNodeName().c_str()  ); // vp0(( "endElement with _CurrentNode = %s", this[01;31m-[00m>_CurrentNode[01;31m-[00m>getNodeName().c_str() ));
xmlLoadArchive.cc:187:    if ( this[01;31m-[00m>_CurrentNode != this[01;31m-[00m>_TopNode ) 
xmlLoadArchive.cc:189:	NodeHolder* top = this[01;31m-[00m>stackTop();
xmlLoadArchive.cc:190:	LOG(BF("Poping top of node stack %s") % this[01;31m-[00m>_CurrentNode[01;31m-[00m>getNodeName().c_str()  ); // vp0(( "Poping top of node stack %s", this[01;31m-[00m>_CurrentNode[01;31m-[00m>getNodeName().c_str() ));
xmlLoadArchive.cc:191:	string buffer = top[01;31m-[00m>characters();
xmlLoadArchive.cc:192:	this[01;31m-[00m>_CurrentNode[01;31m-[00m>setCharacters(buffer);
xmlLoadArchive.cc:193:	this[01;31m-[00m>stackPopNode();
xmlLoadArchive.cc:194:	NodeHolder* top2 = this[01;31m-[00m>stackTop();
xmlLoadArchive.cc:195:        this[01;31m-[00m>_CurrentNode = top2[01;31m-[00m>getNode();
xmlLoadArchive.cc:198:    if ( this[01;31m-[00m>_CurrentNode != nd ) 
xmlLoadArchive.cc:200:	LOG(BF("Adding child node(%s) to parent node(%s)") % nd[01;31m-[00m>getNodeName().c_str() % this[01;31m-[00m>_CurrentNode[01;31m-[00m>getNodeName().c_str()  ); // vp0(("Adding child node(%s) to parent node(%s)", nd[01;31m-[00m>getNodeName().c_str(), this[01;31m-[00m>_CurrentNode[01;31m-[00m>getNodeName().c_str() ));
xmlLoadArchive.cc:201:        this[01;31m-[00m>_CurrentNode[01;31m-[00m>addChild(nd);
xmlLoadArchive.cc:210:    // Must be VERY careful here, only the first (this[01;31m-[00m>getDataLength())
xmlLoadArchive.cc:211:    // characters of the character array pointed to by this[01;31m-[00m>getData() is
xmlLoadArchive.cc:217:    const char* zc = this[01;31m-[00m>getData();
xmlLoadArchive.cc:218:    for (int zz=0; zz< this[01;31m-[00m>getDataLength(); zz++ )
xmlLoadArchive.cc:225:    NodeHolder* top = this[01;31m-[00m>stackTop();
xmlLoadArchive.cc:226:    top[01;31m-[00m>appendData(this[01;31m-[00m>getData(),this[01;31m-[00m>getDataLength());
xmlLoadArchive.cc:264:{ _F(this[01;31m-[00m>lisp());
xmlLoadArchive.cc:272:    this[01;31m-[00m>eraseAll();
xmlLoadArchive.cc:274:    topNode = this[01;31m-[00m>newArchiveNode();
xmlLoadArchive.cc:275:    this[01;31m-[00m>_TopNode = topNode;
xmlLoadArchive.cc:276:    handler.setArchive(this[01;31m-[00m>sharedThis<O_XmlLoadArchive>());
xmlLoadArchive.cc:281:	TOSS(_lisp[01;31m-[00m>create<O_FileNotFoundException>(fileName));
xmlLoadArchive.cc:283:    MySaxParser parser(this[01;31m-[00m>lisp());
xmlLoadArchive.cc:286:	_lisp[01;31m-[00m>print(BF("error during XML initialization" ));
xmlLoadArchive.cc:293:    if ( this[01;31m-[00m>_Verbosity > 0 )
xmlLoadArchive.cc:295:	_lisp[01;31m-[00m>print(BF(" Finished parsing archive"));
xmlLoadArchive.cc:298:    	TOSS(_lisp[01;31m-[00m>create<O_LispError>(boost::format("Could not parse file: %s") %fileName ));
xmlLoadArchive.cc:304:{_F(this[01;31m-[00m>lisp());
xmlLoadArchive.cc:305:    this[01;31m-[00m>parse(fileName);
xmlLoadArchive.cc:309:{_F(this[01;31m-[00m>lisp());
xmlLoadArchive.cc:313:    if ( this[01;31m-[00m>_Verbosity > 0 )
xmlLoadArchive.cc:315:	_lisp[01;31m-[00m>print(BF(" About to open file: %s") % fileName.c_str() );
xmlLoadArchive.cc:318:    this[01;31m-[00m>setFileName(fileName);
xmlLoadArchive.cc:319:    if ( this[01;31m-[00m>_Verbosity > 0 )
xmlLoadArchive.cc:321:	_lisp[01;31m-[00m>print(BF(" About to parse file" ));
xmlLoadArchive.cc:324:	_lisp[01;31m-[00m>print(BF(" The size of the file is %u bytes") % fileSize );
xmlLoadArchive.cc:326:    this[01;31m-[00m>_parseFile( fIn, fileName );
xmlLoadArchive.cc:331:    if ( this[01;31m-[00m>_Verbosity > 0 )
xmlLoadArchive.cc:333:	this[01;31m-[00m>describeMemoryUsage();
xmlLoadArchive.cc:335:    this[01;31m-[00m>createContents();
xmlLoadArchive.cc:336:    version = this[01;31m-[00m>_TopNode[01;31m-[00m>getAttributeIntDefault("version",1);
xmlLoadArchive.cc:337:    if ( this[01;31m-[00m>_Verbosity > 0 )
xmlLoadArchive.cc:341:	_lisp[01;31m-[00m>print(BF(" The size of the file that was loaded is %u bytes") % fileSize );
xmlLoadArchive.cc:342:	this[01;31m-[00m>describeMemoryUsage();
xmlLoadArchive.cc:344:    this[01;31m-[00m>setVersion(version);
xmlLoadArchive.cc:351:{_F(this[01;31m-[00m>lisp());
xmlLoadArchive.cc:357:    this[01;31m-[00m>eraseAll();
xmlLoadArchive.cc:359:    topNode = this[01;31m-[00m>newArchiveNode();
xmlLoadArchive.cc:360:    this[01;31m-[00m>_TopNode = topNode;
xmlLoadArchive.cc:361:    handler.setArchive(this[01;31m-[00m>sharedThis<O_XmlLoadArchive>());
xmlLoadArchive.cc:365:    MySaxParser parser(this[01;31m-[00m>lisp());
xmlLoadArchive.cc:368:	_lisp[01;31m-[00m>print(BF("error durint XML initialization" ));
xmlLoadArchive.cc:376:	_lisp[01;31m-[00m>print(BF( "Could not parse file" ));
xmlLoadArchive.cc:386:{_F(this[01;31m-[00m>lisp());
xmlLoadArchive.cc:387:    this[01;31m-[00m>setFileName("[01;31m-[00m[01;31m-[00mstring[01;31m-[00m[01;31m-[00m");
xmlLoadArchive.cc:388:    this[01;31m-[00m>_parseString( buffer.c_str() );
xmlLoadArchive.cc:389:    this[01;31m-[00m>createContents();
xmlLoadArchive.cc:390:    int version = this[01;31m-[00m>_TopNode[01;31m-[00m>getAttributeIntDefault("version",1);
xmlLoadArchive.cc:391:    this[01;31m-[00m>setVersion(version);
xmlLoadArchive.cc:399:    this[01;31m-[00m>Base::initialize();
xmlLoadArchive.cc:400:    this[01;31m-[00m>setVersion(0);
xmlLoadArchive.cc:413:    a[01;31m-[00m>parseString(x.c_str());
xmlLoadArchive.cc:414:    node = a[01;31m-[00m>getTopNode();
xmlLoadArchive.cc:415:    obj = a[01;31m-[00m>loadObjectDirectly(node);
xmlLoadArchive.cc:427:    a[01;31m-[00m>parse(fileName);
xmlLoadArchive.cc:428:    node = a[01;31m-[00m>getTopNode();
xmlLoadArchive.cc:429:    ASSERT(node[01;31m-[00m>numberOfChildren() == 1);
xmlLoadArchive.cc:430:    child = *(node[01;31m-[00m>begin_Children());
xmlLoadArchive.cc:431:    obj = a[01;31m-[00m>loadObjectDirectly(child);
xmlSaveArchive.cc:15:    class_<O_XmlSaveArchive>(e[01;31m-[00m>lisp())
xmlSaveArchive.cc:36:    this[01;31m-[00m>Base::initialize();
xmlSaveArchive.cc:37:    this[01;31m-[00m>setVersion(0);
xmlSaveArchive.cc:44:    this[01;31m-[00m>Base::oldLispInitialize(kargs,env);
xmlSaveArchive.cc:53:    this[01;31m-[00m>completeWeakObjectReferences();
xmlSaveArchive.cc:54:    if ( this[01;31m-[00m>_Verbosity>0 )
xmlSaveArchive.cc:56:	this[01;31m-[00m>describeMemoryUsage();
xmlSaveArchive.cc:76:	TOSS(_lisp[01;31m-[00m>create<O_LispError>(BF("Could not open file: %s [01;31m-[00m check path")%actualFileName));
xmlSaveArchive.cc:78:    this[01;31m-[00m>_TopNode[01;31m-[00m>writeXml(out);
xmlSaveArchive.cc:79:    if ( this[01;31m-[00m>_Verbosity > 0 )
xmlSaveArchive.cc:82:	_lisp[01;31m-[00m>print(BF( " Size of archive file is %lu bytes") % fileSize );
xmlSaveArchive.cc:102:    this[01;31m-[00m>completeWeakObjectReferences();
xmlSaveArchive.cc:104:    this[01;31m-[00m>_TopNode[01;31m-[00m>writeXml(sout);
xmlSaveArchive.cc:116:    for ( ch=this[01;31m-[00m>_TopNode[01;31m-[00m>begin_Children(); ch!=this[01;31m-[00m>_TopNode[01;31m-[00m>end_Children(); ch++ )
xmlSaveArchive.cc:118:	(*ch)[01;31m-[00m>writeXml(sout);
zMatrix.cc:32:    this[01;31m-[00m>Base::initialize();
zMatrix.cc:33:    this[01;31m-[00m>_Value = 0.0;
zMatrix.cc:34:    this[01;31m-[00m>_Constrain = false;
zMatrix.cc:39:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:40:    node[01;31m-[00m>archiveWeakPointer("WeakZMatrix",this[01;31m-[00m>_WeakZMatrix);
zMatrix.cc:41:    node[01;31m-[00m>attribute("InternalName",this[01;31m-[00m>_InternalName);
zMatrix.cc:42:    node[01;31m-[00m>attributeIfNotDefault("Constrain",this[01;31m-[00m>_Constrain,false);
zMatrix.cc:43:    node[01;31m-[00m>attribute("AtomNew",this[01;31m-[00m>_AtomNew);
zMatrix.cc:44:    node[01;31m-[00m>attributeIfNotDefault("Value",this[01;31m-[00m>_Value,0.0);
zMatrix.cc:51:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:52:    return this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomNew);
zMatrix.cc:57:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:58:    this[01;31m-[00m>_AtomNew = atomIndices[atom];
zMatrix.cc:63:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:65:    ss << this[01;31m-[00m>_InternalName << " " << this[01;31m-[00m>_AtomNew << " ";
zMatrix.cc:81:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:84:    ss << this[01;31m-[00m>O_ZMatrixInternal::dump();
zMatrix.cc:85:    ss << " " << this[01;31m-[00m>_AtomBond;
zMatrix.cc:91:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:93:    atomNew = this[01;31m-[00m>getAtomNew();
zMatrix.cc:94:    atomBond = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomBond);
zMatrix.cc:95:    this[01;31m-[00m>setConstrain(true);
zMatrix.cc:96:    if ( atomNew[01;31m-[00m>getMask()==m ||
zMatrix.cc:97:    	 atomBond[01;31m-[00m>getMask()==m )
zMatrix.cc:99:        this[01;31m-[00m>setConstrain(false);
zMatrix.cc:104:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:107:    atomNew = this[01;31m-[00m>getAtomNew();
zMatrix.cc:108:    atomBond = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomBond);
zMatrix.cc:109:    value = calculateDistance(atomNew[01;31m-[00m>getPosition(),
zMatrix.cc:110:			      atomBond[01;31m-[00m>getPosition(),this[01;31m-[00m>lisp());
zMatrix.cc:111:    this[01;31m-[00m>setValue(value);
zMatrix.cc:118:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:119:    return this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomZMatrixNameAtIndex(this[01;31m-[00m>_AtomBond);
zMatrix.cc:124:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:125:    this[01;31m-[00m>O_ZMatrixInternal::archive(node);
zMatrix.cc:126:    node[01;31m-[00m>attribute("AtomBond",this[01;31m-[00m>_AtomBond);
zMatrix.cc:134:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:136:    this[01;31m-[00m>setAtomNew(atomNew,atomIndices);
zMatrix.cc:138:    this[01;31m-[00m>setInternalName(name.str());
zMatrix.cc:139:    this[01;31m-[00m>_AtomBond = atomIndices[atomBond];
zMatrix.cc:140:    this[01;31m-[00m>setValue(0.0);
zMatrix.cc:154:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:157:    ss << this[01;31m-[00m>O_ZMatrixInternal::dump();
zMatrix.cc:158:    ss << " " << this[01;31m-[00m>_AtomBond;
zMatrix.cc:159:    ss << " " << this[01;31m-[00m>_AtomAngle;
zMatrix.cc:166:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:168:    atomNew = this[01;31m-[00m>getAtomNew();
zMatrix.cc:169:    atomBond = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomBond);
zMatrix.cc:170:    atomAngle = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomAngle);
zMatrix.cc:171:    this[01;31m-[00m>setConstrain(true);
zMatrix.cc:172:    if ( atomNew[01;31m-[00m>getMask()==m ||
zMatrix.cc:173:    	 atomBond[01;31m-[00m>getMask()==m ||
zMatrix.cc:174:    	 atomAngle[01;31m-[00m>getMask()==m )
zMatrix.cc:176:        this[01;31m-[00m>setConstrain(false);
zMatrix.cc:182:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:185:    atomNew = this[01;31m-[00m>getAtomNew();
zMatrix.cc:186:    atomBond = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomBond);
zMatrix.cc:187:    atomAngle = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomAngle);
zMatrix.cc:188:    value = calculateAngle(atomNew[01;31m-[00m>getPosition(),
zMatrix.cc:189:    				atomBond[01;31m-[00m>getPosition(),
zMatrix.cc:190:			   atomAngle[01;31m-[00m>getPosition(), this[01;31m-[00m>lisp() );
zMatrix.cc:191:    this[01;31m-[00m>setValue(value);
zMatrix.cc:198:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:199:    this[01;31m-[00m>O_ZMatrixInternal::archive(node);
zMatrix.cc:200:    node[01;31m-[00m>attribute("AtomBond",this[01;31m-[00m>_AtomBond);
zMatrix.cc:201:    node[01;31m-[00m>attribute("AtomAngle",this[01;31m-[00m>_AtomAngle);
zMatrix.cc:205:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:206:    return this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomZMatrixNameAtIndex(this[01;31m-[00m>_AtomBond);
zMatrix.cc:210:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:211:    return this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomZMatrixNameAtIndex(this[01;31m-[00m>_AtomAngle);
zMatrix.cc:216:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:218:    this[01;31m-[00m>setAtomNew(atomNew,atomIndices);
zMatrix.cc:220:    this[01;31m-[00m>setInternalName(name.str());
zMatrix.cc:221:    this[01;31m-[00m>_AtomBond = atomIndices[atomBond];
zMatrix.cc:222:    this[01;31m-[00m>_AtomAngle = atomIndices[atomAngle];
zMatrix.cc:223:    this[01;31m-[00m>setValue(0.0);
zMatrix.cc:237:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:240:    ss << this[01;31m-[00m>O_ZMatrixInternal::dump();
zMatrix.cc:241:    ss << " " << this[01;31m-[00m>_AtomBond;
zMatrix.cc:242:    ss << " " << this[01;31m-[00m>_AtomAngle;
zMatrix.cc:243:    ss << " " << this[01;31m-[00m>_AtomDihedral;
zMatrix.cc:248:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:250:    atomNew = this[01;31m-[00m>getAtomNew();
zMatrix.cc:251:    atomBond = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomBond);
zMatrix.cc:252:    atomAngle = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomAngle);
zMatrix.cc:253:    atomDihedral = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomDihedral);
zMatrix.cc:254:    this[01;31m-[00m>setConstrain(true);
zMatrix.cc:255:    if ( atomNew[01;31m-[00m>getMask()==m ||
zMatrix.cc:256:    	 atomBond[01;31m-[00m>getMask()==m ||
zMatrix.cc:257:    	 atomAngle[01;31m-[00m>getMask()==m ||
zMatrix.cc:258:    	 atomDihedral[01;31m-[00m>getMask()==m )
zMatrix.cc:260:        this[01;31m-[00m>setConstrain(false);
zMatrix.cc:265:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:268:    atomNew = this[01;31m-[00m>getAtomNew();
zMatrix.cc:269:    atomBond = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomBond);
zMatrix.cc:270:    atomAngle = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomAngle);
zMatrix.cc:271:    atomDihedral = this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomAtIndex(this[01;31m-[00m>_AtomDihedral);
zMatrix.cc:272:    value = calculateDihedral(atomNew[01;31m-[00m>getPosition(),
zMatrix.cc:273:    				atomBond[01;31m-[00m>getPosition(),
zMatrix.cc:274:    				atomAngle[01;31m-[00m>getPosition(),
zMatrix.cc:275:			      atomDihedral[01;31m-[00m>getPosition(), this[01;31m-[00m>lisp()
zMatrix.cc:277:    this[01;31m-[00m>setValue(value);
zMatrix.cc:282:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:283:    this[01;31m-[00m>O_ZMatrixInternal::archive(node);
zMatrix.cc:284:    node[01;31m-[00m>attribute("AtomBond",this[01;31m-[00m>_AtomBond);
zMatrix.cc:285:    node[01;31m-[00m>attribute("AtomAngle",this[01;31m-[00m>_AtomAngle);
zMatrix.cc:286:    node[01;31m-[00m>attribute("AtomDihedral",this[01;31m-[00m>_AtomDihedral);
zMatrix.cc:290:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:291:    return this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomZMatrixNameAtIndex(this[01;31m-[00m>_AtomBond);
zMatrix.cc:295:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:296:    return this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomZMatrixNameAtIndex(this[01;31m-[00m>_AtomAngle);
zMatrix.cc:300:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:301:    return this[01;31m-[00m>getZMatrix()[01;31m-[00m>_getAtomZMatrixNameAtIndex(this[01;31m-[00m>_AtomDihedral);
zMatrix.cc:310:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:312:    this[01;31m-[00m>setAtomNew(atomNew,atomIndices);
zMatrix.cc:314:    this[01;31m-[00m>setInternalName(name.str());
zMatrix.cc:315:    this[01;31m-[00m>_AtomBond = atomIndices[atomBond];
zMatrix.cc:316:    this[01;31m-[00m>_AtomAngle = atomIndices[atomAngle];
zMatrix.cc:317:    this[01;31m-[00m>_AtomDihedral = atomIndices[atomDihedral];
zMatrix.cc:318:    this[01;31m-[00m>setValue(0.0);
zMatrix.cc:330:    this[01;31m-[00m>Base::initialize();
zMatrix.cc:331:    this[01;31m-[00m>_ZMatrixAtomName = "";
zMatrix.cc:332:    this[01;31m-[00m>_Atom = O_Atom::nil(this[01;31m-[00m>lisp());
zMatrix.cc:333:    this[01;31m-[00m>_Bond = O_ZMatrixBondInternal::nil(this[01;31m-[00m>lisp());
zMatrix.cc:334:    this[01;31m-[00m>_Angle = O_ZMatrixAngleInternal::nil(this[01;31m-[00m>lisp());
zMatrix.cc:335:    this[01;31m-[00m>_Dihedral = O_ZMatrixDihedralInternal::nil(this[01;31m-[00m>lisp());
zMatrix.cc:343:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:344:    node[01;31m-[00m>attribute("ZMatrixAtomName",this[01;31m-[00m>_ZMatrixAtomName);
zMatrix.cc:345:    ASSERT_NOT_NULL(this[01;31m-[00m>_Atom);
zMatrix.cc:346:    node[01;31m-[00m>archiveObject("Atom",this[01;31m-[00m>_Atom);
zMatrix.cc:347:    node[01;31m-[00m>archiveObjectIfDefined("Bond",this[01;31m-[00m>_Bond);
zMatrix.cc:348:    node[01;31m-[00m>archiveObjectIfDefined("Angle",this[01;31m-[00m>_Angle);
zMatrix.cc:349:    node[01;31m-[00m>archiveObjectIfDefined("Dihedral",this[01;31m-[00m>_Dihedral);
zMatrix.cc:363:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:364:    node[01;31m-[00m>archiveObject("Matter",this[01;31m-[00m>_Matter);
zMatrix.cc:365:    node[01;31m-[00m>archiveList("ZMatrix",this[01;31m-[00m>_ZMatrix);
zMatrix.cc:366:    node[01;31m-[00m>archiveList("Internals",this[01;31m-[00m>_Internals);
zMatrix.cc:370:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:371:    ASSERT_lessThan(i,this[01;31m-[00m>_ZMatrix.size());
zMatrix.cc:372:    return this[01;31m-[00m>_ZMatrix.get(i)[01;31m-[00m>getAtom();
zMatrix.cc:376:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:377:    LOG(BF("Looking for atom at index: %d    _ZMatrix.size=%d") % i % this[01;31m-[00m>_ZMatrix.size()  ); // vp0(("Looking for atom at index: %d    _ZMatrix.size=%d",i,this[01;31m-[00m>_ZMatrix.size() ));
zMatrix.cc:378:    ASSERT_lessThan(i,this[01;31m-[00m>_ZMatrix.size());
zMatrix.cc:379:    return this[01;31m-[00m>_ZMatrix.get(i)[01;31m-[00m>getTargetAtomZMatrixName();
zMatrix.cc:383:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:392:    LOG(BF("Starting on atom: %s") % atom[01;31m-[00m>description().c_str()  ); // vp0(("Starting on atom: %s",atom[01;31m-[00m>description().c_str() ));
zMatrix.cc:393:    this[01;31m-[00m>_Matter = matter;
zMatrix.cc:394:    span = this[01;31m-[00m>lisp()[01;31m-[00m>create<O_SpanningLoop>();
zMatrix.cc:395:    span[01;31m-[00m>setTop(atom);
zMatrix.cc:397:    while ( span[01;31m-[00m>advanceLoopAndProcess() )
zMatrix.cc:399:        newAtom = span[01;31m-[00m>getAtom();
zMatrix.cc:400:        _BLOCK_TRACEF(BF("ZMatrix entry for: %s") % newAtom[01;31m-[00m>description().c_str() );
zMatrix.cc:401:	atomIndices[newAtom] = this[01;31m-[00m>_ZMatrix.size();
zMatrix.cc:402:	entry = O_ZMatrixEntry::create(this[01;31m-[00m>lisp(),newAtom,atomIndices);
zMatrix.cc:403:	this[01;31m-[00m>_ZMatrix.append(entry);
zMatrix.cc:404:	numberOfEntries = this[01;31m-[00m>_ZMatrix.size();
zMatrix.cc:405:	if ( ! newAtom[01;31m-[00m>isBackSpanValid() )
zMatrix.cc:409:	bondToAtom = newAtom[01;31m-[00m>getBackSpan();
zMatrix.cc:410:	LOG(BF("bondToAtom = %s") % bondToAtom[01;31m-[00m>description().c_str() ); // vp0(("bondToAtom = %s",bondToAtom[01;31m-[00m>description().c_str()));
zMatrix.cc:411:	bondInternal = O_ZMatrixBondInternal::create(this[01;31m-[00m>lisp(),newAtom,bondToAtom,atomIndices,this[01;31m-[00m>sharedThis<O_ZMatrix>());
zMatrix.cc:412:	this[01;31m-[00m>_Internals.append(bondInternal);
zMatrix.cc:413:	entry[01;31m-[00m>_Bond = bondInternal;
zMatrix.cc:414:	if ( !bondToAtom[01;31m-[00m>isBackSpanValid() )
zMatrix.cc:419:	angleToAtom = bondToAtom[01;31m-[00m>getBackSpan();
zMatrix.cc:420:	LOG(BF("angleToAtom = %s") % angleToAtom[01;31m-[00m>description().c_str() ); // vp0(("angleToAtom = %s",angleToAtom[01;31m-[00m>description().c_str()));
zMatrix.cc:422:					angleToAtom,atomIndices,this[01;31m-[00m>sharedThis<O_ZMatrix>(), this[01;31m-[00m>lisp());
zMatrix.cc:423:	this[01;31m-[00m>_Internals.append(angleInternal);
zMatrix.cc:424:	entry[01;31m-[00m>_Angle = angleInternal;
zMatrix.cc:425:	if ( !angleToAtom[01;31m-[00m>isBackSpanValid() )
zMatrix.cc:431:	        dihedralToAtom = this[01;31m-[00m>_getAtomAtIndex(2);
zMatrix.cc:435:	        TOSS(_lisp[01;31m-[00m>create<O_LispError>("There are too many entries to run out of a dihedral atom"));
zMatrix.cc:439:	    dihedralToAtom = angleToAtom[01;31m-[00m>getBackSpan();
zMatrix.cc:441:	LOG(BF("dihedralToAtom = %s") % dihedralToAtom[01;31m-[00m>description().c_str() ); // vp0(("dihedralToAtom = %s",dihedralToAtom[01;31m-[00m>description().c_str()));
zMatrix.cc:443:				angleToAtom,dihedralToAtom,atomIndices,this[01;31m-[00m>sharedThis<O_ZMatrix>(),this[01;31m-[00m>lisp());
zMatrix.cc:445:	this[01;31m-[00m>_Internals.append(dihedralInternal);
zMatrix.cc:446:	LOG(BF("Setting entry[01;31m-[00m>_Dihedral") ); // vp0(("Setting entry[01;31m-[00m>_Dihedral"));
zMatrix.cc:447:	entry[01;31m-[00m>_Dihedral = dihedralInternal;
zMatrix.cc:455:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:464:	if ( atom[01;31m-[00m>numberOfBonds() == 1 )
zMatrix.cc:471:    this[01;31m-[00m>defineForMatterWithStartingAtom(matter,atom);
zMatrix.cc:476:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:478:    for ( it=this[01;31m-[00m>_Internals.begin(); it!=this[01;31m-[00m>_Internals.end(); it++ )
zMatrix.cc:480:        (*it)[01;31m-[00m>extractInternal();
zMatrix.cc:486:{_F(this[01;31m-[00m>lisp());
zMatrix.cc:488:    for ( it=this[01;31m-[00m>_Internals.begin(); it!=this[01;31m-[00m>_Internals.end(); it++ )
zMatrix.cc:490:        (*it)[01;31m-[00m>constrainIfNoAtomsWithMask(mask);
