\rule{6in}{0.01cm}\par
\framebox{Scraped from candoScript.cc 122 path: candoScript  type: chapter}\par
\chapter{Cando Scripting Language}
Cando-Script is a language tailored to constructing and searching virtual oligomer libraries.
Cando-Script is modeled after the languages Lisp and Scheme with Smalltalk/Objective-C thrown in, not to be different but because
these languages have a simple and compact syntax and they seemed to be a good match for the
problem.\par

Cando-Script is designed to allow a chemists to easily define virtual oligomer libraries, build 3D models of members of of
oligomer libraries, score members of these libraries and identify the best 
oligomer structures that present functional groups
in a desired three-dimensional constellation.\par

Cando-Script commands are invoked using two forms: 

\begin{itemize}
\item Prefix form - [\textbf{command} \emph{arg1 arg2 arg3 ...} ]

This is the ``prefix'' form, where the \textbf{command} is given followed by its arguments. 
Square brackets are used to indicate that this is a prefix form command.

When {\CANDOSCRIPT} encounters a command in prefix form it does the following:
\begin{enumerate}
\item It checks if the command is a macro name like ``defClass'' or ``if'' and if it is
then the arguments are passed to the internal macro code for it to handle in its own way.
{\CANDOSCRIPT} then goes on to the next command.

\item {\CANDOSCRIPT} evaluates all of the arguments and constructs a list of evaluated arguments to
pass to the function or method.

\item {\CANDOSCRIPT} checks to see if the first evaluated argument object recognizes the method with
the \textbf{command} name and if it does {\CANDOSCRIPT} invokes the method with the evaluated argument list.
{\CANDOSCRIPT} then puts the result of the invocation into a growing argument list and goes to the
next command.

\item If the \textbf{command} didn't match an object/method call then {\CANDOSCRIPT} checks if \textbf{command}
matches a function call.  If it does then {\CANDOSCRIPT} invokes the function with the evaluated arguments and puts the
result into a growing result list and goes to the next command.

\item {\CANDOSCRIPT} throws an error saying that the current command is not recognized.

\end{enumerate}

Examples:\par
\begin{verbatim}
[save hitList "hits.oml" ]  # saves the hitList object 
                            #    to the file: hits.oml.
[:= x 10.0]                 # assigns the value 10.0 
                            #    to the global variable x.
[println "Hello world" ]    # prints "Hello world" to stdout 
                            #    followed by a carriage return.
\end{verbatim}

\item Infix form - ( object \textbf{command} \emph{arg1 arg2 ...} )

This is the "infix" form, where the \textbf{command} is sent to the \emph{object} 
with the arguments \emph{arg1 arg2 ...}. 

Internally the ``infix'' form is automatically converted into ``prefix'' form 
by swapping the order of \emph{object} and \textbf{command}. 

So the command: ( \emph{object} \textbf{command} \emph{arg1 arg2 ...} ) \par
is converted to [ \textbf{command} \emph{object} \emph{arg1 arg2 ...} ]

The purpose of the infix-form is
to allow the programmer to use a more familiar notation for mathematical 
expressions and conditional expressions.


\end{verbatim}

\rule{6in}{0.01cm}\par
\framebox{Generated by candoScript.cc 122 path: candoScript.database  type: section}\par
\section{database}
\rule{6in}{0.01cm}\par
\framebox{Scraped from candoScript.cc 157 path: candoScript.database.bundleDatabasePath  type: subsection}\par
\subsection{bundleDatabasePath}
\scriptCmd{bundleDatabasePath}{directoryName:text}

Return the full path of a file in the bundle database directory.

\rule{6in}{0.01cm}\par
\framebox{Scraped from candoScript.cc 210 path: candoScript.database.contextGrep  type: subsection}\par
\subsection{contextGrep}
\positional{Text::contextKeySubstring}

Search for contexts with keys that contain the substring.

\rule{6in}{0.01cm}\par
\framebox{Scraped from candoScript.cc 175 path: candoScript.database.setDatabase  type: subsection}\par
\subsection{setDatabase}
\scriptCmd{standardDatabase}{directoryName:text}

Set the database.

\rule{6in}{0.01cm}\par
\framebox{Scraped from candoScript.cc 122 path: candoScript.database.standardDatabase  type: subsection}\par
\subsection{standardDatabase}
\args{((Text databaseFileName) &optional (Bool loadSeed) (Int (verbosity 0)))}
\returns{()}

Load the database with the name \emph{databaseFileName}.
If \emph{loadSeed} is true then it loads the seed database (no MonomerCoordinates) 
- otherwise it loads the standard database.
If :verbosity is set to a non zero value then debugging information is printed during loading.

\rule{6in}{0.01cm}\par
\framebox{Scraped from intrinsics.cc 69 path: candoScript.debug  type: section}\par
\section{Debugging}
CandoScript commands used for debugging scripts.

\rule{6in}{0.01cm}\par
\framebox{Scraped from candoScript.cc 407 path: candoScript.general  type: section}\par
\section{general}
These commands apply to a variety of objects.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3515 path: candoScript.general.and  type: subsection}\par
\subsection{and}
  \scriptCmdRet{and}{boolA boolB}{bool}\par

  Return boolA AND boolB.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2253 path: candoScript.general.apply  type: subsection}\par
\subsection{apply}
  \scriptCmdRet{apply}{}{Function argList}

  Evaluate the function with the argument list.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2063 path: candoScript.general.apropos  type: subsection}\par
\subsection{apropos}
  \scriptCmdRet{apropos}{}{Text::substring [packageName]}

  Return every symbol that contains the (substring)

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2458 path: candoScript.general.backtrace  type: subsection}\par
\subsection{backtrace}
  \scriptCmdRet{backtrace}{}{Cons::}

  Return a backtrace as a list of SourceCodeCons.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2973 path: candoScript.general.caddr  type: subsection}\par
\subsection{caddr}
  \scriptCmdRet{caddr}{list}{object}

  Return the third element of the list.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2954 path: candoScript.general.cadr  type: subsection}\par
\subsection{cadr}
  \scriptCmdRet{cadr}{list}{object}

  Return the second element of the list.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2863 path: candoScript.general.car  type: subsection}\par
\subsection{car}
  \scriptCmdRet{car}{list}{object}

  Return the first element of the list.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2936 path: candoScript.general.cdddr  type: subsection}\par
\subsection{cdddr}
  \scriptCmdRet{cdddr}{list}{object}

  Return the cdddr list after the first element is removed.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2918 path: candoScript.general.cddr  type: subsection}\par
\subsection{cddr}
  \scriptCmdRet{cddr}{list}{object}

  Return the cddr list after the first element is removed.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2899 path: candoScript.general.cdr  type: subsection}\par
\subsection{cdr}
  \scriptCmdRet{cdr}{list}{object}

  Return the rest of the list after the first element is removed.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2506 path: candoScript.general.changeWorkingDirectory  type: subsection}\par
\subsection{changeWorkingDirectory}
  \scriptCmdRet{changeWorkingDirectory}{}{Text::}

  Change the current working directory.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3034 path: candoScript.general.className  type: subsection}\par
\subsection{className}
  \scriptCmdRet{className}{object}{string}

  Return the name of the class the object belongs to.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2882 path: candoScript.general.cons  type: subsection}\par
\subsection{cons}
  \scriptCmdRet{cons}{object list}{cons}

  Create a "cons" with from object,list.

\rule{6in}{0.01cm}\par
\framebox{Scraped from matter.cc 879 path: candoScript.general.contentWithName  type: subsection}\par
\subsection{contentWithName}
\scriptCmd{contentWithName}{object:matter name:text}

Return the content of the Matter(Aggregate/Molecule/Residue) with the name \scriptArg{name}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2489 path: candoScript.general.databaseDir  type: subsection}\par
\subsection{databaseDir}
  \scriptCmdRet{databaseDir}{}{Text::}

  Return the path for the database directory.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2629 path: candoScript.general.debugDumpClassManager  type: subsection}\par
\subsection{debugDumpClassManager}
  \scriptCmd{debugDumpClassManager}{}

  Dump the class manager.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2614 path: candoScript.general.debugLogOff  type: subsection}\par
\subsection{debugLogOff}
  \scriptCmd{debugLogOff}{true/false:bool}

  Turn on or off writing debug statements to the debug log. This is useful when running
  long scripts that crash, you can turn of debug logging up to the point where
  the crash happens and then examine the output.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2596 path: candoScript.general.debugLogOn  type: subsection}\par
\subsection{debugLogOn}
  \scriptCmd{debugLogOn}{true/false:bool}

  Turn on or off writing debug statements to the debug log. This is useful when running
  long scripts that crash, you can turn of debug logging up to the point where
  the crash happens and then examine the output.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1156 path: candoScript.general.defparameter  type: subsection}\par
\subsection{defparameter}
  \scriptCmd{let}{symbol object}\par

  Evaluate the arguments and put it into the global variable \scriptArg{symbol}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1186 path: candoScript.general.defvarAndExport  type: subsection}\par
\subsection{defvarAndExport}
  \scriptCmd{let}{symbol object}\par

  Evaluate the arguments and put it into the global variable \scriptArg{symbol}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3226 path: candoScript.general.div  type: subsection}\par
\subsection{div}
  \scriptCmdRet{div}{valueA:number valueB:number}{number}\par
  \scriptCmdRet{/}{valueA:number valueB:number}{number}

  Return the division of the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 1884 path: candoScript.general.dumpEnvironment  type: subsection}\par
\subsection{dumpEnvironment}
  \scriptCmdRet{dumpEnvironment}{}{Text::packageName}

  Dump the current environment.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 1958 path: candoScript.general.dumpHidden  type: subsection}\par
\subsection{dumpHidden}
  \scriptCmdRet{dumpHidden}{}{Text::packageName}

  Dump the keys in the Hidden binder.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3400 path: candoScript.general.eq  type: subsection}\par
\subsection{eq}
  \scriptCmdRet{eq}{valueA valueB }{Bool::}\par
  \scriptMethodRet{valueA}{==}{valueB }{Bool::}

  Return true if the objects are equal. For some objects (numbers,strings,bools) it compares the objects values. For more complex objects it returns true if they are identical.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2745 path: candoScript.general.export  type: subsection}\par
\subsection{export}
  \scriptCmd{export}{symbols...}

  Tell the symbols that they can be exported.


\rule{6in}{0.01cm}\par
\framebox{Scraped from values.cc 478 path: candoScript.general.format  type: subsection}\par
\subsection{format}
  \scriptCmdRet{format}{Text::format args ...}{string}\par
  \scriptMethodRet{Text::format}{\%}{args ...}{string}

  Generates formatted output using the boost "format" library.  
  It generates formatted output similar to the C-printf function.
  The result is returned as a string.

\rule{6in}{0.01cm}\par
\framebox{Scraped from values.cc 545 path: candoScript.general.formatCons  type: subsection}\par
\subsection{formatCons}
  \scriptCmdRet{format}{Text::formatCons Cons::args}{string}\par
  \scriptMethodRet{Text::formatCons}{\%}{Cons::argsstring}

  Generates formatted output using the boost "format" library.  
  Arguments are passed as a Cons.
  It generates formatted output similar to the C-printf function.
  The result is returned as a string.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2231 path: candoScript.general.funcall  type: subsection}\par
\subsection{funcall}
  \scriptCmdRet{funcall}{}{Function arg1 arg2 ...}

  Evaluate the function with the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3484 path: candoScript.general.ge  type: subsection}\par
\subsection{ge}
  \scriptCmdRet{ge}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{$>=$}{valueB }{bool}

  Return true if valueA $>=$ valueB.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2296 path: candoScript.general.getForm  type: subsection}\par
\subsection{getForm}
  \scriptCmdRet{getForm}{}{Symbol::}

  Return the Procedure associated with the symbol

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2214 path: candoScript.general.getPackage  type: subsection}\par
\subsection{getPackage}
  \scriptCmdRet{getPackage}{}{Text::packageName}

  Make the package.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1128 path: candoScript.general.global  type: subsection}\par
\subsection{global}
  \scriptCmd{let}{symbol object}\par

  Evaluate the arguments and put it into the global variable \scriptArg{symbol}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3450 path: candoScript.general.gt  type: subsection}\par
\subsection{gt}
  \scriptCmdRet{gt}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{$>$}{valueB }{bool}

  Return true if valueA $>$ valueB.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 302 path: candoScript.general.handlerCase  type: subsection}\par
\subsection{handlerCase}
  \scriptCmdRet{handlerCase}{}{Cons::expression Cons::errorClauses$*$}

  Evaluate the expression and if a Condition is thrown then evaluate the appropriate errorClause.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2114 path: candoScript.general.import  type: subsection}\par
\subsection{import}
  \scriptCmdRet{import}{}{symbols &optional package}

  Import the symbols into the (package) or the current package.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2156 path: candoScript.general.inPackage  type: subsection}\par
\subsection{inPackage}
  \scriptCmdRet{inPackage}{}{Symbol::packageName}

  Cause the package (packageName) to be set to the current package.
  If that package doesn't exist then throw an exception.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3050 path: candoScript.general.isAssignableTo  type: subsection}\par
\subsection{isAssignableTo}
  \scriptInfixRet{Object::object}{isAssignableTo}{Class::classObject}{Bool::}

  Return true if \scriptArg{object} can be assigned to a C++ variable of class \scriptArg{classObject}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3090 path: candoScript.general.isOfClass  type: subsection}\par
\subsection{isOfClass}
  \scriptInfixRet{Object::object}{isOfClass}{Class::classObject}{Bool::}

  Return true if \scriptArg{object} is a subclass of \scriptArg{classObject}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3069 path: candoScript.general.isSubClassOf  type: subsection}\par
\subsection{isSubClassOf}
  \scriptInfixRet{Object::object}{isSubClassOf}{Class::classObject}{Bool::}

  Return true if \scriptArg{object} can be assigned to a C++ variable of class \scriptArg{classObject}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2521 path: candoScript.general.isTopLevelScript  type: subsection}\par
\subsection{isTopLevelScript}

  Return a true if this is a top level script or false if its an include file.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3140 path: candoScript.general.keyedList  type: subsection}\par
\subsection{keyedList}
  \scriptCmdRet{list}{object1 object2 ...}{list}\par
  \scriptCmdRet{:}{object1 object2 ...}{list}

  Return a list formed by evaluating the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3467 path: candoScript.general.le  type: subsection}\par
\subsection{le}
  \scriptCmdRet{le}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{$<$=}{valueB }{bool}

  Return true if valueA $<$= valueB.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2993 path: candoScript.general.length  type: subsection}\par
\subsection{length}
  \scriptCmdRet{length}{list}{int}

  Return the length of the list.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1245 path: candoScript.general.let  type: subsection}\par
\subsection{let}
  \scriptCmd{let}{symbol object}\par
  \scriptInfix{symbol}{=}{object}

  Evaluate the arguments and put it into the local variable \scriptArg{symbol}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3126 path: candoScript.general.list  type: subsection}\par
\subsection{list}
  \scriptCmdRet{list}{object1 object2 ...}{list}\par
  \scriptCmdRet{:}{object1 object2 ...}{list}

  Return a list formed by evaluating the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2018 path: candoScript.general.listAllPackages  type: subsection}\par
\subsection{listAllPackages}
  \scriptCmdRet{listAllPackages}{}{Text::packageName}

  Return a list of all packages.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3014 path: candoScript.general.listref  type: subsection}\par
\subsection{listref}
  \scriptCmdRet{listref}{list index}{object}

  Return the element of the \scriptArg{list} at position \scriptArg{index}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2799 path: candoScript.general.load  type: subsection}\par
\subsection{load}
  \scriptCmd{load}{Text::fileName}

  Open the \sa{fileName}, compile and evaluate its contents.
  It looks through all of the directories in the global variable PATH and then 
  the Scripts directory in the Cando application directory.


\rule{6in}{0.01cm}\par
\framebox{Scraped from candoScript.cc 755 path: candoScript.general.loadArchive  type: subsection}\par
\subsection{loadArchive}
\scriptCmd{load}{ fileName:text [debug:level] }

Load an object from an archive and return it.


\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1214 path: candoScript.general.local  type: subsection}\par
\subsection{local}
  \scriptCmd{local}{symbol object}\par

  Evaluate the arguments and put it into the local variable \scriptArg{symbol}. If the local variable doesn't exist it is created.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2421 path: candoScript.general.localVariableNames  type: subsection}\par
\subsection{localVariableNames}
  \scriptCmdRet{localVariableNames}{}{Text::}

  Return a list of all local variable names.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2474 path: candoScript.general.locals  type: subsection}\par
\subsection{locals}
  \scriptCmdRet{locals}{}{Text::}

  Print a list of all local variable names.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3433 path: candoScript.general.lt  type: subsection}\par
\subsection{lt}
  \scriptCmdRet{lt}{valueA valueB }{Bool::}\par
  \scriptMethodRet{valueA}{$<$}{valueB }{Bool::}

  Return true if valueA $<$ valueB.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 1999 path: candoScript.general.makePackage  type: subsection}\par
\subsection{makePackage}
  \scriptCmdRet{makePackage}{}{Text::packageName}

  Make the package.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2815 path: candoScript.general.map  type: subsection}\par
\subsection{map}
\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2535 path: candoScript.general.max  type: subsection}\par
\subsection{max}
  \scriptCmdRet{max}{valueA:number valueB:number ...}{number}\par

  Return the max of the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2563 path: candoScript.general.min  type: subsection}\par
\subsection{min}
  \scriptCmdRet{min}{valueA:number valueB:number ...}{number}\par

  Return the min of the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3371 path: candoScript.general.mod  type: subsection}\par
\subsection{mod}
  \scriptCmdRet{mod}{valueA:number valueB:number}{number}\par

  Return the result of modulus of the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 1919 path: candoScript.general.mpiEnabled  type: subsection}\par
\subsection{mpiEnabled}
  \scriptCmdRet{mpiEnabled}{}{}

  Return true if MPI is enabled.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 1932 path: candoScript.general.mpiRank  type: subsection}\par
\subsection{mpiRank}
  \scriptCmdRet{mpiRank}{}{}

  Return the mpi rank or 0 if not enabled.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 1945 path: candoScript.general.mpiSize  type: subsection}\par
\subsection{mpiSize}
  \scriptCmdRet{mpiSize}{}{}

  Return the mpi rank or 0 if not enabled.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3294 path: candoScript.general.mul  type: subsection}\par
\subsection{mul}
  \scriptCmdRet{mul}{valueA:number valueB:number}{number}\par
  \scriptCmdRet{/}{valueA:number valueB:number}{number}

  Return the mulision of the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3416 path: candoScript.general.ne  type: subsection}\par
\subsection{ne}
  \scriptCmdRet{ne}{valueA valueB }{bool}\par
  \scriptInfixRet{valueA}{!=}{valueB }{bool}

  Return true if the objects are not equal. For some objects (numbers,strings,bools) it compares the objects values. For more complex objects it returns true if they are not identical.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3502 path: candoScript.general.not  type: subsection}\par
\subsection{not}
  \scriptCmdRet{not}{boolA}{bool}\par

  Return not boolA.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3533 path: candoScript.general.or  type: subsection}\par
\subsection{or}
  \scriptInfixRet{boolA}{or}{boolB}{Bool::}\par

  Return boolA OR boolB.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2311 path: candoScript.general.parseConsOfStrings  type: subsection}\par
\subsection{parseConsOfStrings}
  \scriptCmdRet{parseConsOfStrings}{}{Text::}

  Parse a string as a list of elements.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3613 path: candoScript.general.prin1  type: subsection}\par
\subsection{prin1}
  \scriptCmd{prin1}{args ...}\par

  Print string representations of the arguments with no new line.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3598 path: candoScript.general.print  type: subsection}\par
\subsection{print}
  \scriptCmd{println}{args ...}\par

  Print new line followed by string representations of the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3569 path: candoScript.general.printPopPrefix  type: subsection}\par
\subsection{printPopPrefix}
  \scriptCmd{printPopPrefixln}{args ...}\par

  Pop a prefix to be printed everytime print is called the arguments followed by a new line.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3555 path: candoScript.general.printPushPrefix  type: subsection}\par
\subsection{printPushPrefix}
  \scriptCmd{printPushPrefixln}{args ...}\par

  Push a prefix to be printed everytime print is called the arguments followed by a new line.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3583 path: candoScript.general.println  type: subsection}\par
\subsection{println}
  \scriptCmd{println}{args ...}\par

  Print string representations of the arguments followed by a new line.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3108 path: candoScript.general.repr  type: subsection}\par
\subsection{repr}
  \scriptCmdRet{repr}{object}{string}

  Return a string representation of the object.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2720 path: candoScript.general.require  type: subsection}\par
\subsection{require}
  \scriptCmd{export}{Text::fileName}

  Open the \sa{fileName}, compile and evaluate its contents.
  It looks through all of the directories in the global variable PATH and then 
  the Scripts directory in the Cando application directory.


\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2437 path: candoScript.general.sourceFileLine  type: subsection}\par
\subsection{sourceFileLine}
  \scriptCmdRet{sourceFileLine}{}{Cons::}

  Return the current file name and line number in a two element Cons.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 3158 path: candoScript.general.sub  type: subsection}\par
\subsection{sub}
  \scriptCmdRet{sub}{valueA:number valueB:number}{number}\par
  \scriptCmdRet{-}{valueA:number valueB:number}{number}

  Return the sum of the arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2642 path: candoScript.general.testScanner  type: subsection}\par
\subsection{scannerTest}
  \scriptCmd{testScanner}{Text::fileName}

  Open the \sa{fileName}, run it through the scanner to test it.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2101 path: candoScript.general.usePackage  type: subsection}\par
\subsection{usePackage}
  \scriptCmdRet{usePackage}{}{Symbol::packageName}

  Use the package. Return true if we used it.

\rule{6in}{0.01cm}\par
\framebox{Scraped from lisp.cc 2407 path: candoScript.general.yourself  type: subsection}\par
\subsection{yourself}
  \scriptCmdRet{yourself}{}{Object::}

  Return the value of the object.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1305 path: candoScript.macros  type: section}\par
\section{Macro commands}
These are special commands that manipulate the CandoScript environment.
They don't evaluate their arguments in the same way that all other CandoScript commands do.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1305 path: candoScript.macros.defClass  type: subsection}\par
\subsection{defClass}
  \scriptCmd{defClass}{Text::className instanceVariableNameList }\par
  \scriptCmd{defClass}{Text::className Class::baseCandoClass instanceVariableNameList }

  Define a class with the name \scriptArg{className}. 
  The \scriptArg{baseClass} is optional and if provided then this new class
  will inherit all of the instance variables and methods of the base class.
  The \scriptArg{instanceVariableNameList} are the names of the instance variables (slots) for this class. Each instance variable "x" will become part of the local namespace within methods for this class.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1432 path: candoScript.macros.defFunction  type: subsection}\par
\subsection{defFunction}
  \scriptCmd{defMacro}{macroName argumentNameList code...}

  Define a macro with the name \scriptArg{macroName}.
  The \scriptArg{argumentNameList} defines the variables that are
  passed to the \scriptArg{code...}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1383 path: candoScript.macros.defMethod  type: subsection}\par
\subsection{defMethod}
  \scriptCmd{defMethod}{Text::methodName Class::class argumentList code... }

  Define a method with the name \scriptArg{methodName} for the \scriptArg{class}.
  The first argument of the \scriptArg{argumentList} is the class 
  instance (the "self" or "this" object)  for which the method is being invoked.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1470 path: candoScript.macros.flet  type: subsection}\par
\subsection{flet}
  \scriptCmd{flet}{(function bindings) code...}

  Define functions in a new lexical environment.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1506 path: candoScript.macros.labels  type: subsection}\par
\subsection{labels}
  \scriptCmd{labels}{(function bindings) code...}

  Define functions recursively in new lexical environments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 1545 path: candoScript.macros.macroLet  type: subsection}\par
\subsection{macroLet}
  \scriptCmd{macroLet}{(function bindings) code...}

  Define macros recursively in new lexical environments.

\rule{6in}{0.01cm}\par
\framebox{Generated by matter.cc 645 path: candoScript.matter  type: section}\par
\section{matter}
\rule{6in}{0.01cm}\par
\framebox{Scraped from matter.cc 645 path: candoScript.matter.setAtomAliasesForResiduesNamed  type: subsection}\par
\subsection{setAtomAliasesForResiduesNamed}
\scriptCmd{extendAliases}{Cons::residuesAndInterestingAtomNames Cons::atomAliases}\par

Lookup the residues in the Matter and set the atom aliases of the atoms.


\begin{verbatim}
setAtomAliasesForResiduesNamed (:
        (: 'glu(S) (aliasAtoms 'OE ) )
        (: 'glu(R) (aliasAtoms 'OE ) )
    )
    (atomAliases 'carbO )
\end{verbatim}

\rule{6in}{0.01cm}\par
\framebox{Generated by monomerPack.cc 40 path: candoScript.monomerPack  type: section}\par
\section{monomerPack}
\rule{6in}{0.01cm}\par
\framebox{Scraped from monomerPack.cc 40 path: candoScript.monomerPack.createMonomerPack  type: subsection}\par
\subsection{createMonomerPack}
\scriptCmd{createMonomerPack}{name:text monomersAndInterestingAtomNames:list atomAliases:list }\par
\scriptCmd{createMonomerPack}{name:text monomersAndInterestingAtomNames:list}\par

Create a MonomerPack and put it into the database with the name: \scriptArg{name}. A MonomerPack is a group of Stereoisomers each of which has zero or more atom names associated with it that will be built by CANDO during rapid searching through sequence and conformational space. 

\begin{verbatim}
( aaGLu = [createMonomerPack "aaGlu"
    [parts
        [addPart 'glu(S) [aliasAtoms 'OE ] ]
        [addPart 'glu(R) [aliasAtoms 'OE ] ]
    ]
    [atomAliases 'carbO ]
] )
\end{verbatim}

The command names "parts" and "atomAliases" are aliases for the "list" command.

\rule{6in}{0.01cm}\par
\framebox{Scraped from monomerPack.cc 97 path: candoScript.monomerPack.extendAliases  type: subsection}\par
\subsection{extendAliases}
\scriptCmd{extendAliases}{Text::monomerPackName Cons::monomersAndInterestingAtomNames Cons::atomAliases}\par

Lookup a MonomerPack in the CandoDatabase and extend the interesting atom list.



\begin{verbatim}
extendAliases "allBis"
    (:
        (: 'glu(S) (aliasAtoms 'OE ) )
        (: 'glu(R) (aliasAtoms 'OE ) )
    )
    (atomAliases 'carbO )
) )
\end{verbatim}

\rule{6in}{0.01cm}\par
\framebox{Scraped from monomerPack.cc 140 path: candoScript.monomerPack.setMonomerPack  type: subsection}\par
\subsection{setMonomerPack}
\scriptCmd{setMonomerPack}{name:text monomersAndInterestingAtomNames:list atomAliases:list }\par
\scriptCmd{setMonomerPack}{name:text monomersAndInterestingAtomNames:list}\par

Create a MonomerPack and put it into the database with the name: \scriptArg{name}, also create a local variable with the name \sa{name} containing this MonomerPack. A MonomerPack is a group of Stereoisomers each of which has zero or more atom names associated with it that will be built by CANDO during rapid searching through sequence and conformational space. 

\begin{verbatim}
[setMonomerPack "aaGlu"
    [parts
        [addPart 'glu(S) [aliasAtoms 'OE ] ]
        [addPart 'glu(R) [aliasAtoms 'OE ] ]
    ]
    [atomAliases 'carbO ]
]
\end{verbatim}

The commands "parts" and "atomAliases" are aliases for the "list" command.

\rule{6in}{0.01cm}\par
\framebox{Scraped from ringFinder.cc 8 path: candoScript.ringFinder  type: section}\par
\section{Ring identification commands and objects}
Commands to identify rings and to manage RingFinder objects.

\rule{6in}{0.01cm}\par
\framebox{Scraped from ringFinder.cc 810 path: candoScript.ringFinder.identifyRings  type: subsection}\par
\subsection{identifyRings}
\scriptCmd{identifyRings}{matter}

Identify the Smallest Set of Smallest Rings (SSSR) for the Molecule or Aggregate \scriptArg{matter}.
Set the ring membership flags of the atoms that are in rings.

\rule{6in}{0.01cm}\par
\framebox{Generated by evaluator.cc 71 path: candoScript.specialForm  type: section}\par
\section{specialForm}
\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 792 path: candoScript.specialForm.ASSERT  type: subsection}\par
\subsection{ASSERT}
  \scriptCmd{ASSERT}{condition logString}

  If the condition is false then throw an exception with logString.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 770 path: candoScript.specialForm.LOG  type: subsection}\par
\subsection{LOG}
  \scriptCmd{LOG}{logString}

  If debugging is on the \scriptArg{logString} is written to the log.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 715 path: candoScript.specialForm.block  type: subsection}\par
\subsection{block}
  \scriptCmdRet{block}{command1 command2 ...}{lastObject}

  Evaluates each command and returns the value \scriptArg{lastObject} from evaluating the last command. This is what you use to write blocks of code.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 728 path: candoScript.specialForm.blockDEBUG  type: subsection}\par
\subsection{blockDEBUG}
  \scriptCmd{blockDEBUG}{command1 command2 ...}{lastObject}

  Evaluate the block only if debugging is enabled.
  Return the last evaluated element or nil.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 745 path: candoScript.specialForm.blockLOG  type: subsection}\par
\subsection{blockLOG}
  \scriptCmdRet{blockLOG}{"comment" command1 command2 ...}{lastObject}

  Works just like "block" but if debugging is enabled then it prints a message to the log file when this block is
  entered and when it exists.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 574 path: candoScript.specialForm.break  type: subsection}\par
\subsection{break}
  \scriptCmd{break}{}

  Break out of the current "foreach" or "while" loop.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 187 path: candoScript.specialForm.callAncestorMethod  type: subsection}\par
\subsection{callAncestorMethod}
  \scriptCmdRet{callAncestorMethod}{}{arg1 arg2 ...}

  Call the current method in an ancestor class.
  If no arguments are passed then use the current arguments.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 455 path: candoScript.specialForm.cond  type: subsection}\par
\subsection{cond}
  \scriptCmd{cond}{[ [cond1 code1 ...] [cond2 code2 ... ] ...] }\par

  Works just like lisp "cond" control structure. Evaluates each condition and for the first one that evaluates as true its associated block is evaluated.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 592 path: candoScript.specialForm.continue  type: subsection}\par
\subsection{continue}
  \scriptCmd{continue}{}

  Continue to the next iteration of the current "foreach" or "while" loop.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 878 path: candoScript.specialForm.foreach  type: subsection}\par
\subsection{foreach}
  \scriptCmd{foreach}{localVariableName list code}

  For each element of the list put it in the localVariableName and evaluate the code.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 651 path: candoScript.specialForm.function  type: subsection}\par
\subsection{function}
  \scriptCmd{function}{object}

  Returns function associated with the symbol.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 389 path: candoScript.specialForm.if  type: subsection}\par
\subsection{if}
  \scriptCmd{if}{condition thenCode elseCode}\par
  \scriptCmd{if}{condition thenCode }

  If/then/else control statement.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 416 path: candoScript.specialForm.ifTrue  type: subsection}\par
\subsection{ifTrue}
  \scriptCmd{ifFalse}{condition thenCode1 thenCode2 ...}\par

  If the condition is true then evaluate the thenCodes.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 364 path: candoScript.specialForm.invoke  type: subsection}\par
\subsection{invoke}
  \scriptCmd{invoke}{Symbol::variable Cons::argumentList}\par

  Lookup the function in \sa{variable} and call it with \sa{argumentList}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 962 path: candoScript.specialForm.lambda  type: subsection}\par
\subsection{lambda}
  \scriptCmdRet{lambda}{arguments code}{object}

  Creates an anonymous function that takes a list of \scriptArg{arguments} and evaluates \scriptArg{code} and returns the result.
  This is used for functional programming.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 71 path: candoScript.specialForm.let  type: subsection}\par
\subsection{let}
  \scriptCmd{let\*}{assignments code}

  Assign lexical variables and then evaluate code in that context.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 271 path: candoScript.specialForm.method  type: subsection}\par
\subsection{method}
  \scriptCmd{method}{name arguments code1 code2 code3 ...}\par

  Define a method within a class definition

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 257 path: candoScript.specialForm.pass  type: subsection}\par
\subsection{pass}
  \scriptCmd{pass}{}\par

  Do nothing

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 994 path: candoScript.specialForm.quote  type: subsection}\par
\subsection{quote}
  \scriptCmdRet{quote}{object}{unevaluatedObject}

  Returns the \scriptArg{object} without evaluating it.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 687 path: candoScript.specialForm.return  type: subsection}\par
\subsection{return}
  \scriptCmd{return}{object}

  Returns from the current function/method and returns the object.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 241 path: candoScript.specialForm.slot  type: subsection}\par
\subsection{slot}
  \scriptCmd{slot}{object selector}\par

  Return the value of the slot within the CandoObject.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 615 path: candoScript.specialForm.throw  type: subsection}\par
\subsection{throw}
  \scriptCmd{throw}{messageString}

  Throw an exception. For now just throw string messages.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 223 path: candoScript.specialForm.when  type: subsection}\par
\subsection{when}
  \scriptCmd{ifTrue}{condition thenCode1 thenCode2 ...}\par

  If the condition is true then evaluate the thenCodes.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 831 path: candoScript.specialForm.while  type: subsection}\par
\subsection{while}
  \scriptCmd{while}{condition code}

  While \scriptArg{condition} is True \scriptArg{code} is evaluated.

  Example:
  \begin{verbatim}
  ( x = 1 )
  [while ( x < 10 ) [block
  [println ( "x = %d" % x ) ]
  ( x = ( x + 1 ) )
  ] ]
  \end{verbatim}

\rule{6in}{0.01cm}\par
\framebox{Generated by evaluator.cc 31 path: candoScript.specialForms  type: section}\par
\section{specialForms}
\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 53 path: candoScript.specialForms.debug  type: subsection}\par
\subsection{debug}
  \scriptCmdRet{debug}{}{}

  Start the debugger.

\rule{6in}{0.01cm}\par
\framebox{Scraped from evaluator.cc 31 path: candoScript.specialForms.eval  type: subsection}\par
\subsection{eval}
  \scriptCmdRet{eval}{}{Cons::expression}

  Evaluate the expression.

\rule{6in}{0.01cm}\par
\framebox{Scraped from alchemist.cc 130 path: classes  type: chapter}\par
\chapter{Cando Object Classes}

This chapter describes the classes and methods available within Cando-Script.

\rule{6in}{0.01cm}\par
\framebox{Scraped from alchemist.cc 130 path: classes.Alchemist  type: section}\par
\section{Alchemist}
  \inheritsFrom{Object}

  A Alchemist object builds three-dimensional structures of Oligomers. To achieve this, a Alchemist needs to be given at least one Oligomer object using ``addOligomer'' and any MonomerPacks that are used by the Oligomer using the ``addMonomerPack'' method.

  A Alchemist object can be given any number of Oligomers and when its building an Oligomer it creates and manages an Kinemat object that does the actual building of a single Oligomer.

  A Alchemist object lets the user select between the oligomers that it has been given, select between the sequences of the current oligomer and select between the conformationsof the current sequence. It allows the user to build the entire three-dimensional structure of the current conformation or just the ``interesting'' atoms.

\rule{6in}{0.01cm}\par
\framebox{Generated by alias.cc 47 path: classes.Alias  type: section}\par
\section{Alias}
\rule{6in}{0.01cm}\par
\framebox{Generated by alias.cc 47 path: classes.Alias.!class  type: subsection}\par
\subsection{Alias class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from alias.cc 47 path: classes.Alias.!class.Alias  type: subsubsection}\par
\subsubsection{Alias}
\positional{Text::monomerAlias Text::atomAlias}

Create an Alias object that maintains a \sa{monomerAlias} name and an \sa{atomAlias} name.

\rule{6in}{0.01cm}\par
\framebox{Generated by anchor.cc 97 path: classes.AnchorOnOtherSideOfPlug  type: section}\par
\section{AnchorOnOtherSideOfPlug}
\rule{6in}{0.01cm}\par
\framebox{Generated by anchor.cc 97 path: classes.AnchorOnOtherSideOfPlug.!class  type: subsection}\par
\subsection{AnchorOnOtherSideOfPlug class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from anchor.cc 97 path: classes.AnchorOnOtherSideOfPlug.!class.AnchorOnOtherSideOfPlug  type: subsubsection}\par
\subsubsection{AnchorOnOtherSideOfPlug}
\requiredKeyed{plugName:}{Text::plugName}

\rule{6in}{0.01cm}\par
\framebox{Generated by atomGrid.cc 56 path: classes.AtomGrid  type: section}\par
\section{AtomGrid}
\rule{6in}{0.01cm}\par
\framebox{Generated by atomGrid.cc 56 path: classes.AtomGrid.!class  type: subsection}\par
\subsection{AtomGrid class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from atomGrid.cc 56 path: classes.AtomGrid.!class.AtomGrid  type: subsubsection}\par
\subsubsection{AtomGrid}
\positional{Matter::matter}
\optionalKeyed{gridResolution}
\optionalKeyed{addRadius}
\optionalKeyed{withinSphere}{List::sphere}

\rule{6in}{0.01cm}\par
\framebox{Generated by chemdraw.cc 714 path: classes.ChemDraw  type: section}\par
\section{ChemDraw}
\rule{6in}{0.01cm}\par
\framebox{Generated by chemdraw.cc 714 path: classes.ChemDraw.!class  type: subsection}\par
\subsection{ChemDraw class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from chemdraw.cc 714 path: classes.ChemDraw.!class.ChemDraw  type: subsubsection}\par
\subsubsection{ChemDraw}
\requiredKeyed{fileName:}{Text::name}

Define a ChemDraw object.  Load a cdxml file from \sa{name} and return the ChemDraw object define by it.

\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 130 path: classes.ExplicitFrame  type: section}\par
\section{ExplicitFrame}
\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 130 path: classes.ExplicitFrame.!class  type: subsection}\par
\subsection{ExplicitFrame class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from frame.cc 130 path: classes.ExplicitFrame.!class.ExplicitFrame  type: subsubsection}\par
\subsubsection{ExplicitFrame}
\requiredKeyed{name:}{Text::nameOfExplicitFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{xAtom:}{Text::nameOfXAtom}
\requiredKeyed{xyAtom:}{Text::nameOfXYAtom}

Define a ExplicitFrame with \sa{nameOfExplicitFrame} and centered on the atom with name \sa{nameOfOriginAtom}
with the x-axis on \sa{nameOfXAtom} and xy-plane on \sa{nameOfXYAtom}.


\rule{6in}{0.01cm}\par
\framebox{Generated by extractFrame.cc 123 path: classes.ExtractFrameFinisher  type: section}\par
\section{ExtractFrameFinisher}
\rule{6in}{0.01cm}\par
\framebox{Generated by extractFrame.cc 123 path: classes.ExtractFrameFinisher.!class  type: subsection}\par
\subsection{ExtractFrameFinisher class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from extractFrame.cc 123 path: classes.ExtractFrameFinisher.!class.ExtractFrameFinisher  type: subsubsection}\par
\subsubsection{ExtractFrameFinisher}
\requiredKeyed{othersFrameName:}{Text::othersFrameName}
\requiredKeyed{plugName:}{Text::myPlugName}
\requiredKeyed{overlapsFrame:}{Frame::myFrame}
\requiredKeyed{recognizer:}{FrameRecognizer::recognizer}


Create an object that will extract a frame of reference that has its
origin atom in a preceeding monomer but overlaps this monomer.  
You must specify a frame of reference in this monomer \sa{myFrame} that overlaps the
others frame of reference and the FrameRecognizer that will recognize the others frame
of reference.

\rule{6in}{0.01cm}\par
\framebox{Generated by fragment.cc 94 path: classes.Fragment  type: section}\par
\section{Fragment}
\rule{6in}{0.01cm}\par
\framebox{Generated by fragment.cc 94 path: classes.Fragment.!class  type: subsection}\par
\subsection{Fragment class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from fragment.cc 94 path: classes.Fragment.!class.Fragment  type: subsubsection}\par
\subsubsection{Fragment}
\requiredKeyed{name:}{Text::nameOfFragment}
\requiredKeyed{atoms:}{Cons::listOfAtomNames}

Define a Fragment with \sa{nameOfFragment} and containing the atom named in \sa{listOfAtomNames}.


\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 40 path: classes.Frame  type: section}\par
\section{Frame}
\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 40 path: classes.Frame.!class  type: subsection}\par
\subsection{Frame class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from frame.cc 40 path: classes.Frame.!class.Frame  type: subsubsection}\par
\subsubsection{Frame}
\requiredKeyed{name:}{Text::nameOfFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{xAtom:}{Text::nameOfXAtom}
\requiredKeyed{xyAtom:}{Text::nameOfXYAtom}

Define a Frame with \sa{nameOfFrame} and centered on the atom with name \sa{nameOfOriginAtom}
with the x-axis on \sa{nameOfXAtom} and xy-plane on \sa{nameOfXYAtom}.


\rule{6in}{0.01cm}\par
\framebox{Generated by hits.cc 174 path: classes.Hit  type: section}\par
\section{Hit}
\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 222 path: classes.Hit.getBuiltMolecule  type: subsection}\par
\subsection{getBuiltMolecule}
  \returns{Molecule::structure}

  Looks up the ``alchemistState'' entry in the hit data and recreates a alchemist in the state that it was when the hit was identified. This method then returns the molecule with all atoms built in the hit conformation.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 210 path: classes.Hit.getData  type: subsection}\par
\subsection{getData}
  \returns{Dictionary::data}

  Return the Dictionary associated with the hit. The dictionary stores name/object pairs that describe the hit. The user can put any data they want into this dictionary.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 174 path: classes.Hit.getScore  type: subsection}\par
\subsection{getScore}
  \returns{Real::score}

  Return the score value of the hit.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 239 path: classes.Hit.recreateGenerator  type: subsection}\par
\subsection{recreateGenerator}
  \returns{Generator::generator}

  This method restores the Generator to exactly the state that it had when the hit was recorded.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 186 path: classes.Hit.setScore  type: subsection}\par
\subsection{setScore}
  \positional{Real::value}

  Set the score value of the hit.  Only use this method on hits that haven't been added yet to a HitList - once the hit is in a HitList changing the score will mess up the ordering in the HitList.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 483 path: classes.HitList  type: section}\par
\section{HitList commands}
  Commands that operate on HitLists.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 667 path: classes.HitList.addAllHits  type: subsection}\par
\subsection{addAllHits}
  \scriptMethod{hitList}{addAllHits}{HitList::hits}\par
  Adds all of the hits in \sa{hits} to \sa{hitList}. If the \sa{hitList} becomes overfull then the excess hits are discarded.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 618 path: classes.HitList.addHit  type: subsection}\par
\subsection{addHit}
  \scriptMethod{hitList}{addHit}{Hit::hit}\par
  Adds the \sa{hit} to \sa{hitList} if it isn't already in there. If the \sa{hitList} becomes overfull then the excess hits are discarded.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 762 path: classes.HitList.describe  type: subsection}\par
\subsection{describe}
  \scriptMethod{hitList}{describe}{}\par
  Print a description of the contents of the HitList.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 687 path: classes.HitList.getHit  type: subsection}\par
\subsection{getHit}
  \scriptMethodRet{hitList}{getHit}{Int::index}{Hit::}\par
  Return a hit by its index value \sa{index} (zero is the first entry). If the index is beyond the end of the \sa{hitList} then the nil object [] is returned.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 890 path: classes.HitList.hitListGet  type: subsection}\par
\subsection{hitListGet}
  \scriptCmd{hitListGet}{hitList index}\par
  Return the hit at \scriptArg{index} from the \scriptArg{hitList}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 496 path: classes.HitList.isAHit  type: subsection}\par
\subsection{isAHit}
  \scriptMethodRet{hitList}{isAHit}{Real::score}{Bool::}\par
  This method is used to evaluate if a new score represents a hit that is good enough to add to \sa{hitList}.
  Compare the \sa{score} to the scores of every hit in this list. If \sa{score} is better than the worst score in the list then return true, if not return false. 

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 483 path: classes.HitList.numberOfHits  type: subsection}\par
\subsection{numberOfHits}
  \scriptMethodRet{hitList}{numberOfHits}{}{Int::}\par
  Return the number of hits in this HitList.

\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 477 path: classes.InPlug  type: section}\par
\section{InPlug}
\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 477 path: classes.InPlug.!class  type: subsection}\par
\subsection{InPlug class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 477 path: classes.InPlug.!class.InPlug  type: subsubsection}\par
\subsubsection{InPlug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}

Initialize a InPlug object. InPlugs can have one bond (eg: amide) or two bonds (eg:diketopiperazine).

\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 435 path: classes.IncompleteFrame  type: section}\par
\section{IncompleteFrame}
\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 435 path: classes.IncompleteFrame.!class  type: subsection}\par
\subsection{IncompleteFrame class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from frame.cc 435 path: classes.IncompleteFrame.!class.IncompleteFrame  type: subsubsection}\par
\subsubsection{IncompleteFrame}
\requiredKeyed{name:}{Text::nameOfFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{recognizer:}{FrameRecognizer::recognizer}

Define a IncompleteFrame with \sa{nameOfFrame} and centered on the atom with name \sa{nameOfOriginAtom}
recognized by \sa{recognizer}.


\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 143 path: classes.Mate  type: section}\par
\section{Mate}
\inheritsFrom{MonomerGrouper}
A MonomerSet that keeps track of a capping monomer that is used to cap training oligomers when they are being defined.
The capping monomer is supposed to be small and best represent the other members of the Mate.

\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 152 path: classes.Mate.!class  type: subsection}\par
\subsection{Mate class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 152 path: classes.Mate.!class.Mate  type: subsubsection}\par
\subsubsection{Mate}
\requiredKeyed{cap:}{Text::capName}
\requiredKeyed{groupNames:}{List::groupNames}

Initialize a Mate object.

\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 209 path: classes.OneAtomFrame  type: section}\par
\section{OneAtomFrame}
\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 209 path: classes.OneAtomFrame.!class  type: subsection}\par
\subsection{OneAtomFrame class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from frame.cc 209 path: classes.OneAtomFrame.!class.OneAtomFrame  type: subsubsection}\par
\subsubsection{OneAtomFrame}
\requiredKeyed{name:}{Text::nameOfOneAtomFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}

Define a OneAtomFrame with \sa{nameOfOneAtomFrame} and centered on the atom with name \sa{nameOfOriginAtom}.


\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 513 path: classes.OriginPlug  type: section}\par
\section{OriginPlug}
\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 513 path: classes.OriginPlug.!class  type: subsection}\par
\subsection{OriginPlug class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 513 path: classes.OriginPlug.!class.OriginPlug  type: subsubsection}\par
\subsubsection{OriginPlug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{originFrame:}{Frame::originFrame}

Initialize a OriginPlug object. OriginPlugs don't make bonds don't have mates but they do have an origin frame that is within the topology.

\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 403 path: classes.OutPlug  type: section}\par
\section{OutPlug}
\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 403 path: classes.OutPlug.!class  type: subsection}\par
\subsection{OutPlug class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 403 path: classes.OutPlug.!class.OutPlug  type: subsubsection}\par
\subsubsection{OutPlug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}
\optionalKeyed{exportFrame:}{Frame::exportFrame}

Initialize a OutPlug object. OutPlugs can have one bond (eg: amide) or two bonds (eg:diketopiperazine).
Outgoing plugs export a frame of reference to the next monomer, use \sa{exportFrame} to define this.

\rule{6in}{0.01cm}\par
\framebox{Generated by fileSystem.cc 172 path: classes.Path  type: section}\par
\section{Path}
\rule{6in}{0.01cm}\par
\framebox{Generated by fileSystem.cc 172 path: classes.Path.!class  type: subsection}\par
\subsection{Path class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from fileSystem.cc 172 path: classes.Path.!class.Path  type: subsubsection}\par
\subsubsection{Path}
\optionalKeyed{path:}{Text::path}

Create a Path object that maintains a system independant path to a file in the file system.

\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 179 path: classes.Plug  type: section}\par
\section{Plug}
Defines one or two atoms of this monomer that can be plugged into, a plug name and a
collection of Mate objects that can act as mates for this plug.

\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 192 path: classes.Plug.!class  type: subsection}\par
\subsection{Plug class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 192 path: classes.Plug.!class.Plug  type: subsubsection}\par
\subsubsection{Plug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}
\optionalKeyed{exportFrame:}{Frame::exportFrame}

Initialize a Plug object. Plugs can have one bond (eg: amide) or two bonds (eg:diketopiperazine).
Outgoing plugs export a frame of reference to the next monomer, use \sa{exportFrame} to define this.

\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 308 path: classes.PlugWithMates  type: section}\par
\section{PlugWithMates}
Defines one or two atoms of this monomer that can be plugged into, a plug name and a
collection of Mate objects that can act as mates for this plug.

\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 319 path: classes.PlugWithMates.!class  type: subsection}\par
\subsection{PlugWithMates class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 319 path: classes.PlugWithMates.!class.PlugWithMates  type: subsubsection}\par
\subsubsection{PlugWithMates}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}

Initialize a PlugWithMates object. PlugWithMatess can have one bond (eg: amide) or two bonds (eg:diketopiperazine).

\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 356 path: classes.RecognizedFrame  type: section}\par
\section{RecognizedFrame}
\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 356 path: classes.RecognizedFrame.!class  type: subsection}\par
\subsection{RecognizedFrame class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from frame.cc 356 path: classes.RecognizedFrame.!class.RecognizedFrame  type: subsubsection}\par
\subsubsection{RecognizedFrame}
\requiredKeyed{name:}{Text::nameOfFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{recognizer:}{FrameRecognizer::recognizer}

Define a RecognizedFrame with \sa{nameOfFrame} and centered on the atom with name \sa{nameOfOriginAtom}
recognized by \sa{recognizer}.


\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 67 path: classes.RingClosingMate  type: section}\par
\section{RingClosingMate}
\inheritsFrom{MonomerGrouper}
A MonomerSet that keeps track of a capping monomer that is used to cap training oligomers when they are being defined.
The capping monomer is supposed to be small and best represent the other members of the RingClosingMate.

\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 75 path: classes.RingClosingMate.!class  type: subsection}\par
\subsection{RingClosingMate class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 75 path: classes.RingClosingMate.!class.RingClosingMate  type: subsubsection}\par
\subsubsection{RingClosingMate}
\requiredKeyed{groupNames:}{List::groupNames}

Initialize a RingClosingMate object.

\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 577 path: classes.RingClosingPlug  type: section}\par
\section{RingClosingPlug}
\rule{6in}{0.01cm}\par
\framebox{Generated by plug.cc 577 path: classes.RingClosingPlug.!class  type: subsection}\par
\subsection{RingClosingPlug class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from plug.cc 577 path: classes.RingClosingPlug.!class.RingClosingPlug  type: subsubsection}\par
\subsubsection{RingClosingPlug}
\requiredKeyed{name:}{Text::plugName}
\requiredKeyed{bond0:}{Text::bond0AtomName}
\optionalKeyed{bond1:}{Text::bond1AtomName}
\requiredKeyed{mates:}{Cons::listOfMates}
\optionalKeyed{exportFrame:}{Frame::exportFrame}
\requiredKeyed{ringClosingMates:}{Cons::listOfRingClosingMates}

Initialize a RingClosingPlug object. RingClosingPlugs can have one bond (eg: amide) or two bonds (eg:diketopiperazine).
RingClosingPlugs export a frame of reference to the next monomer, use \sa{exportFrame} to define this.
There is an additional list of ringClosingMates that can be attached to this plug without building the mates.

\rule{6in}{0.01cm}\par
\framebox{Generated by stereochemistry.cc 52 path: classes.StereoConfiguration  type: section}\par
\section{StereoConfiguration}
\rule{6in}{0.01cm}\par
\framebox{Generated by stereochemistry.cc 52 path: classes.StereoConfiguration.!class  type: subsection}\par
\subsection{StereoConfiguration class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from stereochemistry.cc 52 path: classes.StereoConfiguration.!class.StereoConfiguration  type: subsubsection}\par
\subsubsection{StereoConfiguration}
\requiredKeyed{atomName:}{Text::atom}
\requiredKeyed{config:}{Text::configuration}

Provide the atom name and the stereo-configuration \sa{configuration} of "R" or "S".

\rule{6in}{0.01cm}\par
\framebox{Generated by stereochemistry.cc 294 path: classes.StereoInformation  type: section}\par
\section{StereoInformation}
\rule{6in}{0.01cm}\par
\framebox{Generated by stereochemistry.cc 334 path: classes.StereoInformation.!class  type: subsection}\par
\subsection{StereoInformation class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from stereochemistry.cc 334 path: classes.StereoInformation.!class.StereoInformation  type: subsubsection}\par
\subsubsection{StereoInformation}
\requiredKeyed{stereoisomers:}{List::stereoisomers}
\optionalKeyed{proChiralCenters:}{List::}
\optionalKeyed{constrainedPiBonds:}{List::}

\rule{6in}{0.01cm}\par
\framebox{Generated by stereochemistry.cc 294 path: classes.StereoInformation.!instance  type: subsection}\par
\subsection{StereoInformation instance methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from stereochemistry.cc 294 path: classes.StereoInformation.!instance.addProChiralCenter  type: subsubsection}\par
\subsubsection{addProChiralCenter}
\scriptMethod{self}{addProChiralCenter}{ProChiralCenter::center}

Add the \sa{center} to the StereoInformation object.

\rule{6in}{0.01cm}\par
\framebox{Generated by stereochemistry.cc 222 path: classes.Stereoisomer  type: section}\par
\section{Stereoisomer}
\rule{6in}{0.01cm}\par
\framebox{Generated by stereochemistry.cc 222 path: classes.Stereoisomer.!class  type: subsection}\par
\subsection{Stereoisomer class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from stereochemistry.cc 243 path: classes.Stereoisomer.!class.MultiStereoisomers  type: subsubsection}\par
\subsubsection{MultiStereoisomers}
\scriptCmdRet{MultiStereoisomers}{nameTemplate:(Text::template) centers:(List::) configs:(List::)}{Cons::stereoisomers}

\rule{6in}{0.01cm}\par
\framebox{Scraped from stereochemistry.cc 222 path: classes.Stereoisomer.!class.Stereoisomer  type: subsubsection}\par
\subsubsection{Stereoisomer}
\scriptCmdRet{Stereoisomer}{name:(Text::name) pdb:(Text::pdb) configs:(List::)}{StereoIsomer::}

\rule{6in}{0.01cm}\par
\framebox{Generated by stringSet.cc 30 path: classes.StringSet  type: section}\par
\section{StringSet}
\rule{6in}{0.01cm}\par
\framebox{Generated by stringSet.cc 30 path: classes.StringSet.!class  type: subsection}\par
\subsection{StringSet class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from stringSet.cc 30 path: classes.StringSet.!class.StringSet  type: subsubsection}\par
\subsubsection{StringSet}
\requiredKeyed{entries:}{Cons::listOfStrings}

Create a StringSet containing the strings in \sa{listOfStrings}.

\rule{6in}{0.01cm}\par
\framebox{Generated by symbolSet.cc 34 path: classes.SymbolSet  type: section}\par
\section{SymbolSet}
\rule{6in}{0.01cm}\par
\framebox{Generated by symbolSet.cc 34 path: classes.SymbolSet.!class  type: subsection}\par
\subsection{SymbolSet class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from symbolSet.cc 34 path: classes.SymbolSet.!class.SymbolSet  type: subsubsection}\par
\subsubsection{SymbolSet}
\requiredKeyed{entries:}{Cons::listOfStrings}

Create a SymbolSet containing the strings in \sa{listOfStrings}.

\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 276 path: classes.TwoAtomFrame  type: section}\par
\section{TwoAtomFrame}
\rule{6in}{0.01cm}\par
\framebox{Generated by frame.cc 276 path: classes.TwoAtomFrame.!class  type: subsection}\par
\subsection{TwoAtomFrame class methods}
\rule{6in}{0.01cm}\par
\framebox{Scraped from frame.cc 276 path: classes.TwoAtomFrame.!class.TwoAtomFrame  type: subsubsection}\par
\subsubsection{TwoAtomFrame}
\requiredKeyed{name:}{Text::nameOfTwoAtomFrame}
\requiredKeyed{origin:}{Text::nameOfOriginAtom}
\requiredKeyed{xAtom:}{Text::nameOfXAtom}

Define a TwoAtomFrame with \sa{nameOfTwoAtomFrame} and centered on the atom with name \sa{nameOfOriginAtom}
with the x-axis on \sa{nameOfXAtom}.


\rule{6in}{0.01cm}\par
\framebox{Scraped from metaClass.cc 344 path: classes.classMethods  type: section}\par
\section{Class methods}
In Cando-Script class names like ``Hit'' or ``Real'' return objects that are of the class ``Class''.  These objects respond to the following methods.

\rule{6in}{0.01cm}\par
\framebox{Scraped from metaClass.cc 344 path: classes.classMethods.describe  type: subsection}\par
\subsection{describe}
\scriptCmd{describe}{classObject}

Dumps a description of the class to stdout.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 317 path: classes.hitList  type: section}\par
\section{HitList class}
  HitList objects store a sorted list of Hit objects as well as a Dictionary for name/object pairs.

\rule{6in}{0.01cm}\par
\framebox{Scraped from hits.cc 865 path: classes.hitList.setHitList  type: subsection}\par
\subsection{setHitList}
  \scriptCmd{setHitList}{'symbol maxHits:int}\par
  Create a HitList that can store \scriptArg{maxHits} and put it into the variable named \scriptArg{'symbol}.

\rule{6in}{0.01cm}\par
\framebox{Scraped from msmarts_Parser.yy 65 path: msmarts  type: chapter}\par
\chapter{MSMARTS chemical pattern matching}

Based on SMARTS documentation at 
\begin{verbatim}
http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html
\end{verbatim}

MSMARTS is similar to SMARTS with the following differences.
\begin{itemize}
	\item MSMARTS supports atom tags: numerical labels that can be attached to atoms as an MSMARTS substructure is matched to a molecule. The tagged atoms can then be referenced after the substructure is matched.

	For example: the MSMARTS string "[N\&H1]1C2(=O3)" will recognize a secondary amide and the amide nitrogen, carbonyl carbon and carbonyl oxygen can be obtained using the tags "1", "2" and "3" after a successful match.
	\item The syntax for identifying rings is different. Rings are recognized with strings like: "C1CCC[C\&?1]".  The first "1" assigns a tag "1" to the first carbon, The "[C\&?1]" atom tests if the atom is carbon and has the tag "1".
\end{itemize}

   Substructure searching, the process of finding a particular pattern (subgraph) in a molecule (graph), is one of the most important tasks for computers in chemistry. It is used in virtually every application that employs a digital representation of a molecule, including depiction (to highlight a particular functional group), drug design (searching a database for similar structures and activity), analytical chemistry (looking for previously-characterized structures and comparing their data to that of an unknown), and a host of other problems.

   MSMARTS expressions allow a chemist to specify substructures using rules that 
   are straightforward extensions of SMILES. For example: to search a database 
   for phenol-containing structures, one would use the SMARTS string 
   [OH]c1cccc[c\&?1], which is similar to SMILES (Note: the [c\&?1] atom 
   primative test is used to identify rings in MSMARTS). In fact, almost all 
   SMILES specifications are valid SMARTS targets. Using SMARTS, flexible 
   and efficient substructure-search specifications can be made in terms 
   that are meaningful to chemists.

   In the SMILES language, there are two fundamental types of symbols: atoms and bonds. Using these SMILES symbols, once can specify a molecule's graph (its "nodes" and "edges") and assign "labels" to the components of the graph (that is, say what type of atom each node represents, and what type of bond each edge represents).

   The same is true in SMARTS: One uses atomic and bond symbols to specify a graph. However, in SMARTS the labels for the graph's nodes and edges (its "atoms" and "bonds") are extended to include "logical operators" and special atomic and bond symbols; these allow SMARTS atoms and bonds to be more general. For example, the SMARTS atomic symbol [C,N] is an atom that can be aliphatic C or aliphatic N; the SMARTS bond symbol ~ (tilde) matches any bond.

Below is example code that uses SMARTS to find every amide bond in a molecule:
\begin{verbatim}
#
# Define a ChemInfo object that can carry out
# substructure searches
#
( amideSmarts = [ new ChemInfo] )
#
# Compile a substructure pattern using SMARTS code
#
( amideSmarts compileSmarts "N1~C2=O3" )
# 
# Load a molecule
#
( p53 = [ loadMol2 "p53.mol2" ] )
#
# Iterate through every atom and if it matches
# the substructure search then extract the tagged
# atoms and print their names
#
[foreach a [ atoms p53 ] [block
    [ if ( amideSmarts matches a ) [block 
        [println ( "-----Matching atom: %s" % ( a getName ) ) ]
        ( coAtom = ( amideSmarts getAtomWithTag "2" ) )
        ( oAtom = ( amideSmarts getAtomWithTag "3" ) )
        [ println ( "    Carbonyl carbon: %s" % ( coAtom getName ) ) ]
        [ println ( "    Carbonyl oxygen: %s" % ( oAtom getName ) ) ]
    ] ]
] ]
\end{verbatim}

\rule{6in}{0.01cm}\par
\framebox{Scraped from msmarts_Parser.yy 300 path: msmarts.atomics  type: section}\par
\section{Atomic Primitives}
   SMARTS provides a number of primitive symbols describing atomic properties beyond those used in SMILES (atomic symbol, charge, and isotopic specifications). The following tables list the atomic primitives used in SMARTS (all SMILES atomic symbols are also legal). In these tables <n> stands for a digit, <c> for chiral class.

   Note that atomic primitive H can have two meanings, implying a property or the element itself. [H] means hydrogen atom. [*H2] means any atom with exactly two hydrogens attached
   
   	\begin{tabular}{| l | l | l | l |}
	\hline
	Symbol & Symbol name & Atomic property requirements & Default \\ \hline
	* & wildcard & any atom & (no default) \\ \hline
	D\emph{n} & APDegree & explicit connections & exactly one \\ \hline
	H\emph{n} & APTotalHCount& \emph{n} attached hydrogens & exactly one \\ \hline
	h\emph{n} & APImplicitHCount& \emph{n} implicit attached hydrogens & at least one\\ \hline
	?\emph{n} & APRingTest& Atom is matched to atom tagged with \emph{n}& (no default)\\ \hline
	U\emph{n} & APResidueTest& Atom must be in same residue as atom tagged \emph{n}& (no default)\\ \hline
	R\emph{n} & APRingMemberCount & is in \emph{n} SSSR rings \par(WORKS?)& any ring atom\\ \hline
	r\emph{n} & APRingSize & is in smallest SSSR size \emph{n} & any ring atom\\ \hline
	v\emph{n} & APValence & total bond order \emph{n} & exactly 1 \\ \hline
	X\emph{n} & APConnectivity& \emph{n} total connections & exactly 1 \\ \hline
	-\emph{n} & APNegativeCharge & -\emph{n} charge & exactly -1 \\ \hline
	-- & APNegativeCharge 2x & -2 charge & exactly -2 \\ \hline
	--- & APNegativeCharge 3x & -3 charge & exactly -3 \\ \hline
	+\emph{n} & APPositiveCharge & +\emph{n} charge & exactly +1 \\ \hline
	++ & APPositiveCharge 2x & +2 charge & exactly +2 \\ \hline
	+++ & APPositiveCharge 3x & +3 charge & exactly +3 \\ \hline
	\#\emph{n} & APAtomicNumber & atomic number \emph{n} & (no default) \\ \hline
	\emph{n} & APAtomicMass & atomic mass \emph{n} & (no default) \\ \hline
	\$(\emph{\tiny MSMARTS}) & recursive MSMARTS & match recursive MSMARTS & (no default) \\ \hline
\end{tabular}

Some of these have not been debugged. Test before you trust them.

Examples: \par
\begin{tabular}{| l | l |}
\hline
  [CH2] & aliphatic carbon with two hydrogens (methylene carbon) \\ \hline
  [!C;R] & ( NOT aliphatic carbon ) AND in ring \\ \hline
  [!C;!R0] & same as above ("!R0" means not in zero rings) \\ \hline
  [n;H1] & H-pyrrole nitrogen \\ \hline
  [n\&H1] & same as above \\ \hline
  [nH1] & same as above \\ \hline
  [c,n\&H1] & any arom carbon OR H-pyrrole nitrogen \\ \hline
  [X3\&H0] & atom with 3 total bonds and no H's \\ \hline
  [c,n;H1] & (arom carbon OR arom nitrogen)  and exactly one H \\ \hline
  [Cl] & any chlorine atom \\ \hline
  [35*] & any atom of mass 35 \\ \hline
  [35Cl] & chlorine atom of mass 35 \\ \hline
  [F,Cl,Br,I] & the 1st four halogens. \\ \hline
\end{tabular}

\rule{6in}{0.01cm}\par
\framebox{Scraped from msmarts_Parser.yy 667 path: msmarts.logical  type: section}\par
\section{Logical Operators}

 Atom and bond primitive specifications may be combined to form expressions by using logical operators. In the following table, e is an atom or bond SMARTS expression (which may be a primitive). The logical operators are listed in order of decreasing precedence (high precedence operators are evaluated first).

All atomic expressions which are not simple primitives must be enclosed in brackets. The default operation is \& (high precedence "and"), i.e., two adjacent primitives without an intervening logical operator must both be true for the expression (or subexpression) to be true.

The ability to form expressions gives the SMARTS user a great deal of power to specify exactly what is desired. The two forms of the AND operator are used in SMARTS instead of grouping operators.

\begin{tabular}{|l|l|l|}
\hline
\textbf{Symbol} & \textbf{Expression} & \textbf{Meaning} \\ \hline
exclamation & !e1 & not e1 \\ \hline
ampersand & e1\&e2 & e1 and e2 (high precedence) \\ \hline
comma & e1,e2  & e1 or e2 \\ \hline
semicolon & e1;e2  & e1 and e2 (low precedence) \\ \hline
\end{tabular}

\rule{6in}{0.01cm}\par
\framebox{Scraped from msmarts_Parser.yy 651 path: msmarts.recursive  type: section}\par
\section{Recursive MSMARTS}

     Any MSMARTS expression may be used to define an atomic environment by writing a SMARTS starting with the atom of interest in this form:
     \$(\emph{MSMARTS})
     Such definitions may be considered atomic properties. These expressions can be used in same manner as other atomic primitives (also, they can be nested). Recursive SMARTS expressions are used in the following manner:

	\begin{tabular}{| l | l |}
	\hline
	*C & atom connected to methyl or methylene carbon \\ \hline
	*CC & atom connected to ethyl carbon \\ \hline
	[\$(*C);\$(*CC)] & Atom in both above environments (matches CCC) \\ \hline
	\end{tabular}

The additional power of such expressions is illustrated by the following
example which derives an expression for methyl carbons which are ortho to
oxygen and meta to a nitrogen on an aromatic ring.


\begin{tabular}{| l | l | }
\hline
CaaO & C ortho to O \\ \hline
CaaaN & C meta to N \\ \hline
Caa(O)aN & C ortho to O and meta to N (but 2O,3N only) \\ \hline
Ca(aO)aaN & C ortho to O and meta to N (but 2O,5N only) \\ \hline
C[\$( aaO);\$( aaaN)] & C ortho to O and meta to N (all cases) \\ \hline
\end{tabular}

