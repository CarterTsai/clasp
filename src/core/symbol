archiveNode.h:600:		    Symbol_sp sym = _lisp->intern(enumStr);
archiveNode.h:626:		Symbol_sp enumSym = _lisp->intern(enumStr);
archiveNode.h:660:		Symbol_sp enumSym = _lisp->intern(enumStr);
archiveNode.h:687:	    Symbol_sp enumSym = _lisp->intern(enumStr);
archiveNode.h:721:		core::Symbol_sp sym = _lisp->intern(str);
character.h:161:	    THROW(_lisp->error(BF("Cannot convert %s to Character") % o->__repr__() ));
conditions.h:96:#define THROW_TYPE_ERROR(bad_obj,expected_type_symbol) THROW(_lisp->create<type_error_O>(bad_obj,expected_type_symbol,_lisp));
debugger.h:76:		this->_Condition = _lisp->nil<ConditionBase_O>();
debugger.h:77:		_lisp->incrementDebuggerLevel();
debugger.h:86:		this->_Condition = _lisp->nil<ConditionBase_O>();
debugger.h:87:		_lisp->incrementDebuggerLevel();
debugger.h:97:		_lisp->incrementDebuggerLevel();
debugger.h:103:	    _lisp->decrementDebuggerLevel();
debugger.h:114:	this->_SingleStepLevel = _lisp->getSingleStepLevel();
debugger.h:115:	_lisp->setSingleStepLevel(newSingleStepLevel);
debugger.h:120:	_lisp->setSingleStepLevel(this->_SingleStepLevel);
exceptions.h:183:// usage lisp_THROW(_lisp,_lisp->create<LispError_O>("STUFF"));
exceptions.h:191:#define	NOT_SUPPORTED() THROW(_lisp->create<FatalError>(BF("Subclass(%s) does not support the function(%s) file(%s) lineNumber(%d)") % this->className() % __FUNCTION__ % __FILE__ % __LINE__ ));
external_wrappers.h:50:	    THROW(_lisp->error(BF("Attempting to add methods for "
foundation.h:136:    _lisp->add_accessor_pair(_sym_##x,_sym_setf_##x);
foundation.h:141:    _lisp->add_accessor_pair(_sym_##x,_sym_setf_##x);
lisp.h:155:#define CREATE_SYMBOL(sidsym,rsid,pkg,name) sidsym = _lisp->internWithPackageName(pkg,name);
lisp.h:156:#define LOOKUP_SYMBOL(pkg,name) _lisp->internWithPackageName(pkg,name)
lisp.h:940:    PushLispMode(uint newMode) {this->_OldMode = _lisp->_Mode; _lisp->_Mode = newMode;};
lisp.h:941:    virtual ~PushLispMode() { _lisp->_Mode = this->_OldMode;};
lisp.h:969:	    _lisp->__pushFrame(frame);
lisp.h:970:	    LOG(BF("Pushed code onto frame stack - new stack size[%d] code: %s") % _lisp->__lastFrameIndex() % code->__repr__() );
lisp.h:974:	    _lisp->__popFrame(); 
multipleValues.fwd.h:13:#define MULTIPLE_VALUES_COUNT() (_lisp->values()->size())
predefinedSymbols.h:20://    lisp->predefinedSymbol(_sym_kw_renderStyle)
predefinedSymbols_inc.h:316:    lisp->allocatePredefinedSymbols(31);
predefinedSymbols_inc.h:319:    lisp->createPredefinedSymbol(_sym_ClPackage_StarPATHStar,ClPackage,"*PATH*");
predefinedSymbols_inc.h:322:    lisp->createPredefinedSymbol(_sym_ClPackage_StarARGSStar,ClPackage,"*ARGS*");
predefinedSymbols_inc.h:325:    lisp->createPredefinedSymbol(_sym_ClPackage_foreach,ClPackage,"foreach");
predefinedSymbols_inc.h:328:    lisp->createPredefinedSymbol(_sym_kw_debug,":","debug");
predefinedSymbols_inc.h:331:    lisp->createPredefinedSymbol(_sym_kw_lambda,":","lambda");
predefinedSymbols_inc.h:334:    lisp->createPredefinedSymbol(_sym_kw_nonbondTerm,":","nonbondTerm");
predefinedSymbols_inc.h:337:    lisp->createPredefinedSymbol(_sym_kw_restraintAnchor,":","restraintAnchor");
predefinedSymbols_inc.h:340:    lisp->createPredefinedSymbol(_sym_MbbPackage_elementColors,MbbPackage,"elementColors");
predefinedSymbols_inc.h:343:    lisp->createPredefinedSymbol(_sym_MbbPackage_bondOrderToSymbolConverter,MbbPackage,"bondOrderToSymbolConverter");
predefinedSymbols_inc.h:346:    lisp->createPredefinedSymbol(_sym_MbbPackage_elementToSymbolConverter,MbbPackage,"elementToSymbolConverter");
predefinedSymbols_inc.h:349:    lisp->createPredefinedSymbol(_sym_MbbPackage_hybridizationToSymbolConverter,MbbPackage,"hybridizationToSymbolConverter");
predefinedSymbols_inc.h:352:    lisp->createPredefinedSymbol(_sym_MbbPackage_scorerOperationsToSymbolConverter,MbbPackage,"scorerOperationsToSymbolConverter");
predefinedSymbols_inc.h:355:    lisp->createPredefinedSymbol(_sym_MbbPackage_scorerOperationsUseArgs,MbbPackage,"scorerOperationsUseArgs");
predefinedSymbols_inc.h:358:    lisp->createPredefinedSymbol(_sym_MbbPackage_simulatedAnnealingSearchTypeConverter,MbbPackage,"simulatedAnnealingSearchTypeConverter");
predefinedSymbols_inc.h:361:    lisp->createPredefinedSymbol(_sym_MbbPackage_atomFlagSymbolConverter,MbbPackage,"atomFlagSymbolConverter");
predefinedSymbols_inc.h:364:    lisp->createPredefinedSymbol(_sym_MbbPackage_iterateMatterSymbolConverter,MbbPackage,"iterateMatterSymbolConverter");
predefinedSymbols_inc.h:367:    lisp->createPredefinedSymbol(_sym_MbbPackage_preconditionerTypeConverter,MbbPackage,"preconditionerTypeConverter");
predefinedSymbols_inc.h:370:    lisp->createPredefinedSymbol(_sym_MbbPackage_minimizerStatusConverter,MbbPackage,"minimizerStatusConverter");
predefinedSymbols_inc.h:373:    lisp->createPredefinedSymbol(_sym_MbbPackage_bondOrderConverter,MbbPackage,"bondOrderConverter");
predefinedSymbols_inc.h:376:    lisp->createPredefinedSymbol(_sym_MbbPackage_configurationEnumConverter,MbbPackage,"configurationEnumConverter");
predefinedSymbols_inc.h:379:    lisp->createPredefinedSymbol(_sym_MbbPackage_stereochemistryTypeConverter,MbbPackage,"stereochemistryTypeConverter");
predefinedSymbols_inc.h:382:    lisp->createPredefinedSymbol(_sym_kw_superpose,":","superpose");
predefinedSymbols_inc.h:385:    lisp->createPredefinedSymbol(_sym_kw_name,":","name");
predefinedSymbols_inc.h:388:    lisp->createPredefinedSymbol(_sym_kw_renderStyle,":","renderStyle");
predefinedSymbols_inc.h:391:    lisp->createPredefinedSymbol(_sym_kw_ballAndStick,":","ballAndStick");
predefinedSymbols_inc.h:394:    lisp->createPredefinedSymbol(_sym_kw_line,":","line");
predefinedSymbols_inc.h:397:    lisp->createPredefinedSymbol(_sym_kw_cpk,":","cpk");
predefinedSymbols_inc.h:400:    lisp->createPredefinedSymbol(_sym_kw_showLabel,":","showLabel");
predefinedSymbols_inc.h:403:    lisp->createPredefinedSymbol(_sym_kw_label,":","label");
predefinedSymbols_inc.h:406:    lisp->createPredefinedSymbol(_sym_kw_colorByElement,":","colorByElement");
predefinedSymbols_inc.h:409:    lisp->createPredefinedSymbol(_sym_kw_color,":","color");
python_wrappers.h:73:	    core::Symbol_sp funcSymbol = lisp->internWithPackageName(packageName,functionName);
python_wrappers.h:76:	    core::LambdaListHandler_sp llh = lisp_function_lambda_list_handler(_lisp,ll,_lisp->cnil(),_lisp->topLevelEnvironment());
python_wrappers.h:87:							    _lisp->cnil(),
python_wrappers.h:90:							    _lisp->topLevelEnvironment(),
python_wrappers.h:113:	    core::Symbol_sp funcSymbol = lisp->internWithPackageName(packageName,functionName);
python_wrappers.h:139:					    lisp->lisp(),
python_wrappers.h:152:	    core::Class_sp classOT = lisp->classFromClassSymbol(OT::static_classSymbol());
python_wrappers.h:154:	    core::Symbol_sp methodSymbol = lisp->internWithPackageName(packageName,methodName);
ql.h:16:  C++: (ql::list(lisp) , x , y , z , _lisp->symbol(_kw_color) , objBlue ).cons() 
ql.h:219:  apply::apply(func,(apply::list(_lisp) % x % y % z % _lisp->symbol(_kw_rest) % stuff ).cons() )
ql.h:220:  apply::apply(func,(apply::list(_lisp) % x % y % z % _lisp->symbol(_kw_rest) % stuff ).cons(tail) )
serializerNode.h:139:    virtual Node_p firstDataChild() const {_OF(); THROW(_lisp->error(BF("Subclass of Node must implement firstDataChild")));};
serializerNode.h:516:	THROW(_lisp->error(BF("Write specific handler for savePOD for type[%s]") % sreal ));
serializerNode.h:530:	THROW(_lisp->error(BF("Write specific handler for loadPOD for type[%s]") % sreal ));
serializerNode.h:563:		wobj = _lisp->nil<OT>();
serializerNode.h:633:		obj = _lisp->nil<T>();
serializerNode.h:675:		THROW(_lisp->error(BF("Could not find node named[%s]") % name));
serializerNode.h:791:		THROW(_lisp->error(BF("Could not find node named[%s]") % name));
serializerNode.h:973:		    THROW(_lisp->error(BF("Loading: did not recognize enumerated value: %s") % enumSym->__repr__() ));
serializerNode.h:1003:		THROW(_lisp->error(BF("Loading: did not recognize enumerated value: %s") % enumSym->__repr__() ));
serializerNode.h:1221:		    THROW(_lisp->error(BF("MultiMap with name(%s) is missing") % uid));
serializerNode.h:1505:	THROW(_lisp->error(BF("Illegal type for conversion to double - got %s") % ov->className() ));
serializerNode.h:1543:	core::Symbol_sp head = _lisp->internKeyword("VectorInt");
wrappedCppClass.h:21:    wrappedClass_<O_wxObject>(lisp->lisp())
wrappers.h:305:	    THROW(_lisp->error(BF("Attempting to add methods for "
wrappers.h:444:	this->_Converter = _lisp->create<SymbolToEnumConverter_O>(title);
activationFrame.cc:63:	    THROW(_lisp->error(BF("Hit depth=0 and did not find value - this activation frame: %s") % this->__repr__() ));
activationFrame.cc:79:	    THROW(_lisp->error(BF("Hit depth=0 and did not find function - this activation frame: %s") % this->__repr__() ));
activationFrame.cc:96:	core::class_<ActivationFrame_O>(lisp->lisp(),no_init)
activationFrame.cc:163:	    THROW(_lisp->error(BF("Out of range index[%d] for ValueFrame with %d entries") % index % this->_NumArgs ));
activationFrame.cc:173:	    THROW(_lisp->error(BF("Out of range index[%d] for ValueFrame with %d entries") % index % this->_NumArgs ));
activationFrame.cc:185:		THROW(_lisp->error(BF("Out of range index[%d] for ValueFrame with %d entries") % index % this->_NumArgs ));
activationFrame.cc:316:	core::class_<ValueFrame_O>(lisp->lisp())
activationFrame.cc:380:		THROW(_lisp->error(BF("Out of range index[%d] for FunctionFrame with %d entries") % index % this->_NumArgs ));
activationFrame.cc:410:	core::class_<FunctionFrame_O>(lisp->lisp())
archive.cc:31:	lisp->print(BF("Describe symbol manager memory usage here"));
archive.cc:227:	_lisp->print(BF("   Total memory usage of archive = %ld bytes") %  total );
archive.cc:289:	    _lisp->print(BF(" Finalizing archive objects" ));
archive.cc:396:	    child->setClassNodeName(_lisp->classFromClassSymbol(classSymbol));
archive.cc:405:	    THROW(_lisp->create<ArchiveError_O>("There is already a node with ClassName: "+
archive.cc:406:						_lisp->classFromClassSymbol(classSymbol)->getPackagedName(),
archive.cc:511:	    _lisp->print(BF(" Creating archive contents" ));
archive.cc:537:		ASSERTP(lisp->notNil(),"Default Environment is nil and it should never be nil");
archive.cc:538:		lisp->setCandoDatabase(obj->as<CandoDatabase_O>());
archive.cc:539:		_lisp->print(BF("Loaded archive with m:*DATABASE*-> replaced system CandoDatabase"));
archive.cc:679:		THROW(_lisp->create<ArchiveError_O>("Attribute("+attr+") is missing", node ));
archive.cc:689:		 <<_lisp->classFromClassSymbol(expectedClassSymbol)->getPackagedName()<< endl;
archive.cc:691:	    THROW(_lisp->create<ArchiveError_O>(serr.str(),node));
archive.cc:701:		     <<_lisp->classFromClassSymbol(expectedClassSymbol)->getPackagedName()<< endl;
archive.cc:706:		THROW(_lisp->create<ArchiveError_O>(serr.str(),node));
archive.cc:716:	if ( !_lisp->isClassName(linkedNode->getNodeName()) ) {
archive.cc:718:	    serr << "Weak pointer for attr("<<attr<<") must point to a "<<_lisp->classFromClassSymbol(expectedClassSymbol)->getPackagedName() << endl;
archive.cc:721:	    THROW(_lisp->create<ArchiveError_O>(serr.str(),node));
archive.cc:726:	if ( !_lisp->subClassOrder(expectedClassSymbol,_lisp->getClassSymbolForClassName(linkedNode->getNodeName())) ) {
archive.cc:729:		 <<_lisp->classFromClassSymbol(expectedClassSymbol)->getPackagedName()<< endl;
archive.cc:732:	    THROW(_lisp->create<ArchiveError_O>(serr.str(),node));
archive.cc:807:	childNode = node->childWithUniqueNodeName(_lisp->classFromClassSymbol(classSymbol)->getPackagedName());
archiveNode.cc:146:    lisp->print(BF("       nodeNames   = %u") %  nodeNames );
archiveNode.cc:148:    lisp->print(BF("characterStructures= %u") %  characterStructure );
archiveNode.cc:150:    lisp->print(BF("          pointers = %u") %  pointers );
archiveNode.cc:152:    lisp->print(BF("  lineNumbersFlags = %u") %  lineNumbersFlags );
archiveNode.cc:154:    lisp->print(BF("attributesStructure= %u") %  attributesStructure );
archiveNode.cc:156:    lisp->print(BF("     attributesKeys= %u") %  attributesKeys );
archiveNode.cc:158:    lisp->print(BF("     attributesText= %u") %  attributesText );
archiveNode.cc:160:    lisp->print(BF("          uidMap   = %u") %  uidMap );
archiveNode.cc:162:    lisp->print(BF("           focus   = %u") %  focus );
archiveNode.cc:164:    lisp->print(BF("           TOTAL   = %u") %  total );
archiveNode.cc:165:    lisp->print(BF(" countAttributes   = %u") %  countAttributes );
archiveNode.cc:316:	    THROW(_lisp->create<ArchiveError_O>(BF("Could not find child with name: %s")%nodeName, parent));
archiveNode.cc:318:	THROW(_lisp->create<ArchiveError_O>(BF("There can be only one child with name: ")%nodeName, parent ));
archiveNode.cc:353:    THROW(_lisp->create<ArchiveError_O>(BF("Could not find child with NodeName(%s) and key (%s)") % nodeName % key, parent ));
archiveNode.cc:523:    ASSERTP(!_lisp->isClassName(nm),
archiveNode.cc:533:    Class_sp baseClass = _lisp->classFromClassSymbol(baseId);
archiveNode.cc:536:	Symbol_sp sym = _lisp->intern((*ci)->getNodeName());
archiveNode.cc:688:    _lisp->print(BF(" Estimated memory usage broken down" ));
archiveNode.cc:689:    _lisp->print(BF(" Number of symbols in SymbolManager: %d") %  this->archive().symbolManager().numberOfSymbols() );
archiveNode.cc:692:#define DP(n) {_lisp->print(BF("    %20s = %u bytes") %  #n % sizeof(n) ); }
archiveNode.cc:693:    _lisp->print(BF("   Memory usage of top node broken down by parts" ));
archiveNode.cc:948:	    THROW(_lisp->create<ArchiveError_O>(BF("Parent node already has uid(%s)") % uid, parent ));
archiveNode.cc:986:	    THROW(_lisp->create<ArchiveError_O>("Could not find node name("+lookForClassName+")", this));
archiveNode.cc:1100:	        THROW(_lisp->create<ArchiveError_O>(ess.str(), curNode ));
archiveNode.cc:1174:	THROW(_lisp->create<ArchiveError_O>("Could not find child with uid("+uid+") This node doesn't have children", this ));
archiveNode.cc:1179:	THROW(_lisp->create<ArchiveError_O>("Could not find child with uid("+uid+") This node has children but none with that uid", this ));
archiveNode.cc:1190:	THROW(_lisp->create<ArchiveError_O>(ss.str(),this));
archiveNode.cc:1197:	THROW(_lisp->create<ArchiveError_O>(ss.str(),this));
archiveNode.cc:1246:    return((_lisp->isClassName(className)));
archiveNode.cc:1253:    Symbol_sp sym = _lisp->intern(symname);
archiveNode.cc:1269:	if ( !_lisp->isClassName(className) )
archiveNode.cc:1272:	    LOG(BF("Known class names: %s")% _lisp->allClassNames()->asString() );
archiveNode.cc:1273:	    Symbol_sp newForwardClassSymbol = _lisp->intern(className);
archiveNode.cc:1283:	    if ( !_lisp->isClassName(coreClassName) )
archiveNode.cc:1285:		THROW(_lisp->create<ArchiveError_O>((BF("Trying to create object with CoreBuiltInClass(%s) but that class doesn't exist")%coreClassName).str(),
archiveNode.cc:1289:	    Class_sp coreBuiltInClass = _lisp->classFromClassName(coreClassName);
archiveNode.cc:1298:    //	THROW(_lisp->create<ArchiveError_O>("Trying to create an object for an unknown class name("+className+")",this));
archiveNode.cc:1305:	Symbol_sp classSymbol = _lisp->findSymbol(className);
archiveNode.cc:1327:	obj = _lisp->createObjectOfClass(mc);
archiveNode.cc:1563:    _lisp->print(BF( "Children names: "));
archiveNode.cc:1565:	_lisp->prin1(BF( " %s") % (*ci)->getNodeName().c_str() );
archiveNode.cc:1567:    _lisp->print(BF(""));
archiveNode.cc:1885:	vs.push_back(_lisp->intern(s.substr(start,stop-start+1)));
archiveNode.cc:2003:	Symbol_sp sym = lisp->intern(sstr);
archiveNode.cc:2028:	Symbol_sp sym = lisp->intern(sstr);
archiveNode.cc:2052:	Symbol_sp sym = lisp->intern(sstr);
archiveNodeWrite.cc:73:	        THROW(_lisp->create<ArchiveError_O>(e.message()+"\nError while creating a path from node",fromNode));
archiveNodeWrite.cc:136:	        THROW(_lisp->create<ArchiveError_O>(e.message()+"\nError while creating a path from node",fromNode));
archiveNodeWrite.cc:156:	        THROW(_lisp->create<ArchiveError_O>(e.message()+"\nError while creating a path from node",fromNode));
argumentHandler-modified.cc:40:    LOG(BF("LambdaListHandler_O::create called with current package[%s] arguments[%s]") % lisp->getCurrentPackage()->getName() % argumentsInString );
argumentHandler-modified.cc:48:    LambdaListHandler_sp ah = lisp->create<LambdaListHandler_O>();
arguments.cc:33:	THROW(_lisp->error(BF("Illegal target")));
arguments.cc:204:	THROW(_lisp->error(BF("DynamicScopeManager doesn't bind anything other than SPECIAL_TARGET bindings - you gave it a binding to[%s] index[%d]") % arg._ArgTarget->__repr__() % arg._ArgTargetFrameIndex));
arguments.cc:255:	THROW(_lisp->error(BF("Illegal classified type: %s\n") % classified->__repr__() ));
array.cc:155:		THROW(_lisp->error(BF("Bad index")));
array.cc:159:		THROW(_lisp->error(BF("Index#%d[%d] must be less than[%d]")
array.cc:268:	::core::class_<Array_O>(lisp->lisp())
arrayInt.cc:17:	::core::class_<ArrayInt_O>(lisp->lisp())
arrayObjects.cc:44:	::core::class_<ArrayObjects_O>(lisp->lisp())
arrayObjects.cc:165:	THROW(_lisp->error(BF("ArrayObjects has more than one dimension - cannot use svref")));
arrayObjects.cc:178:	THROW(_lisp->error(BF("ArrayObjects has more than one dimension - cannot use setf-svref")));
backquote.cc:176:	    THROW(_lisp->error(BF(",@%s after `") % x->ocadr()->__repr__() ));
backquote.cc:179:	    THROW(_lisp->error(BF(",.%s after `") % x->ocadr()->__repr__() ));
backquote.cc:191:		    THROW(_lisp->error(BF("Malformed ,%s") % p->__repr__() ));
backquote.cc:203:		THROW(_lisp->error(BF("Dotted ,@%s") % p->__repr__()));
backquote.cc:207:		THROW(_lisp->error(BF("Dotted ,.%s") % p->__repr__() ));
backquote.cc:486:	if ( x->isNil() ) return(Values(_lisp->_true()));
backquote.cc:490:	    if ( cx->ocar() == _sym_STARbq_quoteSTAR ) return(Values(_lisp->_true()));
backquote.cc:492:	return(Values(_lisp->_false()));
backquote.cc:668:	_sym_STARbq_simplifySTAR->setf_symbolValue(_lisp->_true());
bformat.cc:75:		      THROW(_lisp->error(BF("Unknown bformat command error")));
bformat.cc:77:	if ( output == _lisp->_true() )
bformat.cc:79:	    _lisp->printvWrite(fmter_str.c_str());
bformat.cc:92:	    THROW(_lisp->error(BF("Illegal output stream arguments[%s]") % output->__repr__() ));
bformat.cc:113:	    THROW(_lisp->error(BF("Add support for functions as FORMAT controls")));
bformat.cc:117:	    THROW(_lisp->error(BF("FORMAT control must be a string or a function - you gave: %s") % control->__repr__() ));
bformat.cc:145:		    THROW(_lisp->error(BF("Add support for control[%s]") % cur));
bignum.cc:46:	THROW(_lisp->error(BF("Cannot convert Bignum %s to sint") % this->__repr__() ));
bignum.cc:62:	THROW(_lisp->error(BF("Cannot convert Bignum %s to sint") % this->__repr__() ));
bignum.cc:71:				   _lisp->integer_ordering()._mpz_import_word_order,
bignum.cc:72:				   _lisp->integer_ordering()._mpz_import_size,
bignum.cc:73:				   _lisp->integer_ordering()._mpz_import_endian, 
bignum.cc:96:	THROW(_lisp->error(BF("Cannot convert Bignum %s to sint") % this->__repr__() ));
bignum.cc:214:	core::class_<Bignum_O>(lisp->lisp())	
binder.cc:33:	class_<Binder_O>(lisp->lisp(),no_init)
binder.cc:57:	    allowedSymbols.insert(lisp->intern(*str));
binder.cc:59:	Binder_sp binder = lisp->create<Binder_O>();
binder.cc:152:		Symbol_sp sym = _lisp->intern(key);
binder.cc:162:	DisplayList_sp dl = _lisp->create<DisplayList_O>();
binder.cc:241:	    THROW(_lisp->error(BF("Could not find variable binding for %s") % sym->__repr__() ));
binder.cc:252:	Symbol_sp sym = _lisp->internWithPackageName(package,symStr);
binder.cc:283:	Symbol_sp sym = _lisp->findSymbol(str);
binder.cc:293:	Symbol_sp sym = _lisp->findSymbol(str);
bitVector.cc:15:    class_<BitVector_O>(lisp->lisp())
bitVector.cc:296:    class_<SimpleBitVector_O>(lisp->lisp())
bootStrapCoreSIDMap.cc:61:	    Package_sp pkg = _lisp->findPackage(it->second._PackageName);
bootStrapCoreSymbolMap.cc:61:	    Package_sp pkg = _lisp->findPackage(it->second._PackageName);
builtInClass.cc:30:	oclass->setName(instanceClassSymbol); // lisp->intern(name);
builtInClass.cc:84:	_lisp->print(BF("-------------  Class name: %s")
builtInClass.cc:88:	    _lisp->print(BF("Base class: %s") % (cur->ocar()->as<Class_O>())->className() );
builtInClass.cc:90:	_lisp->print(BF("%s") % this->dumpInfo() );
builtInClass.cc:99:	class_<BuiltInClass_O>(lisp->lisp())
bundle.cc:213:	    printf("Using lisp-source-directory --> %s\n", lispdir );
cache.cc:144:	    THROW(_lisp->error(BF("search_method_hash"))); // ecl_internal_error("search_method_hash");
candoClass.cc:31:	_lisp->createPredefinedSymbol(oclass->_InstanceClassSymbol,name);
candoClass.cc:59:	_lisp->print(BF("------------  CandoClass name: %s    instanceClassSymbol: %d") % this->_Name->__repr__() % this->_InstanceClassSymbol );
candoClass.cc:60://    _lisp->print(BF("Instance variables: %s") % this->_InstanceVariableNames->__repr__().c_str() );
candoClass.cc:61:	_lisp->print(BF("%s") % this->dumpInfo() );
candoClass.cc:106:	    Symbol_sp setterSymbol = _lisp->internKeyword(setterName);
candoClass.cc:110:	    Symbol_sp getterSymbol = _lisp->internKeyword(getterName);
candoClass.cc:122:	    class_<CandoClass_O>(lisp->lisp())
candoFormatSaveArchive.cc:93:    StringOutStream_sp sout = _lisp->create<StringOutStream_O>();
candoFormatSaveArchive.cc:102:    StringOutStream_sp sout = _lisp->create<StringOutStream_O>();
character.cc:46:	return _lisp->_true();
character.cc:186:	return(Values(_lisp->_true()));
character.cc:196:	if ( args->isNil() ) return(Values(_lisp->_true()));
character.cc:205:	return(Values(_lisp->_true()));
character.cc:227:	return(Values(_lisp->_true()));
character.cc:237:	if ( args->isNil() ) return(Values(_lisp->_true()));
character.cc:248:	return(Values(_lisp->_true()));
character.cc:504:	::core::class_<Character_O>(lisp->lisp())
character.cc:551:	PYTHON_CLASS(Pkg(),Character,"","",lisp->lisp())
character.cc:606:	::core::class_<BaseChar_O>(lisp->lisp())
character.cc:613:	PYTHON_CLASS(Pkg(),BaseChar,"","",lisp->lisp())
character.cc:649:	    THROW(_lisp->error(BF("Unknown character name[%s]") % ssup ));
character.cc:658:	class_<StandardChar_O>(lisp->lisp())
character.cc:747:	THROW(_lisp->error(BF("Wrong format for ge with Char")));
character.cc:760:	THROW(_lisp->error(BF("Wrong format for le with Char")));
character.cc:772:	THROW(_lisp->error(BF("Wrong format for le with Char")));
character.cc:784:	THROW(_lisp->error(BF("Wrong format for comparison with Char")));
character.cc:796:	THROW(_lisp->error(BF("Wrong format for comparison with Character")));
character.cc:807:	THROW(_lisp->error(BF("Wrong format for comparison with Char")));
character.cc:821:	THROW(lisp->error(BF("Illegal argument for sub")));
character.cc:880:	::core::class_<ExtendedChar_O>(lisp->lisp())
character.cc:887:	PYTHON_CLASS(Pkg(),ExtendedChar,"","",lisp->lisp())
compiler.cc:82:		THROW(_lisp->error(BF("Could not find initialization function %s or %s") % kernelInitName % userInitName ));
compiler.cc:137:		THROW(_lisp->error(BF("Could not find initialization function %s or %s") % kernelInitName % userInitName ));
compiler.cc:211:		THROW(_lisp->error(BF("Illegal keyword[%s] for dlsym - only :rtld-next :rtld-self :rtld-default :rtld-main-only are allowed") % sym->__repr__()));
compiler.cc:290:		THROW(_lisp->error(BF("Badd input to processDeclarations: %s") % inputBody->__repr__()));
compiler.cc:320:				THROW(_lisp->error(BF("Illegal object[%s] in declare special") % v));
conditionHandlers.cc:26:	class_<ConditionHandlerBase_O>(lisp->lisp())
conditionHandlers.cc:69:	class_<HandlerCaseHandler_O>(lisp->lisp())
conditionHandlers.cc:104:	class_<HandlerBindHandler_O>(lisp->lisp())
conditionHandlers.cc:141:	class_<RestartCase_O>(lisp->lisp())
conditionHandlers.cc:180:	this->_SavedEnvironment = lisp->getConditionHandlers();
conditionHandlers.cc:195:		T_sp conditionBase = eval::funcall(_sym_findClass,conditionClassSymbol,_lisp->_true());
conditionHandlers.cc:228:		Cons_sp one = Cons_O::create(hc,lisp->getConditionHandlers(),lisp);
conditionHandlers.cc:229:		lisp->setConditionHandlers(one);
conditions.cc:59:	if ( _lisp.get() ) this->saveStackTrace(_lisp->debugLog().cppCallStack()); 
conditions.cc:70:	this->saveStackTrace(_lisp->debugLog().cppCallStack()); 
cons.cc:45:	    THROW(_lisp->error(BF("type_error_plist %s") % place->__repr__() ));
cons.cc:88:	    THROW(_lisp->error(BF("Illegal size %d for list") % size ));
cons.cc:174:	return((_lisp->create<Str_O>(s)));
cons.cc:241:		    THROW(_lisp->error(BF("both test and test-not were defined")));
cons.cc:374:	    THROW(_lisp->error(BF("Illegal end for subseq[%s]") % end->__repr__() ));
cons.cc:417:		obj = lisp->internKeyword(keyStr);
cons.cc:439:		obj = lisp->internKeyword(keyStr);
cons.cc:639:	    THROW(_lisp->error(BF("Index[%d] is beyond the length[%d] of the cons") % index % this->length() ));
cons.cc:651:	    THROW(_lisp->error(BF("Illegal index %d for Cons containing %d elements") % index % this->length() ));
cons.cc:661:	    THROW(_lisp->error(BF("Illegal index %d for Cons containing %d elements") % index % this->length() ));
cons.cc:740:	    THROW(_lisp->error(BF("Illegal last index")));
cons.cc:749:		THROW(_lisp->error(BF("Type not list")));
cons.cc:922:	    _lisp->print(BF("WARNING@%s:%d  Cons length is > %d - its cdr length is(%d) : trunated head: %s") % __FILE__ % __LINE__ % WARN_CONS_LENGTH % this->_CdrLength % sss );
cons.cc:946:	    _lisp->print(BF("WARNING@%s:%d  Cons length is > %d - its cdr length is(%d) : trunated head: %s") % __FILE__ % __LINE__ % WARN_CONS_LENGTH % this->_CdrLength % sss );
cons.cc:1326:	class_<Cons_O>(lisp->lisp(),no_init)
cons.cc:1368:	class_<SourceCodeCons_O>(lisp->lisp())
cons.cc:1390:	::core::class_<CompiledBody_O>(lisp->lisp())
corePackage.cc:372:	_lisp->_CorePackage = corePackage;
corePackage.cc:376:	_lisp->_KeywordPackage = keywordPackage;
corePackage.cc:377:	_lisp->_PackageNameIndexMap[KeywordPkg] = _lisp->_Packages.size();
corePackage.cc:378:	_lisp->_Packages.push_back(keywordPackage);
corePackage.cc:409:	_lisp->_CorePackage->_add_symbol_to_package(_sym_nil);
corePackage.cc:410:	_sym_nil->_WeakPackage = _lisp->_CorePackage;
corePackage.cc:415:	_lisp->_TrueObject = _sym_T_O;
corePackage.cc:416:	_sym_T_O->exportYourself()->defparameter(_lisp->_TrueObject);
corePackage.cc:417:	_lisp->_EofObject = _lisp->create<Str_O>("-eof-eof-eof-");
corePackage.cc:418:	_sym_STARload_printSTAR->exportYourself()->defparameter(_lisp->_false());
corePackage.cc:419:	_sym_STARload_verboseSTAR->exportYourself()->defparameter(_lisp->_false());
corePackage.cc:421:	_sym_STARread_suppressSTAR->exportYourself()->defparameter(_lisp->_false());
corePackage.cc:422:	_sym_STARpackageSTAR->exportYourself()->defparameter(lisp->_CorePackage);
corePackage.cc:423:	_sym_STARpreserve_whitespace_pSTAR->defparameter(_lisp->_false());
corePackage.cc:424:	_sym_STARprint_repl_readSTAR->exportYourself()->defparameter(_lisp->_false());
corePackage.cc:425:	_sym_STARprint_source_code_consSTAR->exportYourself()->defparameter(_lisp->_false());
corePackage.cc:428:	_sym_STARexecutable_nameSTAR->defparameter(Str_O::create(_lisp->_FunctionName,_lisp));
corePackage.cc:429:	_sym_STARread_evalSTAR->defparameter(_lisp->_true());
corePackage.cc:479:	_sym_STARprintEscapeSTAR->defparameter(_lisp->_true());
corePackage.cc:498:	_sym_STARbq_simplifySTAR->defparameter(_lisp->_true());
debugger.cc:31:	if ( !_lisp->isSingleStepOn() ) return;
debugger.cc:32:	if ( currentStackLevel > _lisp->getSingleStepLevel() ) return;
debugger.cc:33:	_lisp->print(BF("%s") % lisp_debugLog()->cppCallStack().asStringAtStackLevel(currentStackLevel));
debugger.cc:41:	    _lisp->setSingleStepLevel(UndefinedUnsignedInt);
debugger.cc:46:	    _lisp->setSingleStepLevel(_lisp->getSingleStepLevel()+1);
debugger.cc:49:	    uint out = _lisp->getSingleStepLevel()-1;
debugger.cc:50:	    _lisp->setSingleStepLevel(out);
debugger.cc:92:	_lisp->print(BF("%s\n") % ss.str());
debugger.cc:114:	    _lisp->print(BF("Debugger entered with condition: %s") % this->_Condition->message() );
debugger.cc:116:	_lisp->print(BF("%s") % lisp_debugLog()->cppCallStack().asStringAtStackLevel(lisp_debugLog()->cppCallStack().size()-1) );
debugger.cc:117:	_lisp->print(BF("The following restarts are available:"));
debugger.cc:118:	_lisp->print(BF("ABORT      a    Abort to REPL"));
debugger.cc:129:	    sprompt << "[" << _lisp->debuggerLevel() << "]>";
debugger.cc:136:		_lisp->print(BF("?      - help"));
debugger.cc:137:		_lisp->print(BF("s      - single step"));
debugger.cc:138:		_lisp->print(BF("e sexp - evaluate sexp"));
debugger.cc:139:		_lisp->print(BF("c sexp - continue - return values of evaluating sexp"));
debugger.cc:140:		_lisp->print(BF("l      - list local variables"));
debugger.cc:141:		_lisp->print(BF("p      - print current expression"));
debugger.cc:142:		_lisp->print(BF("b      - print backtrace"));
debugger.cc:143:		_lisp->print(BF("u      - up one frame"));
debugger.cc:144:		_lisp->print(BF("d      - down one frame"));
debugger.cc:145:		_lisp->print(BF("U      - up to frame with environment"));
debugger.cc:146:		_lisp->print(BF("D      - down to frame with environment"));
debugger.cc:147:		_lisp->print(BF("a      - abort and return to top repl"));
debugger.cc:148:		_lisp->print(BF("g      - invoke GDB by calling core::gdb_hook (set break point in gdb"));
debugger.cc:149:		_lisp->print(BF("f ##   - jump to frame ##"));
debugger.cc:165:		_lisp->print(BF("%s") % lisp_debugLog()->cppCallStack().asStringAtStackLevel(this->_ExecutionFrameIndex) );
debugger.cc:171:		_lisp->print(BF("%s") % lisp_debugLog()->cppCallStack().asStringAtStackLevel(this->_ExecutionFrameIndex) );
debugger.cc:188:		    _lisp->print(BF("Could not find environment"));
debugger.cc:191:		    _lisp->print(BF("%s") % lisp_debugLog()->cppCallStack().asStringAtStackLevel(this->_ExecutionFrameIndex) );
debugger.cc:201:		_lisp->print(BF("%s") % lisp_debugLog()->cppCallStack().asStringAtStackLevel(this->_ExecutionFrameIndex) );
debugger.cc:218:		    _lisp->print(BF("Could not find environment"));
debugger.cc:221:		    _lisp->print(BF("%s") % lisp_debugLog()->cppCallStack().asStringAtStackLevel(this->_ExecutionFrameIndex) );
debugger.cc:227:		_lisp->print(BF("%s") % lisp_debugLog()->cppCallStack().asString() );
debugger.cc:228://		_lisp->print(BF("%s") % _lisp->backTraceAsString() );
debugger.cc:233:		_lisp->print(BF("%s") % lisp_debugLog()->cppCallStack().asStringAtStackLevel(this->_ExecutionFrameIndex) );
debugger.cc:242:		    _lisp->print(BF("%s") % env->environmentStackAsString());
debugger.cc:245:		    _lisp->print(BF("-- Only global environment available --"));
debugger.cc:262:		    result = _lisp->readEvalPrintString(sexp,env,true);
debugger.cc:267:		    _lisp->print(BF("Continuing with result: %s") % result->__repr__() );
debugger.cc:270:		_lisp->print(BF("You cannot resume after condition thrown"));
debugger.cc:288:			_lisp->readEvalPrintString(sexp,env,true);
debugger.cc:294:			_lisp->print(BF("%s") % msg );
debugger.cc:302:			_lisp->print(BF("Unknown condition"));
debugger.cc:309:		    _lisp->print(BF("Unknown command[%c] - try '?'") % cmd );
designators.cc:46:	THROW(_lisp->error(BF("Illegal path designator[%s]") % obj));
designators.cc:55:		return _lisp->getCurrentPackage();
designators.cc:61:	    return _lisp->findPackage(packageName->get());
designators.cc:109:	    THROW(_lisp->error(BF("Illegal string designator[%s] of class[%s]") % obj->__repr__() % obj->_class()->__repr__() ));
designators.cc:130:	    THROW(_lisp->error(BF("Illegal list of string designators[%s]") % obj->__repr__() ));
designators.cc:140:	THROW(_lisp->error(BF("Handle streamDesignator nil --> *standard-input*")));
designators.cc:141:    } else if (obj == _lisp->_true() )
designators.cc:143:	THROW(_lisp->error(BF("Handle streamDesignator true --> *terminal-io*")));
designators.cc:148:    THROW(_lisp->error(BF("Cannot convert object[%s] into a Stream") % obj->__repr__()));
designators.cc:156:	THROW(_lisp->error(BF("Handle streamDesignator nil --> *standard-output*")));
designators.cc:157:    } else if (obj == _lisp->_true() )
designators.cc:159:	THROW(_lisp->error(BF("Handle streamDesignator nil --> *terminal-io*")));
designators.cc:164:    THROW(_lisp->error(BF("Cannot convert object[%s] into a Stream") % obj->__repr__()));
environment.cc:101:	THROW(_lisp->error(BF("Only RuntimeVisibleEnvironments support runtime environments")));
environment.cc:106:	THROW(_lisp->error(BF("Only RuntimeVisibleEnvironments support runtime environments")));
environment.cc:125:	class_<Environment_O>(lisp->lisp(),no_init)
environment.cc:178:	this->_Id = _lisp->nextEnvironmentId();
environment.cc:244:	    THROW(_lisp->error(BF("Could not find value")));
environment.cc:248:	    THROW(_lisp->error(BF("Could not find value")));
environment.cc:286:	    THROW(_lisp->error(BF("Could not update local symbol(%s) because it was not defined") % sym->__repr__() ));
environment.cc:429:	    THROW(_lisp->error(BF("Could not find tag %s") % tag->__repr__() ));
environment.cc:452:	    THROW(_lisp->error(BF("Could not find current code environment") ));
environment.cc:506:	    THROW(_lisp->error(BF("Could not find block with name[%s]") % blockName->__repr__() ));
environment.cc:527:	    THROW(_lisp->error(BF("Could not find tagbody tag with name[%s]") % tag->__repr__() ));
environment.cc:562:	    return(Values(_lisp->_boolean(special),T_O::_nil));
environment.cc:564:	return(Values(value,_lisp->_true()));
environment.cc:570:	Symbol_sp sym = _lisp->internWithPackageName(package,symStr);
environment.cc:632:	core::class_<LexicalEnvironment_O>(lisp->lisp())
environment.cc:709:	return(Values(it->second,_lisp->_true()));
environment.cc:723:	return(Values(it->second,_lisp->_true(),this->const_sharedThis<Environment_O>()));
environment.cc:737:	core::class_<RuntimeVisibleEnvironment_O>(lisp->lisp())
environment.cc:814:	    THROW(_lisp->error(BF("Ran out of parent environments - could not find value")));
environment.cc:837:		THROW(_lisp->error(BF("The lexical variable[%s] is already defined with index[%d] - we tried to set it to[%d]") % sym->__repr__() % it->second % idx ));
environment.cc:851:		THROW(_lisp->error(BF("The lexical variable[%s] is already defined idx[%d]  - we tried to set it to special") % sym->__repr__() % it->second ));
environment.cc:1037:	    THROW(_lisp->error(BF("The symbol[%s] is already in the environment") % sym->__repr__() ));
environment.cc:1046:	    THROW(_lisp->error(BF("There is no symbol[%s] in the current ValueEnvironment") % sym->__repr__() ));
environment.cc:1068:	core::class_<ValueEnvironment_O>(lisp->lisp())
environment.cc:1103:	core::class_<FunctionValueEnvironment_O>(lisp->lisp())
environment.cc:1230:	core::class_<CompileTimeEnvironment_O>(lisp->lisp())
environment.cc:1295:	class_<UnwindProtectEnvironment_O>(lisp->lisp(),no_init)
environment.cc:1387:	class_<BlockEnvironment_O>(lisp->lisp(),no_init)
environment.cc:1445:	    THROW(_lisp->error(BF("Could not find block symbol %s") % sym->__repr__() ));
environment.cc:1475:	class_<CatchEnvironment_O>(lisp->lisp(),no_init)
environment.cc:1545:	class_<FunctionContainerEnvironment_O>(lisp->lisp(),no_init)
environment.cc:1625:	class_<TagbodyEnvironment_O>(lisp->lisp(),no_init)
environment.cc:1720:	THROW(_lisp->error(BF("Could not find tag %s") % tag->__repr__() ));
environment.cc:1780:	class_<MacroletEnvironment_O>(lisp->lisp(),no_init)
environment.cc:1874:	class_<SymbolMacroletEnvironment_O>(lisp->lisp(),no_init)
environment.cc:1924:	class_<GlueEnvironment_O>(lisp->lisp(),no_init)
environment.cc:1933:	return(Values(it->second,_lisp->_true()));
evaluator.cc:45:		for ( Set<Function_O>::iterator it=_lisp->_TraceFunctions.begin(); it!=_lisp->_TraceFunctions.end(); it++ )
evaluator.cc:58:		    THROW(_lisp->error(BF("Could not find function[%s] to trace")
evaluator.cc:62:		_lisp->_TraceFunctions.insert(func);
evaluator.cc:79:		for ( Set<Function_O>::iterator it=_lisp->_TraceFunctions.begin(); it!=_lisp->_TraceFunctions.end(); it++ )
evaluator.cc:83:		_lisp->_TraceFunctions.clear();
evaluator.cc:92:		_lisp->_TraceFunctions.remove(func);
evaluator.cc:132:	    _lisp->print(BF("%s:%d - A Condition was caught in readEvalPrint - _lisp shouldn't happen - exiting") % __FILE__ % __LINE__ );
evaluator.cc:133://	    _lisp->reportConditionAndTerminateProgramIfBatch(err.conditionObject());
evaluator.cc:139:	    _lisp->print(BF("HardError - should never happen! Catch and convert to Condition below"));
evaluator.cc:141://		    _lisp->enterDebugger();
evaluator.cc:145:	    _lisp->print(BF("Exiting"));
evaluator.cc:182:	THROW(_lisp->error(BF("Could not find variable %s in lexical/global environment") % sym->__repr__()));
evaluator.cc:219:	Function_sp fn = _lisp->get_setfDefinition(name);
evaluator.cc:327:		    if ( keys == _sym_otherwise || keys == _lisp->_true() )
evaluator.cc:331:			    THROW(_lisp->error(BF("otherwise-clause must be the last clause of case - it is not")));
evaluator.cc:352:		    THROW(_lisp->error(BF("Bad case clause: %s") % oclause->__repr__() ));
evaluator.cc:442:		FunctionEnvironment_sp newEnvironment = FunctionEnvironment_O::create(_lisp->symbol(_sym_dolist),implicitBlock,_lisp);
evaluator.cc:500:		FunctionEnvironment_sp newEnvironment = FunctionEnvironment_O::create(_lisp->symbol(_sym_dotimes),implicitBlock,_lisp);
evaluator.cc:569:			    THROW(_lisp->error(BF("do variable %s has dynamic value - you shouldn't use it as an iterator variable") % var->__repr__() ));
evaluator.cc:642:		FunctionEnvironment_sp newEnvironment = FunctionEnvironment_O::create(_lisp->symbol(_sym_do),implicitBlock,_lisp);
evaluator.cc:708:		    THROW(_lisp->error(BF("Bad input to processDeclares: %s") % inputBody->__repr__()));
evaluator.cc:737:				THROW(_lisp->error(BF("Illegal object[%s] in declare special") % v));
evaluator.cc:758:			THROW(_lisp->error(BF("Unexpected docstring in: %s") % inputBody->__repr__() ));
evaluator.cc:761:			THROW(_lisp->error(BF("Duplicate documentation in: %s") % inputBody->__repr__() ));
evaluator.cc:907:	    return eval::evaluate(form,_lisp->topLevelEnvironment());
evaluator.cc:941:		    THROW(_lisp->error(BF("Illegal situation[%s] for eval-when - only :compile-toplevel, :load-toplevel, :execute, compile, load or eval allowed") % s->__repr__() ));
evaluator.cc:944:	    uint mode = _lisp->mode();
evaluator.cc:978:		THROW(_lisp->error(BF("I don't have a compiler yet")));
evaluator.cc:1069:		THROW(_lisp->error(BF("Could not find tag[%s] in the lexical environment: %s") % tag->__repr__() % env->__repr__() ));
evaluator.cc:1221:		THROW(_lisp->error(BF("Illegal if has too many expressions: %s") % args->__repr__() ));
evaluator.cc:1311:		THROW(_lisp->error(BF("Could not find block named %s in lexical environment: %s") % blockSymbol->__repr__() % environment->__repr__() ));
evaluator.cc:1327:	    THROW(_lisp->error(BF("Block symbol %s not recognized") % blockSymbol->__repr__() ));
evaluator.cc:1416:		lisp->unhandledCondition(condition,environment);
evaluator.cc:1543:		THROW(_lisp->error(BF("Illegal object for lambda-list you can "
evaluator.cc:1585:		    THROW(_lisp->error(BF("Could not find function %s") % fnSymbol->__repr__() ));
evaluator.cc:1598:			THROW(_lisp->error(BF("Could not find function %s") % consArg->__repr__() ));
evaluator.cc:1630:	    THROW(_lisp->error(BF("Illegal argument[%s] for function") % arg->__repr__() ));
evaluator.cc:1710:			THROW(_lisp->error(BF("Missing value for setq of target[%s] - body of setq: %s")
evaluator.cc:1732:		    THROW(_lisp->error(BF("Illegal target[%s] for setq - body of setq: %s") % target->__repr__() % args->__repr__() ));
evaluator.cc:1915:		    THROW(_lisp->error(cond.conditionObject()/*,environment */));
evaluator.cc:1926:		    THROW(_lisp->error(BF("HARD_ERROR: %s") % err.message() ));
evaluator.cc:1935:		THROW(_lisp->error(BF("HARD_ERROR: %s") % err.message() ));
evaluator.cc:1945:		THROW(_lisp->error(BF("std::exception--> %s") % exc.what() ));
evaluator.cc:1947:	    THROW(_lisp->error(BF("Failed to handle exception")));
evaluator.cc:1973:		    THROW(_lisp->error(BF("Error invoking %s - %s") % head->getFunctionName()->__repr__() % cond->message() ));
evaluator.cc:2021:			THROW(_lisp->error(BF("Could not find function[%s]") % shead->fullName()));
evaluator.cc:2142:		THROW(_lisp->error(BF("evaluate depth exceeded %d levels - there may be an infinite loop") % MAX_EVALUATE_DEPTH));
evaluator.cc:2200:		if ( _lisp->isSingleStepOn() )
evaluator.cc:2204:		SpecialForm_sp specialForm = _lisp->specialFormOrNil(headSym);
evaluator.cc:2253://			THROW(_lisp->error(BF("Macros should have been processed out already")));
evaluator.cc:2271://			_lisp->error(cond.conditionObject()/*,environment*/);
evaluator.cc:2283:		    THROW(_lisp->error(BF("Could not find form(%s) in the lexical/dynamic environment")
evaluator.cc:2301:		    THROW(_lisp->error(BF("Could not find form(%s) in the lexical/dynamic environment")
evaluator.cc:2326:		    if ( _lisp->isSingleStepOn() )
evaluator.cc:2337:		THROW(_lisp->error(BF("Illegal form: %s") % exp->__repr__() ));
evaluator.cc:2441:				_lisp->error(err.conditionObject() /*,environment */);
evaluator.cc:2463:	    _lisp->defineSpecialForm("special-var", &sp_specialVar);
evaluator.cc:2464:	    _lisp->defineSpecialForm("lexical-var", &sp_lexicalVar);
evaluator.cc:2465:	    _lisp->defineSpecialForm("block", &sp_block);
evaluator.cc:2466:	    _lisp->defineSpecialForm("catch",&sp_catch);
evaluator.cc:2467:	    _lisp->defineSpecialForm("eval-when",&sp_eval_when);
evaluator.cc:2468:	    _lisp->defineSpecialForm("dbg-i32",&sp_dbg_i32);
evaluator.cc:2469:	    _lisp->defineSpecialForm("flet", &sp_flet);
evaluator.cc:2470:	    _lisp->defineSpecialForm("function",&sp_function);
evaluator.cc:2471:	    _lisp->defineSpecialForm("the",&sp_the);
evaluator.cc:2472:	    _lisp->defineSpecialForm("truly-the",&sp_the); // SBCL defined truly-the as a 
evaluator.cc:2473:	    _lisp->defineSpecialForm("go",&sp_go);
evaluator.cc:2474:	    _lisp->defineSpecialForm("if",&sp_if);
evaluator.cc:2475:	    _lisp->defineSpecialForm("labels", &sp_labels);
evaluator.cc:2476:	    _lisp->defineSpecialForm("let", &sp_let);
evaluator.cc:2477:	    _lisp->defineSpecialForm("let*", &sp_letSTAR);
evaluator.cc:2478:	    _lisp->defineSpecialForm("locally",&sp_locally);
evaluator.cc:2479:	    _lisp->defineSpecialForm("macrolet", &sp_macrolet);
evaluator.cc:2480:	    _lisp->defineSpecialForm("multipleValueProg1",&sp_multipleValueProg1);
evaluator.cc:2481:	    _lisp->defineSpecialForm("multipleValueCall",&sp_multipleValueCall);
evaluator.cc:2482:	    _lisp->defineSpecialForm("progn",&sp_progn);
evaluator.cc:2483:	    _lisp->defineSpecialForm("quote",&sp_quote);
evaluator.cc:2484:	    _lisp->defineSpecialForm("return-from",&sp_returnFrom);
evaluator.cc:2485:	    _lisp->defineSpecialForm("setq",&sp_setq);
evaluator.cc:2486:	    _lisp->defineSpecialForm("tagbody",&sp_tagbody);
evaluator.cc:2487:	    _lisp->defineSpecialForm("throw",&sp_throw);
evaluator.cc:2488:	    _lisp->defineSpecialForm("unwind-protect",&sp_unwindProtect);
evaluator.cc:2489:	    _lisp->defineSpecialForm("symbol-macrolet",&sp_symbolMacrolet);
evaluator.cc:2496:	    _lisp->defineSpecialForm("lambda",&sp_lambda);
evaluator.cc:2497:	    _lisp->defineSpecialForm("lambda-block",&sp_lambda_block,
evaluator.cc:2500:	    _lisp->defineSpecialForm("raise",&sp_raise);
evaluator.cc:2505://	    _lisp->defineSpecialForm("defClass",&sp_defClass);
evaluator.cc:2506://	    _lisp->defineSpecialForm("handler-case", &sp_handlerCase );
evaluator.cc:2507:	    _lisp->defineSpecialForm("step",&sp_step);
exceptions.cc:266:	THROW(_lisp->error(BF("Nothing on the stack has parsePos")));
exceptions.cc:659:    if ( !_lisp->debugLog().debugScript() )
exceptions.cc:663:	    if ( !_lisp->debugLog().cppCallStack().at(entryIndex-1).getWroteToLog() )
exceptions.cc:669:    e = &(_lisp->debugLog().cppCallStack().at(entryIndex));
exceptions.cc:673:	_lisp->debugLog().beginNode(e->debugFlags(),
exceptions.cc:679:	_lisp->debugLog().beginNode(e->debugFlags(),
exceptions.cc:692:    e = &(_lisp->debugLog().cppCallStack().last());
exceptions.cc:693:    bool shouldBeLogged = _lisp->debugLog().isOn(e->getSourceFilePath(),debugFlags);
exceptions.cc:695:    _stackTraceEnter_WriteEntryToLog(_lisp->debugLog().cppCallStack().size()-1);
exceptions.cc:706:    int numFrames = _lisp->debugLog().cppCallStack().size();
exceptions.cc:712:    _LexicalScope& e = (_lisp->debugLog().cppCallStack().last());
exceptions.cc:714:    _lisp->debugLog().endNode(e.debugFlags());
exceptions.cc:722:    ss = _lisp->debugLog().cppCallStack().asString();
exceptions.cc:723:    _lisp->debugLog().writeText(ss);
exceptions.cc:745:    this->saveCppStackTrace(lisp->debugLog().cppCallStack());
exceptions.cc:752:    this->saveCppStackTrace(lisp->debugLog().cppCallStack());
executables.cc:45:	    this->_CurrentLevel = _lisp->_TraceLevel;
executables.cc:46:	    _lisp->_TraceLevel++;
executables.cc:56:	    _lisp->_TraceLevel = this->_CurrentLevel;
executables.cc:75:	    _lisp->print(BF("%s >%d: %s")
executables.cc:82:	    _lisp->print(BF("%s <%d: %s  -->  %s")
executables.cc:128:	class_<Function_O>(lisp->lisp())
executables.cc:187:	class_<Interpreted_O>(lisp->lisp())
executables.cc:215:	proc = lisp->create<Interpreted_O>();
executables.cc:368:		    THROW(_lisp->error(BF("What do we do now, this->_Code = %s") % this->_Code->__repr__() ));
executables.cc:497:	    this->_LambdaListHandler->createBindingsInActivationFrame(args,scope,_lisp->topLevelEnvironment());
executables.cc:508:	    THROW(_lisp->error(BF("Error: UNDEFINED result from INVOKE of function[%s] on arguments[%s]") % this->getFunctionName()->__repr__() %  args->__repr__() ));
executables.cc:540:	core::class_<BuiltIn_O>(lisp->lisp())
executables.cc:595:	    this->_LambdaListHandler->createBindingsInActivationFrame(args,scope,_lisp->topLevelEnvironment());
executables.cc:607:	    THROW(_lisp->error(BF("Error: UNDEFINED result from INVOKE of function[%s] on arguments[%s]") % this->getFunctionName()->__repr__() %  args->__repr__() ));
executables.cc:640:	core::class_<CompiledFunction_O>(lisp->lisp())
externalObject.cc:51:	THROW(_lisp->error(BF("The external pointer@%p is not recognized") % ptr ));
externalObject.cc:55:	THROW(_lisp->error(BF("Object for external ptr@p was deleted") % ptr ));
fileSystem.cc:65:		tail->setCdr(Cons_O::create(_lisp->create<Path_O>(itr->path()),
fileSystem.cc:151:	    THROW(_lisp->error(BF("Could not create_directories for path[%s]") % parent.string())); 
fileSystem.cc:153:	return(Values(pathspec,_lisp->_true()));
fileSystem.cc:385:	class_<Path_O>(lisp->lisp(),no_init)
fileSystem.cc:424:// 	defInPackage(CorePkg,"directory",&directory, lisp->lisp());
fileSystem.cc:425:// 	defInPackage(CorePkg,"remove",&remove, lisp->lisp());
fileSystem.cc:426:// 	defInPackage(CorePkg,"rename",&rename, lisp->lisp());
fileSystem.cc:427:// 	defInPackage(CorePkg,"removeAll",&removeAll, lisp->lisp());
fileSystem.cc:428:// 	defNoWrapPackageWithArguments(CorePkg,"ensure-directories-exist",&ensureDirectoriesExist, "(path)", lisp->lisp());
fileSystem.cc:456:	class_<DirectoryIterator_O>(lisp->lisp())
fileSystem.cc:520:	      THROW(_lisp->error(BF("%s") % err.what() ));
fileSystem.cc:551:	DirectoryEntry_sp de = _lisp->create<DirectoryEntry_O>();
fileSystem.cc:591:	class_<RecursiveDirectoryIterator_O>(lisp->lisp())
fileSystem.cc:656:	      THROW(_lisp->error(BF("%s") % err.what() ));
fileSystem.cc:687:	DirectoryEntry_sp de = _lisp->create<DirectoryEntry_O>();
fileSystem.cc:720:	class_<DirectoryEntry_O>(lisp->lisp())
fileSystem.cc:756:	FileStatus_sp fs = _lisp->create<FileStatus_O>();
fileSystem.cc:763:	FileStatus_sp fs = _lisp->create<FileStatus_O>();
fileSystem.cc:770:	Path_sp path = _lisp->create<Path_O>();
fileSystem.cc:783:	class_<FileStatus_O>(lisp->lisp())
forwardReferencedClass.cc:18:	::core::class_<ForwardReferencedClass_O>(lisp->lisp())
forwardReferencedClass.cc:25:	PYTHON_CLASS(Pkg(),ForwardReferencedClass,"","",lisp->lisp())
foundation.cc:255:	bool ret = _lisp->debugLog().isOn(fileName,debugFlags);
foundation.cc:261:	return &(_lisp->debugLog());
foundation.cc:268:	return lisp->_true();
foundation.cc:274:	return lisp->_false();
foundation.cc:296:	return lisp->CoreBuiltInClassesInitialized();
foundation.cc:301:	return lisp->BuiltInClassesInitialized();
foundation.cc:306:	return lisp->NilsCreated();
foundation.cc:315://    ASSERTP(lisp->notNil(),"In lisp_exposeClass env can not be nil");
foundation.cc:329:	Class_sp mc = eval::funcall(_sym_findClass,_lisp->_true())->as<Class_O>();
foundation.cc:339:	Class_sp mc = lisp->classFromClassSymbol(classSymbol);
foundation.cc:340://	lisp->addClassNameToPackageAsDynamic(packageName,name,mc); // lisp->addClassToEnvironment(packageName,name,mc);
foundation.cc:346://     Class_sp mc = lisp->classFromClassSymbol(classSymbol);
foundation.cc:360:	lisp->addClass(packageName,name,classSymbol,cb,base1ClassSymbol,base2ClassSymbol);
foundation.cc:367:	Package_sp pkg = _lisp->findPackage(packageName);
foundation.cc:380:	Package_sp pkg = _lisp->findPackage(packageName);
foundation.cc:399:	Symbol_sp sym = _lisp->internWithPackageName(pkg,lisp_name);
foundation.cc:402:	_lisp->add_c_function(sym,ptr,args);
foundation.cc:417:	Class_sp receiver_class = eval::funcall(_sym_findClass,classSymbol,_lisp->_true())->as<Class_O>();
foundation.cc:422:	    THROW(_lisp->error(BF("Defining + as a single-dispatch-method")));
foundation.cc:424:	Symbol_sp sym = _lisp->internWithPackageName(receiver_class->getPackageName(),name);
foundation.cc:449:		THROW(_lisp->error(BF("Mismatch between hard coded class[%s] and"
foundation.cc:460:	    THROW(_lisp->error(BF("No arguments were provided and number_of_required_arguments is %d") % number_of_required_arguments));
foundation.cc:470:	    gfn = _lisp->find_single_dispatch_generic_function(sym,true);
foundation.cc:481:	    THROW(_lisp->error(BF("%s dispatch-on-index[%d] does not match that of the arguments[%d] - arguments: %s") % gfn->dispatch_on_index() % single_dispatch_argument_index % arguments ));
foundation.cc:506:	Symbol_sp accessorName = _lisp->intern(name);
foundation.cc:507:	Symbol_sp setfName = _lisp->intern(lispify_symbol_name("setf_"+name));
foundation.cc:523:	_lisp->print(BF("%s:%d ---> trying to add setfExpander for: %s") % __FILE__ % __LINE__ % setfName->__repr__() );
foundation.cc:524://	lisp->addSetfExpander(accessorName,expander);
foundation.cc:536:	Symbol_sp accessorName = _lisp->intern(name);
foundation.cc:537:	Symbol_sp setfName = _lisp->intern(lispify_symbol_name("setf_"+name));
foundation.cc:541:	lisp->addSetfExpander(accessorName,expander);
foundation.cc:548:	lisp->throwIfBuiltInClassesNotInitialized();
foundation.cc:553:	return lisp->classNameFromClassSymbol(classSymbol);
foundation.cc:558:	return eval::funcall(_sym_findClass,classSymbol,_lisp->_true())->as<Class_O>();
foundation.cc:562:	Symbol_sp sym = lisp->internWithPackageName(pkg,n);
foundation.cc:565://    lisp->globalEnvironment()->extend(sym,i);
foundation.cc:570:	return lisp->isClassName(n);
foundation.cc:575:	return lisp->getClassSymbolForClassName(n);
foundation.cc:581:	Class_sp baseClass = lisp->classFromClassSymbol(baseClassSymbol);
foundation.cc:582:	Class_sp testClass = lisp->classFromClassSymbol(classSymbol);
foundation.cc:620:	Symbol_sp sym = lisp->internWithPackageName(packageName,lispName);
foundation.cc:663:	Symbol_sp sym = _lisp->internWithPackageName(packageName,lispName);
foundation.cc:683://    Package_sp package = lisp->getPackage(packageName);
foundation.cc:704:	Symbol_sp sym = lisp->internWithPackageName(packageName,lispName);
foundation.cc:705:	lisp->createPredefinedSymbol(symSymbol,sym);
foundation.cc:745:	    THROW(_lisp->error(BF("lisp_defmethod[generic-function=%s] - specializedLambdaList is missing")%func_spec->__repr__() ));
foundation.cc:753:	Function_sp canonicalize_specializers_fn = _lisp->topLevelEnvironment()->lookup_function(_sym_canonicalize_specializer);
foundation.cc:773:					    << _kw_environment << _lisp->topLevelEnvironment() ), _lisp);
foundation.cc:781:	return lisp->internKeyword(name);
foundation.cc:787:	return lisp->intern(name);
foundation.cc:793:	return lisp->internWithPackageName(pkg,name);
foundation.cc:799:	return lisp->lookupPredefinedSymbol(name);
foundation.cc:819:	lisp->installGlobalInitializationCallback(initGlobals);
foundation.cc:825:	T_sp obj = lisp->hiddenBinder()->lookup(sym);
foundation.cc:831:	return lisp->symbol(symId);
foundation.cc:837:	SymbolToEnumConverter_sp converter = lisp->hiddenBinder()->lookup(lisp->symbol(predefSymId))->as<SymbolToEnumConverter_O>();
foundation.cc:844:	SymbolToEnumConverter_sp converter = lisp->hiddenBinder()->lookup(lisp->symbol(predefSymId))->as<SymbolToEnumConverter_O>();
foundation.cc:851:	lisp->hiddenBinder()->extend(sym,obj);
foundation.cc:864:	return lisp->isGlobalInitializationAllowed();
foundation.cc:872:	    _lisp->debugLog().beginNode(DEBUG_TOPLEVEL,fileName,functionName,lineNumber,0,fmt_str);
foundation.cc:873:	    _lisp->debugLog().endNode(DEBUG_TOPLEVEL);
foundation.cc:878:	    _lisp->debugLog().beginNode(DEBUG_SHOUT,fileName,functionName,lineNumber,0,fmt_str);
foundation.cc:879:	    _lisp->debugLog().endNode(DEBUG_SHOUT);
foundation.cc:882:	_lisp->debugLog().beginNode(DEBUG_LOG,fileName,functionName,lineNumber,0,fmt_str);
foundation.cc:883:	_lisp->debugLog().endNode(DEBUG_LOG);
foundation.cc:889:	lisp->debugLog().beginNode(DEBUG_EXCEPTION,file,fn,line,0,message);
foundation.cc:890:	lisp->debugLog().endNode(DEBUG_EXCEPTION);
foundation.cc:918:	lisp->print(BF("> ") );
foundation.cc:919:	lisp->printvFlush();
foundation.cc:929:	lisp->setOutputStream(os);
foundation.cc:934:	lisp->outputStream() << outputBuffer;
foundation.cc:939:	lisp->outputStream() << outputChar;
foundation.cc:945:	lisp->outputStream().flush();
foundation.cc:952:	lisp->printfPrefixStack().push_back(prefix);
foundation.cc:959:	lisp->printfPrefixStack().pop_back();
foundation.cc:968:	    lisp->printvWrite((*si).c_str());
foundation.cc:1020:		lisp->printvWriteChar(*cp);
foundation.cc:1022:	    lisp->printvFlush();
foundation.cc:1030:	lisp->print(BF("%s")%str);
foundation.cc:1036:	lisp->print(BF("%s") %str.c_str());
foundation.cc:1168:	return _lisp->create<Str_O>(s);
foundation.cc:1360:	    lisp->print(BF("Debug information was being written when classes have not yet been initialized"));
foundation.cc:1361:	    lisp->print(BF("This should never happen."));
foundation.cc:1362:	    lisp->print(BF( "Run with the debugger and use the following commands:" ));
foundation.cc:1363:	    lisp->print(BF( "l foundation.cc:1" ));
foundation.cc:1364:	    lisp->print(BF( "search throwIfClassesNotInitialized" ));
foundation.cc:1365:	    lisp->print(BF( "--> set a breakpoint in the if block" ));
foundation.cc:1366:	    lisp->print(BF( "Then backtrace to find the offending initialization routine." ));
funcallableStandardClass.cc:45:	    Symbol_sp sym = _lisp->intern((*ci)->getUniqueIdCharacters());
funcallableStandardClass.cc:81:	    baseClasses = Cons_O::create(lisp->classFromClassSymbol(StandardObject_O::static_classSymbol()),lisp);
funcallableStandardClass.cc:115:	_lisp->print(BF("------------  FuncallableStandardClass name: %s    instanceClassSymbol: %d") % this->_Name->__repr__() % this->_InstanceClassSymbol );
funcallableStandardClass.cc:116://    _lisp->print(BF("Instance variables: %s") % this->_InstanceVariableNames->__repr__().c_str() );
funcallableStandardClass.cc:117:	_lisp->print(BF("%s") % this->dumpInfo() );
funcallableStandardClass.cc:121:	    _lisp->print(BF("Baseclass--->"));
funcallableStandardClass.cc:127:	    _lisp->print(BF("Did not see any base classes"));
funcallableStandardClass.cc:211:		SIMPLE_ERROR(BF((_lisp->creat"There is already a slot with name(%s)")%sym->currentName()));
funcallableStandardClass.cc:251:	    Symbol_sp setterSymbol = _lisp->internKeyword(setterName);
funcallableStandardClass.cc:255:	    Symbol_sp getterSymbol = _lisp->internKeyword(getterName);
funcallableStandardClass.cc:270:	class_<FuncallableStandardClass_O>(lisp->lisp())
genericFunction.cc:178:	return(Values(methods,_lisp->_true()));
genericFunction.cc:200:	return(Values(methods,_lisp->_true()));
genericFunction.cc:249:		THROW(_lisp->error(BF("Wrong number of arguments")));
genericFunction.cc:252:		THROW(_lisp->error(BF("Too many arguments to fill_spec_vector()")));
genericFunction.cc:296:	Cache* cache = _lisp->methodCachePtr();
genericFunction.cc:406:	ASSERT(_lisp->methodCachePtr());
genericFunction.cc:407:	ASSERT(_lisp->slotCachePtr());
genericFunction.cc:408:	_lisp->methodCachePtr()->removeOne(what);
genericFunction.cc:409:	_lisp->slotCachePtr()->removeOne(what);
hashTable.cc:39://	_lisp->print(BF("%s:%d - make_hash_table - fix me so that I grow by powers of 2\n") % __FILE__ % __LINE__ );
hashTable.cc:54:	    THROW(_lisp->error(BF("Illegal test[%s] for make-hash-table") % test_func->__repr__() ));
hashTable.cc:324:	THROW(_lisp->error(BF("Illegal value for hash-table-test %s") % this->_HashTest->__repr__() ));
hashTable.cc:553:	::core::class_<HashTable_O> ht(lisp->lisp());
hashTable.cc:588:	PYTHON_CLASS(Pkg(),HashTable,"","",lisp->lisp())
hashTableEq.cc:17:	::core::class_<HashTableEq_O>(lisp->lisp())
hashTableEq.cc:24:	PYTHON_CLASS(Pkg(),HashTableEq,"","",lisp->lisp())
hashTableEql.cc:18:	::core::class_<HashTableEql_O>(lisp->lisp())
hashTableEql.cc:25:	PYTHON_CLASS(Pkg(),HashTableEql,"","",lisp->lisp())
hashTableEqual.cc:18:	::core::class_<HashTableEqual_O>(lisp->lisp())
hashTableEqual.cc:25:	PYTHON_CLASS(Pkg(),HashTableEqual,"","",lisp->lisp())
hashTableEqualp.cc:17:	::core::class_<HashTableEqualp_O>(lisp->lisp())
hashTableEqualp.cc:24:	PYTHON_CLASS(Pkg(),HashTableEqualp,"","",lisp->lisp())
implementAmberFunction.cc:53:    _lisp->profiler().timer(timerPreconditioner).start();
implementAmberFunction.cc:54:    _lisp->profiler().timer(timerPreconditionerSetup).start();
implementAmberFunction.cc:70:    _lisp->profiler().timer(timerPreconditionerSetup).stop();
implementAmberFunction.cc:71:    _lisp->profiler().timer(timerPreconditioner).stop();
implementAmberFunction.cc:180:	_lisp->profiler().timer(timerEnergy).start();
implementAmberFunction.cc:182:	_lisp->profiler().timer(timerBondAngleDihedral).start();
implementAmberFunction.cc:187:	_lisp->profiler().timer(timerBond).start();
implementAmberFunction.cc:192:	_lisp->profiler().timer(timerBond).stop();
implementAmberFunction.cc:194:	_lisp->profiler().timer(timerAngle).start();
implementAmberFunction.cc:199:	_lisp->profiler().timer(timerAngle).stop();
implementAmberFunction.cc:201:	_lisp->profiler().timer(timerDihedral).start();
implementAmberFunction.cc:206:	_lisp->profiler().timer(timerDihedral).stop();
implementAmberFunction.cc:207:	_lisp->profiler().timer(timerBondAngleDihedral).stop();
implementAmberFunction.cc:209:	_lisp->profiler().timer(timerNonbond).start();
implementAmberFunction.cc:212:	_lisp->profiler().timer(timerNonbond).stop();
implementAmberFunction.cc:214:	_lisp->profiler().timer(timerImproperRestraint).start();
implementAmberFunction.cc:217:	_lisp->profiler().timer(timerImproperRestraint).stop();
implementAmberFunction.cc:219:	_lisp->profiler().timer(timerChiralRestraint).start();
implementAmberFunction.cc:222:	_lisp->profiler().timer(timerChiralRestraint).stop();
implementAmberFunction.cc:224:	_lisp->profiler().timer(timerAnchorRestraint).start();
implementAmberFunction.cc:227:	_lisp->profiler().timer(timerAnchorRestraint).stop();
implementAmberFunction.cc:237:	_lisp->profiler().timer(timerEnergy).stop();
initializeClassesWithWx.cc:18:    lisp->makePackage(WxPackage);
initializeClassesWithWx.cc:26:    lisp->installGlobalInitializationCallback(initializeWxWidgetsConstants);
instance.cc:85:	    THROW(_lisp->error(BF("illegal class-of")));
instance.cc:299:	    THROW(_lisp->error(BF("Wrong type argument")));
integerKeyObjectDictionary.cc:94:	    Symbol_sp isymbol = _lisp->internKeyword((BF("i%d")%vi->first).str());
integerKeyObjectDictionary.cc:235:    class_<IntegerKeyObjectDictionary_O>(lisp->lisp())
interpreter.cc:48:		FunctionEnvironment_sp newEnvironment = FunctionEnvironment_O::create(_lisp->symbol(_sym_dolist),implicitBlock,_lisp);
interpreter.cc:106:		FunctionEnvironment_sp newEnvironment = FunctionEnvironment_O::create(_lisp->symbol(_sym_dotimes),implicitBlock,_lisp);
interpreter.cc:175:			    THROW(_lisp->error(BF("do variable %s has dynamic value - you shouldn't use it as an iterator variable") % var->__repr__() ));
interpreter.cc:252:		FunctionEnvironment_sp newEnvironment = FunctionEnvironment_O::create(_lisp->symbol(_sym_do),implicitBlock,_lisp);
iterator.cc:31:	class_<Iterator_O>(lisp->lisp())
lambdaListHandler.cc:48:	THROW(_lisp->error(BF("Lambda list is destructuring_bind but context does not support it context[%s]") % context->__repr__() ));
lambdaListHandler.cc:490:		    THROW(_lisp->error(BF("Illegal target type for bind: %s") % it->asString() ));
lambdaListHandler.cc:494:		    scope.new_binding(it->_Sensor,_lisp->_true());
lambdaListHandler.cc:515:		    THROW(_lisp->error(BF("Illegal target type for bind: %s") % it->asString() ));
lambdaListHandler.cc:519:		    scope.new_binding(it->_Sensor,_lisp->_false());
lambdaListHandler.cc:565:		    THROW(_lisp->error(BF("Illegal target type for bind: %s") % it->asString() ));
lambdaListHandler.cc:569:		    scope.new_binding(it->_Sensor,_lisp->_true());
lambdaListHandler.cc:591:			THROW(_lisp->error(BF("Illegal target type for bind: %s") % it->asString() ));
lambdaListHandler.cc:595:			scope.new_binding(it->_Sensor,_lisp->_false());
lambdaListHandler.cc:636:		THROW(_lisp->error(BF("Illegal target for bind_whole_var[%s]") % wholearg.asString() ));
lambdaListHandler.cc:655:		THROW(_lisp->error(BF("Illegal target for bind_whole_var[%s]") % wholearg.asString() ));
lambdaListHandler.cc:673:		THROW(_lisp->error(BF("Illegal target for bind_environment_var[%s]") % environmentarg.asString() ));
lambdaListHandler.cc:691:		THROW(_lisp->error(BF("Illegal target for bind_environment_var[%s]") % environmentarg.asString() ));
lambdaListHandler.cc:711:		THROW(_lisp->error(BF("Illegal target for bind_rest_var[%s]") % restarg.asString() ));
lambdaListHandler.cc:764:				THROW(_lisp->error(BF("Illegal target type for bind: %s") % fi->asString() ));
lambdaListHandler.cc:768:				scope.new_binding(fi->_Sensor,_lisp->_true());
lambdaListHandler.cc:808:			THROW(_lisp->error(BF("Illegal target type for bind: %s") % fi->asString() ));
lambdaListHandler.cc:812:			scope.new_binding(fi->_Sensor,_lisp->_false());
lambdaListHandler.cc:882:				THROW(_lisp->error(BF("Illegal target type for bind: %s") % fi->asString() ));
lambdaListHandler.cc:886:				scope.new_binding(fi->_Sensor,_lisp->_true());
lambdaListHandler.cc:920:			THROW(_lisp->error(BF("Illegal target type for bind: %s") % fi->asString() ));
lambdaListHandler.cc:924:			scope.new_binding(fi->_Sensor,_lisp->_false());
lambdaListHandler.cc:1118:	     || context == _lisp->_true() ) return;
lambdaListHandler.cc:1119:	THROW(_lisp->error(BF("Illegal parse_lambda_list context[%s]") % context->__repr__() ));
lambdaListHandler.cc:1192:	allow_other_keys = _lisp->_false();
lambdaListHandler.cc:1211:			allow_other_keys = _lisp->_true();
lambdaListHandler.cc:1274:		    THROW(_lisp->error(BF("Lambda list dot followed by more than one argument")));
lambdaListHandler.cc:1327:		THROW(_lisp->error(BF("&allow-other-keys must be processed just after switch_add_argument_mode")));
lambdaListHandler.cc:1346:		    THROW(_lisp->error(BF("&aux variables must be specified by a symbol or a cons of a symbol and an expression")));
lambdaListHandler.cc:1368:	key_flag = _lisp->_boolean(keys.size()>0);
lambdaListHandler.cc:1445:		      _lisp->_boolean(keyFlag),
lambdaListHandler.cc:1563:	    THROW(_lisp->error(BF("There are unused arguments: %s") % args->asCons(args_idx)->__repr__() ));
lambdaListHandler.cc:1614:		THROW(_lisp->error(BF("Required arguments of single dispatch generic functions must be symbols - I got: %s") % ri->asString() ));
lambdaListHandler.cc:1617:	THROW(_lisp->error(BF("Could not find single dispatch target symbol[%s]") % target->__repr__() ));
lambdaListHandler.cc:1741:		      _lisp->_boolean(keyFlag),
lambdaListHandler.cc:1801:	class_<LambdaListHandler_O>(lisp->lisp(),no_init)
lambdaListStuff.cc:39:    LOG(BF("LambdaListHandler_O::create called with current package[%s] arguments[%s]") % lisp->getCurrentPackage()->getName() % argumentsInString );
lambdaListStuff.cc:47:    LambdaListHandler_sp ah = lisp->create<LambdaListHandler_O>();
lambdaListStuff.cc:64:    this->_KeyedArgumentsWithDefaults = _lisp->create<Binder_O>();
lambdaListStuff.cc:102:		if ( symbol == _lisp->getAmpOptionalSymbol() )
lambdaListStuff.cc:107:		} else if ( symbol == _lisp->getAmpRestSymbol() )
lambdaListStuff.cc:112:		} else if ( symbol == _lisp->getAmpKeySymbol() )
lambdaListStuff.cc:123:		if ( symbol == _lisp->getAmpOptionalSymbol() )
lambdaListStuff.cc:127:		if ( symbol == _lisp->getAmpRestSymbol() )
lambdaListStuff.cc:133:		if ( symbol == _lisp->getAmpKeySymbol() )
lambdaListStuff.cc:144:		if ( symbol == _lisp->getAmpOptionalSymbol() )
lambdaListStuff.cc:148:		if ( symbol == _lisp->getAmpRestSymbol() )
lambdaListStuff.cc:152:		if ( symbol == _lisp->getAmpKeySymbol() )
lambdaListStuff.cc:163:		if ( symbol == _lisp->getAmpOptionalSymbol() )
lambdaListStuff.cc:167:		if ( symbol == _lisp->getAmpRestSymbol() )
lambdaListStuff.cc:171:		if ( symbol == _lisp->getAmpKeySymbol() )
lambdaListStuff.cc:308:    this->_KeyedArgumentsWithDefaults = _lisp->create<Binder_O>();
lambdaListStuff.cc:423:    Symbol_sp sym = _lisp->intern(name);
lambdaListStuff.cc:430:    Symbol_sp sym = _lisp->intern(name);
lambdaListStuff.cc:438:    Symbol_sp sym = _lisp->intern(name);
lambdaListStuff.cc:440:    Symbol_sp sensor = _lisp->intern(sensorName);
lambdaListStuff.cc:448:    Symbol_sp sym = _lisp->intern(name);
lambdaListStuff.cc:456:    Symbol_sp sym = _lisp->intern(name);
lambdaListStuff.cc:465:    Symbol_sp sym = _lisp->intern(name);
lambdaListStuff.cc:467:    Symbol_sp sensor = _lisp->intern(sensorName);
lambdaListStuff.cc:517:		    environment->extend(providedName,_lisp->_true());
lambdaListStuff.cc:525:		    environment->extend(providedName,_lisp->_false());
lambdaListStuff.cc:551:		    environment->extend(supplied,_lisp->_false());
lambdaListStuff.cc:578:			SIMPLE_ERROR(BF((_lisp->creat"unexpected keyed argument(%s)")
lambdaListStuff.cc:591:			environment->extend(suppliedName,_lisp->_true());
lambdaListStuff.cc:633:		if ( symbol == _lisp->getAmpOptionalSymbol() )
lambdaListStuff.cc:638:		} else if ( symbol == _lisp->getAmpRestSymbol() )
lambdaListStuff.cc:643:		} else if ( symbol == _lisp->getAmpKeySymbol() )
lambdaListStuff.cc:654:		if ( symbol == _lisp->getAmpOptionalSymbol() )
lambdaListStuff.cc:658:		if ( symbol == _lisp->getAmpRestSymbol() )
lambdaListStuff.cc:664:		if ( symbol == _lisp->getAmpKeySymbol() )
lambdaListStuff.cc:675:		if ( symbol == _lisp->getAmpOptionalSymbol() )
lambdaListStuff.cc:679:		if ( symbol == _lisp->getAmpRestSymbol() )
lambdaListStuff.cc:683:		if ( symbol == _lisp->getAmpKeySymbol() )
lambdaListStuff.cc:694:		if ( symbol == _lisp->getAmpOptionalSymbol() )
lambdaListStuff.cc:698:		if ( symbol == _lisp->getAmpRestSymbol() )
lambdaListStuff.cc:702:		if ( symbol == _lisp->getAmpKeySymbol() )
lisp.cc:218:	THROW(_lisp->error(BF("Nothing on the stack has parsePos")));
lisp.cc:231:	Package_sp corePackage = lisp->_CorePackage;
lisp.cc:297:	lisp->setupMpi(mpiEnabled,mpiRank,mpiSize);
lisp.cc:298:	lisp->__setWeakThis(lisp);
lisp.cc:299://	lisp->__resetInitializationOwner();
lisp.cc:300:	lisp->_DebugStream = new DebugStream(mpiRank);
lisp.cc:302:	lisp->_profiler = new LightProfiler();
lisp.cc:303:	lisp->_PrintvWriteChar = foundation_printv_writeChar;
lisp.cc:304:	lisp->_PrintvFlush = foundation_printv_flush;
lisp.cc:430:	    initializeCandoPrimitives(lisp->lisp());
lisp.cc:512:	_lisp->addSetfExpander(getSym,expander);
lisp.cc:586:	ReadSerializer_sp reader = _lisp->create<ReadSerializer_O>();
lisp.cc:593:	WriteSerializer_sp writer = _lisp->create<WriteSerializer_O>();
lisp.cc:794:	Symbol_sp sym = _lisp->intern(formName)->exportYourself();
lisp.cc:872:	Symbol_sp classSymbol = _lisp->intern(name,_lisp->findPackage(package));
lisp.cc:910:	    THROW(_lisp->error(BF("There must be one base class")));
lisp.cc:1008:		THROW(_lisp->error(BF("Package nickname[%s] is already being used by package[%s]") % nickName % this->_Packages[existingIndex]->getName()));
lisp.cc:1051:	    THROW(_lisp->error(BF("In getPackage - there is no package with name[%s] - available packages[%s]") %name % ss.str() ));
lisp.cc:1163:	    THROW(_lisp->error(BF("Finish implementing Lisp_O::translateLogicalPathname")));
lisp.cc:1199:	    THROW(_lisp->error(BF("Finish implementing Lisp_O::translateLogicalPathname")));
lisp.cc:1276:	    _lisp->print(BF("%s")% ss.str());
lisp.cc:1319:		    THROW(_lisp->error(BF("You must provide a feature with -+")));
lisp.cc:1321:		features = Cons_O::create(_lisp->internKeyword(lispify_symbol_name(*fit)),features,_lisp);
lisp.cc:1387:	LOG(BF("lisp->_ScriptInFile(%d)  lisp->_FileNameOrCode(%s)") % this->_ProgramCode._ScriptInFile % this->_ProgramCode._FileNameOrCode );
lisp.cc:1446:	    this->readEvalPrint(sin,_lisp->topLevelEnvironment(),print);
lisp.cc:1475:		T_sp expression = read_lisp_object(sin,false,_lisp->_eof(),false,_lisp);
lisp.cc:1476:		if ( expression == _lisp->_eof() ) break;
lisp.cc:1486:			    THROW(_lisp->error(BF("*read-suppress* is true but the following expression was read: %s") % expression->__repr__() ));
lisp.cc:1624:	    _lisp->print(BF("%s:%d Invoking debugger") % __FILE__ % __LINE__ );
lisp.cc:1627:	    _lisp->print(BF("%s:%d You tried to continue from debugger - this should never happen") % __FILE__ % __LINE__ );
lisp.cc:1640:	    _lisp->print(BF("%s:%d Invoking debugger with for expression: %s(%s)") %__FILE__ % __LINE__ % head->__repr__() % args->__repr__() );
lisp.cc:1642:	    _lisp->print(BF("%s:%d You tried to continue from debugger - this should never happen") % __FILE__ % __LINE__ );
lisp.cc:1738:	return(Values(_lisp->getLoadTimeValues(name,dataSize, symbolSize)));
lisp.cc:1761:	return(Values(_lisp->topLevelEnvironment()));
lisp.cc:1911:	    THROW(_lisp->create<core::ContentException_O>("There must be one and only one object in the file"));
lisp.cc:1941:	    THROW(_lisp->create<core::ContentException_O>("There must be one and only one object in the file"));
lisp.cc:1977:	    _lisp->print(BF("%s ") % prompt->get() );
lisp.cc:1978:	    _lisp->printvFlush();
lisp.cc:2039:	    THROW(_lisp->create<core::LispError_O>("You must provide the object to render as the only positional argument, 'options' is a keyedArgument "));
lisp.cc:2079:	_lisp->sprint(obj,sout);
lisp.cc:2093:	T_sp obj = _lisp->sread(sin->as<Stream_O>(),true,T_O::_nil);
lisp.cc:2110:	if ( _lisp->bootClassTableIsValid() )
lisp.cc:2112:	    return Values(_lisp->boot_findClass(symbol,errorp));
lisp.cc:2125:		THROW(_lisp->error(BF("Could not find class %s") % symbol->__repr__() ));
lisp.cc:2146:	    THROW(_lisp->error(BF("Classes in cando have to be subclasses of Class unlike ECL which uses Instances to represent classes - while trying to (setf find-class) of %s you gave: %s") % name->__repr__() % newValue->__repr__() ));
lisp.cc:2148:	if ( _lisp->bootClassTableIsValid() )
lisp.cc:2150:	    return Values(_lisp->boot_setf_findClass(name,newValue->as<Class_O>()));
lisp.cc:2156:	    THROW(_lisp->error(BF("The built-in class associated to the CL specifier %s cannot be changed") % name->__repr__() ));
lisp.cc:2195:	Path_sp fullPath = _lisp->translateLogicalPathnameUsingPaths(partialPath);
lisp.cc:2210:	Package_sp pkg = _lisp->findPackage(name->get());
lisp.cc:2226:	_lisp->selectPackage(pkg);
lisp.cc:2249:	return(Values(_lisp->_boolean(_lisp->mpiEnabled())));
lisp.cc:2265:	return(Values(Fixnum_O::create(_lisp->mpiRank())));
lisp.cc:2284:	return(Values(Fixnum_O::create(_lisp->mpiSize())));
lisp.cc:2298:	lisp->print(BF("Hidden Binder keys:%s\n") % lisp->hiddenBinder()->summaryOfContents().c_str() );
lisp.cc:2322:		if ( _lisp->specialFormOrNil(headSymbol)->isNil() )
lisp.cc:2345:	    return(Values(expanded,_lisp->_true()) );
lisp.cc:2347:	return(Values(form,_lisp->_false()) );
lisp.cc:2383:	return(Values(cur,_lisp->_boolean(expandedMacro)) );
lisp.cc:2450:	    _lisp->print(BF("%s") % ss.str());
lisp.cc:2472:	    for ( Vector0<Package_O>::iterator pi=_lisp->packages().begin();
lisp.cc:2473:		  pi != _lisp->packages().end(); pi++ )
lisp.cc:2718:	Path_sp dir = _lisp->create<Path_O>(_lisp->bundle().getLispDir());
lisp.cc:2731:	    boost::filesystem::path lp = _lisp->bundle().getLibDir();
lisp.cc:2735:	return(Values(Path_O::create(_lisp->bundle().getLibDir(),_lisp)));
lisp.cc:2747:	    boost::filesystem::path lp = _lisp->bundle().getLibDir();
lisp.cc:2751:	return(Values(Path_O::create(_lisp->bundle().getLibDir(),_lisp)));
lisp.cc:2771:	Path_sp dir = Path_O::create(_lisp->bundle().getDatabasesDir(),_lisp);
lisp.cc:2795:	_lisp->setCurrentWorkingDirectory(cwd);
lisp.cc:2815:	LOG(BF("isTopLevelScript = %d") % _lisp->getRequireLevel()  );
lisp.cc:2816:	T_sp top = _lisp->_boolean(_lisp->getRequireLevel() == 0);
lisp.cc:2840:	_lisp->debugLog().setSuppressMessages(false);
lisp.cc:2861:	_lisp->debugLog().setSuppressMessages(true);
lisp.cc:2879:	    lisp->addModule(path->asString());
lisp.cc:2880:	    lisp->pushRequireLevel();
lisp.cc:2881:	    LOG(BF("  pushed require level to %d") % lisp->getRequireLevel()  );
lisp.cc:2882:	    lisp->load(path);
lisp.cc:2926:	    _lisp->exportToPython(one);
lisp.cc:2962:	    _lisp->error(c/*,environ*/);
lisp.cc:2966:	    _lisp->error(c/*,environ*/);
lisp.cc:2970:	    _lisp->error(c);
lisp.cc:2972:	THROW(_lisp->error(BF("Currently you must pass a ConditionBase object, string or designator for condition to error - you passed datum: %s initializers: %s") % datum->__repr__() % initializers->__repr__() ));
lisp.cc:2998:	    THROW(_lisp->error(BF("I don't handle externalFormat - convert this to a warning")));
lisp.cc:3000:	_lisp->load(filespec,verbose->isTrue(),print->isTrue(),if_does_not_exist->isTrue());
lisp.cc:3001:	return(Values(_lisp->_true()));
lisp.cc:3031:	return(Values(_lisp->_boolean(io)));
lisp.cc:3051:	return(Values(_lisp->_boolean(io)));
lisp.cc:3136:	return lisp->_boolean(o1->equal(o2));
lisp.cc:3152:	return lisp->_boolean(o1->ne(o2));
lisp.cc:3169:	return lisp->_boolean(o1->lt(o2));
lisp.cc:3186:	return lisp->_boolean(o1->gt(o2));
lisp.cc:3203:	return lisp->_boolean(o1->le(o2));
lisp.cc:3220:	return lisp->_boolean(o1->ge(o2));
lisp.cc:3241:	return(Values(_lisp->_boolean(!x->isTrue())));
lisp.cc:3315:	DynamicScopeManager scope(_sym_STARprintEscapeSTAR,_lisp->_true());
lisp.cc:3325:	DynamicScopeManager scope(_sym_STARprintEscapeSTAR,_lisp->_true());
lisp.cc:3357:	THROW(_lisp->error(BF("Handle createObjectOfClass when mc is not a Class")));
lisp.cc:3388:		THROW(_lisp->error(BF("No class named %s") % className->__repr__() ));
lisp.cc:3421:	SymbolMap<SingleDispatchGenericFunction_O>::const_iterator fi = _lisp->_SingleDispatchGenericFunctionTable.find(gfSym);
lisp.cc:3422:	if ( fi == _lisp->_SingleDispatchGenericFunctionTable.end() )
lisp.cc:3426:		THROW(_lisp->error(BF("No single-dispatch-generic-function named %s") % gfSym->__repr__() ));
lisp.cc:3442:	_lisp->_SingleDispatchGenericFunctionTable[gfName] = gf;
lisp.cc:3452:	_lisp->_SingleDispatchGenericFunctionTable.clear();
lisp.cc:3475:		THROW(_lisp->error(BF("No generic function named %s") % gfName->__repr__() ));
lisp.cc:3517:	return _lisp->findClass(sym);
lisp.cc:3646:	    THROW(_lisp->error(BF("You cannot intern[%s] as a keyword - it has package designating ':' characters in it at pos[%d]") % realName % colonPos));
lisp.cc:3721:	for ( Vector0<Package_O>::iterator pi=_lisp->packages().begin();
lisp.cc:3722:	      pi != _lisp->packages().end(); pi++ )
lisp.cc:3733:	_lisp->print(BF("%s")%bt);
lisp.cc:3744:	    _lisp->print(BF("Tracing: "));
lisp.cc:3747:		_lisp->print(BF("%s") % (*ti)->getFunctionName()->__repr__() );
lisp.cc:3759:		_lisp->print(BF("trace: %s") % sym->__repr__() );
lisp.cc:3762:		_lisp->print(BF("Cannot trace function[%s] - it doesnt' exist") % sym->__repr__() );
lisp.cc:3776:	    _lisp->print(BF("untracing all"));
lisp.cc:3856:		    Path_sp loadPath = _lisp->translateLogicalPathnameUsingPaths(Str_O::create(scriptFileName,_lisp));
lisp.cc:3939:	class_<Lisp_O>(lisp->lisp())
lisp.cc:3998://	defNoWrapPackage(CorePkg,"apply", &prim_apply,lisp->lisp());
lisp.cc:4002://	defNoWrapPackage(CorePkg,"allGlobalNames", &prim_allGlobalNames ,lisp->lisp());
lisp.cc:4003://	defNoWrapPackage(CorePkg,"locals", &prim_locals,lisp->lisp());
lisp.cc:4010://	defNoWrapPackage(CorePkg,"globals", &prim_globals,lisp->lisp());
lisp.cc:4031://	defNoWrapPackage(CorePkg,"print", &prim_print ,lisp->lisp());
lisp.cc:4038://	defNoWrapPackage(CorePkg,"derive", &prim_derive ,lisp->lisp());
lisp.cc:4039://	defNoWrapPackage(CorePkg,"isA", &prim_isA ,lisp->lisp());
lisp.cc:4041://	defNoWrapPackage(CorePkg,"parseConsOfStrings", &prim_parseConsOfStrings ,lisp->lisp());
lisp.cc:4047://	defNoWrapPackage(CorePkg,"sub", &prim_sub ,lisp->lisp());
lisp.cc:4048://	defNoWrapPackage(CorePkg,"-", &prim_sub ,lisp->lisp());
lisp.cc:4049://	defNoWrapPackage(CorePkg,"div", &prim_div ,lisp->lisp());
lisp.cc:4050://    defNoWrapPackage(CorePkg,"mod", &prim_mod ,lisp->lisp());
lisp.cc:4051://	defNoWrapPackage(CorePkg,"/", &prim_div ,lisp->lisp());
lisp.cc:4052://	defNoWrapPackage(CorePkg,"mul", &prim_mul ,lisp->lisp());
lisp.cc:4053://	defNoWrapPackage(CorePkg,"*", &prim_mul ,lisp->lisp());
lisp.cc:4054://	defNoWrapPackage(CorePkg,"className", &prim_className ,lisp->lisp());
lisp.cc:4081://	defNoWrapPackage(CorePkg,"consp",&prim_consp,lisp->lisp());
lisp.cc:4082://	defNoWrapPackage(CorePkg,"symbolp",&prim_symbolp,lisp->lisp());
lisp.cc:4104://	defNoWrapPackage(CorePkg,"dumpHidden", &prim_dumpHidden,lisp->lisp());
lisp.cc:4143://	boost::python::def_raw(CorePkg,"export",&prim_export,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4144://	boost::python::def_raw(CorePkg,"apply", &prim_apply,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4145:	boost::python::def_raw(CorePkg,"testomp", &prim_testomp,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4146:	boost::python::def_raw(CorePkg,"isTopLevelScript", &prim_isTopLevelScript ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4147://	boost::python::def_raw(CorePkg,"allGlobalNames", &prim_allGlobalNames ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4148://	boost::python::def_raw(CorePkg,"locals", &prim_locals,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4149://	boost::python::def_raw(CorePkg,"sourceFileLine", &prim_sourceFileLine,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4150:	boost::python::def_raw(CorePkg,"backtrace", &prim_backtrace,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4151://	boost::python::def_raw(CorePkg,"globals", &prim_globals,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4153:	boost::python::def_raw(CorePkg,"load", &prim_load,ARGS_prim_load,DOCS_empty,lisp->lisp());
lisp.cc:4154:	boost::python::def_raw(CorePkg,"include",&prim_include,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4155:	boost::python::def_raw(CorePkg,"testScanner", &prim_testScanner ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4156:	boost::python::def_raw(CorePkg,"printPushPrefix", &prim_printPushPrefix ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4157:	boost::python::def_raw(CorePkg,"printPopPrefix", &prim_printPopPrefix ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4158:	boost::python::def_raw(CorePkg,"println", &prim_println ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4159://	boost::python::def_raw(CorePkg,"print", &prim_print ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4160:	boost::python::def_raw(CorePkg,"prin1", &prim_prin1 ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4161:	boost::python::def_raw(CorePkg,"prim-dump", &prim_dump ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4162:	boost::python::def_raw(CorePkg,"isAssignableTo", &prim_isAssignableTo ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4163:	boost::python::def_raw(CorePkg,"isSubClassOf", &prim_isSubClassOf,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4164://	boost::python::def_raw(CorePkg,"derive", &prim_derive ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4165://	boost::python::def_raw(CorePkg,"isA", &prim_isA ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4166:	boost::python::def_raw(CorePkg,"dumpln", &prim_dumpln ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4167://	boost::python::def_raw(CorePkg,"parseConsOfStrings", &prim_parseConsOfStrings ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4168:	boost::python::def_raw(CorePkg,"exit", &prim_exit ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4169:	boost::python::def_raw(CorePkg,"quit", &prim_exit ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4170://	boost::python::def_raw(CorePkg,"funcall", &prim_funcall ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4171://	boost::python::def_raw(CorePkg,"apply", &prim_apply ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4172://	boost::python::def_raw(CorePkg,"sub", &prim_sub ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4173://	boost::python::def_raw(CorePkg,"-", &prim_sub ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4174://	boost::python::def_raw(CorePkg,"div", &prim_div ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4175://    boost::python::def_raw(CorePkg,"mod", &prim_mod ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4176://	boost::python::def_raw(CorePkg,"/", &prim_div ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4177://	boost::python::def_raw(CorePkg,"mul", &prim_mul ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4178://	boost::python::def_raw(CorePkg,"*", &prim_mul ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4180:	boost::python::def_raw(CorePkg,"listref", &prim_listref ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4181:	boost::python::def_raw(CorePkg,"@", &prim_listref ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4182:	boost::python::def_raw(CorePkg,"car", &prim_car ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4183:	boost::python::def_raw(CorePkg,"cdr", &prim_cdr ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4184:	boost::python::def_raw(CorePkg,"cddr", &prim_cddr ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4185:	boost::python::def_raw(CorePkg,"cdddr", &prim_cdddr ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4186:	boost::python::def_raw(CorePkg,"cadr", &prim_cadr ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4187:	boost::python::def_raw(CorePkg,"caddr", &prim_caddr ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4189://    boost::python::def_raw(CorePkg,"cons", &prim_cons ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4190://	boost::python::def_raw(CorePkg,"className", &prim_className ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4191:	boost::python::def_raw(CorePkg,"repr", &prim_repr ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4192://	boost::python::def_raw(CorePkg,"list", &prim_list ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4193://	boost::python::def_raw(CorePkg,"error", &prim_error ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4195:	boost::python::def_raw(CorePkg,"eq", &prim_eq,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4196:	boost::python::def_raw(CorePkg,"==", &prim_eq,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4197:	boost::python::def_raw(CorePkg,"ne", &prim_ne,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4198:	boost::python::def_raw(CorePkg,"!=", &prim_ne,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4199:	boost::python::def_raw(CorePkg,"lt", &prim_lt,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4200:	boost::python::def_raw(CorePkg,"<", &prim_lt,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4201:	boost::python::def_raw(CorePkg,"gt", &prim_gt,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4202:	boost::python::def_raw(CorePkg,">", &prim_gt,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4203:	boost::python::def_raw(CorePkg,"le", &prim_le,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4204:	boost::python::def_raw(CorePkg,"<=", &prim_le,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4205:	boost::python::def_raw(CorePkg,"ge", &prim_ge,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4206:	boost::python::def_raw(CorePkg,">=", &prim_ge,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4208://	boost::python::def_raw(CorePkg,"not", &prim_not,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4209:	boost::python::def_raw(CorePkg,"debugLogOn",&prim_debugLogOn,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4210:	boost::python::def_raw(CorePkg,"debugLogOff",&prim_debugLogOff,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4211:	boost::python::def_raw(CorePkg,"dumpClasses",&prim_dumpClasses,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4214://	boost::python::def_raw(CorePkg,"consp",&prim_consp,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4215://	boost::python::def_raw(CorePkg,"symbolp",&prim_symbolp,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4219://	boost::python::def_raw(CorePkg,"comparer", &prim_list ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4220://	boost::python::def_raw(CorePkg,"sorted", &prim_sorted ,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4221://	boost::python::def_raw(CorePkg,"sort", &prim_sort,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4223://	boost::python::def_raw(CorePkg,"databaseDir", &prim_databaseDir,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4224://	boost::python::def_raw(CorePkg,"scriptDir", &prim_scriptDir,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4225://	boost::python::def_raw(CorePkg,"dumpHidden", &prim_dumpHidden,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4227:	boost::python::def_raw(CorePkg,"setCurrentWorkingDirectory",&prim_setCurrentWorkingDirectory,ARGS_empty,DOCS_empty,lisp->lisp());
lisp.cc:4229:	initializePythonPrimitives(lisp->lisp());
lisp.cc:4259:	if (_lisp->mpiEnabled())
lisp.cc:4262:	    ss << "P"<<_lisp->mpiRank()<<":";
lisp.cc:4265:	_lisp->parseCommandLineArguments(argc,argv,true);
lisp.cc:4281:	if ( !lisp->recognizesPackage(packageName) )
lisp.cc:4289:	    this->_Package = lisp->makePackage(packageName,lnnames,lp);
lisp.cc:4292:	    this->_Package = lisp->findPackage(packageName);
lisp.cc:4300:	if ( !lisp->recognizesPackage(packageName) )
lisp.cc:4304:	    this->_Package = lisp->makePackage(packageName,lnnames,lpkgs);
lisp.cc:4307:	    this->_Package = lisp->findPackage(packageName);
lisp.cc:4322:    ChangePackage::ChangePackage(Package_sp newPackage) : _SavedPackage(_lisp->getCurrentPackage())
lisp.cc:4324:	_lisp->selectPackage(newPackage);
lisp.cc:4329:	_lisp->selectPackage(this->_SavedPackage);
lispList.cc:134:	class_<List_O>(lisp->lisp(),no_init)
lispList.cc:155:	PYTHON_CLASS(Pkg(),List,"","",lisp->lisp())
lispReader.cc:61:		    THROW(_lisp->error(BF("Illegal exponent character[%c]") % *cur));
lispReader.cc:206:	    THROW(_lisp->error(BF("unhandled state[%d] for token assignment") % state ));
lispReader.cc:214:	THROW(_lisp->error(BF("There was no token!!!!")));
lispReader.cc:222:	return _lisp->getCurrentPackage()->intern(symbolName);
lispReader.cc:240:	Package_sp pkg = _lisp->findPackage(packageSin.str());
lispReader.cc:250:	return _lisp->keywordPackage()->intern(keywordName);
lispReader.cc:256:	THROW(_lisp->error(BF("ReaderError_O::create(sin,_lisp))")));
lispReader.cc:315:	THROW(_lisp->error(BF("Shouldn't get here - unhandled exponent type")));
lispReader.cc:319:    THROW(_lisp->error(BF("create<ReaderError_O>(sin));")));
lispReader.cc:338:       (when (setq values (multiple-value-list (lisp-object? stream t nil t)))
lispReader.cc:357:	    Character_sp cp = sin->peek_char(_lisp->_true(),true,Character_O::_nil,true);
lispReader.cc:393:			Character_sp cdotp = sin->peek_char(_lisp->_true(),true,Character_O::_nil,true);
lispReader.cc:396:			    THROW(_lisp->error(BF("Nothing after consing dot")));
lispReader.cc:401:			THROW(_lisp->error(BF("Illegal consing dot")));
lispReader.cc:407:			THROW(_lisp->error(BF("More than one object after consing dot")));
lispReader.cc:473:	ReadTable_sp readTable = _lisp->getCurrentReadTable();
lispReader.cc:489:	if ( x1_syntax_type == _kw_invalid_character ) THROW(_lisp->error(BF("ReaderError_O::create(sin,_lisp)")));
lispReader.cc:566:	    if ( y8_syntax_type == _kw_invalid_character) THROW(_lisp->error(BF("ReaderError_O::create()")));
lispReader.cc:617:		THROW(_lisp->error(BF("ReaderError_O::create()")));
lispReader.cc:619:	    THROW(_lisp->error(BF("Should never get here")));
lispStream.cc:132:		return(Values(eof_value,_lisp->_true()));
lispStream.cc:139:	T_sp res = reader->read(false,_lisp->_eof());
lispStream.cc:141:	T_sp res = read_lisp_object(sin,false,_lisp->_eof(),false,_lisp);
lispStream.cc:142:	if ( res == _lisp->_eof() )
lispStream.cc:149:		return(Values(eof_value,_lisp->_true()));
lispStream.cc:172:	    THROW(_lisp->error(BF("Currently I can't handle stdin as input - create a *standard-input* object")));
lispStream.cc:181:		return(Values(eof_value,_lisp->_true()));
lispStream.cc:195:		return(Values(Str_O::create(sbuf,_lisp),_lisp->_true()));
lispStream.cc:219:	class_<Stream_O>(lisp->lisp(),no_init)
lispStream.cc:266:	if ( !this->inputStreamP() ) THROW(_lisp->error(BF("Not input-stream")));
lispStream.cc:290:	if ( !this->inputStreamP() ) THROW(_lisp->error(BF("Not input-stream")));
lispStream.cc:311:	if ( !this->inputStreamP() ) THROW(_lisp->error(BF("Not input-stream")));
lispStream.cc:327:	ASSERT(peek_type == _lisp->_true());
lispStream.cc:342:		    THROW(_lisp->error(BF("Hit end of stream in peek")));
lispStream.cc:367:	class_<AnsiStream_O>(lisp->lisp(),no_init)
lispStream.cc:388:	core::class_<FileStream_O>(lisp->lisp())
lispStream.cc:424:	class_<FileInStream_O>(lisp->lisp())
lispStream.cc:510:	    _lisp->print(BF("-----Close for %s with abort=true called - I don't currently support abort=true") % this->className() );
lispStream.cc:571:	class_<FileOutStream_O>(lisp->lisp())
lispStream.cc:683:	class_<FileInCompressedStream_O>(lisp->lisp())
lispStream.cc:770:	    _lisp->print(BF("-----Close for %s with abort=true called - I don't currently support abort=true") % this->className() );
lispStream.cc:790:	class_<FileOutCompressedStream_O>(lisp->lisp())
lispStream.cc:893:	core::class_<StringStream_O>(lisp->lisp())
lispStream.cc:948:	class_<StringInStream_O>(lisp->lisp())
lispStream.cc:1064:	class_<StringOutStream_O>(lisp->lisp())
lispStream.cc:1177:	    THROW(_lisp->error(BF("You tried to close a file that is not closeable")));
lispStream.cc:1181:	    THROW(_lisp->error(BF("Could not close file - it was already closed")));
lispStream.cc:1185:	    _lisp->print(BF("-----Close for %s with abort=true called - I don't currently support abort=true") % this->className() );
lispStream.cc:1203:	core::class_<FDStream_O>(lisp->lisp())
lispStream.cc:1232:	    THROW(_lisp->error(BF("The file is not open!!")));
lispStream.cc:1274:	class_<FDInStream_O>(lisp->lisp())
lispStream.cc:1292:	    THROW(_lisp->error(BF("Could not fseek to end of file: %s") % this->_SourceFileInfo->fileName() ));
lispStream.cc:1297:	    THROW(_lisp->error(BF("Problem with fseek")));
lispStream.cc:1320:	if ( res < 0 ) THROW(_lisp->error(BF("Problem with fseek")));
lispStream.cc:1330:	if ( res < 0 ) THROW(_lisp->error(BF("Problem with fseek")));
lispStream.cc:1333:	if ( res < 0 ) THROW(_lisp->error(BF("Problem with fseek")));
lispStream.cc:1428:	THROW(_lisp->error(BF("Could not convert ios_base openmode flags: %d") % mode ));
lispStream.cc:1459:	    THROW(_lisp->error(BF("Could not open file: %s") % currentPath->asString() ));
lispStream.cc:1465:	    if ( res<0 ) THROW(_lisp->error(BF("Problem with fseek")));
lispStream.cc:1544:	    THROW(_lisp->error(BF("You tried to close a file that is not closeable")));
lispStream.cc:1566:	class_<FDOutStream_O>(lisp->lisp())
lispStream.cc:1622:	core::class_<SynonymStream_O>(lisp->lisp(),no_init)
lispStream.cc:1816:	THROW(_lisp->error(BF("two-way-stream in-stream is nil!")));
lispStream.cc:1823:	THROW(_lisp->error(BF("two-way-stream in-stream is nil!")));
lispStream.cc:1830:	THROW(_lisp->error(BF("two-way-stream out-stream is nil!")));
lispStream.cc:1837:	THROW(_lisp->error(BF("two-way-stream out-stream is nil!")));
lispStream.cc:1955:	core::class_<TwoWayStream_O>(lisp->lisp(),no_init)
lispStream.cc:1984:	core::class_<BroadcastStream_O>(lisp->lisp(),no_init)
lispStream.cc:2008:	core::class_<ConcatenatedStream_O>(lisp->lisp(),no_init)
lispStream.cc:2032:	core::class_<EchoStream_O>(lisp->lisp(),no_init)
lispString.cc:75:	::core::class_<String_O>(lisp->lisp(),no_init)
lispString.cc:88:	PYTHON_CLASS(Pkg(),String,"","",lisp->lisp())
lispVector.cc:42:	    THROW(_lisp->error(BF("Handle make-vector :element-type %s") % element_type->__repr__() ));
lispVector.cc:47:	THROW(_lisp->error(BF("Handle make-vector :element-type %s") % element_type->__repr__() ));
lispVector.cc:144:	::core::class_<Vector_O>(lisp->lisp())
lispVector.cc:155://	PYTHON_CLASS_2BASES(Pkg(),Vector,"","",lisp->lisp())
lispVector.cc:159:			       "","",lisp->lisp());
llh.cc:130:	if ( whole_symbol->isNil() ) whole_symbol = _lisp->gensym("whole");
llh.cc:131:	if ( environment_symbol->isNil() ) environment_symbol = _lisp->gensym("environment");
llh.cc:132:	Symbol_sp name_symbol = _lisp->gensym("macro-name");
llh.cc:161:	class_<LambdaListHandler_O>(lisp->lisp())
llh.cc:373:		    THROW(_lisp->error(BF("Illegal target type for bind: %s") % target->__repr__() ));
llh.cc:379:		    env->extend(sensor,_lisp->_true());
llh.cc:402:		    THROW(_lisp->error(BF("Illegal target type for bind: %s") % target->__repr__() ));
llh.cc:405:		if ( sensor->notNil() )	env->extend(sensor,_lisp->_false());
llh.cc:448:		    THROW(_lisp->error(BF("Illegal target type for bind: %s") % target->__repr__() ));
llh.cc:451:		if ( osensor->notNil() ) activation_frame.setElement(it->_SensorFrameIndex,_lisp->_true());
llh.cc:474:		    THROW(_lisp->error(BF("Illegal target type for bind: %s") % target->__repr__() ));
llh.cc:477:		if ( sensor->notNil() )	activation_frame.setElement(it->_SensorFrameIndex,_lisp->_false());
llh.cc:511:		THROW(_lisp->error(BF("Illegal target for bind_whole_var[%s]") % whole_var->__repr__() ));
llh.cc:536:		THROW(_lisp->error(BF("&rest argument cannot currently be destructuring")));
llh.cc:540:		THROW(_lisp->error(BF("Illegal target for bind_rest_var[%s]") % restarg._Target->__repr__() ));
llh.cc:585:				THROW(_lisp->error(BF("Illegal target type for bind: %s") % target->__repr__() ));
llh.cc:590:				env->extend(sensor_symbol,_lisp->_true());
llh.cc:599:			    THROW(_lisp->error(BF("Unnexpected keyword arguments %s")
llh.cc:630:			THROW(_lisp->error(BF("Illegal target type for bind: %s") % target->__repr__() ));
llh.cc:635:			env->extend(sensor_symbol,_lisp->_false());
llh.cc:699:				THROW(_lisp->error(BF("Illegal target type for bind: %s") % target->__repr__() ));
llh.cc:702:			    if ( sensor_symbol->notNil() ) activation_frame.element(fi->_SensorFrameIndex) = _lisp->_true();
llh.cc:706:		    if ( fi ==  keyed_args.end() && !will_allow_other_keywords ) THROW(_lisp->error(BF("Unnexpected keyword arguments %s") % keyword ));
llh.cc:734:			THROW(_lisp->error(BF("Illegal target type for bind: %s") % target->__repr__() ));
llh.cc:737:		    if ( sensor_symbol->notNil() ) activation_frame.element(fi->_SensorFrameIndex) = _lisp->_false();
llh.cc:935:    THROW(_lisp->error(BF("Illegal parse_lambda_list context") % context->__repr__() ));
llh.cc:1003:		THROW(_lisp->error(BF("Bad &whole lambda-list argument[%s]") % arguments->ocadr()->__repr__() ));
llh.cc:1021:		    THROW(_lisp->error(BF("Bad &environment lambda-list argument[%s]") % arguments->ocaddr()->__repr__() ));
llh.cc:1100:		    THROW(_lisp->error(BF("Lambda list dot followed by more than one argument")));
llh.cc:1153:	    allow_other_keys = _lisp->_true();
llh.cc:1172:		THROW(_lisp->error(BF("&aux variables must be specified by a symbol or a cons of a symbol and an expression")));
llh.cc:1181:    key_flag = _lisp->_boolean(keys.size()>0);
llh.cc:1206:    core::class_<LambdaListHandler_O>(lisp->lisp())
llh.cc:1279:	    THROW(_lisp->error(BF("There are unused arguments: %s") % cur->__repr__() ));
llh.cc:1391:    core::class_<DestructuringLambdaListHandler_O>(lisp->lisp())
llh.cc:1484:    core::class_<MacroLambdaListHandler_O>(lisp->lisp(),make_class_name_init)
llh.cc:1538:	    THROW(_lisp->error(BF("The sensor of the optional arguments must be a symbol - you have: %s") % this->_OptionalArguments->__repr__() ));
loadTimeValues.cc:22:	return(Values(_lisp->loadTimeValuesIds()));
loadTimeValues.cc:32:	LoadTimeValues_sp ltv = _lisp->getLoadTimeValues(name->get());
loadTimeValues.cc:56:	::core::class_<LoadTimeValues_O>(lisp->lisp())
loadTimeValues.cc:69:	PYTHON_CLASS(Pkg(),LoadTimeValues,"","",lisp->lisp())
macros.cc:15:	SetfExpander_sp expander = _lisp->lookupSetfExpander(accessor);
macros.cc:22:	SetfExpander_sp expander = _lisp->lookupSetfExpander(accessor);
macros.cc:33:	SetfExpander_sp expander = _lisp->lookupSetfExpander(accessor);
mbbComp.cc:87:    sl = _lisp->create<SpanningLoop_O>();
metaClass.cc:46:	    THROW(_lisp->error(BF("Deal with non-nil orig in allocateRawClass")));
metaClass.cc:70:	    THROW(_lisp->error(BF("There is a mismatch between the number of class slots defined in Class_O and defined in CL CLOS")));
metaClass.cc:133:	    THROW(_lisp->error(BF("Classes need at least %d slots - you asked for %d") % Class_O::NumberOfClassSlots % slots));
metaClass.cc:201:	if ( this == _lisp->_true().get() )
metaClass.cc:337:	Class_sp cl = eval::funcall(_sym_findClass,className,_lisp->_true())->as<Class_O>();
metaClass.cc:370:	oclass->_Name = lisp->internWithPackageName(package,name);
metaClass.cc:391:	_lisp->print(BF("%s") % this->dumpInfo().c_str() );
metaClass.cc:540:	    THROW(_lisp->error(BF("handle reference to Class slot: %d name: %s" ) % idx % closClassSlotInfo(idx)->__repr__() ));
metaClass.cc:599:		THROW(_lisp->error(BF("Tried to set CLASS_NAME for Class[%s] to an unexpected value[%s] - the CLASS_name is was hard-wired to: %s") % this->__repr__() % val->__repr__() % this->_Name->__repr__() ));
metaClass.cc:621:	    THROW(_lisp->error(BF("You tried to change DirectSuperClasses of %s from %s to %s - you can only expand DirectSuperClasses") % this->__repr__() % this->_DirectSuperClasses->__repr__() % val->__repr__() ));
metaClass.cc:653:	    THROW(_lisp->error(BF("You tried to change ClassPrecedenceList of %s from %s to %s - it can only be expanded") % this->__repr__() % this->_ClassPrecedenceList->__repr__() % val->__repr__() ));
metaClass.cc:730:	THROW(_lisp->error(BF("handle setf reference to Class[%s] slot[%d] slotInfo[%d] --> value: %s" ) % this->__repr__() % idx % closClassSlotInfo(idx)->__repr__() % val->__repr__() ));
metaClass.cc:788:	THROW(_lisp->error(BF("You cannot change the meta-class of a class object" )));
metaClass.cc:819:	THROW(_lisp->error(BF("Illegal argument for subclassp: %s") % low->__repr__() ));
metaClass.cc:826:	class_<Class_O>(lisp->lisp())
metaobject.cc:24:	    class_<Metaobject_O>(lisp->lisp())
model.cc:39:	return lisp->intern(name);
model.cc:262:	THROW(_lisp->error(BF("Could not delete trigger for notification[%s] code[%s]") % notification->__repr__() % code->__repr__() ));
model.cc:379://	const char* _SaveCallerFileName = _lisp->debugLog().getTraceFile();
model.cc:380://	uint	_SaveCallerLineNumber = _lisp->debugLog().getTraceLine();
model.cc:459:	Symbol_sp signal = _lisp->symbol(signalSymbolIndex);
model.cc:471:	class_<Model_O>(lisp->lisp())
msmartsParse.tab.cc:2687:		        TOSS(_lisp->create<O_LispError>("Exceeded max number of digits in Number"));
multiStringBuffer.cc:262:    _lisp->print(BF("MultiStringBlock storage = %d bytes") % headerMemory );
multiStringBuffer.cc:265:    _lisp->print(BF("String storage = %d bytes") % storage );
multipleValues.cc:44:		THROW(_lisp->error(BF("Overflow when returning multiple values - only %d are supported and you tried to return %d values") % this->_Values.size() % args->length() ));
multipleValues.cc:59:	    Cons_sp one = _lisp->create<Cons_O>(this->_Values[i]);
myReadLine.cc:20://      lisp->print(BF("%s")%prompt);
myReadLine.cc:33:	  _lisp->print(BF("%s ") % prompt );
null.cc:18:	::core::class_<Null_O>(lisp->lisp(),no_init)
null.cc:25:	PYTHON_CLASS_2BASES(Pkg(),Null,"","",lisp->lisp())
num.cc:24:	THROW(_lisp->create<MathException_O>("longLongIntAdd>> LongLongInt is about to overflow"));
num.cc:42:        THROW(_lisp->create<MathException_O>(ss.str() ));
num.cc:178:	    THROW(_lisp->error(BF("Support random-state in random"))_);
num.cc:193:	THROW(_lisp->error(BF("Illegal limit for random")));
numbers.cc:415:	    THROW(_lisp->error(BF("Cannot contagen_add two numbers of class %s and %s")
numbers.cc:549:	    THROW(_lisp->error(BF("Cannot contagen_sub two numbers of class %s and %s")
numbers.cc:685:	    THROW(_lisp->error(BF("Cannot contagen_mul two numbers of class %s and %s")
numbers.cc:803:	THROW(_lisp->error(BF("Add support to div numbers %s[%s] and %s[%s]")
numbers.cc:1032:	    THROW(_lisp->error(BF("Cannot compare two numbers of class %s and %s")
numbers.cc:1049:	    if ( dir < t) return _lisp->_false();
numbers.cc:1053:	return _lisp->_true();
numbers.cc:1227:	    THROW(_lisp->error(BF("Cannot compare two numbers of class %s and %s")
numbers.cc:1253:	return(Values(_lisp->_true()));
numbers.cc:1263:	if ( args->isNil() ) return(Values(_lisp->_true()));
numbers.cc:1269:	    if ( !basic_equalp(a,b) ) return(Values(_lisp->_false()));
numbers.cc:1272:	return(Values(_lisp->_true()));
numbers.cc:1286:	class_<Number_O>(lisp->lisp())
numbers.cc:1417:	class_<Real_O>(lisp->lisp())
numbers.cc:1443:	class_<Float_O>(lisp->lisp())
numbers.cc:1496:	class_<Rational_O>(lisp->lisp())
numbers.cc:1564:	mpz_import(z.get_mpz_t(),2,_lisp->integer_ordering()._mpz_import_word_order,
numbers.cc:1565:		   _lisp->integer_ordering()._mpz_import_size,
numbers.cc:1566:		   _lisp->integer_ordering()._mpz_import_endian, 0, &v);
numbers.cc:1575:	class_<Integer_O>(lisp->lisp())
numbers.cc:1751:	    THROW(_lisp->error(BF("LongLongInt value(%d) was too large/small to cast to int") % nm ));
numbers.cc:1761:	    THROW(_lisp->error(BF("uint value(%d) was too large/small to cast to int") % nm ));
numbers.cc:1886:	core::class_<Fixnum_O>(lisp->lisp())
numbers.cc:1911:	class_<Bool_O>(lisp->lisp())
numbers.cc:2038:	THROW(_lisp->error(BF("Illegal argument[%s] for expt") % expt->__repr__() ));
numbers.cc:2109:	class_<ShortFloat_O>(lisp->lisp())
numbers.cc:2203:	THROW(_lisp->error(BF("Illegal argument[%s] for expt") % expt->__repr__() ));
numbers.cc:2300:	class_<SingleFloat_O>(lisp->lisp())
numbers.cc:2411:	THROW(_lisp->error(BF("Illegal argument[%s] for expt") % expt->__repr__() ));
numbers.cc:2479:	class_<DoubleFloat_O>(lisp->lisp())
numbers.cc:2596:	THROW(_lisp->error(BF("Illegal argument[%s] for expt") % expt->__repr__() ));
numbers.cc:2674:	class_<LongFloat_O>(lisp->lisp())
numbers.cc:2786:	THROW(_lisp->error(BF("Cannot raise a ratio to the power %s") % num->__repr__() ));
numbers.cc:2855:	class_<Ratio_O>(lisp->lisp())
numbers.cc:2966:	class_<Complex_O>(lisp->lisp())
numerics.cc:178:	THROW(_lisp->error(BF("Illegal limit for random")));
object.cc:195:	THROW(_lisp->error(BF("Illegal class[%s] for copyList") % this->__repr__() ));
object.cc:201:	THROW(_lisp->error(BF("Illegal class[%s] for copyTree") % this->__repr__() ));
object.cc:340:	return ( this == _lisp->_eof().get() );
object.cc:358:				   _lisp->integer_ordering()._mpz_import_word_order,
object.cc:359:				   _lisp->integer_ordering()._mpz_import_size,
object.cc:360:				   _lisp->integer_ordering()._mpz_import_endian, 
object.cc:447:    _lisp->print(BF("%s") % s.c_str() );
object.cc:448:    _lisp->print(BF(""));
object.cc:488:	THROW(_lisp->error(BF("T_O::serialize was invoked for an object that is nil!!!")));
object.cc:490:    THROW(_lisp->error(BF("T_O::serialize was invoked for an object of class[%s]\n"
object.cc:521:    } else if ( this == _lisp->_true().get() )
object.cc:569:    T_sp ancestorClass = eval::funcall(_sym_findClass,ancestorClassSymbol,_lisp->_true());
object.cc:586:    Class_sp mc = _lisp->classFromClassSymbol(classSymbol);
object.cc:605:    THROW(_lisp->error(BF("T_O::instanceRef(%d) invoked on object class[%s] val-->%s") % idx % this->className() % this->__repr__() ));
object.cc:610:    THROW(_lisp->error(BF("T_O::instanceSet(%d,%s) invoked on object class[%s] val-->%s") % idx % val->__repr__() % this->className() % this->__repr__() ));
object.cc:617:    THROW(_lisp->error(BF("T_O::instanceSig() invoked on object class[%s] val-->%s") % this->className() % this->__repr__() ));
object.cc:622:    THROW(_lisp->error(BF("T_O::instanceSigSet() invoked on object class[%s] val-->%s") % this->className() % this->__repr__() ));
object.cc:654:        THROW(_lisp->create<ContentException_O>("Archive(_lisp,"+fileName+") must contain 1 and only 1 object"));
object.cc:667:    class_<T_O> ot(lisp->lisp(),no_init);
object.cc:935:	class_<ConditionBase_O>(lisp->lisp())
objectSet.cc:29:		THROW(_lisp->error(BF("Illegal argument for ObjectSet init")));
objectSet.cc:132:	    Cons_sp op = _lisp->create<Cons_O>(*si,*bi);
objectSet.cc:210:    class_<ObjectSet_O>(lisp->lisp())
oclass.cc:28:	oclass->_Name = lisp->intern(name);
oclass.cc:77:	_lisp->print(BF("-------------  Class name: %s    instanceClassId: %s") % this->_Name->__repr__() % this->_InstanceClassId->__repr__() );
oclass.cc:81:	    _lisp->print(BF("Base class: %s") % (*it)->className() );
oclass.cc:83:	_lisp->print(BF("%s") % this->dumpInfo() );
oclass.cc:99:	    Symbol_sp sym = _lisp->intern((*ci)->getUniqueIdCharacters());
oclass.cc:136:	    baseClasses = Cons_O::create(lisp->classFromClassId(StandardObject_O::static_classId()),lisp);
oclass.cc:173:	_lisp->print(BF("------------  StandardClass name: %s    instanceClassId: %d") % this->_Name->__repr__() % this->_InstanceClassId );
oclass.cc:174://    _lisp->print(BF("Instance variables: %s") % this->_InstanceVariableNames->__repr__().c_str() );
oclass.cc:175:	_lisp->print(BF("%s") % this->dumpInfo() );
oclass.cc:179:	    _lisp->print(BF("Baseclass--->"));
oclass.cc:185:	    _lisp->print(BF("Did not see any base classes"));
oclass.cc:296:	    Symbol_sp setterSymbol = _lisp->internKeyword(setterName);
oclass.cc:300:	    Symbol_sp getterSymbol = _lisp->internKeyword(getterName);
oclass.cc:311:	class_<BuiltInClass_O>(lisp->lisp())
oclass.cc:325:	class_<StandardClass_O>(lisp->lisp())
package.cc:65:	return(Values(_lisp->makePackage(package_name->get(),lnn,lup)));
package.cc:88:	for ( Vector0<Package_O>::iterator mi = _lisp->packages().begin(); mi!= _lisp->packages().end(); mi++ )
package.cc:120:	return(Values(_lisp->_true()));
package.cc:148:	return(Values(_lisp->_true()));
package.cc:161:	return(Values(_lisp->_true()));
package.cc:174:	return(Values(_lisp->_true()));
package.cc:223:	THROW(_lisp->error(BF("Could not find unique gentemp")));
package.cc:520:	    THROW(_lisp->error(BF("Error: Name conflict when importing package[%s]"
package.cc:539:		THROW(_lisp->error(BF("Problem exporting symbol - it has no name")));
package.cc:701:		THROW(_lisp->error(BF("unintern symbol[%s] revealed name collision with used packages containing symbols: %s") % sym->__repr__() % ss.str()));
package.cc:806:	_lisp->print(BF("%s")%all);
pointer.cc:27:	core::class_<Pointer_O>(lisp->lisp())
posixTime.cc:178:	class_<PosixTime_O>(lisp->lisp())
posixTime.cc:203:	class_<PosixTimeDuration_O>(lisp->lisp())
primitives.cc:131:	    THROW(_lisp->error(BF("Invalid function name: %s") % functionName->__repr__() ));
primitives.cc:148:	return(Values(_lisp->_true()));
primitives.cc:160:	    THROW(_lisp->error(BF("Add support for non character string output streams - you asked for %s") % elementType->__repr__() ));
primitives.cc:219:		    THROW(_lisp->error(BF("Expected one or two element list got: %s") % pair->__repr__() ));
primitives.cc:223:		THROW(_lisp->error(BF("Expected single object or 2-element list - got: %s") % element->__repr__() ));
primitives.cc:238:	return(Values(_lisp->lookup_c_function_ptr(sym)));
primitives.cc:306:	    return(Values(_lisp->_true()));
primitives.cc:353:	_lisp->print(BF("%s:%d af_debug --> %s") % __FILE__
primitives.cc:354:		     % __LINE__ % af_format(_lisp->_true(),format_control,format_arguments)->__repr__());
primitives.cc:463:	if (obj->isNil() ) return(Values(_lisp->_true()));
primitives.cc:506:		THROW(_lisp->error(BF("You cannot define a macro with the name[%s]") % functionName->__repr__() ));
primitives.cc:525:		_lisp->set_setfDefinition(symbol,fn);
primitives.cc:529:	THROW(_lisp->error(BF("Illegal name for function[%s]") % functionName->__repr__() ));
primitives.cc:555:		    return(Values(_lisp->get_setfDefinition(name)));
primitives.cc:559:	THROW(_lisp->error(BF("Illegal function-name[%s]") % functionName->__repr__() ));
primitives.cc:582:		    return _lisp->get_setfDefinition(name)->notNil();
primitives.cc:586:	THROW(_lisp->error(BF("Illegal function-name[%s]") % functionName->__repr__() ));
primitives.cc:611:		    _lisp->remove_setfDefinition(name);
primitives.cc:616:	THROW(_lisp->error(BF("Illegal function-name[%s]") % functionName->__repr__() ));
primitives.cc:637:	    THROW(_lisp->error(BF("Currently I don't handle recursive-p[true] for read_delimited_list")));
primitives.cc:765:		THROW(_lisp->error(BF("Illegal object for stepper[%s] class[%s]") % obj->__repr__() % obj->className() ));
primitives.cc:788:	if ( this->_AtEnd) THROW(_lisp->error(BF("Tried to make list of ended stepper")));
primitives.cc:801:	if ( this->_AtEnd) THROW(_lisp->error(BF("Tried to make list of ended stepper")));
primitives.cc:815:	if ( this->_AtEnd) THROW(_lisp->error(BF("Tried to advance ended stepper")));
primitives.cc:886:	return(Values(_lisp->_boolean(result)));
primitives.cc:898:	return(Values(_lisp->_boolean(result)));
primitives.cc:912:	return(Values(_lisp->_boolean(result)));
primitives.cc:925:	return(Values(_lisp->_boolean(result)));
primitives.cc:1178:	    THROW(_lisp->error(BF("start[%d] must be greater than zero") % start->__repr__()));
primitives.cc:1182:	    THROW(_lisp->error(BF("end[%d] must be <= length of sequence[%d]") % end->__repr__() % sequence->length() ));
primitives.cc:1187:	    THROW(_lisp->error(BF("end[%d] is less than start[%d]") % end->__repr__() % start->__repr__() ));
primitives.cc:1227:	THROW(_lisp->error(BF("For file[%s] Bad external-format option: %s") % filespec % external_format->__repr__() ));
primitives.cc:1262:		    THROW(_lisp->error(BF("You cannot append to a file of external_format[%s]") % external_format->__repr__() ));
primitives.cc:1268:	    THROW(_lisp->error(BF("unknown option[%s] for if-exists") % if_exists->__repr__() ));
primitives.cc:1326:	THROW(_lisp->error(BF("Illegal argument for gensym[%s]") % x->__repr__() ));
primitives.cc:1365:    THROW(_lisp->error(BF("Add af_type_to_symbol support for type: %s") % x->className() ));
primitives.cc:1388:	    THROW(_lisp->error(BF("Illegal class %s for instance class of %s") % cl->__repr__() % instance->__repr__() ));
primitives.cc:1413:	if ( x == _lisp->_true() ) return _sym_boolean;
primitives.cc:1510:	return(Values(plist,_lisp->_true()));
primitives.cc:1518:	    return(Values(plist,_lisp->_true()));
primitives.cc:1521:    return(Values(plist,_lisp->_false()));
primitives.cc:1723:	def_raw(CorePkg,"read",&fn_read,ARGS_fn_read,DOCS_fn_read,lisp->lisp());
primitives.cc:1725:	def_raw(CorePkg,"readDelimitedList",&fn_read_delimited_list,ARGS_fn_read_delimited_list,DOCS_fn_read_delimited_list,lisp->lisp());
processLambdaList.cc:30:    bool isAmpSymbol = ( symbol == _lisp->getAmpKeySymbol()	// &key
processLambdaList.cc:31:			 || symbol == _lisp->getAmpAuxSymbol()	// &aux
processLambdaList.cc:32:			 || symbol == _lisp->getAmpEnvironment() // &environment
processLambdaList.cc:33:			 || symbol == _lisp->getAmpAllowOtherKeysSymbol()	// &allow-other-keys
processLambdaList.cc:34:			 || symbol == _lisp->getAmpRestSymbol()	// &rest
processLambdaList.cc:35:			 || symbol == _lisp->getAmpBodySymbol()	// &body
processLambdaList.cc:36:			 || symbol == _lisp->getAmpAuxSymbol() // &aux
processLambdaList.cc:37:			 || symbol == _lisp->getAmpOptionalSymbol()	// &optional
processLambdaList.cc:46:	    if ( symbol == _lisp->getAmpOptionalSymbol() )
processLambdaList.cc:51:	    } else if ( symbol == _lisp->getAmpRestSymbol() || symbol == _lisp->getAmpBodySymbol() )
processLambdaList.cc:56:	    } else if ( symbol == _lisp->getAmpKeySymbol() )
processLambdaList.cc:61:	    } else if ( symbol == _lisp->getAmpAuxSymbol() )
processLambdaList.cc:72:	    if ( symbol == _lisp->getAmpOptionalSymbol() )
processLambdaList.cc:76:	    if ( symbol == _lisp->getAmpRestSymbol() )
processLambdaList.cc:82:	    if ( symbol == _lisp->getAmpKeySymbol() )
processLambdaList.cc:88:	    if ( symbol == _lisp->getAmpAuxSymbol() )
processLambdaList.cc:99:	    if ( symbol == _lisp->getAmpOptionalSymbol() )
processLambdaList.cc:103:	    if ( symbol == _lisp->getAmpRestSymbol() )
processLambdaList.cc:107:	    if ( symbol == _lisp->getAmpKeySymbol() )
processLambdaList.cc:113:	    if ( symbol == _lisp->getAmpAuxSymbol() )
processLambdaList.cc:124:	    if ( symbol == _lisp->getAmpOptionalSymbol() )
processLambdaList.cc:128:	    if ( symbol == _lisp->getAmpRestSymbol() )
processLambdaList.cc:132:	    if ( symbol == _lisp->getAmpKeySymbol() )
processLambdaList.cc:136:	    if ( symbol == _lisp->getAmpAllowOtherKeysSymbol() )
processLambdaList.cc:140:	    if ( symbol == _lisp->getAmpAuxSymbol() )
processLambdaList.cc:151:	    if ( symbol == _lisp->getAmpOptionalSymbol() )
processLambdaList.cc:155:	    if ( symbol == _lisp->getAmpRestSymbol() )
processLambdaList.cc:159:	    if ( symbol == _lisp->getAmpKeySymbol() )
processLambdaList.cc:163:	    if ( symbol == _lisp->getAmpAllowOtherKeysSymbol() )
processLambdaList.cc:172:	    if ( symbol == _lisp->getAmpOptionalSymbol() )
processLambdaList.cc:174:		THROW(_lisp->error(BF("&optional argument specified after &aux is illegal - &aux must be last")));
processLambdaList.cc:176:	    if ( symbol == _lisp->getAmpRestSymbol() )
processLambdaList.cc:178:		THROW(_lisp->error(BF("&rest argument after &aux is illegal - &aux must be last")));
processLambdaList.cc:180:	    if ( symbol == _lisp->getAmpKeySymbol() )
processLambdaList.cc:182:		THROW(_lisp->error(BF("&key argument after &aux - &aux must be last")));
processLambdaList.cc:184:	    if ( symbol == _lisp->getAmpAllowOtherKeysSymbol() )
processLambdaList.cc:188:	    if ( symbol == _lisp->getAmpAuxSymbol() )
processLambdaList.cc:190:		THROW(_lisp->error(BF("&Duplicate &aux symbol")));
processLambdaList.cc:193:	    THROW(_lisp->error(BF("Did not recognize symbol(%s)")%symbol->fullName()));
processLambdaList.cc:196:	    THROW(_lisp->error(BF("Argument handling was attempted when the LambdaListHandler setup was complete")));
processLambdaList.cc:227:    allow_other_keys = _lisp->_false();
processLambdaList.cc:341:	    allow_other_keys = _lisp->_true();
processLambdaList.cc:360:		THROW(_lisp->error(BF("&aux variables must be specified by a symbol or a cons of a symbol and an expression")));
processLambdaList.cc:375:    key_flag = _lisp->_boolean(num_keys>0);
profile.cc:252://	_lisp->mapClassNamesAndClasses(&dumpCount);
python_wrappers.cc:71:		    Symbol_sp keywordSymbol = lisp->internKeyword(PyString_AsString(pyokey));
python_wrappers.cc:156:	    if ( value == Py_True ) result = lisp->_true();
python_wrappers.cc:219:	if ( obj == lisp->_true() )
python_wrappers.cc:240:	    THROW(_lisp->error(BF("Cannot convert Bignum %s to python int")%bn->valueAsString() ));
quickDom.cc:146:	_lisp->print(BF("%s") % err->message().c_str() );
quickDom.cc:217:	    _lisp->print(BF("%s") % err->message().c_str() );
quickDom.cc:249:    first = _lisp->create<Cons_O>();
quickDom.cc:253:	Cons_sp one = _lisp->create<Cons_O>(*ci);
quickDom.cc:728:    ASSERT(_lisp->notNil());
quickDom.cc:832:    class_<QDomNode_O>(lisp->lisp())
reader.cc:28:	class_<Reader_O>(lisp->lisp())
reader.cc:42:	Reader_sp reader = lisp->create<Reader_O>();
reader.cc:74:	Symbol_sp sym = _lisp->intern(chars);
reader.cc:93:	    ASSERTNOTNULL(_lisp->_true());
reader.cc:94:	    return _lisp->_true();
reader.cc:100:	    return _lisp->_false();
reader.cc:193:	    rs->setf_symbolValue(_lisp->_true());
reader.cc:197:	    _sym_STARread_suppressSTAR->setf_symbolValue(_lisp->_boolean(this->_SavedReadSuppress));
reader.cc:268:		result = SourceCodeCons_O::createList(_lisp->symbol(_sym_quote),
reader.cc:282:		T_sp str = _lisp->create<Str_O>(chars);
reader.cc:294:		result = SourceCodeCons_O::createList(_lisp->symbol(_sym_function),
reader.cc:403:		result = SourceCodeCons_O::createList(_lisp->symbol(_sym_double_backquote),
reader.cc:419:		result = SourceCodeCons_O::createList(_lisp->symbol(_sym_comma),quotedObject,this->_Input->lineNumber(),this->_Input->column(),this->_Input->sourceFileInfo());
reader.cc:430:		result = SourceCodeCons_O::createList(_lisp->symbol(_sym_comma_atsign),quotedObject,this->_Input->lineNumber(),this->_Input->column(),this->_Input->sourceFileInfo());
reader.cc:440:		THROW(_lisp->error(BF("Hit unexpected close parenthesis %s") % this->posAsString() ));
reader.cc:444:		THROW(_lisp->error(BF("Hit unexpected token %s") % this->posAsString() ));
reader.cc:577:		THROW(_lisp->error(BF("Unterminated string %s - it started on line %d") % this->posAsString() % startLineNumber ));
reader.cc:661:	    THROW(_lisp->error(BF("Illegal sharp sequence (#%c)") % p ));
readtable.cc:154:	THROW(_lisp->error(BF("Unmatched close parenthesis in file: %s line: %s")
readtable.cc:211:		THROW(_lisp->error(BF("Hit eof in sharp macro")));
readtable.cc:226:	    THROW(_lisp->error(BF("Undefined reader macro for %s %s") % ch->__repr__() % subchar->__repr__()));
readtable.cc:258:	ReadTable_sp readTable = _lisp->getCurrentReadTable();
readtable.cc:262:	    THROW(_lisp->error(BF("invalid-character-error: %s") %c->__repr__() ));
readtable.cc:286:	    ReadTable_sp readTable = _lisp->getCurrentReadTable();
readtable.cc:290:		THROW(_lisp->error(BF("invalid-character-error: %s") %c->__repr__() ));
readtable.cc:333:		THROW(_lisp->error(BF("Illegal entry for make_str[%s]") % obj->__repr__() ));
readtable.cc:361:		    THROW(_lisp->error(BF("Unknown character name[%s]") % name->__repr__() ));
readtable.cc:385:	    T_sp result = eval::evaluate(object,_lisp->topLevelEnvironment());
readtable.cc:413:	T_sp olist = af_read_delimited_list(right_paren,sin,_lisp->_true());
readtable.cc:419:		THROW(_lisp->error(BF("vector is longer than specified length %s: %s") % num->get() % list->__repr__() ));
readtable.cc:482:	    THROW(_lisp->error(BF("Radix missing in #R reader macro")));
readtable.cc:488:		THROW(_lisp->error(BF("Illegal radix for #R: %d") % iradix));
readtable.cc:496:		    THROW(_lisp->error(BF("#%s (base %d) is not a rational: %s")
readtable.cc:551:		THROW(_lisp->error(BF("#C complex number needs two numbers")));
readtable.cc:600:	    THROW(_lisp->error(BF("af_sharp_equal should have read something before it returned nil")));
readtable.cc:604:	if ( num->isNil() ) THROW(_lisp->error(BF("You must provide a number for #xx=")));
readtable.cc:616:	    THROW(_lisp->error(BF("#%d= is already defined") % num->get() ));
readtable.cc:620:	    THROW(_lisp->error(BF("need to tag something more than just #%d#") % num->get()));
readtable.cc:638:	if ( num->isNil() ) THROW(_lisp->error(BF("You must provide a number for #xx#")));
readtable.cc:648:	    THROW(_lisp->error(BF("Whoah! no object labeled %d could be identified") % num->get() ));
readtable.cc:650:	THROW(_lisp->error(BF("No object labeled %d is seen") % num->get() ));
readtable.cc:673:		return(Values(_lisp->_not(eval::funcall(_sym_reader_feature_p,features_cons->osecond()))));
readtable.cc:681:	    THROW(_lisp->error(BF("Illegal feature test: %s") % features_cons->__repr__() ));
readtable.cc:691:	DynamicScopeManager dynamicScopeManager(_sym_STARpackageSTAR,_lisp->keywordPackage());
readtable.cc:717:		DynamicScopeManager dynScopeManager(_sym_STARread_suppressSTAR,_lisp->_true());
readtable.cc:741:	    DynamicScopeManager dynScopeManager(_sym_STARread_suppressSTAR,_lisp->_true());
readtable.cc:866:	rt->make_dispatch_macro_character(sharp,_lisp->_true());
readtable.cc:945:	    THROW(_lisp->error(BF("Illegal newValue[%s] for (setf (readtable-case {readtable}) newValue) - it can only be :upcase, :downcase, :preserve or :invert")%newCase->__repr__() ));
readtable.cc:969:	return _lisp->_true();
readtable.cc:1004:	    return(Values(dispatcher,_lisp->_true()));
readtable.cc:1025:	return _lisp->_true();
readtable.cc:1036:	    THROW(_lisp->error(BF("%c is not a dispatch character") % disp_char->__repr__() ));
readtable.cc:1048:	return _lisp->_true();
readtable.cc:1057:	    THROW(_lisp->error(BF("%c is not a dispatch character") % disp_char->__repr__() ));
readtable.cc:1086:	    THROW(_lisp->error(BF("I can't handle invert yet, that has to be handled when the token is converted")));
readtable.cc:1088:	THROW(_lisp->error(BF("Bad readtable case[%s]") % this->_Case->__repr__() ));
readtable.cc:1097:	::core::class_<ReadTable_O>(lisp->lisp())
readtable.cc:1169:	PYTHON_CLASS(Pkg(),ReadTable,"","",lisp->lisp())
sequence.cc:106:	::core::class_<Sequence_O>(lisp->lisp())
sequence.cc:130:	PYTHON_CLASS(Pkg(),Sequence,"","",lisp->lisp())
serializer.cc:96:	::core::class_<Serializer_O>(lisp->lisp())
serializer.cc:145:	    THROW(_lisp->error(BF("You can only resolve weak references once! this function was called twice")));
serializer.cc:212:	_lisp->sprint(obj,sout);
serializer.cc:228:	return(Values(_lisp->sread(sin,eof_error_p->isTrue(),eof_value)));
serializer.cc:234:	::core::class_<WriteSerializer_O>(lisp->lisp())
serializer.cc:269:	    root->saveObject(_lisp->internKeyword("SerializedCandoData"));
serializer.cc:312:	::core::class_<ReadSerializer_O>(lisp->lisp())
serializer.cc:368:	THROW(_lisp->error(BF("Could not find id[%d]") % id ));
serializer.cc:416:		THROW(_lisp->error(BF("readFromStream failed")));
serializer.cc:450:	    THROW(_lisp->error(BF("There are no children left")));
serializer.cc:459:		THROW(_lisp->error(BF("I found the named node[%s] but it doesn't have a data node following it") % namedCur->_Name ));
serializerName.cc:17:	::core::class_<SerializerName_O>(lisp->lisp())
serializerName.cc:24:	PYTHON_CLASS(Pkg(),SerializerName,"","",lisp->lisp())
serializerNode.cc:18:	if ( obj == _lisp->_true() ) return false;
serializerNode.cc:34:	if ( this->_Object == _lisp->_true() ) return false;
serializerNode.cc:159:	THROW(_lisp->error(BF("Subclass must implement write()")));
serializerNode.cc:165:	THROW(_lisp->error(BF("Subclass[%s] must implement object()") % this->className()));
serializerNode.cc:172:	THROW(_lisp->error(BF("SUBCLASS_MUST_IMPLEMENT")));
serializerNode.cc:178:	THROW(_lisp->error(BF("Subclass must implement appendNamedWeakReferenceNode")));
serializerNode.cc:183:	THROW(_lisp->error(BF("SUBCLASS_MUST_IMPLEMENT")));
serializerNode.cc:190:	THROW(_lisp->error(BF("SUBCLASS_MUST_IMPLEMENT")));
serializerNode.cc:210:	     || obj == _lisp->_true()
serializerNode.cc:319:	    THROW(_lisp->error(BF("I found the named node[%s] but there is no data node after it") % name ));
serializerNode.cc:370:		    core::Symbol_sp classSymbol = _lisp->intern(mc->getPackagedName());
serializerNode.cc:421:	    THROW(_lisp->create<core::SerializeError_O>(BF("Expected next child of node@%p but there was none!") % this ,this));
serializerNode.cc:432:	    THROW(_lisp->create<core::SerializeError_O>(BF("Within node@%p hit NULL when told to skip NameNode[%s]!") % this % name ,this));
serializerNode.cc:437:	    THROW(_lisp->create<core::SerializeError_O>(BF("Within node@%p cursor was on a child data node@%p when told to skip the NameNode[%s]") % this % cur % name, this));
serializerNode.cc:448:	    THROW(_lisp->error(BF("There are no children left")));
serializerNode.cc:522:	    THROW(_lisp->error(BF("writeChildren doesn't have children to write")));
serializerNode.cc:527:	    THROW(_lisp->error(BF("The head must be a leaf node! - instead it is a %s") % this->_Children->className() ));
serializerNode.cc:556:		THROW(_lisp->error(BF("Could not find node named[%s]") % name));
serializerNode.cc:576:	    core::Symbol_sp head = _lisp->internKeyword(subNodeKey);
serializerNode.cc:661:		THROW(_lisp->create<SerializeError_O>("NameNode("+attr+") is missing", this ));
serializerNode.cc:681:		 <<_lisp->classFromClassSymbol(expectedClassSymbol)->getPackagedName()<< endl;
serializerNode.cc:683:	    THROW(_lisp->create<ArchiveError_O>(serr.str(),node));
serializerNode.cc:693:		     <<_lisp->classFromClassSymbol(expectedClassSymbol)->getPackagedName()<< endl;
serializerNode.cc:698:		THROW(_lisp->create<ArchiveError_O>(serr.str(),node));
serializerNode.cc:708:	if ( !_lisp->isClassName(linkedNode->getNodeName()) ) {
serializerNode.cc:710:	    serr << "Weak pointer for attr("<<attr<<") must point to a "<<_lisp->classFromClassSymbol(expectedClassSymbol)->getPackagedName() << endl;
serializerNode.cc:713:	    THROW(_lisp->create<ArchiveError_O>(serr.str(),node));
serializerNode.cc:718:	if ( !_lisp->subClassOrder(expectedClassSymbol,_lisp->getClassSymbolForClassName(linkedNode->getNodeName())) ) {
serializerNode.cc:721:		 <<_lisp->classFromClassSymbol(expectedClassSymbol)->getPackagedName()<< endl;
serializerNode.cc:724:	    THROW(_lisp->create<ArchiveError_O>(serr.str(),node));
serializerNode.cc:789:	if ( this->_Object == _lisp->_true() ) return false;
serializerNode.cc:820:	    THROW(_lisp->error(BF("CrossRefNode reference is NULL")));
serializerNode.cc:870:	    THROW(_lisp->error(BF("WeakCrossRefNode has unresolved referenceId[%d]")% this->_ReferenceId));
serializerNode.cc:875://	    THROW(_lisp->error(BF("WeakCrossRefNode reference is NULL")));
serializerNode.cc:933:	THROW(_lisp->error(BF("object() was invoked on a NameNode[%s] - did you mean to skip over the NameNode to get to the following data node?")
serializerNode.cc:998:	    THROW(_lisp->error(BF("createObjects with no children!")));
serializerNode.cc:1013:	    THROW(_lisp->error(BF("createObjects with no children!")));
serializerNode.cc:1098:	    THROW(_lisp->error(BF("We have a problem, a Node head[%s] must be bound to a dynamic value that is a Class - this symbol isn't dynamic - NEW APPROACH - LOOKUP THE SYMBOL IN THE TYPE/CLASS dictionaries") % sym->__repr__()));
serializerNode.cc:1103:	    THROW(_lisp->error(BF("We have a problem, a Node head[%s] must be bound to a Class - it is not - it is bound to an object of class[%s]") % sym->__repr__() % mcObj->className()));
serializerNode.cc:1107:	core::T_sp newObject = _lisp->createObjectOfClass(mc);
serializerNode.cc:1119:	    THROW(_lisp->error(BF("createObjects with no children!")));
serializerReader.cc:39:	core::Symbol_sp sym = _lisp->intern(chars);
serializerReader.cc:55:	    return _lisp->_true();
serializerReader.cc:60:	    return _lisp->_false();
serializerReader.cc:225:		THROW(_lisp->error(BF("Unterminated string %s - it started on line %d") % this->posAsString() % startLineNumber ));
serializerReader.cc:307:		    THROW(_lisp->error(BF("Illegal sharp-number sequence terminates with(#%c)")% p));
serializerReader.cc:310:	    THROW(_lisp->error(BF("Illegal sharp sequence (#%c)") % p ));
serializerReader.cc:406:	    THROW(_lisp->error(BF("The head of the list MUST be a LeafNode with a symbol")));
serializerReader.cc:417:	    core::T_sp str = _lisp->create<core::Str_O>(chars);
serializerReader.cc:451:		    THROW(_lisp->error(BF("Illegal character name[%s]") % ssup ));
serializerReader.cc:493:	    THROW(_lisp->error(BF("Hit unexpected close parenthesis %s") % this->posAsString() ));
serializerReader.cc:497:	    THROW(_lisp->error(BF("Hit unexpected token %s") % this->posAsString() ));
serializerReader.cc:500:	THROW(_lisp->error(BF("Hit unexpected token %s") % this->posAsString() ));
singleDispatchEffectiveMethodFunction.cc:19:	::core::class_<SingleDispatchEffectiveMethodFunction_O>(lisp->lisp())
singleDispatchEffectiveMethodFunction.cc:26:	PYTHON_CLASS(Pkg(),SingleDispatchEffectiveMethodFunction,"","",lisp->lisp())
singleDispatchGenericFunction.cc:33:	::core::class_<SingleDispatchGenericFunction_O>(lisp->lisp())
singleDispatchGenericFunction.cc:43:	PYTHON_CLASS(Pkg(),SingleDispatchGenericFunction,"","",lisp->lisp())
singleDispatchGenericFunction.cc:104:			THROW(_lisp->error(BF("You tried to overwrite a locked method with name[%s]") % name->__repr__()));
singleDispatchGenericFunction.cc:178:	    THROW(_lisp->error(BF("There are no applicable methods of %s for receiver class %s")
singleDispatchGenericFunction.cc:192:		THROW(_lisp->error(BF("Sort of applicable_methods got the order wrong")));
singleDispatchGenericFunction.cc:265:	    THROW(_lisp->error(BF("You cannot compute_effective_method_function for gf[%s] because there are no methods!") % this->getFunctionName()->__repr__() ));
singleDispatchGenericFunction.cc:278:	Symbol_sp emf_name = _lisp->intern(emf_name_ss.str(),af_functionBlockName(this->getFunctionName())->getPackage());
singleDispatchMethod.cc:19:	::core::class_<SingleDispatchMethod_O>(lisp->lisp())
singleDispatchMethod.cc:26:	PYTHON_CLASS(Pkg(),SingleDispatchMethod,"","",lisp->lisp())
singleDispatchMethod.cc:61:		THROW(_lisp->error(BF("No next method for generic function %s") % this->_previous_emf_name->__repr__() ));
singleDispatchMethod.cc:91:	    if ( this->_next_emfun->notNil() ) return _lisp->_true();
singleDispatchMethod.cc:148:	    Function_sp fp_next_method_p = Function_O::make(_sym_next_method_p,LambdaListHandler_O::create(0,_lisp->topLevelEnvironment(),_lisp),cb_next_method_p);
sourceFileInfo.cc:30:	THROW(_lisp->error(BF("Illegal argument for source-file-info-get-or-create")));
sourceFileInfo.cc:42:	SourceFileInfo_sp spi = _lisp->bundle().getSourceFileInfo(pathName);
sourceFileInfo.cc:47:	    _lisp->bundle().setSourceFileInfo(pathName,spi);
sourceFileInfo.cc:114:	core::class_<SourceFileInfo_O>(lisp->lisp())
specialForm.cc:18:    class_<SpecialForm_O>(lisp->lisp())
specializer.cc:26:	    class_<Specializer_O>(lisp->lisp())
standardClass.cc:50:	    Symbol_sp sym = _lisp->intern((*ci)->getUniqueIdCharacters());
standardClass.cc:86:	    baseClasses = Cons_O::create(lisp->classFromClassSymbol(StandardObject_O::static_classSymbol()),lisp);
standardClass.cc:123:	_lisp->print(BF("------------  StandardClass name: %s    instanceClassSymbol: %d") % this->_Name->__repr__() % this->_InstanceClassSymbol );
standardClass.cc:124://    _lisp->print(BF("Instance variables: %s") % this->_InstanceVariableNames->__repr__().c_str() );
standardClass.cc:125:	_lisp->print(BF("%s") % this->dumpInfo() );
standardClass.cc:129:	    _lisp->print(BF("Baseclass--->"));
standardClass.cc:135:	    _lisp->print(BF("Did not see any base classes"));
standardClass.cc:233:		SIMPLE_ERROR(BF((_lisp->creat"There is already a slot with name(%s)")%sym->currentName()));
standardClass.cc:273:	    Symbol_sp setterSymbol = _lisp->internKeyword(setterName);
standardClass.cc:277:	    Symbol_sp getterSymbol = _lisp->internKeyword(getterName);
standardClass.cc:292:	class_<StandardClass_O>(lisp->lisp())
standardObject.cc:46:	StandardObject_sp co = lisp->create<StandardObject_O>();
standardObject.cc:151:	    class_<StandardObject_O>(lisp->lisp())
stdClass.cc:26:	    class_<StdClass_O>(lisp->lisp())
str.cc:414:	    class_<Str_O>(lisp->lisp())
str.cc:631:	Symbol_sp sym = _lisp->intern(this->_Value);
str.cc:637:	Symbol_sp sym = _lisp->internKeyword(this->_Value);
str.cc:671:	    Cons_sp one = Cons_O::create(_lisp->create<Str_O>(*it),Cons_O::_nil,_lisp);
str.cc:799:	    result = _lisp->create<Str_O>(fmter_str);
str.cc:867:	    result = _lisp->create<Str_O>(fmter_str);
str.cc:904:	    return _lisp->_false();
str.cc:906:	    return _lisp->_true();
str.cc:929:	    return _lisp->_true();
str.cc:931:	    return _lisp->_false();
str.cc:959:	    return _lisp->_false();
str.cc:984:	return _lisp->_false();
str.cc:1017:	    return _lisp->_false();
str.cc:1047:	return _lisp->_false();
str.cc:1078:	    return _lisp->_false();
str.cc:1080:	    return _lisp->_true();
str.cc:1104:	    return _lisp->_true();
str.cc:1106:	    return _lisp->_false();
str.cc:1136:	    return _lisp->_false();
str.cc:1163:	return _lisp->_false();
str.cc:1198:	    return _lisp->_false();
str.cc:1230:	return _lisp->_false();
str.cc:1246:	    THROW(_lisp->error(BF("Illegal start %d for subseq") % start));
stringList.cc:28:	class_<StringList_O>(lisp->lisp())
stringSet.cc:198:	SIMPLE_ERROR(BF((_lisp->creat"The string: %s was not found in StringSet") % s ));
stringSet.cc:303:	Str_sp s = _lisp->create<Str_O>(*si);
stringSet.cc:312:    class_<StringSet_O>(lisp->lisp())
structureClass.cc:50:	    Symbol_sp sym = _lisp->intern((*ci)->getUniqueIdCharacters());
structureClass.cc:86:	    baseClasses = Cons_O::create(lisp->classFromClassSymbol(StandardObject_O::static_classSymbol()),lisp);
structureClass.cc:123:	_lisp->print(BF("------------  StructureClass name: %s    instanceClassSymbol: %d") % this->_Name->__repr__() % this->_InstanceClassSymbol );
structureClass.cc:124://    _lisp->print(BF("Instance variables: %s") % this->_InstanceVariableNames->__repr__().c_str() );
structureClass.cc:125:	_lisp->print(BF("%s") % this->dumpInfo() );
structureClass.cc:129:	    _lisp->print(BF("Baseclass--->"));
structureClass.cc:135:	    _lisp->print(BF("Did not see any base classes"));
structureClass.cc:237:		SIMPLE_ERROR(BF((_lisp->creat"There is already a slot with name(%s)")%(*si)->currentName()));
structureClass.cc:264:	    Symbol_sp setterSymbol = _lisp->internKeyword(setterName);
structureClass.cc:268:	    Symbol_sp getterSymbol = _lisp->internKeyword(getterName);
structureClass.cc:283:	class_<StructureClass_O>(lisp->lisp())
structureObject.cc:43:	StructureObject_sp co = lisp->create<StructureObject_O>();
structureObject.cc:182:	    class_<StructureObject_O>(lisp->lisp())
svm.cc:52:	Cons_sp first = _lisp->create<Cons_O>();
svm.cc:61:	    Cons_sp one = _lisp->create<Cons_O>(oneOp);
svm.cc:70:	Cons_sp first = _lisp->create<Cons_O>();
svm.cc:77:	    Cons_sp one = _lisp->create<Cons_O>(oneOp);
svm.cc:152:	    TOSS(_lisp->error(BF("Error while evaluating ScorerVirtualMachine: %s") % err.message() ));
svm.cc:158:	    TOSS(_lisp->error(BF("Unknown error while evaluating ScorerVirtualMachine")));
symbol.cc:24:    Symbol_sp 	_sym_t;		// equivalent to _lisp->_true()
symbol.cc:120:	    THROW(lisp->error(BF("Creating symbol with no name")));
symbol.cc:216:	    THROW(_lisp->error(BF("You can't load symbols with serialize!!")));
symbol.cc:219:	    THROW(_lisp->error(BF("You can't save symbols with serialize!!!")));
symbol.cc:227:	    THROW(_lisp->error(BF("You can't load symbols with archiveBase!! See Dumb_Node::createYourSymbol")));
symbol.cc:239:	    THROW(_lisp->error(BF("You are trying to convert the string[%s] into a keyword symbol and it contains colons") % this->identifierName()));
symbol.cc:245:	Symbol_sp kwSymbol = _lisp->internKeyword(this->identifierName());
symbol.cc:299:	    THROW(_lisp->error(BF("Unbound symbol %s") % this->_Name ));
symbol.cc:367:		Package_sp currentPackage = _lisp->getCurrentPackage();
symbol.cc:411:		THROW(_lisp->error(BF("Cannot export - no package")));
symbol.cc:491:	class_<Symbol_O>(lisp->lisp())
symbolList.cc:28:	class_<SymbolList_O>(lisp->lisp())
symbolList.cc:107:	    Symbol_sp sym = _lisp->intern(cur->car<Str_O>()->get());
symbolList.cc:121:	    Symbol_sp sym = _lisp->intern(*it);
symbolList.cc:151:	THROW(_lisp->error(BF("SymbolList does not contain: %s")%nm));
symbolSet.cc:77:	    THROW(_lisp->error(BF("There are no elements in the set so you can't get the first")));
symbolSet.cc:139:	    Symbol_sp sym = _lisp->intern(*it);
symbolSet.cc:151:	    Symbol_sp sym = _lisp->intern(*it);
symbolSet.cc:340:    class_<SymbolSet_O>(lisp->lisp())
symbolToEnumConverter.cc:36:    SymbolToEnumConverter_sp c = lisp->create<SymbolToEnumConverter_O>();
symbolToEnumConverter.cc:145:    this->_SymbolToEnum = _lisp->create<Binder_O>();
symbolVector.cc:164:	Cons_sp first = _lisp->create<Cons_O>();
sysprop.cc:22:	ASSERT(_lisp->_SystemProperties);
sysprop.cc:23:	if ( _lisp->_SystemProperties.unboundp() )
sysprop.cc:25:	    _lisp->_SystemProperties = HashTableEql_O::create_default(_lisp);
sysprop.cc:29:	const T_mv& values = _lisp->_SystemProperties->gethash(area,T_O::_nil);
sysprop.cc:40:	    retval = _lisp->_SystemProperties->hash_table_setf_gethash(area,new_hash_table);
sysprop.cc:54:	if ( _lisp->_SystemProperties.pointerp() ) 
sysprop.cc:58:	    T_mv values = _lisp->_SystemProperties->gethash(area,T_O::_nil);
temp_executables.cc:46:	    this->_CurrentLevel = _lisp->_TraceLevel;
temp_executables.cc:47:	    _lisp->_TraceLevel++;
temp_executables.cc:57:	    _lisp->_TraceLevel = this->_CurrentLevel;
temp_executables.cc:76:	    _lisp->print(BF("%s >%d: %s")
temp_executables.cc:83:	    _lisp->print(BF("%s <%d: %s  -->  %s")
temp_executables.cc:106:	class_<FunctionPrimitive_O>(lisp->lisp())
temp_executables.cc:166:	    Environment_sp newEnviron = Environment_O::create(_lisp->topEnv(),lisp);
temp_executables.cc:222:	Environment_sp newEnviron = _lisp->topEnv();
temp_executables.cc:233:	    newEnviron = Environment_O::create(_lisp->topEnv(),lisp);
temp_executables.cc:249:	class_<Function_O>(lisp->lisp())
temp_executables.cc:318:	class_<Function_O>(lisp->lisp())
temp_executables.cc:347:	proc = lisp->create<Function_O>();
temp_executables.cc:375:				  _lisp->topLevelEnvironment(),
temp_executables.cc:390:	proc = lisp->create<Function_O>();
temp_executables.cc:420:	this->_ClosedEnvironment = _lisp->topLevelEnvironment();
temp_executables.cc:457:	    this->_ClosedEnvironment = _lisp->topLevelEnvironment();
temp_executables.cc:542:		    if ( _lisp->debugLog().isEnabled() )
temp_executables.cc:578:		if ( _lisp->debugLog().isEnabled() )
testing.cc:67:	def_raw(CorePkg,"read",&fn_read,ARGS_fn_read,DOCS_fn_read,lisp->lisp());
testing.cc:69:	def_raw(CorePkg,"readDelimitedList",&fn_read_delimited_list,ARGS_fn_read_delimited_list,DOCS_fn_read_delimited_list,lisp->lisp());
vectorObjects.cc:34:	::core::class_<VectorObjects_O>(lisp->lisp())
vectorObjects.cc:41:	PYTHON_CLASS(Pkg(),VectorObjects,"","",lisp->lisp())
vectorObjects.cc:64:	    THROW(_lisp->error(BF("You can only specify one of initial-element or initialContents")));
vectorObjects.cc:189:	    THROW(_lisp->error(BF("out of bounds for subseq")));
vectorObjectsWithFillPtr.cc:34:	::core::class_<VectorObjectsWithFillPtr_O>(lisp->lisp())
vectorObjectsWithFillPtr.cc:42:	PYTHON_CLASS(Pkg(),VectorObjectsWithFillPtr,"","",lisp->lisp())
vectorObjectsWithFillPtr.cc:93:	    THROW(_lisp->error(BF("Index %d is too large - must be less than %d") % index % this->_FillPtr ));
vectorObjectsWithFillPtr.cc:103:	    THROW(_lisp->error(BF("Index %d is too large - must be less than %d") % index % this->_FillPtr ));
weakReference.cc:18:	class_<WeakReference_O>(lisp->lisp())
xmlLoadArchive.cc:285:	_lisp->print(BF("error during XML initialization" ));
xmlLoadArchive.cc:294:	_lisp->print(BF(" Finished parsing archive"));
xmlLoadArchive.cc:312:	_lisp->print(BF(" About to open file: %s") % fileName.c_str() );
xmlLoadArchive.cc:319:	_lisp->print(BF(" About to parse file" ));
xmlLoadArchive.cc:321:	_lisp->print(BF(" The size of the file is %u bytes") % fileSize );
xmlLoadArchive.cc:347:	_lisp->print(BF("error durint XML initialization" ));
xmlLoadArchive.cc:355:	_lisp->print(BF( "Could not parse file" ));
xmlLoadArchive.cc:400:	    _lisp->print(BF(" The size of the file that was loaded is %u bytes") % fileSize );
xmlSaveArchive.cc:98:    StringOutStream_sp sout = _lisp->create<StringOutStream_O>();
xmlSaveArchive.cc:108:    StringOutStream_sp sout = _lisp->create<StringOutStream_O>();
