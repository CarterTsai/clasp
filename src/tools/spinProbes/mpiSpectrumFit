#! /usr/bin/env pyMPI
import sys




useMpi = False
if ( useMpi ):
    import mpi





profiling = True
#profiling = False
if ( profiling ):
    import hotshot


import time
import getopt
import scipy.optimize


import random
import math

from mbb import *


parm = True

from histogram import *
#from cgBuilders import *
#from cgOligomer import *
#from monteCarlo import *
from constrainedVector import *
#from eprOligomer import *
from gimbalModel import *

from report import *


from multiSpectrumContext import *


Debug = False
minimizer = "fmin_powell"



class	ParameterizedGimbalWrapper:
    def __init__(self):
	self._BaseParmGimbal = ParameterizedGimbal()
	self._WorkingParmGimbal = ParameterizedGimbal()

    def parseFromXml(self,x):
	self._BaseParmGimbal.parseFromXml(x)
	self._WorkingParmGimbal.defineFromParameterizedGimbal(self._BaseParmGimbal)

    def getParameterizedGimbal(self):
	return self._WorkingParmGimbal

    def setFromConstrainedVector(self,cv):
	degToRad = 0.0174533
	aRotX0 = cv.getRawPositionValue("rotx0")*degToRad
	aRotY0 = cv.getRawPositionValue("roty0")*degToRad
	aRotZ0 = cv.getRawPositionValue("rotz0")*degToRad
	aRotYY0 = cv.getRawPositionValue("rotyy0")*degToRad
	aRotZZ0 = cv.getRawPositionValue("rotzz0")*degToRad
	aDist0 = cv.getRawPositionValue("dist0")
	aRotXK = pow(10.0,cv.getRawPositionValue("logrotxk"))
	aRotYK = pow(10.0,cv.getRawPositionValue("logrotyk"))
	aRotZK = pow(10.0,cv.getRawPositionValue("logrotzk"))
	aRotYYK = pow(10.0,cv.getRawPositionValue("logrotyyk"))
	aRotZZK = pow(10.0,cv.getRawPositionValue("logrotzzk"))
	aDistK = pow(10.0,cv.getRawPositionValue("logdistk"))
	wg = self._WorkingParmGimbal
	bg = self._BaseParmGimbal
	wg.setRotX0(bg.getRotX0()+aRotX0)
	wg.setRotY0(bg.getRotY0()+aRotY0)
	wg.setRotZ0(bg.getRotZ0()+aRotZ0)
	wg.setRotYY0(bg.getRotYY0()+aRotYY0)
	wg.setRotZZ0(bg.getRotZZ0()+aRotZZ0)
	wg.setDist0(bg.getDist0()+aDist0)
	wg.setRotXK(bg.getRotXK()*aRotXK)
	wg.setRotYK(bg.getRotYK()*aRotYK)
	wg.setRotZK(bg.getRotZK()*aRotZK)
	wg.setRotYYK(bg.getRotYYK()*aRotYYK)
	wg.setRotZZK(bg.getRotZZK()*aRotZZK)
	wg.setDistK(bg.getDistK()*aDistK)

    def getParameterDescription(self):
	str = ""
	degToRad = 0.0174533
	wg = self._WorkingParmGimbal
	aRotX0 = wg.getRotX0()
	aRotY0 = wg.getRotY0()
	aRotZ0 = wg.getRotZ0()
	aRotYY0 = wg.getRotYY0()
	aRotZZ0 = wg.getRotZZ0()
	aDist0 = wg.getDist0()
	aRotXK = wg.getRotXK()
	aRotYK = wg.getRotYK()
	aRotZK = wg.getRotZK()
	aRotYYK = wg.getRotYYK()
	aRotZZK = wg.getRotZZK()
	aDistK = wg.getDistK()
	str += "//builder   aRotX0 = %9.6lf rad (%9.4lf deg)  aRotXK = %9.4lf\n"%(aRotX0,aRotX0/degToRad,aRotXK)
	str += "//builder   aRotY0 = %9.6lf rad (%9.4lf deg)  aRotYK = %9.4lf\n"%(aRotY0,aRotY0/degToRad,aRotYK)
	str += "//builder   aRotZ0 = %9.6lf rad (%9.4lf deg)  aRotZK = %9.4lf\n"%(aRotZ0,aRotZ0/degToRad,aRotZK)
	str += "//builder  aRotYY0 = %9.6lf rad (%9.4lf deg) aRotYYK = %9.4lf\n"%(aRotYY0,aRotYY0/degToRad,aRotYYK)
	str += "//builder  aRotZZ0 = %9.6lf rad (%9.4lf deg) aRotZZK = %9.4lf\n"%(aRotZZ0,aRotZZ0/degToRad,aRotZZK)
	str += "//builder   dist0 = %9.6lf Angstroms            distK = %9.4lf\n"%(aDist0,aDistK)
	return str


class	EprOligomer:
    def __init__(self):
	self._OutputPrefix = None
	self._RootBuilder = None
	self._Meter = None

    def setRootBuilder(self,b):
	self._RootBuilder = b

    def getRootBuilder(self):
	return self._RootBuilder

    def setOutputPrefix(self,o):
	self._OutputPrefix = o

    def setMeter(self,m):
	self._Meter = m

    def getMeter(self):
	return self._Meter

    def getName(self):
	return self._RootBuilder.getName()

def buildNMer_EprOligomer(n,trailPoacTable,parameterizedGimbal,leadPro4Table,leadPoacTable,outputPrefix):
    root = RootSegmentBuilder()
    root.setName("%s-mer"%n)
    segLead = None

    segTail = TableLookupSegmentBuilder()
    segTail.setName("Poac_Trail")
    segTail.setGimbalTable(trailPoacTable)
    root.addChild(segTail)
    segTailPoac = segTail

    segPrev = root
    for i in range(0,n-2):
	seg = ParameterizedSegmentBuilder()
	seg.setName("SS%d"%(i+1))
	seg.setParameterizedGimbal(parameterizedGimbal.getParameterizedGimbal())
	segPrev.addChild(seg)
	segPrev = seg

    seg = TableLookupSegmentBuilder()
    seg.setName("SSl")
    seg.setGimbalTable(leadPro4Table)
    segPrev.addChild(seg)
    segPrev = seg

    seg = TableLookupSegmentBuilder()
    seg.setName("Poac_Lead")
    seg.setGimbalTable(leadPoacTable)
    segPrev.addChild(seg)
    segLeadPoac = seg

    meter = DistanceMeter(0.5,segTailPoac,segLeadPoac)
    root.addMeter(meter)
    eo = EprOligomer()
    eo.setRootBuilder(root)
    eo.setOutputPrefix(outputPrefix)
    eo.setMeter(meter)
    return eo







#
# Here we call instruct the context to carry out the MonteCarlo simulations
# if we are 

def functionToOptimize(inVec,context):
    global useMpi
    startTime = time.time()
    if ( context.getMPIRank() == 0 ):
	print "Input vector: "
	print inVec
	# broadcast the vec to the other processes
	# if vec=="FINALIZE" then finalize and terminate
	# carry out the monte carlo simulations
	# if we are rank==0
	#	accumulate the results
	#
	# if we are mpiRank=0 return the result
	# otherwise wait for the next vec until we get "FINALIZE"
    while (1):
        startTime = time.time()
	context.VP0("TOP OF LOOP")
	if ( useMpi ):
	    vec = mpi.bcast(inVec)
	else:
	    vec = inVec
	if ( useMpi and vec == "FINALIZE" ):
	    mpi.finalize()
	    sys.exit(0)
		#
		# now carry out monte carlo simulations
		#
	myPopDists = context.calculatePopulationDistributions(vec)
	context.VP0("Finished calculation and about to collect results")

	mcTime = time.time() - startTime
		#
		# If we are using MPI then convert each of the population
		# distributions into a serialized message and gather them
		# into process 0 and convert them back into population
		# distributions and combine them together
		#
	if ( useMpi and context.getMPISize()>1 ):
	    myMessage = myPopDists.asXml().asString()
	    context.VP0("Going into gather")
	    allMessages = mpi.gather([myMessage])
	    context.VP0("Coming out of gather")
	    if (context.getMPIRank()==0):
		context.VP0("Gathered all messages: %s"%allMessages)
		allPopDists = []
			#
			# convert the messages back into 
			# PopulationDistributionDict
			#
		for oneMessage in allMessages:
		    onePopDist = PopulationDistributionDict([])
		    node = QuickDomFromString(oneMessage)
		    onePopDist.parseFromXml(node)
#	            onePopDist.parseFromMessage(oneMessage,context)
		    allPopDists.append(onePopDist)
			#
			# Now sum all of the population distributions
			#
	        names = allPopDists[0].keys()
	        summedPopDists = PopulationDistributionDict(names)
		for p in allPopDists:
		   summedPopDists = summedPopDists + p
	else:
	    allPopDists = [myPopDists]
	    summedPopDists = myPopDists
	    allMessages = "single-process-job"
	context.VP0("Finished gather")

		#
		# Only mpiRank(0) actually returns to the minimizer
		# all other ranks just run MC simulations until
		# they are told to quit
		#
	if ( context.getMPIRank() == 0 ):
	    context.VP0("Comparing spectra")
	    context.setSummedPopulationDistributions(summedPopDists)
	    context.compareSpectra()
	    spectralError = context.getSpectralError()
	    constraintError = context.getConstraintError()
	    result = constraintError + spectralError
	    if ( str(result).lower() == "nan" ):
		print "ERROR result = nan"
		print "spectralError = ", spectralError
		print "constraintError = ", constraintError
		print "allMessages = ", allMessages
		result = -1.0
		spectralError = -1.0
		constraintError = -1.0
#	    context.renderSpectra()
	    evalTime = time.time()-startTime
	    status = context.getParameterizedBuilder().getParameterDescription()
	    status += """// processors = %d
// pre monte carlo steps = %9d
// monte carlo steps ===== %9d / processor
// constraint_error ====== %9.7lf
// spectral_error ======== %9.7lf
// total_error =========== %9.7lf
// monte carlo time(%lf seconds)
// evaluation time(%lf seconds)
"""%(context.getMPISize(),context.getPreMonteCarloSteps(),context.getMonteCarloSteps(),constraintError,spectralError,result,mcTime,evalTime)
	    context.addToComment(status)
	    context.setIndividualPopulationDistributions(allPopDists)
	    context.generateReport()
	    context.saveContext()
	    print context.getComment()
	    print "----------------^^^^^^^^^^ main process returning"
	    sys.stdout.flush()
	    return result
	context.VP0("--------- Bottom of loop ")









def main():
    global minimizer, useMpi
    if ( useMpi ):
        mpiRank = mpi.rank
        mpiSize = mpi.size
    else:
	mpiRank = 0
	mpiSize = 1

    if (len(sys.argv) <=1):
	argList = [sys.argv[0],"-h"]
    else:
	argList = sys.argv

    print "DEBUG(rank%d): starting"%mpiRank
    sys.stdout.flush()
    outputPrefix = "out/_opt"
    longOptions = [ "outputPrefix=",
			"restart=",
			"randomStart",
			"singlePoint",
			"debugFile=",
			"parmFile=",
			"parmDir=",
			"logPreMonteCarloSteps=",
			"logMonteCarloSteps=",
			"maxFunctionEvaluations=",
			"spectrum=", "column=", "createNMer="  
						# always in this order
		  ]

    constVector = ConstrainedVector( [ 
			( "rotx0", 	10.0, 0.0, (-30,+30) ),
			( "roty0", 	10.0, 0.0, (-30,+30) ),
			( "logrotyk", 	 1.0, 0.0, (-1,1) ),
			( "rotz0", 	10.0, 0.0, (-30,+30) ),
			( "logrotzk", 	 1.0, 0.0, (-1,1) ),
			( "rotyy0", 	10.0, 0.0, (-30,+30) ),
			( "rotzz0", 	10.0, 0.0, (-30,+30) ),
			( "logrotxk", 	 1.0, 0.0, (-1,1) ),
			( "logrotyyk", 	 1.0, 0.0, (-1,1) ),
			( "logrotzzk", 	 1.0, 0.0, (-1,1) ),
			( "logdistk", 	 1.0, 0.0, (-1,1) ),
			( "dist0", 	 0.1, 0.0, (-0.5,+0.5) ) ])

    longOptions.extend(constVector.getOptionsForGetOpt())
    optlist, args = getopt.getopt(argList[1:],"h",longOptions)


    singlePoint = False
    parmFile = "dkp-pro4SS+pro4SS.xml"
    parmDir = "parms/"
    spectraAndOligomers = []
    logPreMonteCarloSteps = 3
    logMonteCarloSteps = 5.5
    restartFile = None
    maxFunctionEvaluations = 100000
    debugFile = None
    randomStart = False
    for opt,arg in optlist:
	if ( opt in constVector.getOptions() ):
	    constVector.setOption(opt,arg)
	if ( opt == "--debugFile" ):
	    debugFile = arg
	if ( opt == "--restart" ):
	    restartFile = arg
	if ( opt == "--logPreMonteCarloSteps" ):
	    logPreMonteCarloSteps = float(arg)
	if ( opt == "--logMonteCarloSteps" ):
	    logMonteCarloSteps = float(arg)
	if ( opt == "--outputPrefix" ):
	    outputPrefix = arg
	if ( opt == "--spectrum" ):
	    spectrumFile = arg
	    column = 2
	if ( opt == "--randomStart" ):
	    randomStart = True
	if ( opt == "--singlePoint" ):
	    singlePoint = True
	if ( opt == "--parmFile" ):
	    parmFile = arg
	if ( opt == "--parmDir" ):
	    parmDir = arg
	if ( opt == "--maxFunctionEvaluations" ):
	    maxFunctionEvaluations = int(arg)
	if ( opt == "--column" ):
	    column = int(arg)
	if ( opt == "--createNMer" ):
	    nmer = int(arg)
	    print "Adding oligomer with %d pro4(SS) monomers and spectrum in: %s"%(nmer,spectrumFile)
	    spectraAndOligomers.append((nmer,spectrumFile,column))
	if ( opt == "-h" ):
	    print "Usage: %s [options] {--spectrum _specFile.xy_ --nmer #}"
	    print "  -h           = Help"
	    sys.exit(0)


    if ( randomStart ):
	constVector.initializePositionAtRandom()
    else:
	constVector.initializePositionAtZero()
    if ( restartFile != None ):
	constVector.initializeFromRestartFile(restartFile)

    preMcSteps = pow( 10, logPreMonteCarloSteps )
    mcSteps = pow( 10, logMonteCarloSteps )/mpiSize

    if ( mpiRank == 0 ):
	print "Number of processors  (%d)"%mpiSize
	print "Pre monte-carlo steps (%d)"%preMcSteps
	print "    Monte-carlo steps (%d)"%mcSteps
	sys.stdout.flush()

    ssparm = ParameterizedGimbalWrapper()
    xml = QuickDomNode()
    xml.parseFileName("%s/%s"%(parmDir,parmFile))
    ssparm.parseFromXml(xml)


    builderSS_dkp_SS = GimbalTable()
    builderSS_dkp_SS.readFromFile("%s/middle_parameters.xml"%parmDir,
						"dkp-OSS2+OSS3")
    builderSS_dkp_SSend = GimbalTable()
    builderSS_dkp_SSend.readFromFile("%s/lead_parameters.xml"%parmDir,
						"dkp-OSS5+OSS2")

    builderSS_main_Poac = GimbalTable()
    builderSS_main_Poac.readFromFile("%s/lead_parameters.xml"%parmDir,
						"main-OSS2+POA3")

    builderSS_back_Poac = GimbalTable()
    builderSS_back_Poac.readFromFile("%s/tail_parameters.xml"%parmDir,
						"back-OSS4+POA5")



#
# Build all of the EprOligomers
#
    outputFile = "%s-results.pl"%outputPrefix
    context = MultiSpectrumContext()
    context.setup( mpiRank, mpiSize,
			ssparm, constVector, 
			preMcSteps, mcSteps )
    context.setOutputPrefix(outputPrefix)
    context.setPlotIntermediateResults(True)
    if ( debugFile != None ):
	context.createDebugFile(debugFile)
	context.VP0("Starting to run program")

#
# Fill the context with N-mers and experimental spectra
#

    for nmer,specFile,column in spectraAndOligomers:
	if ( mpiRank == 0 ):
	    print "Creating %d-mer oligomer with spectrum: %s"%(nmer,specFile)
	    sys.stdout.flush()
	eprOlig = buildNMer_EprOligomer(nmer,builderSS_back_Poac, ssparm,
				builderSS_dkp_SSend,builderSS_main_Poac,
				outputPrefix)
	experimentalSpectrum = NumericalFunction()
	experimentalSpectrum.parseFromXYFile(specFile,1,column)
	experimentalSpectrum.setXAxisName("time(ns)")
	context.addOligomer( eprOlig )
	context.addExperimentalSpectrum(eprOlig.getName(),experimentalSpectrum)

    valueVector = constVector.getValueVector()

    if ( mpiRank == 0 ):
        print "Starting optimization valueVector = ", valueVector
    if ( singlePoint ):
	functionToOptimize(valueVector,context)
    else:
	if ( minimizer == "fmin_powell"):
	    result = scipy.optimize.fmin_powell(func=functionToOptimize,
				x0=valueVector,
				maxfun = maxFunctionEvaluations,
				args=[context])
	if ( minimizer == "fmin_l_bfgs_b" ):
	    boundsVector = constVector.getBoundsVector()
	    if (mpiRank == 0 ):
		print "Bounds vector = ", boundsVector 
	    result = scipy.optimize.fmin_l_bfgs_b(func=functionToOptimize,
			    x0=valueVector,
			    fprime=None,
			    approx_grad=True,
			    bounds=boundsVector,
			    maxfun = maxFunctionEvaluations,
			    args=[context])
	if ( minimizer == "fmin_tnc" ):
	    boundsVector = constVector.getBoundsVector()
	    if (mpiRank == 0 ):
		print "Bounds vector = ", boundsVector 
	    scaleVector = constVector.getScaleVector()
	    constVector.setScaleLocally(False)
	    result = scipy.optimize.fmin_tnc(func=functionToOptimize,
				x0=valueVector,
				fprime=None,
				approx_grad=True,
				bounds=boundsVector,
				scale=scaleVector,
				maxfun = maxFunctionEvaluations,
				args=[context])
	if ( mpiRank == 0 ):
	    print "Result = ", result


    if ( useMpi ):
        res = mpi.bcast("FINALIZE")

    context.writeAllContextsToXmlFile("%s.xml"%outputPrefix)

    
    print "DONE DONE DONE DONE DONE"
#    if ( useMpi ):
#        mpi.finalize()


if ( __name__ == "__main__" ):
    main()


