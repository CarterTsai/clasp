#! /usr/bin/env pyMPI


from report import *


#profiling = True
profiling = False
if ( profiling ):
    import hotshot


import time
import getopt
import scipy.optimize

from mbb import *
import sys
import random
import math

parm = True

from histogram import *
from cgBuilders import *
from cgOligomer import *
from monteCarlo import *
from constrainedVector import *
from eprOligomer import *

from multiSpectrumContext import *


Debug = False
minimizer = "fmin_powell"




#
# Here we call instruct the context to carry out the MonteCarlo simulations
# if we are 

def functionToOptimize(inVec,context):
    global useMpi
    startTime = time.time()
    if ( context.getMPIRank() == 0 ):
	print "Input vector: "
	print inVec
	# broadcast the vec to the other processes
	# if vec=="FINALIZE" then finalize and terminate
	# carry out the monte carlo simulations
	# if we are rank==0
	#	accumulate the results
	#
	# if we are mpiRank=0 return the result
	# otherwise wait for the next vec until we get "FINALIZE"
    while (1):
        startTime = time.time()
	context.VP0("TOP OF LOOP")
	if ( useMpi ):
	    vec = mpi.bcast(inVec)
	else:
	    vec = inVec
	if ( useMpi and vec == "FINALIZE" ):
	    mpi.finalize()
	    sys.exit(0)
		#
		# now carry out monte carlo simulations
		#
	myPopDists = context.calculatePopulationDistributions(vec)
	context.VP0("Finished calculation and about to collect results")

	mcTime = time.time() - startTime
		#
		# If we are using MPI then convert each of the population
		# distributions into a serialized message and gather them
		# into process 0 and convert them back into population
		# distributions and combine them together
		#
	if ( useMpi and context.getMPISize()>1 ):
	    myMessage = myPopDists.asXml().asString()
	    context.VP0("Going into gather")
	    allMessages = mpi.gather([myMessage])
	    context.VP0("Coming out of gather")
	    if (context.getMPIRank()==0):
		context.VP0("Gathered all messages: %s"%allMessages)
		allPopDists = []
			#
			# convert the messages back into 
			# PopulationDistributionDict
			#
		for oneMessage in allMessages:
		    onePopDist = PopulationDistributionDict([])
		    node = QuickDomFromString(oneMessage)
		    onePopDist.parseFromXml(node)
#	            onePopDist.parseFromMessage(oneMessage,context)
		    allPopDists.append(onePopDist)
			#
			# Now sum all of the population distributions
			#
	        names = allPopDists[0].keys()
	        summedPopDists = PopulationDistributionDict(names)
		for p in allPopDists:
		   summedPopDists = summedPopDists + p
	else:
	    allPopDists = [myPopDists]
	    summedPopDists = myPopDists
	    allMessages = "single-process-job"
	context.VP0("Finished gather")

		#
		# Only mpiRank(0) actually returns to the minimizer
		# all other ranks just run MC simulations until
		# they are told to quit
		#
	if ( context.getMPIRank() == 0 ):
	    context.VP0("Comparing spectra")
	    context.setSummedPopulationDistributions(summedPopDists)
	    context.compareSpectra()
	    spectralError = context.getSpectralError()
	    constraintError = context.getConstraintError()
	    result = constraintError + spectralError
	    if ( str(result).lower() == "nan" ):
		print "ERROR result = nan"
		print "spectralError = ", spectralError
		print "constraintError = ", constraintError
		print "allMessages = ", allMessages
		result = -1.0
		spectralError = -1.0
		constraintError = -1.0
#	    context.renderSpectra()
	    evalTime = time.time()-startTime
	    status = context.getParameterizedBuilder().getParameterDescription()
	    status += """// processors = %d
// pre monte carlo steps = %9d
// monte carlo steps ===== %9d / processor
// constraint_error ====== %9.7lf
// spectral_error ======== %9.7lf
// total_error =========== %9.7lf
// monte carlo time(%lf seconds)
// evaluation time(%lf seconds)
"""%(context.getMPISize(),context.getPreMonteCarloSteps(),context.getMonteCarloSteps(),constraintError,spectralError,result,mcTime,evalTime)
	    context.addToComment(status)
	    context.setIndividualPopulationDistributions(allPopDists)
	    context.generateReport()
	    context.saveContext()
	    print context.getComment()
	    print "----------------^^^^^^^^^^ main process returning"
	    sys.stdout.flush()
	    return result
	context.VP0("--------- Bottom of loop ")









def main():
    if (len(sys.argv) <=1):
	argList = [sys.argv[0],"-h"]
    else:
	argList = sys.argv

    sys.stdout.flush()
    outputPrefix = "out/_opt"
    longOptions = [ 
			"createNMer="  
		  ]

    optlist, args = getopt.getopt(argList[1:],"h",longOptions)
    parmFile = "parms/dkp-pro4SS+pro4SS.xml"



    nmer = 3
    spectraAndOligomers = []
    logPreMonteCarloSteps = 3
    logMonteCarloSteps = 5.5
    restartFile = None
    maxFunctionEvaluations = 100000
    debugFile = None
    for opt,arg in optlist:
	if ( opt == "--createNMer" ):
	    nmer = int(arg)
	if ( opt == "-h" ):
	    print "Usage: %s [options] {--spectrum _specFile.xy_ --nmer #}"
	    print "  -h           = Help"
	    sys.exit(0)


    print "Reading pro4 parameters from file(%s)"%parmFile
    ssparm = CGParameterizedPro4Builder()
    ssparm.defineFromFile(parmFile)

    builderSS_dkp_SS = CGTableBuilder()
    builderSS_dkp_SS.appendMatrices("parms/middle_parameters.xml",
						"dkp-OSS2+OSS3")
    builderSS_dkp_SSend = CGTableBuilder()
    builderSS_dkp_SSend.appendMatrices("parms/lead_parameters.xml",
						"dkp-OSS5+OSS2")
#    builderSS_dkp_SSend.outputValues("out/_table_SS_dkp_SSlead.txt")

    builderSS_main_Poac = CGTableBuilder()
    builderSS_main_Poac.appendMatrices("parms/lead_parameters.xml",
						"main-OSS2+POA3")
#    builderSS_dkp_SSend.outputValues("out/_table_lead_poac.txt")

    builderSS_back_Poac = CGTableBuilder()
    builderSS_back_Poac.appendMatrices("parms/tail_parameters.xml",
						"back-OSS4+POA5")
#    builderSS_back_Poac.outputValues("out/_table_back_poac.txt")




#
# Fill the context with N-mers and experimental spectra
#

    eprOlig = EprOligomer("")
    eprOlig.createNMer(nmer,builderSS_back_Poac, ssparm,
			    builderSS_dkp_SSend,builderSS_main_Poac,
			    outputPrefix)
    eprOlig.originStep()
    dist = eprOlig.getEndToEndDistance()

    eprOlig.describe()
    print "Distance for %d-mer is: %lf"%(nmer,dist)
    objectDumpXml(eprOlig)


if ( __name__ == "__main__" ):
    main()


