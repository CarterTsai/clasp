#! /usr/bin/env pyMPI
import sys




useMpi = False
if ( useMpi ):
    import mpi





profiling = True
#profiling = False
if ( profiling ):
    import hotshot


import time
import getopt
import scipy.optimize


import random
import math

from mbb import *


parm = True

from histogram import *
from cgBuilders import *
from cgOligomer import *
from monteCarlo import *
from constrainedVector import *
from eprOligomer import *

from report import *


from multiSpectrumContext import *


Debug = False
minimizer = "fmin_powell"






#
# Here we call instruct the context to carry out the MonteCarlo simulations
# if we are 

def functionToOptimize(inVec,context):
    global useMpi
    startTime = time.time()
    if ( context.getMPIRank() == 0 ):
	print "Input vector: "
	print inVec
	# broadcast the vec to the other processes
	# if vec=="FINALIZE" then finalize and terminate
	# carry out the monte carlo simulations
	# if we are rank==0
	#	accumulate the results
	#
	# if we are mpiRank=0 return the result
	# otherwise wait for the next vec until we get "FINALIZE"
    while (1):
        startTime = time.time()
	context.VP0("TOP OF LOOP")
	if ( useMpi ):
	    vec = mpi.bcast(inVec)
	else:
	    vec = inVec
	if ( useMpi and vec == "FINALIZE" ):
	    mpi.finalize()
	    sys.exit(0)
		#
		# now carry out monte carlo simulations
		#
	myPopDists = context.calculatePopulationDistributions(vec)
	context.VP0("Finished calculation and about to collect results")

	mcTime = time.time() - startTime
		#
		# If we are using MPI then convert each of the population
		# distributions into a serialized message and gather them
		# into process 0 and convert them back into population
		# distributions and combine them together
		#
	if ( useMpi and context.getMPISize()>1 ):
	    myMessage = myPopDists.asXml().asString()
	    context.VP0("Going into gather")
	    allMessages = mpi.gather([myMessage])
	    context.VP0("Coming out of gather")
	    if (context.getMPIRank()==0):
		context.VP0("Gathered all messages: %s"%allMessages)
		allPopDists = []
			#
			# convert the messages back into 
			# PopulationDistributionDict
			#
		for oneMessage in allMessages:
		    onePopDist = PopulationDistributionDict([])
		    node = QuickDomFromString(oneMessage)
		    onePopDist.parseFromXml(node)
#	            onePopDist.parseFromMessage(oneMessage,context)
		    allPopDists.append(onePopDist)
			#
			# Now sum all of the population distributions
			#
	        names = allPopDists[0].keys()
	        summedPopDists = PopulationDistributionDict(names)
		for p in allPopDists:
		   summedPopDists = summedPopDists + p
	else:
	    allPopDists = [myPopDists]
	    summedPopDists = myPopDists
	    allMessages = "single-process-job"
	context.VP0("Finished gather")

		#
		# Only mpiRank(0) actually returns to the minimizer
		# all other ranks just run MC simulations until
		# they are told to quit
		#
	if ( context.getMPIRank() == 0 ):
	    context.VP0("Comparing spectra")
	    context.setSummedPopulationDistributions(summedPopDists)
	    context.compareSpectra()
	    spectralError = context.getSpectralError()
	    constraintError = context.getConstraintError()
	    result = constraintError + spectralError
	    if ( str(result).lower() == "nan" ):
		print "ERROR result = nan"
		print "spectralError = ", spectralError
		print "constraintError = ", constraintError
		print "allMessages = ", allMessages
		result = -1.0
		spectralError = -1.0
		constraintError = -1.0
#	    context.renderSpectra()
	    evalTime = time.time()-startTime
	    status = context.getParameterizedBuilder().getParameterDescription()
	    status += """// processors = %d
// pre monte carlo steps = %9d
// monte carlo steps ===== %9d / processor
// constraint_error ====== %9.7lf
// spectral_error ======== %9.7lf
// total_error =========== %9.7lf
// monte carlo time(%lf seconds)
// evaluation time(%lf seconds)
"""%(context.getMPISize(),context.getPreMonteCarloSteps(),context.getMonteCarloSteps(),constraintError,spectralError,result,mcTime,evalTime)
	    context.addToComment(status)
	    context.setIndividualPopulationDistributions(allPopDists)
	    context.generateReport()
	    context.saveContext()
	    print context.getComment()
	    print "----------------^^^^^^^^^^ main process returning"
	    sys.stdout.flush()
	    return result
	context.VP0("--------- Bottom of loop ")









def main():
    global minimizer, useMpi
    if ( useMpi ):
        mpiRank = mpi.rank
        mpiSize = mpi.size
    else:
	mpiRank = 0
	mpiSize = 1

    if (len(sys.argv) <=1):
	argList = [sys.argv[0],"-h"]
    else:
	argList = sys.argv

    print "DEBUG(rank%d): starting"%mpiRank
    sys.stdout.flush()
    outputPrefix = "out/_opt"
    longOptions = [ "outputPrefix=",
			"restart=",
			"randomStart",
			"singlePoint",
			"debugFile=",
			"parmFile=",
			"logPreMonteCarloSteps=",
			"logMonteCarloSteps=",
			"maxFunctionEvaluations=",
			"spectrum=", "column=", "createNMer="  
						# always in this order
		  ]

    constVector = ConstrainedVector( [ 
			( "rotx0", 	10.0, 0.0, (-30,+30) ),
			( "roty0", 	10.0, 0.0, (-30,+30) ),
			( "logrotyk", 	 1.0, 0.0, (-1,1) ),
			( "rotz0", 	10.0, 0.0, (-30,+30) ),
			( "logrotzk", 	 1.0, 0.0, (-1,1) ),
			( "rotyy0", 	10.0, 0.0, (-30,+30) ),
			( "rotzz0", 	10.0, 0.0, (-30,+30) ),
			( "logrotxk", 	 1.0, 0.0, (-1,1) ),
			( "logrotyyk", 	 1.0, 0.0, (-1,1) ),
			( "logrotzzk", 	 1.0, 0.0, (-1,1) ),
			( "logdistk", 	 1.0, 0.0, (-1,1) ),
			( "dist0", 	 0.1, 0.0, (-0.5,+0.5) ) ])

    longOptions.extend(constVector.getOptionsForGetOpt())
    optlist, args = getopt.getopt(argList[1:],"h",longOptions)


    singlePoint = False
    parmFile = "parms/dkp-pro4SS+pro4SS.xml"
    spectraAndOligomers = []
    logPreMonteCarloSteps = 3
    logMonteCarloSteps = 5.5
    restartFile = None
    maxFunctionEvaluations = 100000
    debugFile = None
    randomStart = False
    for opt,arg in optlist:
	if ( opt in constVector.getOptions() ):
	    constVector.setOption(opt,arg)
	if ( opt == "--debugFile" ):
	    debugFile = arg
	if ( opt == "--restart" ):
	    restartFile = arg
	if ( opt == "--logPreMonteCarloSteps" ):
	    logPreMonteCarloSteps = float(arg)
	if ( opt == "--logMonteCarloSteps" ):
	    logMonteCarloSteps = float(arg)
	if ( opt == "--outputPrefix" ):
	    outputPrefix = arg
	if ( opt == "--spectrum" ):
	    spectrumFile = arg
	    column = 2
	if ( opt == "--randomStart" ):
	    randomStart = True
	if ( opt == "--singlePoint" ):
	    singlePoint = True
	if ( opt == "--parmFile" ):
	    parmFile = arg
	if ( opt == "--maxFunctionEvaluations" ):
	    maxFunctionEvaluations = int(arg)
	if ( opt == "--column" ):
	    column = int(arg)
	if ( opt == "--createNMer" ):
	    nmer = int(arg)
	    print "Adding oligomer with %d pro4(SS) monomers and spectrum in: %s"%(nmer,spectrumFile)
	    spectraAndOligomers.append((nmer,spectrumFile,column))
	if ( opt == "-h" ):
	    print "Usage: %s [options] {--spectrum _specFile.xy_ --nmer #}"
	    print "  -h           = Help"
	    sys.exit(0)


    if ( randomStart ):
	constVector.initializePositionAtRandom()
    else:
	constVector.initializePositionAtZero()
    if ( restartFile != None ):
	constVector.initializeFromRestartFile(restartFile)

    preMcSteps = pow( 10, logPreMonteCarloSteps )
    mcSteps = pow( 10, logMonteCarloSteps )/mpiSize

    if ( mpiRank == 0 ):
	print "Number of processors  (%d)"%mpiSize
	print "Pre monte-carlo steps (%d)"%preMcSteps
	print "    Monte-carlo steps (%d)"%mcSteps
	sys.stdout.flush()

    ssparm = CGParameterizedPro4Builder()
    ssparm.defineFromFile(parmFile)

    builderSS_dkp_SS = CGTableBuilder()
    builderSS_dkp_SS.appendMatrices("parms/middle_parameters.xml",
						"dkp-OSS2+OSS3")
    builderSS_dkp_SSend = CGTableBuilder()
    builderSS_dkp_SSend.appendMatrices("parms/lead_parameters.xml",
						"dkp-OSS5+OSS2")
#    builderSS_dkp_SSend.outputValues("out/_table_SS_dkp_SSlead.txt")

    builderSS_main_Poac = CGTableBuilder()
    builderSS_main_Poac.appendMatrices("parms/lead_parameters.xml",
						"main-OSS2+POA3")
#    builderSS_dkp_SSend.outputValues("out/_table_lead_poac.txt")

    builderSS_back_Poac = CGTableBuilder()
    builderSS_back_Poac.appendMatrices("parms/tail_parameters.xml",
						"back-OSS4+POA5")
#    builderSS_back_Poac.outputValues("out/_table_back_poac.txt")



#
# Build all of the EprOligomers
#
    outputFile = "%s-results.pl"%outputPrefix
    context = MultiSpectrumContext()
    context.setup( mpiRank, mpiSize,
			ssparm, constVector, 
			preMcSteps, mcSteps )
    context.setOutputPrefix(outputPrefix)
    context.setPlotIntermediateResults(True)
    if ( debugFile != None ):
	context.createDebugFile(debugFile)
	context.VP0("Starting to run program")

#
# Fill the context with N-mers and experimental spectra
#

    for nmer,specFile,column in spectraAndOligomers:
	if ( mpiRank == 0 ):
	    print "Creating %d-mer oligomer with spectrum: %s"%(nmer,specFile)
	    sys.stdout.flush()
	eprOlig = EprOligomer("")
	eprOlig.createNMer(nmer,builderSS_back_Poac, ssparm,
				builderSS_dkp_SSend,builderSS_main_Poac,
				outputPrefix)
	experimentalSpectrum = NumericalFunction()
	experimentalSpectrum.parseFromXYFile(specFile,1,column)
	experimentalSpectrum.setXAxisName("time(ns)")
	context.addOligomer( eprOlig )
	context.addExperimentalSpectrum(eprOlig.getName(),experimentalSpectrum)



    valueVector = constVector.getValueVector()

    if ( mpiRank == 0 ):
        print "Starting optimization valueVector = ", valueVector
    if ( singlePoint ):
	functionToOptimize(valueVector,context)
    else:
	if ( minimizer == "fmin_powell"):
	    result = scipy.optimize.fmin_powell(func=functionToOptimize,
				x0=valueVector,
				maxfun = maxFunctionEvaluations,
				args=[context])
	if ( minimizer == "fmin_l_bfgs_b" ):
	    boundsVector = constVector.getBoundsVector()
	    if (mpiRank == 0 ):
		print "Bounds vector = ", boundsVector 
	    result = scipy.optimize.fmin_l_bfgs_b(func=functionToOptimize,
			    x0=valueVector,
			    fprime=None,
			    approx_grad=True,
			    bounds=boundsVector,
			    maxfun = maxFunctionEvaluations,
			    args=[context])
	if ( minimizer == "fmin_tnc" ):
	    boundsVector = constVector.getBoundsVector()
	    if (mpiRank == 0 ):
		print "Bounds vector = ", boundsVector 
	    scaleVector = constVector.getScaleVector()
	    constVector.setScaleLocally(False)
	    result = scipy.optimize.fmin_tnc(func=functionToOptimize,
				x0=valueVector,
				fprime=None,
				approx_grad=True,
				bounds=boundsVector,
				scale=scaleVector,
				maxfun = maxFunctionEvaluations,
				args=[context])
	if ( mpiRank == 0 ):
	    print "Result = ", result


    if ( useMpi ):
        res = mpi.bcast("FINALIZE")

    context.writeAllContextsToXmlFile("%s.xml"%outputPrefix)

    
    print "DONE DONE DONE DONE DONE"
#    if ( useMpi ):
#        mpi.finalize()


if ( __name__ == "__main__" ):
    main()


